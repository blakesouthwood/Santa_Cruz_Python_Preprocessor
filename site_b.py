## tahoe_dream1_working_bliss.py 
#========================
#module for nested switches beta jan 19th, 2022
##===============================================
passcounter=[]
passcounter.append(0)
#so we have passcounter[0] dreamed up on saturday january 29th 2021


#this actually works dec 31st, 2021 11:17am PST California, Menlo Park
# Blake Southwood Software Engineer 
columbia_river=[]
gold_list=[]
## this works dec 31st, 2021
## Blake Southwood Software Engineer 
holdinput=[]
holdinput.append(0)
pobox=[]
pobox.append(0)
#pobox[0]
#import official_switch_case_silver
#from official_switch_case_silver  import *  
#from booster2 import *
#==============
#so if we had endswitch(

     #do_bypass205()
     #bottom_stages()
     
########################=========
#### blues_jazz list
blues_jazz =[]
#### bluejay list initialized 
bluejay=[]
quail=[]

def fill_bluejay_list(): #so I need to use bluejay.append(item)
    ## this is just for testing purposes 
    bluejay.append('a')
    bluejay.append('b')

def show_bluejay(): #show the bluejay list 
    print('bluejay=',bluejay)


def clearbluejay():
    del bluejay[:]

def fill_quail_from_bluejay():
    for item in bluejay:
      quail.append(item)


def show_quail():
     print("quail=", quail)

def empty_quail():
    del quail[:]

'''
print("stsrt")
fill_bluejay_list()
show_bluejay()
fill_quail_from_bluejay()
clearbluejay()
show_quail()
show_bluejay()
empty_quail()
show_quail()
'''
#Sent from my iPhone


##========================
## neutralize_list(name)
##========================
def neutralize_list(name):
    #print("===neutralize_list method called===")
    #print("neutralizing this list (emptying it) ", name)
    if len(name) > 0:
        del name[:]
    #print(" + str(name) + "=",name)
    for item in name:
        name.pop()
    name.clear()
    for item in name:
        name.remove(item)   
        
#mission_control(1,red_robin)
#not calling this just yet 
def nested_endswitch(y): #pulls in sw  this does nothing really 
	return
	#print("=======NESTED_ENDSWITCH called ======")
	#print("inside of nested_endswitch(y) at bottom now")
	#print("did this finally actually work?")
	#for line in y.splitlines():
	#	print(line)
	#print("=======================/////////====================")
	#print("we have an input argument parameter y",y)
	#this determines if switch ca
	
#mission_control(1,red_robin) #which only does the filling of the qual strings before bypass205
#-----------------------------
#nested_endswitch(red_robin)
#-----------------------------

##====== javascript hack trick ===january 13th, 2022
variableinput=[]
variableinput.append(0)
stringlist=[]
stringlist.append(0)
##==========================================
variableinput[0]= 1
#stringlist[0] = red_robin
run=[]
run.append(0)
run[0]= False #default


########################################### this is where I added module 1 into this file ########
#### this idea came to me on january 18th, 2022 actually the day before on Monday.....
#I can fill this with a funciton now

#I have to import a list now to do it
thegreenlist=[]
greenlist=[]
greenlist.append(0)

the_main_sequence=[]


def add_to_the_main_sequence(x):
    the_main_sequence.append(x)
    
##===========================
## empty_this_list(me)
##======================================
def empty_this_list(me):  #use like this:  empty_this_list(listname)
    if len(me) > 0:
        for item in range(0,len(me)):
            me.pop()
        else:
            pass
   
       
        ##===============
        
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'

#new on january 12th, 2022 ==========



fossil=[]
fossil.append(0)
#print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

endswitch_location=[]
switch_location=[]

#new on january 2nd, 2022======================
def clear_out_all_lists_for_reset():
    del endswitch_location[:]
    del switch_location[:]
    del sweetlist[:]
    del holdinglist[:]; 
    del boomerang[:]
    
def happy():
    return
    #print("======= happiness========")

def show_the_date_and_time():
    #print("=====show the date and time() called======")
    import datetime
    now = datetime.datetime.now()
    print("Current date and time : ")
    print(now.strftime("%Y-%m-%d %H:%M:%S"))


#testing on January 12th Wednesday ====================
def nested_endswitch(inputstring):
    return
    #fossil[0] =inputstring
    #print("===holy test ====we are in nested_endswitch()======")
    print("=======we are in nested_endswitch()======")
    print("=======we are in nested_endswitch()======")
    print("=======we are in nested_endswitch()======")
    print("=======we are in nested_endswitch()======")
    
    #print("we grabbed this string----------")
    #for line in inputstring.splitlines():
    #    print(line)
    #print('some match now')
    x = 2
    y = x * x;
    #print("y=",y)
    
##################=======@@@@@@@@@@@@@...................        
        

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    empty_this_list(switch_location)
    empty_this_list(endswitch_location)
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	#print("### must work now ###get switch and endswitch locations########")
	#print("####3##get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#right here going thru input string look for switch and endswitch
		#and append the line number to either switch_location or endswitch_location
		if "switch" in line and "end" not in line:
			#print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		elif "endswitch" in line:
			#print("endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1
			
			
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	
	answer = len(switch_location)
	answer = answer -1
	
	if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
		pass #print("endswitch locations =",endswitch_location)
		#print("out of curiosity print the number of endswitches", len(endswitch_location))
	else:
		pass
		
	

	
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	
	
	
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location
smart_rat=[]
string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
#print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
#print(string)

#print("end of test from the web")
#print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 

# october 11th, 2021 
#testing texas here to do what I want

sweetlist=[]
holdinglist=[]; holdinglist.append(0) #to create slot 0
boomerang=[];   boomerang.append(0)
#def get_switch_parents()

# I need to do a second pass and modify this just modified 
# texas string to show it's inner switch line numbers

##============================================
##  modify_string_before_splitting_it_up():
##============================================
def modify_string_before_splitting_it_up():
    return
    #print("texas string first")
    #for line in texas.splitlines(): #where does string texas come from???
    #    print(line)
    print("=========================") 
    counter =0    
    #print("modify_string_before_splitting_it_up():")
    craftline =''
    for line in texas.splitlines():
        if holdinglist[0] == 0: #this compendates for the first one
            holdinglist[0] = '1' #ASSIGN JUST ONE EQUAL
        else:
            boomerang[0]= holdinglist[0]
    
        if "switch" in line and "end" not in line: #this eliminates endswitch confusion
            tabcount=line.count("\t")#                                   line number          tab count 
            if tabcount == 3: #this compensates for 2nd nested switch at 3 tabs
                boomerang[0]='1' #representing parent switch 
            else:
                pass
            if tabcount == 3:
                boomerang[0]= '1'; #assignment only use one = 
            craftline += line.replace("switch(exp){","switch(exp){ # "+str(counter)+":" + str(tabcount) + " "+"parent switch=" + str(boomerang[0]) + "\n")
            holdinglist[0]=  str(counter)
            #I need to add this to the special dictionary now
            #put it into a list first
            sweetlist.append([counter,tabcount,boomerang[0]])
            counter += 1
        else:
            craftline += line + "\n"
            counter += 1
    #print("this is the output test revisiting this on November 2nd, Tuesday")
    #print(craftline)    
    #print('end of test......... monday morning blues ')  

#modify_string_before_splitting_it_up()

listinput=[]
#exit()


#need to figure out how to add these automatically
  

switchnumbers=[]
tabslist=[]
switchlinenumbers=[]
peach_data=[]




isnt_this_pretty='nada'
pattern_input=[]
pattern_input.append('0')
pattern_input.append('0') #[1] patterninput[1]
pattern_input.append('0') #[2] patterninput[2]

##============================
##  input_tab_combo(x,y):
##=============================
def input_tab_combo(x,y):
    #print("====== input_tab_combo(===", x, y)
    pattern_input[1]=x #5
    pattern_input[2]=y #7

porsche_carerra=[]
capture_switch_lines_nested=[]


plums=[]
plums_data=[]
endswitchlinenumbers=[]
endtabslist=[]


             



#this builds the pairs of switch endswitches by tabs since they ahve to be lined up
#from the switch down to the endswitch in the same tab depth 


 ##=====================this might be teh top of the methods ==========================================================
 ##===============================================================================
 
 
        
## loops thru tabsubs and appends item to tabcount
#=========================
#  little_method(tabcount)            
#=========================
def little_method(tabcount): #threetabs example is the param here in tabcount
    for item in tabsubs:
        tabcount.append(item)
    del tabsubs[:]
        
        
        
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

#==============================
#  build_listinput_list  for threetabs,fivetabs, seventabs,ninetabs, eleventtabs,thirteentabs
#==============================
def build_list_input_list():  
    #print('=======METHOD 3 ====>>>')
    mx = holding_themax[0] #it's using this number 
    input= holding_themax[0]
    #cascading down is how it works
    if holding_themax[0] >= 3: put(3);
    if holding_themax[0] >= 5: put(5);
    if holding_themax[0] >= 7: put(7); 
    if holding_themax[0] >= 9: put(9); 
    if holding_themax[0] >= 11:put(11);
    if holding_themax[0] >= 13:put(13);
    if holding_themax[0] >= 15:put(15);
    #loop thru listinput   
    for item in listinput:
        super_listinput.append(item) #fills super_listinput list
    
  
  
##=================================
##  list_tabs_lists_by_depth():
##================================== 
def list_tabs_lists_by_depth():
    pass
    #print("==list tabs lists by depth=====METHOD 5======>>")
    #print("threetabs=" ,threetabs); print("fivetabs="  ,fivetabs);
    #print("seventabs=" ,seventabs); print("ninetabs="  ,ninetabs);
    #print("eleventabs=",eleventabs);print("thirteentabs=",thirteentabs) 
    


#this takes in the tab depth with x and goes thru the string
#and fills the appropiate tab list if 3 then threetabs, if 5 then fivetabs
##====================================================
## internal_machinery()   designed wed sep 29th, 2021
##====================================================
## key engine inside of function this_makes_switch_and_endswitch_pairs_by_tab_levels()
def internal_machinery(x,inputstring): #this doesn't change anything in the string whatsoever
    #print("===internal_machinery() called=== METHOD 4.5  inside of METHOD 4  ===")
    counter=0
    for line in inputstring.splitlines():
        tab_length = line.count("\t")
        if tab_length != x or "switch" not in line:
            counter += 1; continue
        if tab_length == x: 
            if "switch" in line and "end" not in line:
                tabsubs.append(counter);counter += 1;continue
            if "endswitch" in line:
                tabsubs.append(counter);counter += 1;continue 
    #print("tabsubs = ",tabsubs) #this can be increased to manage n number of tabs depth
    if   x == 3: little_method(threetabs)
    elif x == 5: little_method(fivetabs)
    elif x == 7: little_method(seventabs)
    elif x == 9: little_method(ninetabs)
    elif x == 11:little_method(eleventabs)
    elif x == 13:little_method(thirteentabs)
    else:
        pass
          







##==================================================
## make_switch_and_endswitch_pairs_by_tab_levels() 
##=================================================== 
def make_switch_and_endswitch_pairs_by_tab_levels(inputstring): 
    neutralize_list(threetabs)
    neutralize_list(fivetabs)
    neutralize_list(seventabs) #trying this out 
    #print(":=============== METHOD 4 ======") 
    for item in super_listinput: # listinput is dynamically made above
        x = item;
        internal_machinery(x,inputstring)
     

###=============================== 
 
        #del tabsubs[:] #should clear it
###=================
rattabs=[]



##==============================
##  experimental_machinery
##===============================
def experimental_machinery(x,inputstring): 
    counter =0
    #newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    internal_machinery(x,inputstring)
 
    ###============

combined_tabs=[]
christmastree=[]




##============================================
## combine the lists together  #waterfall ifs
##=============================================
def combine_the_lists_together(x): 
    get_length_of_threetabs    = len(threetabs)
    get_length_of_fivetabs     = len(fivetabs)
    get_length_of_seventabs    = len(seventabs)
    get_length_of_ninetabs     = len(ninetabs)
    get_length_of_eleventabs   = len(eleventabs)
    get_length_of_thirteentabs = len(thirteentabs)
    #test if threetabs list is empty
    if get_length_of_threetabs > 0: #then proceed there is at least one
        #this is a waterfall extending numbers to add to christmastree list
        if x >=  3:christmastree.extend(threetabs);
        if x >=  5:christmastree.extend(fivetabs);  
        if x >=  7:christmastree.extend(seventabs);
        if x >=  9:christmastree.extend(ninetabs); 
        if x >= 11:christmastree.extend(eleventabs);
        if x >= 13:christmastree.extend(thirteentabs);
    
    else:
        pass
        #print('all of the tab lists are empty')
        #print("don't bother trying to extend empty tab lists")
       

##========================================================
##  build_tab_list_added_together(largest_tab_number):   Thursday, Nov 4th, 2021 
#   this does this combined_tabs = threetabs + fivetabs + seventabs etc
##========================================================
def build_tab_list_added_together(largest_tab_number):
    del christmastree[:] #clears out the combined_tabs list to erase it
    empty_this_list(christmastree)
    combine_the_lists_together(largest_tab_number) #<<==input is the largest tab number
    
    
 
#==========================================================
# combine_tabs_by_length_into_christmastree_list(input)
#==========================================================
def combine_tabs_by_length_into_christmastree_list():
    #print("======METHOD 6 ===  combine tabs by length into christmastree_list====>>>>")
    themax = holding_themax[0] #this gets the highest tab level (deeply nested)
    build_tab_list_added_together(holding_themax[0])   #METHOD  7
    
   
#================================= 
#  build_pairs_with_jazz()
#=================================  
#this goes thru christmas list of pairs and and makes snowtime list of pairs jazz added to snowtime 
def build_pairs_with_jazz(): 
    #print("=== METHOD 7== build pairs with jazz =======>>>>")
    #nuking snowtime here to bypass the problem
    #look in snowtime first to see what the hell is in it
    #print("this is inside of build_pairs_with_jazz() inside of starship line 460")
    #print("starship line 461 snowtime=",snowtime)
    del snowtime[:] #added this hopeful bug fix on january 2nd, 2022 10:38am
    #===================================================
    counter =0
    #print('snowtime=',snowtime)
    empty_this_list(snowtime) #making sure that it starts out empty
    snowtime=[] #new jan 7th40    
   # print('what is in christmastree=', christmastree)
    for x in christmastree: #loops thru at 2 at a time
        jazz = [christmastree[counter],christmastree[counter+1]]
        snowtime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2 
        #prevents overflow error for out of range error
        if counter >= len(christmastree):
            break
            
            
         
#=======================================
#  build_tab_depth(inputstring)
#========================================            
def build_tab_depth(inputstring):
    #print("build tab depth ==== METHOD 1 ==  build_tab_depth(=======>>")
    for line in inputstring.splitlines():
        if "switch" in line and "end" not in line: #this is looking for a switch in a line
            get_tab_depth=line.count("\t")         #this is a var that gets the count of tabs
            add_tab_depth.append(get_tab_depth)    #this is for filling the list of each tab depth
        else:
            continue
    #print("add_tab_depth=",add_tab_depth)
    #print("max tab depth=",add_tab_depth[0])
            
      
      
            
            
def loop_thru_pairs_in_snowtime():
    #print(" ==== #method 8 ===  loop_thru_pairs_in_snowtime()=============")
    #pass
    for item in snowtime:  
        #print(item);
        rad1=item[0];rad2=item[1];
        #print(rad1,"and ",rad2)
   # print("snowtime list=",snowtime)


'''
quail
the problem is that the data from first pass is not erased
Formula math solution simple jan 26th
I know how many items should be in quail 6 for example
delete total length - input number

in stanford same issue
I will know th enumber from quail true length 
subtract the difference 


so if 12 - 6


'''

##=======================================
## get_max_tab_number_in_list()
##=======================================       
def get_max_tab_number_in_list():  #this fills the max holding_themax[0]
     #print("======  #METHOD 2 ========")
     themax = max(add_tab_depth);  #a list of the tabs before switches
     holding_themax[0]=themax;
     #print("themax=",themax)


##===========================================================================================
##===========================================================================================
##===============================================================
##   ==this_makes_switch_and_endswitch_pairs_by_tab_levels() ====
##===============================================================  
def this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring):
    #print("-----THIS MAKES SWITCH AND ENDSWITCH PAIRS BY TAB LEVELS------line 600----")
    build_tab_depth(inputstring)                               #METHOD 1
    get_max_tab_number_in_list() #fills holding_themax[0]      #METHOD 2
    build_list_input_list()                                    #METHOD 3
    make_switch_and_endswitch_pairs_by_tab_levels(inputstring) #METHOD 4
    list_tabs_lists_by_depth()                                 #METHOD 5
    combine_tabs_by_length_into_christmastree_list()           #METHOD 6 
    build_pairs_with_jazz()  #combines into sublist            #METHOD 7 
    loop_thru_pairs_in_snowtime()                              #METHOD 8
    #print("==bottom of this makes switch and endswitch pairs by tab levels()")
    #print("this is at end of this_makes_switch_and_endswitch_pairs_by_tab_leves()")
    #print("snowtime=",snowtime)
    #this will go into gold_list
        
   
 
     #this gets one pair in showtime designated by x 
def get_pair_in_snowtime(x):
     #print(" get pair in snowtime testing",x)
     #what if I add 0,0 to first position brilliant
     if len(snowtime) == 0:
        pass #print("length of snowtime is zero")
     #print(snowtime) #would be second position
     cool = snowtime[x]
     #print("list at position ",x," is",cool)
 

 


######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)


##==============================================================    
#we know that there will be sets of 2 numbers closest to each other
#go thru list and grab two at a time seems simple enough
#based on highest tab number which we would know like 7
#threetabs= [11, 47, 49, 73]
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]

peartree=[]
startime=[]

##======================================
## fill_main_pear_list(listname):  #this build the combined list correctly 
#the lists threetabs,fivetabs,seventabs,ninetabs need to already be filled
#this is just combining them together adding them together
##=====================================

threetabs=[]
endtabslist=[]
endswitchlinenumbers=[]


##======================
##  sound_of_music
##======================
fivetabs=[]



#=============bottom half which is seperates_input_strings============
#import official_switch_case_silver
#from official_switch_case_silver  import *  

def stop():
    #print('stop called which calls exit')
    exit()
    
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 


# output is to inputstring[0]
#############################################################
passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)

##===================================================
##  add comment and line number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	awesome='';counter =0;newstring='';
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
			### new surgery ===dec 20th monday bug fix out of the blue =======
				#if counter == 1: #modified for bu on dec 20th monday each number was off by 1 except first
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
				
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	return newstring #this way I can capture the changed string
##===================================================================================







import re
def first_letter(s):
    m = re.search(r'[a-z]', s, re.I)
    if m is not None:
        return m.start()
    return -1

s = "##catgiraffeapluscompscI"
i = first_letter(s)
print(i)


testthis='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			print('first prize')
	  		print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
'''

coolinthegang='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			    print('first prize')
	  		   print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	    		    print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''


    
        
#print('after ======= attempting lstrip() which I have no confidence in')



newlist=[]
newtime=''
thelist=[]
finaloutput=[]
finaloutput.append(0) #creates slot
'''
this cleans up input javascript code that is supposed to be 
governed by tabs in front ala Python and if a space is discovered
it is neutralized and deleted. 
This first counts the tabs in each line in the string.
second it cuts out all spaces and tabs from left of each line
then it concats a new string with the correct tab count in
front of each line so it's CLEANED UP essentially. 

'''
#bad input
examplestring='''
	      switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
	  		    print('first prize')
	  		    print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	     		      print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''
#cleaned up output becomes
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
		case 4 to 7:
			print('first prize')
			print('you block head Charlie Brown')
		case 9 thru 11:
'''


finalstage=[]
finalstage.append(0)
##========================================
##  cut_out_left_side(inputstring):
##========================================
def cut_out_left_side(inputstring):
    #print("cut out left side")
    fancy=''
    for line in inputstring.splitlines():
        #print(line)
        newline = line.lstrip() #I am using lstrip() look at that!!
        fancy += newline + "\n"
    finalstage[0] = fancy
    ## concatting tabs in front + line to redone


##========================================
##  concat_tabs_in_front(fancy):
##========================================
def concat_tabs_in_front(fancy):
    #print("conctat_tabs_in_front()")
    redone='';counter=0
    for line in fancy.splitlines():
        redone += newlist[counter] + line + "\n"
        counter += 1
        if counter >= len(newlist):#prevents out of range error
           break
    finaloutput[0]= redone
    #print("right here the OUTPUT =",finaloutput[0])


#==================================
#   append_result()  pure genius
#   #appends tabs to newlist
#=================================  
def append_result(x):
    tab = "\t"
    result = tab * x;
    newlist.append(result)  
    #this replaces: #if item == 1:result = tab * 1;newlist.append(result)


#puts tab count in each line into thelist
##===============================================================
## count_tabs_in_each_line_and_put_into_thelist(inputstring):
##===============================================================
def count_tabs_in_each_line_and_put_into_thelist(inputstring): 
    del thelist[:];
    del finaloutput[:];
    finaloutput.append(0) #creats one slot space
    for line in inputstring.splitlines():
        answer =line.count("\t") 
        thelist.append(answer)
 
#TEST STRINGS taking out junk spaces




smartlist=[]
thelist=[]
#thelist.append(do1)
#thelist.append(do2)
#thelist.append(do3)
#thelist.append(do4)
#thelist.append(do5)
#thelist.append(do6)

fixedstring=[]
fixedstring.append(0)

#================dec 25th, 2021==============
#   remove_spaces_before_words(inputstring):
#============================================
def remove_spaces_before_words(inputstring):
    buildstring=''
    for line in inputstring.splitlines():
        aline= line.lstrip(' ')#strips off left side spaces
        buildstring += aline + "\n"
    fixedstring[0] = buildstring
    
    
#=========================================================================
# take_out_extraneous_white_spaces_on_the_left_of_each_line(): uses quail list
#=========================================================================
def oldtake_out_extraneous_white_spaces_on_the_left_of_each_line():
    return #this method makes it crash, needs more work
    print(" == take_out_extraneous_white_spaces_on_the_left_of_each_line(): ==")
    #print("length of thelist=",len(thelist))
    #this is using the quail list 
    print("length of quail here line 1007 =", len(quail))
    print(" disneyland matterhorn")
    for item in quail: #what am I calling the list 
        remove_spaces_before_words(item)             #method
        smartlist.append(fixedstring[0]) #adds output to new list
        #this fills up the list smartlist
    print("length of smartlist =",len(smartlist))
    print("==rocky gets knocked out==")
    del quail[:]
    for item in smartlist: #now fill quail list 
        quail.append(item)
    print("this is what is in quail list now filled from smartlist")
    print("length of quail=",len(quail))
    for item in quail:
        print(item)
        print("======")
        
        
#=========================================================================
# loop_thru_smartlist_after_adding_fixed_strings():
#=========================================================================
def loop_thru_smartlist_after_adding_fixed_strings():
    for item in smartlist:
        print(item)
        
def loop_thru_list_before_changes():
    return
    #print('what thelist looks like in starting mode')
    #for item in thelist:
    #   print(item)
    #print("=======end of strarting input strings ====")    
##===================================================================
#print("here we go with our christmas morning code to make this work") 
#just commented these out since it was here for purely testing purposes
#loop_thru_list_before_changes()      
#take_out_extraneous_white_spaces_on_the_left_of_each_line()
#loop_thru_smartlist_after_adding_fixed_strings()
#print("end of test to get rid of spaces on left side of precious code")  
##==========================================================================
##===========================================================================    

#exit()



#made into a function on saturday, dec 4th morgan hill starbucks 
# refactored on dec 19th for efficiency and management
##=======================================================
##  take_out_junk_spaces_from_left_side(inputstring):
##=======================================================

def take_out_junk_spaces_from_left_side(inputstring):
	count_tabs_in_each_line_and_put_into_thelist(inputstring) # METHOD
	for item in thelist:  #fill a list with tabs corresponding to numberof tabs numbers
		x = item;
		append_result(x)                                      # METHOD

	cut_out_left_side(inputstring)#puts fancy in finalstage[0]# METHOD
	fancy =finalstage[0]
	concat_tabs_in_front(fancy)                               # METHOD 
    #result in finaloutput[0] for one converted string cleaned up
#####################################################################
#print("here we go big time test..........fireworks...")

    

###========================================================================   

    
#check for position of first character or number in line 
    #check in this line for location of first letter  
    #letter =line.index('s')# or myString.index('c') or myString.index('p') or myString.index('f')
    #print("letter is",letter)
    #no spacesin switch at top so it skips it!!!~!
    #I need the word before
    
    #what if I go thru the line and 
    #first detect a space and proceed till I hit a character
    #so I am only dealing with spaces before the characters
    #and I create a new line modified 





##===================================== border line ======================================








def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations    #this fills the together_pair list
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]






#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#print(genius[0])    	


 ####### august 10th 2021 testing commences.
 


gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

#print("what we are starting with the switch with a nested switch")
#print(find_nested_switch_game)
#print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
#print("this gets the line number of the line that the case starts")
#print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    return
    linecounter =0
    casecounter = 0
   # print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            #print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            #print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
   # print("case line numbers",pacman)    
    #print(pacman[2])  
    #print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            #print(item)
            #print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    #print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    #print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
           #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            #print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    #print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    #print("x=",start_and_finish[1])
    #print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
#r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function




###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    answer=start_and_finish[1]
    start_and_finish[1] = start_and_finish[1] - 1 #added this on dec 20th to show switch word
    #print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
#print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
################################################################################
#print("=======begin Sunday Morning Brew Testing==========================")

def show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water):
    pass  #not printing it out at this time on purpose
    #for line in water.splitlines():
    #    print(line)

def show_the_snowtime_list_of_pairs():
    return
    #print("=======this is the snowtime list of pairs====january 7th discovery ")
    #print("starship line 1436 snowtime=",snowtime)   
    
def empty_columbia_river_list():
    del columbia_river[:] 
    
def add_main_switch_to_columbia_river(water):
    columbia_river.append(water)  

    
holding_string=[]
holding_string.append(0) 

##============================================================================
##  loop_thru_snowtime_list_copy_switch_bodies_and_add_to_columbia_river():
##============================================================================   
def loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river():
    for item in snowtime:#was gold_list #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];
        num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) # get input string from goldlist
        copy_a_nested_switch(holding_string[0]) # copy string based on switch,endswitch pair 
                                                # puts resulting string into makeitwork[0] and output
        output = makeitwork[0]                  # put nested string into columbia_river list
        columbia_river.append(output)
    #print("length of columbia river =",len(columbia_river))
    #counter =1  #adding here the initial string which will be used to make the main switch


    
##=================================  
## loop_thru_columbia_river() 
##================================= 
def loop_thru_columbia_river():
    #print("now loop thru ====== COLUMBIA RIVER === to see the switch bodies seperated")
    counter =1
    return
    #for item in columbia_river:   #it is added just before looping thru i
    #    print("counter=",counter)
    #    print(item);
    #   #print("===========");
    #    counter += 1    
    
          

#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]    

##==============================================

   #This takes in what has already split the mega nested switch into 
   #switch bodies
quail=[]
sfo_pairs=[]
gold_list=[] #dec 26th sunday 7:56 am
##======================================================##=========================================
##  ==split_up_big_string_into_nested_switches(myinputstring)==
##======================================================##=========================================
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    #print(" ==  split_up_big_string_into_nested_switches(inputstring)  ==")
    water =add_comment_and_line_number_to_all_switches(myinputstring)               #METHOD 1
    show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water)   #METHOD 2
    empty_columbia_river_list()                                                     #METHOD 3
    show_the_snowtime_list_of_pairs()                                               #METHOD 4
    add_main_switch_to_columbia_river(water)                                        #METHOD 5
    holding_string[0] = water
    loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river()      #METHOD 6
    loop_thru_columbia_river() #prints out seperated switch bodies top down         #METHOD 7               
    #print("snowtime pairs=",snowtime)
   # print("fill the list sfo_pairs with snowtime list in case I need it")
   #gold_list is filled from snowtime RIGHT HERE
   ##3===================
    for item in snowtime:
        sfo_pairs.append(item)
        gold_list.append(item) #fills gold_list too
        
    #print("looping thru columbia river to fill quail list")
    #print("what is in columbia_river????")
    #print("line 1364")
    #print("the length of columbia_river is",len(columbia_river))
    
    #for item in columbia_river:
    #    print(item)
        
    del quail[:] #added on january 25th 2022 gilroy starbucks
    for item in columbia_river:
        quail.append(item)
        #fills up quail list 
    
    ##==============
   # print("the switch strings cut up are now printed out top down")
    #take_out_extraneous_white_spaces_on_the_left_of_each_line()
    #print("looping thru quail list to see what it has")
    #for item in quail:
    #    print(item)
    #   print('=====')
    #print(snowtime)
##================================================================        
##================================================================

##=================================================================
## manage_creating_pairs_and_separating_input_switch_strings()
## this calls 2 methods  ---------------
## * this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
## * split_up_big_string_into_nested_switches(inputstring)
##=================================================================
def manage_creating_pairs_and_separating_input_switch_strings(inputstring):
    print(" -------------manage_creating_pairs_and_separating_input_switch_strings(inputstring)-------------")
    #empty both critical lists here 
    del columbia_river[:]
    del snowtime[:]
    #print("called manage_creating_pairs_and_separating_input_switch_strings()")
    this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
    split_up_big_string_into_nested_switches(inputstring)
    #that's it

#print("this is where it all starts... make pairs and separate the switch strings")
#inputstring = red_robin
#manage_creating_pairs_and_separating_input_switch_strings(inputstring)


#print('testing booster2 here')
#waterfall_chain_methods_gold_master()
###====================================================================================
#############@@@@@@@@@@@@@  this is stage 1 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########

holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			#location = line.index("#")    #gets location from left where position of #
			#line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			#line[0] = first #this is new to slice off right of brace
			line = line[0]#first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():
	#    print(line)
	    
	##===========today sunday coding
	
	#then look for this } and reposition it
	
	#this is what I need to modify.
	#so the whole modified string after ripping out endswitch is now in holdthis[0]
	
	#print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
#stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)

innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
#print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    #print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
    #print('this now takes out the { brace after switch if it is there')
    innerswitch=''
   # print("this is what it sees when it starts change_switch_to_method_solved()")
    #for line in inputstring.splitlines():
    #    print(line)
    #print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        pass
        #print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    #print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        #print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            #print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
      
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
               # print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        #print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
            #print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            pass# print("=====no { in string  ======")
            #end if
      
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
#print("where is my mocha brainfreeze test october 30th...")





#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##===========================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##===========================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	#print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		pass #print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		#print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	#print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	#print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)



def modern_take_out_endswitch(inputstring):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():




testlist_of_strings=[]

fillherup=[]
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''







###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	#print("======starter engine called======")
	#print("let us look in this string and see what we can see")
	#for line in the_nest_string.splitlines():
	#	print(line)
	#===========================================	
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #means a switch line
			tabdepth = line.count("\t")
			#print('====================================================')
			#print("tabdepth detect in starter_engine =",tabdepth)
			#print('====================================================')
			n= tabdepth;n = n-1  #need to have one tab in front
			#note tabdepth n needs to be at least 1
			# I may make it default at 1 to run otherwise it fails
			#================================
			if tabdepth < 1:
				passthis[0] = 1; #as a potential bug fix
			else:
				break
			#end if =====================================
			break #no matter what it will break out of this loop 
	passthis[0]= n;
	#print("n =",n)
goldtime=[]
goldtime.append(0)


##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    #print("====modern tab shifter to left=======")
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';
    #print("what is in passthis[0] =",passthis[0])
    #print('this is inside of modern_tab_shifter_to_left(the_nest_string)')
    n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    #print("inside of modern tab shifter to left we have this for n")
    #print("n=",n)
    #print(type(n))
    #print("what is it??")
    #print("what is in the line above")
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
    #print("output of concatted string in goldtime[0]")
    #for line in buildstring.splitlines():
    #    print(line)
### deposit now code here for take out switch body to function properly   
 

###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 #where am I filling inputlist?
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        #print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
       # print("counter=>>",counter)
       # print("=====================")
    #print("at bottom of converts  with more than one inner switch at 3 tabs")
    #print("testing if weasel is returnable at the end of the function")
     #this is after it's done
    #for line in weasel.splitlines():
    #    print(line)
    #return weasel 

	
#print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
inputlist =[]
inputlist.append([11,60])
inputlist.append([62,86])
#print(inputlist)
inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#print("after reversing the list we now have===")
#print(inputlist)
#print("convert switch with more than one inner switch at 3 tabs(stringname)==== string1")
#get_switch_and_endswitch_locations_in_string(test_string1) #presumes one inner switch 


#get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#it needs to make these [[11, 60], [62, 86]]
###testing nov 27th at 10:46am starbucks




switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	


#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	#print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#del total_switches_at_3tabs_depth[:]
	##del switch_list[:]
	#del endswitch_list[:]
	
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	#print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	#print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#======== new jan 7th friday
	#print("inside method get_switch_and_endswitch_locations_in_string")
	#print("switch_list=",switch_list)
	empty_this_list(switch_list) #only empties list if it's not empty
	#switch_list=[]
	print("length of switch_list=",len(switch_list))
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	#print("inside get_switch_and_endswitch_locations_in_string")
	#print("endswitch_list=",endswitch_list)
	empty_this_list(endswitch_list)
	#endswitch_list=[]
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("switch_list=",switch_list)
	#print("endswitch_list=",endswitch_list)
	#print("end of line...")
	########################======
	
	########################==========
#print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function

#print("should be 1 for this test")
#del switch_list[:]
#del endswitch_list[:]
#print('real test now i really need this puppy to work')




#print('important testing on Saturday morning')
trialinputlist=[]
inputlist =[]

#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================

def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	#print("===inside of build_triall_inputlist==inside of starship ==")
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]
	empty_this_list(trialinputlist)
	empty_this_list(inputlist)
	#print("build_trail_inputlist()..")
	#print(" coding blues ")
	##==================================================================
	pair=''
	#print("========= look what this says right here ======")
	#print("len of switch_list", len(switch_list))
	#print("len of endswitch_list", len(endswitch_list))
	#print("==============================================")
	counter=0; 
	#print('starting out what is length otrailinputlist')
	#print("it's length = ", trialinputlist)
	#print(trialinputlist) #should be empty 
	#print("length of switch_list=", len(switch_list))
	#print("#####@@@@#@#@@#######==========")
	#print("curious here what is in switch_list and endswitch_list")
	#print("=== TESTING JANUARY 7th == bullseye ===========")
	#print("switch_list=",switch_list)
	#print("endswitch_list=",endswitch_list)
	#print("=====================================")
	for item in switch_list:
		print("switch list counter=",switch_list[counter])
		print("endswitch list counter=",endswitch_list[counter])
		print('================')
		pair=[switch_list[counter],endswitch_list[counter]]
		print("pair=",pair)
		trialinputlist.append(pair)
		counter += 1
	pair='' #clear out pair which is just a mere variable not a list
	#print("var pair=",pair)
	##=========================================================================	
	#print("look for the ball on the green")
	#print("reaching the 18th hole on the green")
	#print("trialinputlist=",trialinputlist)
	for item in trialinputlist:
		inputlist.append(item) #this is putting what is in trailinputlist into inputlist
	#print(":============ look right here for what is different =====")	
	#print("inputlist=",inputlist)
	#for item in inputlist:
	#	print(item)
	inputlist.reverse() #is this needed here or not 

	 
  
  

#inputstring=test_string1
outputstring=[]
outputstring.append(0)
snowboarding=[]
##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	#print("take_out_switch_body      today is november 28th sunday  4:29 pm ")
	#right here look if a switch at 3 tabs if not skip below
	####=== new as of monday december 6th, 2021 =========================
	#determine if 
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
			#print("yes switch at 3 tabs in line")
			#print("frosty says switch at 3 tabs confirmed")
			nestedswitch= True
			break
	#print("frosty the snow man light test for nested switch")
	#print("nestedswitch=",nestedswitch)
	#print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
		#add input into output  this means no changes were done to the switch string
		#print("this switch string DOES NOT have an inner switch")
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	 
	snowboarding.append(lightning[0])  #this is new dec 6th monday
	#for line in lightning[0].splitlines():
	#	print(line)







#making this sucker work no matter what 

#print("the big test begins")
#planB()
#print("now simply loop thru the finished changes in the list")

#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop
#these are the REAL CHAIN METHODS AS OF DEC 11 SATURDAY 2021 8:10 AM ====
result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]

#print("this is after the input stings have already been seperated")
##=================================
##  move_string_to_left_side()        first method modern tab shifter to left 
##=================================


##================================================================
## what is different is that the data strings are in quail above and are fed into testlist_of_strings
##================================================================
#
# this is using testlist_of_strings as input
#output: result_of_first_method all switch strings modified
def move_string_to_left_side():
    #empty testlist of strings and refill with fillherup
    del testlist_of_strings[:]
    testlist_of_strings.clear()
    ##=======================================
    #()
    print("lookign in move_string_to_left_side()")
    for item in quail:
        print(item)
        
    ## using quail to hold the strings so I would use this here 
    for item in quail: #gets input strings from fillherup list
        testlist_of_strings.append(item)
    #print("==== passing the baton here =============/////=============")
    #print("verifying that testlist_of_strings has the switch strings from above at this juncture")    
    #for item in testlist_of_strings:
    #    print(item)
    #   print("===========")
        
  
# modern_tab_shifter_to_left  method used
    #print("=====APPLE== modern_tab_shifter_to_left()=====")
    counter = 1
    for item in testlist_of_strings:
        #print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
    #print("result of shifting input strings to left")
    #print("=====APPLE==APPLE   APPLE   APPLE   APPLE   APPLE=====")
    #for item in result_of_first_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
    #    counter += 1
    




##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
# output result_of_second_method
# method used: take_out_switch_body(string)  PLUM
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    #print("=====PLUM == take_out_switch_body(item)====")
    #take_out_switch_body method used
    print("inside of take out the inenr switch bodies leaving switch")
    print("line 2065 looping thru result_of_first_method")
    #breakpoint()
    for item in result_of_first_method:
        print(item)
        
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
        #print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
        #print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    counter =1
    #print("result of taking out inner switch bodies")
    #for item in result_of_second_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
     #   counter += 1
    

#good_plum()





##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
## output: result_of_third_method  PEACH
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    #print("=====PEACH===change_switch_to_method_solved===")
    # change_switch_to_method_solved method used 
    print("line number 2101")
    for item in result_of_second_method:
        print(item)
        
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        #print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    #########################################
    counter =1
    #print('result of 3rd method on string')
    #for item in result_of_third_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
     #   counter += 1
    
    
    
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
## output: result_of_fourth_method  ORANGE
##=================================================================
def replace_endswitch_with_close_brace(): #orange
    # take_out_myendswitch method used 
    #print("=======ORANGE=take_out_myendswitch===")
    print("result of third method")
    for item in result_of_third_method:
        print(item)
        
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
        #print("=======")
        fizz =  holdthis[0]
        
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        #print("===== counter =",counter)
        counter += 1
   #########################################
    #print('result of 4th method on string')
    counter=1
    #for item in result_of_fourth_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
    #  counter += 1


#######################################################

    
#this gets the numbers and fills up the list switch_numbers_to_transfer  
switch_numbers_to_transfer=[]
cell=[]
cell.append(0)
##==================================== created dec 6th monday 2021
##  get_switch_number_now(lestring): from quail list before bypass205 is called
##====================================
def get_switch_number_now(lestring): #fills list switch_numbers_to_transfer
    
    print("====get_switch_number_now()==line 2139===") #gets it from quail list
    counter =0
    #breakpoint()
    print("line number 2145")
    check_if_words_red_white_blue_in_string(lestring)
    print("starting show: switch_numbers_to_transfer",switch_numbers_to_transfer)
    del switch_numbers_to_transfer[:] #clear it out 
    #breakpoint()
    for line in lestring.splitlines():
        if  counter == 1 and "switch" in line and "#" in line and "end" not in line:
             x =line.index("#");
             x=x+1; #because first position is 0
             answer=line[x:]; #does a slice
             cell[0]=answer;
             switch_numbers_to_transfer.append(answer) #fills up this list
             break;
        else:
             counter +=1
    
    
            
#this fills up the switch_numbers_to_tranfer list used in bypass205 to
#use in the numbering of the switches with a # after each
##====================================================
##  fill_switch_numbers_list_to_transfer():
##  method: get_switch_number_now()
##==================================================  
def fill_switch_numbers_list_to_transfer():
    print("fill_switch_numbers_list_to_transfer() line number fill switch numbers list to transfer 2164")
    print("result_of_fourth_method=",result_of_fourth_method) #added jan 22n, 2022
   
    print("look into resul tof foruth method")
    for item in result_of_fourth_method:
        print(item)
        
    print("==========")
    for item in result_of_fourth_method:
         get_switch_number_now(item) #fills list switch_numbers_to_transfer
    counter=1
    for item in result_of_fourth_method:
        counter += 1
 


#print("=========== get switch numbmer in quail list") 
##=============================================
## get the switch_numbers_to_transfer():
#this is trapeze to get the switch number for first switch in each string
#which will be used for make the def nested_switch and main_switch in python mode
##=============================================
def get_the_switch_numbers_to_transfer():
    #print("these are the item sin chain_output_list line 
    for item in chain_output_list:
        print(item)
        
    counter=1
    print("line 2185 chain_output_list=",chain_output_list)
    for item in chain_output_list:
        get_switch_number_now(item) 
        #print("number =",counter)
        #print(cell[0]) 
        counter += 1          
    #print("switch_numbers_to_transfer",switch_numbers_to_transfer)
  



  
chain_output_list=[]
##===================================================
## fill_chain_output_list():
##==-================================================
def fill_chain_output_list():
    del chain_output_list[:] #empty it to be sure
    #print("====fill chain output list()====")
    #print("this fills the chain_output_list from result_of_four_method list")
    for item in result_of_fourth_method:
        #print(item)  #just don't print it out
        chain_output_list.append(item)

##======================================================
## loop_thru_chain_output_list_and_fill_quail_list()
##======================================================          
def loop_thru_chain_output_list_and_fill_quail_list():
    #print("loop thru chain output list nad fill quail list()")
    del quail[:] #empties quail list
    for item in chain_output_list:
        quail.append(item)


##======================================================
## loop_thru_quail_list():
##===================================    
def loop_thru_quail_list():
    return
    
        
def loop_thru_chain_output_list():
    return
   
        
def fill_output_into_quail_list():
    del quail[:] #added on january 25th 2022
    for item in chain_output_list:
        quail.append(item)
    #print("final output from chain methods for input switch strings")
    #print("note: this is the quail list with these modified switch strings")
    #for item in quail:
    #    print(item)
    #    print("=============")
##=============================================
## show_list_switch_numbers_to_transfer()
##=============================================
def show_list_switch_numbers_to_transfer():
    print("===switch numbers to transfer== stage2 Linus==")
    print(switch_numbers_to_transfer)  
#fillherup=[]
##====================================
##  do_the_blender_chain_methods()   <<<<<<==== this one actually runs 
##====================================
radical_list=[]
#not called 
def xdo_the_blender_chain_methods(): #this one actually runs 
    return #print("=jan  =do_the_blender chain methods()=mayb e this one is called actually .... jan 17th =")
    
    # move_string_to_left_side()                         # method 1 indents to left
#     take_out_the_inner_switch_bodies_leaving_switch()  # method 2 cut out switch bodies leaving switch
#     change_switch_to_nested_switch_method()            # method 3 switch becomes nested_switchX
#     replace_endswitch_with_close_brace()               # method 4 endswitch becomes }
#     fill_switch_numbers_list_to_transfer()             # method 5 list generated used for codegen
#     fill_chain_output_list()  
#     #loop_thru_quail_list()
#     #loop_thru_chain_output_list() #final output to send to rudolph parser now      
#     #now I need to put what is in chain_output_list into quail list
#     del quail[:]
#     fill_output_into_quail_list() #final stage here 
#     for item in quail: #this fills radical from quail list
#         radical_list.append(item)
#     print("==radical_list==same content should be in quail list")
#     for item in radical_list: #this loops thru radical_list that had quail in it 
#         print(item)
#     print("this is in quail list at this point=== quail list")
#     for item in quail:
#         print(item)    
##  waterfall_chain_methods_gold_master()  formally called do_it()  #this is the one actually being used.
## uses testlist_of_strings for input
##==================================================
#the way this works is each method does all of the switch strings as a set
#each of these methods does all of the switch strings in the list at once 
#and the results are passed downward cascading for the next method to modify.
#========WATERFALL CHAIN METHODS GOLD MASTER THE REAL DEAL=======
##===================================================================================    
## ====  WATERFALL CHAIN METHODS GOLD MASTER OFFICIAL OFFICIAL OFFICAL OFFICIAL  =====       
##  fills quail list with converted and prepped input switch strings all clean up
## this is called after the strings have been separated from the main nested switch

##=====not called ================================================================================
def xwaterfall_chain_methods_gold_master():  #THIS WILL TAKE IN THE QUAIL LIST FOR INPUT
    return #print("=jan 26th is this called even ==WATERFALL CHAIN METHODS Gold Master 1.3()===  REAL WORLD = ")
    #do_the_blender_chain_methods() #this runs 
    #loop_thru_chain_output_list_and_fill_quail_list() #yeah makes sense filling quail list
    #show_list_switch_numbers_to_transfer()
 
   ##====================== jan 2nd new =====================
   # to see what are in the lists after ONE RUN of starship booster 1 and booster 2
   #=========================================================
#new january 2nd, 2022 
def show_contents_of_all_lists():
    #return
    print("====show contents of all lists() inside of starship module ===")
    #if the lists are full in here I need to reset and clear them all
    #print("quail=",quail)
    #print("radical_list=",radical_list)
    #print("testlist_of_strings=",testlist_of_strings)
    #print("snowtime =",snowtime)
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("chain_output_list=",chain_output_list)
    #print("result_of_fourth_method=",result_of_fourth_method)
    #print("cell=",cell)
    #print("result_of_third_method=",result_of_third_method)
    #print("result_of_second_method=",result_of_second_method)
    #print("result_of_first_method=",result_of_first_method)
    #print("tabcount=",tabcount) #will have to clear it too likely 
    #print("snowboarding",snowboarding)
    #print("outputstring",outputstring)
    #print('endswitch_list=',endswitch_list)
    #print("string_name=",string_name)
    #print("fillherup=",fillherup)
    #print("holdon=",holdon)
    #print("holdthis=",holdthis)
    #print("galaxy=",galaxy)

def empty_the_contents_of_all_lists_inside_of_starship():
    #print("===resetting the lists in starship===")
    #print("empty_the_contents_of_all_lists_inside_of_starhip CALLED")
    #print("which means to essentially RESET() the lists in it")
    #print("after deleting them emptying them I will show their contents for proof")
    #print("first empty the said lists ")
    del quail[:]
    del radical_list[:]
    del testlist_of_strings[:]
    del switch_numbers_to_transfer[:]
    del snowtime[:]
    del chain_output_list[:]
    del result_of_fourth_method[:]
    #del cell[:]
    cell[0]=''
    del result_of_third_method[:]
    del result_of_second_method[:]
    del result_of_first_method[:]
    del snowboarding[:]
    del outputstring[:]
    del endswitch_list[:]
    del switch_list[:] #just added this one in case  jan 2nd to fix bug 
    #del string_name[:]
    del fillherup[:]
    del holdon[:]
    #del holdthis[:]
    holdthis[0]=''  #can't delete it need it
    #=============== this one was getting overloaded
    del snowtime[:] #this is new just added it
    del sfo_pairs[:]
    del gold_list[:]
    del columbia_river[:]

    #del build_trial_inputlist[:]
   
    #del stanford[:]
    #del galaxy[:]
    ##==========================================
    '''
    print("now show me the empty lists")
    print("quail=",quail)
    #print("stanford=",stanford)
    print("radical_list=", radical_list)
    print("testlist_of_strings=", testlist_of_strings)
    print("switch_numbers_to_transfer=", switch_numbers_to_transfer)
    print("chain_output_list=", chain_output_list)
    print("result_of_fourth_method=", result_of_fourth_method)
    print(" cell=", cell)
    print(" result_of_third_method=", result_of_third_method)
    print("result_of_second_method=", result_of_second_method)
    print("result_of_first_method=", result_of_first_method)
    print("snowboarding=", snowboarding)
    print(" outputstring=", outputstring)
    print(" switch_list=", switch_list)
    print(" endswitch_list=", endswitch_list)
    print("string_name=", string_name)
    print("fillherup=", fillherup)
    print(" holdon=", holdon)
    print("holdthis=", holdthis)
    print("galaxy=", galaxy)
    '''
##===========================================================================
##  convert_nested_switch_string_to_strings_in_quail_list(inputstring):
##============================================================================
def convert_nested_switch_string_to_strings_in_quail_list(inputstring):
    print("------convert_nested_switch_string_to_strings_in_quail_list(inputstring):---")
    manage_creating_pairs_and_separating_input_switch_strings(inputstring)
    waterfall_chain_methods_gold_master()  #this runs 
    show_contents_of_all_lists() #new january 2nd, 2022========>>>>>>>

    
 
 
 
 
 
    
    ##======= first two stages in a mini main right here ===========
    
#inputstring = red_robin
#convert_nested_switch_string_to_strings_in_quail_list(inputstring)

#print("=======end of test inside of startship=====")
#exit()

def so_smart():
    #print("------------------------------------")
    #print("======== so_smart() called==========")
    #print("------------------------------------")
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("snowtime=",snowtime)
    #print("thenumbers=",thenumbers)
    #print("switch_list =",switch_list)
    #print("endswitch_list=",endswitch_list) 
    #print("testlist_of_strings=",testlist_of_strings)
    del switch_numbers_to_transfer[:]
    del snowtime[:]
    #del thenumbers[:]
    del switch_list[:]
    del endswitch_list[:]
    del testlist_of_strings[:]
    #print('and the result is now after deleting them')
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("snowtime=",snowtime)
    #print("thenumbers=",thenumbers)
    #print("switch_list=",switch_list)
    #print("endswitch_list=",endswitch_list)
    #print("testlist_of_strings=",testlist_of_strings)



##==========================
##  empty_this_string(xx):
##==========================
def empty_this_string(xx):
    empty_string = ""
    xx = empty_string
    return xx
    
    
#charmin list doesn't exist
trouble=['one','two']     


  
    
#print("further testing of empty_this_list(me) method")  
empty_this_list(trouble)
#print("trouble=",trouble)


  
  
       
    #===================================    
    #toocool="for item in range(0,len(me)):\n\t me.pop()"
    #print(toocool) #to see what it sees    #quail.pop()
    #print("check this out =======")
    #for line in toocool.splitlines():
    #    print(line)
    #====================   
    #exec(toocool)
##=====================================
##  clear_all_vars_and_lists():
##=====================================
def clear_all_vars_and_lists():
    print("====clear_all_vars_and_lists()====")
    superball = ''
    varinmain=''
    #method_defs = ''
    future_nested_switches =''
    trigger = ''
    tail = ''
    future_nested_switches=''
    #fill_nested_switches_list=[]#[0]=''
    
    #topvalue=[]
    #lovely=[]  
    #fireone=[]
    #method_defs =''
    future_nested_switches =''
    trigger =''
    tail    =''
    #fill_nested_switches_list[0]=''
    show_code= False
    lovely=[] 
    #empty_this_list(lovely)
    varholder=[] 
    #empty_this_list(varholder)
    coldvar =''
    mynumb = ''
    x=''
    y=''
    toocool=[]
    #empty_this_list(toocool)
    #silvermine=[]
    number_counter=0
    xmastime=[]
    #empty_this_list(xmastime)
    mynumb = ''
    the_answer_is = ''
    buildstring=''
    result = ''
    result=[]
    #empty_this_list(result)
    silvermine=[]
    #empty_this_list(silvermine)
    createstring=''
    number_counter=0
    #example clearing a list 
    #for x in alltheway[:]:
    #   alltheway.remove(x)
    #======================================
    fill_nested_switches_list=[]
    #empty_this_list(fill_nested_switches_list)
    #for x in fill_nested_switches_list[:]:
    #    fill_nested_switches_list.remove(x)
    #stanford=[]
    #for x in stanford[:]:
     #   stanford.remove(x)
    #quail=[]
    ##=============================================
    #print("length of stanford=",len(stanford))
    # if len(stanford) > 0:
    #    automatic_list_emptier(stanford)
    #else:
    #    pass
        
    ##===========================

    ##########======================================
    print("length of quail=",len(quail)) #6
    empty_this_list(quail) #pure genius  #0
    stanford=[]
    print('stanford=',stanford)
    #empty_this_list(stanford)
    print("testing here .......")
    brown = "charlie"              
    print("brown=",brown) #'charlie'
    brown=''  #this is how I will just do it
    print('brown=',brown)  # gone
    
    
    
    
    
    
    print('it should be empty now baby')
    ##########
    print("length of quail now should be 0, it is",len(quail))
    #=========================
    #for x in quail:
    #   quail.remove(x)
    print("this is inside clear_all_vars_and_lists")
    print("quail should be 0 here",len(quail))
    #empty_this_list(bad_dog)
    bad_dog=[]
    #for x in bad_dog[:]:
     #   bad_dog.remove(x)
    #empty_this_list(test_list)
    test_list=[]
    #for x in test_list[:]:
    #   test_list.remove(x)
    #empty_this_list(fancy_new_car)
    fancy_new_car=[]   
    #for x in fancy_new_car[:]:
    #    fancy_new_car.remove(x)   
    
    ##==========================
    del endswitch_location[:]
    del switch_location[:]
    #empty_this_list(endswitch_location)
    #empty_this_list(switch_location)
    #empty_this_list(sweetlist)
    #empty_this_list(holdinglist)
    #empty_this_list(boomerang)
    del sweetlist[:]
    print("sweetlist=",sweetlist)
    
    del holdinglist[:]; 
    del boomerang[:]
    z=''
    answer=''
    

def testing_this_idea():
    #print("this is in starship10")
    print("length of quail=",len(quail))
    
#==========here friday jan 7


def clear_switch_number_lists():
    switch_numbers_to_transfer=[]
    thenumbers=[]


thenumbers=[]
#creating churchill list
churchill=[]
real_switch_numbers_to_transfer=[]
'''
def fill_the_numbers_list():
    for item in switch_numbers_to_transfer:
        thenumbers.append(item)

def loop_thru_numbers_list():
    return #print("these are the switch nubmers to tranfser in the numbers")
    #for item in thenumbers:
    #    print(item)   

def fill_real_switch_numbers_to_transfer_list():
    if len(real_switch_numbers_to_transfer) >0:
         real_switch_numbers_to_transfe=[] #empty it
    else:
        pass
        
    for item in switch_numbers_to_transfer:
        real_switch_numbers_to_transfer.append(item)
    #print("what was just imported and saved is real_switch_numbers_to_transfer from starship")
    print(" we have",real_switch_numbers_to_transfer)
    #print("...")   
    #print("the switch numbers to transfer are..",thenumbers) #this is a dependency   
    #print("these numbers are from starship")
    
    
def show_the_numbers_list():
    return
    #print("these are the switch_numbers_to_transfer ")    
    #print("thenumbers=",thenumbers)
    #for item in thenumbers:
    #   print(item)

def loop_thru_radical_list():
    return #print("loop thru radical_list")
    #for item in radical_list:
    #    print(item) 

#def fill_radical_list_with_quail():
#    del quail[:]
#   for item in radical_list: #from starship list which is really quail
#        quail.append(item) 

def fill_churchill_list_from_quail():
    #print("this is what is in quail made by starship from radical_list to quail")
    for item in quail:
        #print(item)  
        churchill.append(item) 
    ##=====================
    print("this is what is in churchill list...")
    for item in churchill:
        print(item)
'''
##==============================================
## phase_one_of_nested_switches_procedures(
##==============================================  
'''                    
def phase_one_of_nested_switches_procedures(inputstring):
    #print("phase one of nested switches procedures()==============")
    convert_nested_switch_string_to_strings_in_quail_list(inputstring) #from starship
    fill_the_numbers_list()
    loop_thru_numbers_list()
    fill_real_switch_numbers_to_transfer_list()
    show_the_numbers_list()
    loop_thru_radical_list()
    fill_radical_list_with_quail()
    fill_churchill_list_from_quail()
    #print("this is new here ")
    switch_numbers_to_transfer=[]
    for item in thenumbers:
        switch_numbers_to_transfer.append(item)
    print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
        
 '''       
#greenbutton=''

def after_running_code_list_status_not_this_one():
    return #essentially kills the function
    '''
   
    print("THIS SHOULD HAVE BEEN CALLED !!!! JAN 3,2020")
    print("====after running code list status (CONTENTS)======")
    print("= these should all be EMPTY =============")
    print("sfo_pairs=",sfo_pairs)
    print("gold_list=",gold_list)
    print("trialinputlist=",trialinputlist)
    print("inputlist=",inputlist)
    
    print("snowtime=",snowtime)
    print("gold_list=",gold_list)
    print("endswitch=",endswitch_location)
    print("switch=",switch_location)
    print("quail=",quail)
    print("thenumbers=",thenumbers)
    print("stanford=",stanford)
    print("churchill=",churchill)
    print("radical_list=", radical_list)
    print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    print("quail=",quail)
    print("radical_list=",radical_list)
    print("testlist_of_strings=",testlist_of_strings)
    print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    print("chain_output_list=",chain_output_list)
    print("result_of_fourth_method=",result_of_fourth_method)
    print("cell=",cell)
    print("result_of_third_method=",result_of_third_method)
    print("result_of_second_method=",result_of_second_method)
    print("result_of_first_method=",result_of_first_method)
    #print("tabcount=",tabcount) #will have to clear it too likely 
    #print("snowboarding",snowboarding)
    print("outputstring",outputstring)
    print("christmastree",christmastree)
    print("switch_list=",switch_list)
    print('endswitch_list=',endswitch_list)
    print("string_name=",string_name)
    print("fillherup=",fillherup)
    print("holdon=",holdon)
    print("holdthis=",holdthis)
    print("galaxy=",galaxy)
    print("======================")
    #print("pair=",pair)
    print("trialinputlist'",trialinputlist)
    print("inputlist=",inputlist)
    print("sfo_pairs=",sfo_pairs)
    print("gold_list=",gold_list)
    '''
    #print('superball=',superball)
    
def after_running_code_list_statusnonono():
    return #essentially kills the function
    '''
    print("THIS SHOULD HAVE BEEN CALLED !!!! JAN 3,2020")
    print("====after running code list status (CONTENTS)======")
    print("= these should all be EMPTY =============")
    print("sfo_pairs=",sfo_pairs)
    print("gold_list=",gold_list)
    print("trialinputlist=",trialinputlist)
    print("inputlist=",inputlist)
    
    print("snowtime=",snowtime)
    print("gold_list=",gold_list)
    print("endswitch=",endswitch_location)
    print("switch=",switch_location)
    print("quail=",quail)
    print("thenumbers=",thenumbers)
    print("stanford=",stanford)
    print("churchill=",churchill)
    print("radical_list=", radical_list)
    print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    print("quail=",quail)
    print("radical_list=",radical_list)
    print("testlist_of_strings=",testlist_of_strings)
    print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    print("chain_output_list=",chain_output_list)
    print("result_of_fourth_method=",result_of_fourth_method)
    print("cell=",cell)
    print("result_of_third_method=",result_of_third_method)
    print("result_of_second_method=",result_of_second_method)
    print("result_of_first_method=",result_of_first_method)
    #print("tabcount=",tabcount) #will have to clear it too likely 
    print("snowboarding",snowboarding)
    print("outputstring",outputstring)
    print("christmastree",christmastree)
    print("switch_list=",switch_list)
    print('endswitch_list=',endswitch_list)
    print("string_name=",string_name)
    print("fillherup=",fillherup)
    print("holdon=",holdon)
    print("holdthis=",holdthis)
    print("galaxy=",galaxy)
    print("======================")
    #print("pair=",pair)
    print("trialinputlist'",trialinputlist)
    print("inputlist=",inputlist)
    print("sfo_pairs=",sfo_pairs)
    print("gold_list=",gold_list)
    '''
    #print('superball=',superball)
    



'''
import starship10
from starship10 import *
from starship10 import switch_numbers_to_transfer
from starship10 import radical_list  
'''


#import cupcake
#from cupcake import *

#this is what was filled from quail in starship after chain methods modifies the input switches
topvalue=[]
topvalue.append(0)



    
#####==========================================
##=============================================
#import official_switch_case_silver
#from official_switch_case_silver  import *  
print("top of rudolph.py ")
print(" ")
stanford=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
def message_from_Woodstock():
    print('hello from Woodstock the bird file')
    
message_from_Woodstock()

#print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

endswitch_location=[]
switch_location=[]

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    endswitch_location=[]
    switch_location=[]

# december 29th fun
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 

#important no comments in case line otherwise it messes up the parser
#learned this yestrday December 31st which prevented the code from running


##======================== massive dirt simple test to make sure it totally work s=======
waffles ='''
	switch(exp){  
		case 1 thru 3: 
			print("to the moon Alice!")
			print('first prize')
			print('Charlie Brown and Snoopy flying against Red Baron')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp)  
				case 'blable':
					print("we are inside of sw 11 now wildness")
					
					print("I just typed this like Snoopy")
					result[0]="snoopy"
					fallthru
				case 'more':
					print("and this fell thru from snoopy above")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
	endswitch
'''

waffles2 ='''
	switch(exp){  
		case 1 thru 3: 
			print("starship to the moon and then mars, never!")
			print('first prize')
			print('starship booster will not succeed for a year or two')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp)  
				case 'blable':
					print("we are inside of sw 11 now wildness")
					
					print("I just typed this like Snoopy")
					result[0]="snoopy"
					fallthru
				case 'more':
					print("and this fell thru from snoopy above")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			exp = 'rocket'
			switch(exp)  
				case 'rocket':
					print("oh this is very interesting the fifth element")
					print("I wonder if it will work ")
					result[0]="starship"
					fallthru
				case 'more':
					print("one never knows what a woman is thinking ")
					break
				default:
					print("out of rocket fuel ")
			endswitch 
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
	endswitch
'''
#endswitch(waffles)
#jumanji
#trying a simple one to see what happens
#for testing exp = 1


### wednesday december 29th, 2021 10:02 am ====DECEMBER 29TH WEDNESDAY ADDITION ==========================
###### this will be called from imported starship file

#it was here that is now in cupcake


##=====/////=================////////////////============================================
inputstring=''
#inputstring = waffles # red_robin # red_robin 

resultis=[]
resultis.append(0)

def determine_if_nested_switch(inputstring):
	realnumber = inputstring.count("endswitch") #it's possible there are no nested switches
	realnumber = realnumber + 1 #this account for the first switch which isn't counted
	if realnumber == None or realnumber == 0:
		realnumber = 1 #this is in case there are no endswitches meaning no nested switches
	#end if
	print("see if this number is different")
	print("counting the endswitch + 1 we get ",realnumber)
	if realnumber >= 2:
	    print("voila we have nested switches ")
	    resultis[0]= True
	else:
	    print("nope, just one single switch ")
	    resultis[0]=False
	    

#determine_if_nested_switch(red_robin) #waffles2	 
#print("for waffles we have")
#print("jeeze if nested switch=",resultis[0])
   
   

#======


def clear_switch_number_lists():
    switch_numbers_to_transfer=[]
    thenumbers=[]


thenumbers=[]
#creating churchill list
churchill=[]
real_switch_numbers_to_transfer=[]

#def fill_the_numbers_list():
#    for item in switch_numbers_to_transfer:
#        thenumbers.append(item)

def loop_thru_numbers_list():
    print("these are the switch nubmers to tranfser in the numbers")
    #for item in thenumbers:
    #    print(item)   

def fill_real_switch_numbers_to_transfer_list():
    if len(real_switch_numbers_to_transfer) >0:
         real_switch_numbers_to_transfe=[] #empty it
    else:
        pass
        
    for item in switch_numbers_to_transfer:
        real_switch_numbers_to_transfer.append(item)
    print("what was just imported and saved is real_switch_numbers_to_transfer from starship")
    print(" we have",real_switch_numbers_to_transfer)
    print("...")   
    print("the switch numbers to transfer are..",thenumbers) #this is a dependency   
    print("these numbers are from starship")
    
    
def show_the_numbers_list():
    #return
    print("these are the switch_numbers_to_transfer ")    
    print("thenumbers=",thenumbers)
    #for item in thenumbers:
    #   print(item)

def loop_thru_radical_list():
    return #print("loop thru radical_list")
    #for item in radical_list:
    #    print(item) 

def fill_radical_list_with_quail():
    del quail[:]
    for item in radical_list: #from starship list which is really quail
        quail.append(item) 

def fill_churchill_list_from_quail():
    #print("this is what is in quail made by starship from radical_list to quail")
    for item in quail:
        #print(item)  
        churchill.append(item) 
        
        
        
## THIS IS PHASE ONE MINI MAIN FOR DOING FIRST TWO STAGES
##  MAKE PAIRS OF SWITCH AND ENDSWITCH
##  SEPARATE THE SWITCH STINGS
m31=[] #new list
##==============================================
## phase_one_of_nested_switches_procedures(
##==============================================                      
def phase_one_of_nested_switches_procedures(inputstring):
    return #not called
   #  print("===phase one of nested switches procedures()===jan 7th Monday coding===========")
#     convert_nested_switch_string_to_strings_in_quail_list(inputstring) #from starship
#     fill_the_numbers_list()
#     loop_thru_numbers_list()
#     fill_real_switch_numbers_to_transfer_list()
#     show_the_numbers_list()
#     loop_thru_radical_list()
#     fill_radical_list_with_quail()
#     fill_churchill_list_from_quail()
#     print("this is new here ")
#     switch_numbers_to_transfer=[]
#     for item in thenumbers:
#         switch_numbers_to_transfer.append(item)
#     print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
#     for item in radical_list:
#         print(item)
#     for item in radical_list:
#         m31.append(item)  
#     print("testing m31 has the stirngs now") #this is all we need for output from it
#     for item in m31:
#         print(item)
        
#================




#greenbutton=''
#======
def test_list():
    #print("test_list called to loop thru quail and stanford")
    return
    #for item in quail:
    #    print(quail)
    #print("===========")
    #for item in stanford:
    #    print(item)


#think of this as endswitch(red_robin)

#test_list()


        

	
##==================================
##==================================
##==================================
##==================================


   



    






listinput=[]
      
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

###=================
rattabs=[]

combined_tabs=[]
christmastree=[]

 
fox=[]  #this is just a simple test 



######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================

##=======================================================
##  check_if_words_red_white_blue_in_string(stringhere)  #dreamed up sat jan 22, 2022
##=======================================================
def check_if_words_red_white_blue_in_string(stringhere):
    #print("  ===check_if_words_red_white_blue_in_string(stringhere):=== ")
    if "red" and "white" and "blue" in stringhere:
        pass #print("YES GREEN LANTERN red white and blue in string")
        #print("== [GREEN]== red white blue are TRUE")
    else:
        pass #print("NO RED ALERT no red, blue, white")
        
    #for line in stringhere.splitlines(): #all correct at this point
    #    print(line)

param1=[]
param2=[]
param1.append(0)
param2.append(0)
##==============================
##  get_pair_in_pairslist   example  get_pair_in_pairslist(1)
##==============================
#output param1[0] and param2[0] for a pair 

test_pairs = {
  "22":  "[22,33]",
  "44":  "[44,66]",
  "55":  "[55,58]",
  "77":  "[77,86]",
  "88":  "[88,99]",
  "102": "[102,110]"
}
#print(test_pairs)
##========================================
## get_pair_for_switch_number(x):  #this accesses the test_pairs dictionary
##========================================
def get_pair_for_this_switch_number(x):
    print("x=",x)
    y = test_pairs[x]
    #y = eval("test_pairs.get(x)")
    print("pair =",y)
   


#make_sets_from_three_tabs()

#threetabs=[]
#endtabslist=[]
#endswitchlinenumbers=[]





    
 





###=================================================
#when running from frosty.py comemnt the two lines below out
#inputstring = string_to_use
#create_list_of_pairs_now(inputstring); #commented out dec 15th for testing


#Santa_Cruz_Python_Preprocessor/fourth_of_july2good.py /

def message_from_linus():
    print('hello from Linus file')
 
#message_from_linus()   
#import official_switch_case_silver
#from official_switch_case_silver  import *  
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 



# output is to inputstring[0]

passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)




##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	#this is called and runs on jan 8th 
	print('what is the date jan 8th saturday morning software')
	awesome='';counter =0;newstring='';
	print(inputstring)
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
			#end if
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		    ####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring
	#for line in newstring.splitlines(): #was redrobin.splitlines()
	#	print(line)
	print("AFTER ADDING the line number as comments to the switches in red robin baby ")	
	print(newstring)   #it prints red_robin switch combo string with the line numbers added in comments
	print("smart_switch_numbers=",smart_switch_numbers)  #this is new here too 
	return newstring #this way I can capture the changed string





quail=[]



def empty_switch_and_endswitch_list_locations():
    print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]
def get_switch_and_endswitch_locations(z): #from string z input parameter
	return
	#return we START BUILDING
	print("thbis is what I am testing now now now")
	print("  get switch and endswitch locations###  called line 322 #####")
	print("######get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		
		if "switch" in line and "end" not in line:
			print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		
		else:
			counter += 1 
	
	counter=0
	for line in z.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line:
			#print(line)
			#print("look right here endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1 
		#'''
	#print("at this point this is what we have...after testing BIG YELLOW BIRD go bird")
	del switch_location[0] #takes out first number not needed
	print("switch_location=",switch_location)
	print("endswitch_location=",endswitch_location)
	#test_string1exit()
	#print("this over writes the contents of these two lists ")		
	
	print(z)                #now I remember that is the first switch which doesn't matter
	print("I deleted the first switch since I'm not bothering with it")
	print("switchlocations=",switch_location)
	print("on line 180 endswitchlocation=",endswitch_location)
	
	print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	
	print('switch_location=',switch_location)
	print('endswitch_location=',endswitch_location)
	#the input is above
	




	
	
	##################################################################################
	############## working on this on saturday, october 23rd, 2021 ###################
	##################################################################################
	#print(" rain fall status ")
	counter=0
	
	
	
	counter=0
	print("starting at counter =0")
	
	print("=============== starbucks morgan hill =====")
	print(switch_location)
	print(endswitch_location)
	print("emptying together pair here")
	del together_pair[:] #delete it just in case to start with clear chalkboard
	print("=======") #THIS FILLS THE TOGETHER_PAIR LIST OF SWITCH,ENDSWITCH 
	#print("this loop fills the together_pair list of switch,endswitch numbers")
	#print("this is so much dam fun oh yeah")
	total1 = len(switch_location)
	total2 = len(endswitch_location)
	print("total1 =",total1)
	print("todal2=",total2)
	#print("this is where we START BUILDING the ===TOGETHER PAIR =====")
	for item in switch_location:
		solution = "[" + str(switch_location[counter]) + "," + str(endswitch_location[counter]) + "]" 
		print("solution=",solution) #to see what it looks like 
		together_pair.append(solution)
		print("counter=",counter)
		counter += 1
		
		#this should prevent stack overflow of the list range added november 9th 
		if counter >= len(switch_location):
			print("stack overflow called since counter > = len(switch_location)")
			break
		else:
			continue
			
	print("now we will loop thru the together_pair to see that the pairs are in there")
	del endswitch_location[-1] #should delete 100
	print("this is what is in TOGETHER_PAIR at line 254")
	for item in together_pair:
		#print(item)
		apple = item.split(",")
		#print("======")
		#print(apple[0])
		sweet1 = apple[0].replace("[",'')
		#print(sweet1)
		#print(apple[1])
		sweet2 = apple[1].replace("]",'')
		#print(sweet1,sweet2)
	

	




#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced




#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#this accesses coolstring august 5th, 2021
#this is to set the inner switch positions in the main switch input strings
#after the bodies of the nested switches have been stripped out

##########################################
##  put_switch_locations_into_switch_list()  #this is making the nested_switch_ number  
##########################################
def put_switch_locations_into_switch_list(inputstring): #just added param
    print("##2### put_switch_locations_into_switch_list ###")
    print("##2## put switch locations into switch list ###")
    print("put switch locations into switch list")
    #### get swith and endswitch locations called here 
    get_switch_and_endswitch_locations(inputstring) #it's right here 
    #make sure switch_list starts out empty initialized
    if len(switch_list) > 0:
        del switch_list[:]
    else:
        pass
    ##================== this is new jan 3, 2022
        
    for item in switch_location: #this is only going thru switch_location
        switch_list.append(int(item))  #was -1 on here #off by one in the string for some reason
    # print(" ");print("switch_list=")
    #print(switch_list)

#######################################
##  swap_switch_to_nested_method()  #this is making the nested_switch_ number  
#######################################
def swap_switch_to_nested_method(stringname,linenumber,series_num):
	print("============== swap_switch_to_nested_method() ==========")
	#print("input: linenumber", linenumber)
	#print("input: series_num", series_num)
	
	#print("##4## swap switch to nested method - numbered ###")
	#print("##4## swap switch to nested method - numbered ###")
	#print(" THIS IS BEING CALLED TO DO THE MAGICswap switch to nested method called....")
	str_list = stringname.split('\n')
	#print('changing line',linenumber)
	#series_num = number_series[0] 
	str_list[linenumber] = "\t\t\tnested_switch_" + str(series_num) + "(n)"
	stringname = "\n".join(str_list)
	genius[0]=stringname   #strings are immutable but lists are mutable(changeable)

######################################	

#this is the control center main that runs this operation
#this numbers the nested switch methods top down
#genius[0]=coolstring  #assignment here <<<==================


#######################################
##  loop_thru_switch_locations():
#######################################
def loop_thru_switch_locations(regularstring):  #looping thru  switch_list[10,18]
    print("##1##loop thru switch locations ## line number 276 ####")
    print("##1##loop thru switch locations ######")
    #trick put_switch_locations_into_switch_list
    #method called
    put_switch_locations_into_switch_list(regularstring) #method
    print('this filles switch_list of switch line numbers')
    #print(genius[0])
    print("what is the order of the switch_list I think it's reversed to do bottom up")
    print(switch_list)
    print("------------")
    print("switch_list=",switch_list)
    le_number=1 #default numbering nested string 
    for item in switch_list: #loops thru switch_list WITH SWITCH LOCATIONS (LINE NUMBERS)
        print("item in switch_list",item)
        #string,switch,line number
        # swap_switch_to_nested_method here 
        #method this one is the holy grail that actually works
        ###############################
        swap_switch_to_nested_method(genius[0],item,le_number) 
        coolstring =genius[0]
        le_number += 1  #adding to the nested number here
    print("#### end of loop thru switch locations() ####")
    print('the EXIT sign is green')
#######################################




##==========================================================|
## swap_nested_switches_with_methods_in_main_switch_string
##==========================================================|
def swap_nested_switches_with_methods_in_main_switch_string(inputstring):
    print("===swap_nested_switches_with_methods_in_main_switch_string()== line number 309=") 
    loop_thru_switch_locations(inputstring) 
    print("this is the output string of the transformation from input string")
    ## this is after loop thruw switch locations method is completed
    print("this is the main input switch string after adding nested methods")
    print("the output of this transformation of swapping switch for nested_method")
    #this is the input string transformed 







#-------------------  july 10th, 2021   11:03 pm  -------starbucks coding-------
#I am hard coding the location of the switch words. I need to have it search on it's own
# but I recall I have code that does that elsewhere
#now I need to find the code that makes the correct nested switch list locations


######======================
#loop_thru_switch_locations() #where to find the inner switches to replace with a nest method
######======================





##================================================================
##===  mission_control() got rid of holiday redundant
#      which calls:  phase_one_of_nested_switches_procedures(thestring)
##===============================================================
#think of this one as endswitch(x)
#this one not called
#def mission_control(acase,thestring):#not called
#    return  #so this is being turned off here by me 
    #print("inside of mission_control we have ",acase,thestring)
    #print("-----------mission control() called--------------")
    #acase=1
    #varholder[0]=1
    #greenlist[0] = acase
    #clear_switch_number_lists() #before just clear them
    #phase_one_of_nested_switches_procedures(thestring) #calls make switch pairs and separate strings

# this calls mission_control()
def now_call_it():  #this dynamically calls mission_control
    print("==now call it()=====")
    anumber = variableinput[0]
    #if run[0] == True:
    stringname=stringlist[0]#red_robin
    #here we are dynamically changing the input params to mission_control
    #mission_control is called right here 
    mission_control(anumber,stringname)  #this function must stay RIGHT HERE 
    stringlist[0]='' #added on jan 22, 2022
    
def mrendswitch(string): #this would run above in the file
    print("------- mrendswitch called --------")
    #print("=== mrendswitch called ====")
    #print("------- mrendswitch called --------")
    stringlist[0]=string
    #print(stringlist[0])  #what this is doing is putting values into 2 lists 
    stringname =stringlist[0] #and then calling mission_control dynamically
    #run[0]= True  
    now_call_it() #this calls mission_control just above this section

#mrendswitch(red_robin) 
#@@@@@@@@@@---------

#I think mrendswitch has to be after chain methods but that doesn't make sense



#look in m31 here to see what's in it.
#and then just access it later


### was calling it here
  
#this will be endswitch(red_robin) and called on the other side
#print("======about to call mrendswitch()=====")












#this will be endswitch(red_robin)
##========= this will be on top at the bottom of a switch string
###=========================



#this might be necessary after all 
'''
and commented out bypass205(y)
and commented out bottom_stages() in this file
'''
#########
#########







#================================================================

#def noway(number_or_word,the_string):
def is_this_thing_turned_on():
    print("----------s this thing turn on() ---- triggered")
    exit()
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
#print("this gets the line number of the line that the case starts")
#print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
    print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            #print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
    print("case line numbers",pacman)    
    #print(pacman[2])  
    print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            #print(item)
            #print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    #print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    #print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
            #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")



#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    print("x=",start_and_finish[1])
    print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
#r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function


################################################################################
################################################################################
################################################################################
################################################################################
columbia_river=[]
#gold_list=[]
################################################################################
################################################################################
################################################################################
################################################################################
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    print("= copy_a_nested_switch() called== just now 10;43 am ====")
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################


# uses methods:
# add_comment_and_line_number_to_all_switches
# inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
# copy_a_nested_switch(water)
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]] 

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################



###3==============================
#it uses the gold_list to copy the nested strings      
##=============================================================
##  split_up_big_string_into_nested_switches(myinputstring)
##=============================================================
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print("-----------split up big string into nested switches()------------")
    water =add_comment_and_line_number_to_all_switches(myinputstring) #stringname goes here
    #for line in water.splitlines():
        #print(line)
    del columbia_river[:]  
    #print("gold_list=",gold_list)
    columbia_river.append(water) #this adds the mega initial string first for the main string
    #print('at this point the length of columbia_river should be 1 and it is',len(columbia_river))
    for item in gold_list: #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
        copy_a_nested_switch(water)  #copy string based on switch,endswitch pair 
        #print("====================")#puts resulting string into makeitwork[0] and output
        output = makeitwork[0]       #put nested string into columbia_river list
        columbia_river.append(output)
    #print("length of columbia river =",len(columbia_river))
    counter =1
    #adding here the initial string which will be used to make the main switch
    print("now loop thru columbia river to see the switch bodies seperated")
    for item in columbia_river:
        print("counter=",counter)
        #print(item);
        print("===========");
        counter += 1
##================================================================        

     
    
     
#######======================================== ## find_nested_switch_game
#the input is the whole string afgter having added comment of swithc line number in loopstring[0]
#x =11; y = 60;
##=======================================
##  testing_code_copying_string_adding_it_to_list()
##========================================
def testing_code_copying_string_adding_it_to_list(x,y):
    print("testing code copying string adding it to list")
    inputs_pair_to_copy_a_string(x,y)
    #water is the modified string with line number (but need to only add the line numbers once as comment
    copy_a_nested_switch(water) #this takes in switchstring with switch numbers added as comment
#######=========================================
    output = makeitwork[0]        #this would have to be after the call to copy a nested switch
    columbia_river.append(output)

#testing_code_copying_string_adding_it_to_list(11,60)


#print("now printing out columbia river")
#print("length of columbia river =",len(columbia_river))
#for item in columbia_river:
#    print(item)
    
#exit()
 






abovenestedswitch=''

####################################
## copy_top_hat_of_main_switch(): #this grabs the string of the main switch above 
# the first nested switch in this case there is only on 
####################################
terriblysmart=''
def copy_top_hat_of_main_switch(): #this is grabbing the top of 
    #the switch case just above the first nested switch 
    print("======copy top hat of main switch()====")
    global abovenestedswitch
    linecounter=0 #string name find_nested_switch_game
    for line in find_nested_switch_game.splitlines():
         # between >= 1 and <= 10
        if linecounter >= int(start) and linecounter <= int(finish):
            abovenestedswitch += line + "\n"
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result copy above  first nested switch case ")        
    print(abovenestedswitch)
    terriblysmart = abovenestedswitch

#copy_top_hat_of_main_switch()  #not called yet

#print("end of copying top half above nested switch ")  
#print("it should end with switch which we will edit")

####################
#replace switch

#linecounter= 0
newlist=[]
newlist.append(0)
#newlist[0]
# I just put this into a function to have control over it 
#COPY COATTAILS BOTTOM OF BIG SWITCH AFTER NESTED SWITCH END
################################################################
## copy_coattails_bottom_of_big_switch_after_nested_switch_end():
################################################################
def copy_coattails_bottom_of_big_switch_after_nested_switch_end():
    print("copy_coattails_bottom_of_big_switch_after_nested_switch_end()")
    linecounter=0
    start = 21 #INPUT PARAMS TO GRB need to put these in a list for efficiency
    finish = 32
    outerswitch=''
    for line in find_nested_switch_game.splitlines(): #string looping thru
        #   IF BETWEEN line numbers 21 and 32 
        if linecounter >= int(start) and linecounter <= int(finish):
            outerswitch += line + "\n"
            linecounter += 1
        else:
            linecounter += 1
            continue   
        
    print("testing getting a COPY COATAILS BOTTOM OF BIG SWITCH")
    print(outerswitch)
    newlist[0]=outerswitch
##===================================================





#this is turning code into a function on july 15th, 2021
#######======
#copy_coattails_bottom_of_big_switch_after_nested_switch_end()
#######=======





#here is where i make this temporary list that I will put the
#input strings of the main switch and the one nested switch for testing

inputstringswitches=[]

###################
##    swap(a,b)
###################
def swap(a,b,c): #c = starbucks[1]
    cooler =c.replace(a,b)
    return cooler #starbucks[1] =string with changes made
    
    
  
#this puts the nest_method on the line selected in the tophalf of the string
#################################
## swap_switch_for_nest_method(n)
################################# 
def swap_switch_for_nest_method(n): # I will add more values later perhaps 3 or 4 for coordinates
    global abovenestedswitch
    abovenestedswitch=terriblysmart
    print("called swap_switch_for_nest_method(n)",n)
    abovenestedswitch = abovenestedswitch.replace("switch(exp){","nested_switch_" + str(n) + "(n)")
    print(abovenestedswitch)
    print("===================")

#june 29th, 2021


def scan_input_string_for_number_of_switches():
    print('work on this')#I have this figured out now elsewhere
    
    
#commented this out on august 3rd testing making big method 
   
#this needs to be put into a method and called below actually
def fishfood(): #necessary testing that's all
    print('about to try new swap method')    
    swap_switch_for_nest_method(2) #feeds it the number 2 for testing
    outerswitch=newlist[0]
    outerswitch= makeitwork[0]
    maybe=abovenestedswitch + outerswitch
    print('we have stripped the nested switch from the main switch')
    print("and inserted a method for now")
    print(maybe)
    ######### put first main switch into inputstringswitches
    print("adding main switch and nested switch taken out into list")
    print("the next step will be to run it thru the silve_module")
    print(" to create teh strings output in python")
    inputstringswitches.append(maybe) #should be position 0

    print("and the nested switch is here before it's converted")
    print(makeitwork[0]) #roadrunner
    #roadrunner = roadrunner.replace("endswitch","}")
    ######### put nested switch into inputstringswitches
    inputstringswitches.append(makeitwork[0]) #should be position 1
    print("====== go for the gold =======")
    print("this shows the resulting strings accessed thru the list that")
    print("they were put into so I can access them now for running silve module")
    print("==--------------==")
    print("here is the result now")
    print(inputstringswitches[0])
    print("now the nested switch")
    #print(inputstringswitches[1])
    galaxy=''
    galaxy = inputstringswitches[1]
    print(galaxy)
    print("Now I replace endswitch with }")### replace endswitch with }
    inputstringswitches[1] = galaxy.replace("endswitch","}")
    print("now looking into inputstringswitches[1] endswitch should be gone")
    print(inputstringswitches[1])
    print("==== end of first major step ==in process of transformation ==")

#################===========
#fishfood()
#################===========




#############################
##  get_inner_switch_line()
#############################
def get_inner_switch_line():
    print("can we get serious here I mean really")       
    bronze=0     
    linecounter=0
    secondswitchline=0  
    for line in find_nested_switch_game.splitlines():
        if "switch" in line: 
            #print(line) 
            linecounter += 1 
            print("switch line number = ",linecounter)
            secondswitchline = linecounter
            break
        else:
            linecounter += 1  
            continue
    print("line with inner switch =",secondswitchline)
    print("==================")
#the inner nested switch will obviously end within the same case it starts in.

###########==============
#get_inner_switch_line()  
###########===============


                
###########################################################

switcharoo=[]
switcharoo.append(0)

linecounter=0





#######################################
##  get_number_of_nested_switches():
#######################################
def get_number_of_nested_switches():
    print("get_number_of_nested_switches()")
    linecounter=0
    #this looks for the line number of 2nd switch for now more later  
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "switch(" in line:  #grabs first line
            #print(line)
            switcharoo.append(linecounter)
            
            linecounter += 1
            continue  
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
              
            #if "switch_nest()" in line:
            #   print(line)
    print("line number of switches",switcharoo)  
    print(switcharoo[2])                

casecounter=0
case_count=0

##########========================
#get_number_of_nested_switches()
##########========================
###############################################################
################ testing call of these methods at once
###========== august 3rd test Tuesday nice air conditioning ====
def nested_switch_trapeze_tricks():
    return #not called
    print("==== nested_switch_TRAPEZE_tricks() called=====")
    loop_thru_switch_locations()
    get_case_line_numbers(find_nested_switch_game)
    get_larger_number_less_than_case()
    get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
    copy_a_nested_switch(find_nested_switch_game)
    copy_coattails_bottom_of_big_switch_after_nested_switch_end() 
    fishfood()
    get_inner_switch_line() #not sure if I need this one
    switcharoo=[];switcharoo.append(0);linecounter=0
    print("the nubmer of nested switches=")
    get_number_of_nested_switches()  # here it is 




################################
## get line number of cases()
################################
def get_line_number_of_cases():
    print("get_line_number_of_cases()")
    for line in find_nested_switch_game.splitlines():
    #get each case number 
    #check if switch in it
        if "case" in line:  #grabs first line
            case_count += 1
            print("case_count=",case_count)
            #print(line)
        
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
     
#answer 2nd case section    
#nested switch on line 10        
 #answer line 2 inside of case
 #case section 2 starts on line 8

    
#Monday june 28th, 2021 thinking
#get switch line number and case it's in and line number inside of case
#and what line the switch ends with }
#which I need to know to copy it. I can set the loop to start
#on a particular line and to concat a string and stop
#after coping a set number of lines. 
#Based on line count between switch and } which I can do first
#if line.startswith("switch") do until line startswith("}")




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========








print("========")
line_1=[]
line_2=[]
line_3=[]
line_4=[]
line_5=[]
line_6=[]
line_7=[]
extra_line_1=[]
extra_line_2=[]
extra_line_1.append(0)
extra_line_2.append(0)
football =[]
football.append(0) #method name 
football[0]="\tinner_switch_1('test4')"

line_1.append(0)
line_2.append(0)
line_3.append(0)  #for example nested switch is line 3
line_4.append(0)
line_5.append(0)
#line_6.append(0)
'''
#line_7.append(0)
 #say it's 4 line case 
line_1[0]="\tprint satement line 1"
line_2[0]="\tprint satement line 2"
########################################
line_3[0]="\tprint satement line 3"
line_4[0]="\tprint satement line 4"
print("================")
#if it's on line 3 we take top off to separate it 
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
# new
print("beginning state")
extra_line_1[0]=line_3[0]
extra_line_2[0]=line_4[0]

print("copying that will be don")
print(extra_line_1[0])
print(extra_line_2[0])

print("====bit flipping==== ")
print("putting nested switch in position 3 which is line 3")
line_3[0]=football[0] #designated line for nested switch 
line_4[0]=extra_line_1[0] #this is a novel approach restarting from 1
line_5[0]=extra_line_2[0]

print("after adding the switch nested method in position 3")
print('we then have this:')
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
print(line_5[0])
print("=========== now adding teh strings to magic concatting them ")
magic=''
magic = line_1[0] +"\n" +line_2[0] +"\n" + line_3[0] +"\n"+ line_4[0] +"\n" + line_5[0]
print(magic)  
print("=====================")  
print("let teh games begin")    
print("done")
#line_5[0]="line 5"
#line_6[0]="line 6"
#line_7[0]="line 7"
#line_8[0]="line 7"
mylist=[]
mylist= ["starter","one","two","three","four","five"]
'''



def sosmart():
    mylist.insert(0,"starter")
    mylist.insert(1,"one")
    mylist.insert(2,"two")
    mylist.insert(3,"three")
    mylist.insert(4,"four")
    mylist.insert(5,"five")
    
    
def put_nested_switch_into_line(x):
    mylist.insert(x,"nested_switch") #it replaces the whole line
    print(mylist)
    
def reset_list():
    for item in mylist:
        del item
    
#print(mylist)


# I ahve to split it in half somewhere and we have top above nested switch line
#and then we have the nestline
#and we have the bottom 

#so if we have lists for each line number of case section up to say up to 10 lines for now
#say switch will go on line 3 of 6 lines for an exmaple
#line 1 and line 2 are top
#line 3 is nest_switch_method
#line 4 to n is the bottom




     
case_guts='''
\tprint("aaaaaa in the main switch")
\tprint("bbbbbb below")
\tprint("ccccc#result of innerswitch running
\t#what ddddddd?? use a list to capture it
\tfallthr eeeeeeeu('word'
'''
    
    #method inner switch withnumber (input will likely be from a list later)
add_this="\tinner_switch_1('test4')\n"
nested_method_name=[]
nested_method_name.append(add_this)
crystal=[]
crystal.append(0)# [0]


#get input string of case section
#
# I need to get the line number where the switch is supposed to go
# based on the input C style location of the nested switch
# based on which case it is in (the sequence starts from 1)
# then detect the line number in order within that case where the switch starts
#
#
  
#exmaple, we need to add nested switchmethod to line 2
#so we copy line1

top=[]
middle=[]
bottom=[] 
put_in_here=[]

#### fudge ########    
def fudge():
    return
    #def copy_one_line_inside_case(x)
    astring=''
    soupstring=''
    line_counter =0
    print(case_guts)  
    
    print("===========STAGE 1=========")  
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == 1:  #grabs first line
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print('first line string=',astring)
    #################
    newstring=''
    coolstring=''
    line_counter =0
# copy from the line where we want to insert (line 2) 
# thru to last line in case section
    print("============STAGE 2===========")
    #this copies 2nd string to string n (the rest)
    
    for line in case_guts.splitlines():
        if line_counter >= 2:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
        
    print(newstring) #this copies all of the lines into newstring
    put_in_here.append(newstring)
    #this is the switch method string on top of rest of case body lines
    #copy from targetline insertion line thur last line
    # we then add the nested switch method to the rest of the case 
    ##########################################
    #this will be a new helper method
    
    #def add switchline to rest of case body()
    #this is necessary BEFORE adding first line
    print("=================STAGE 3=================")
    egg=[]
    nested_switch_method_name=[]
    fossil=[]
    #fossil.append(0)
    #fossil[0] = nested_switch_method_name[0] + put_in_here[0]
    coolstring = add_this + newstring#how so I insert to front of a string
    #higher =nested_method_name[0] + put_in_here[0]
    egg.append(coolstring) #egg[0]
    
    #middle.append(coolstring)
    print(coolstring)
    glory=''
    #this adds the first string followed by coolstring
    #########################
    #this adds the line(s) above the insertion line 
    #put first string ontop of rest of lines of 
    #this adds the first line which was skipped to the new switch line
    #with the rest of the case body
    
    
    #def add_top_above_lines_above_switch_line(a,b)
    #a = string with the switch_method name
    #b = rest of the lines
    print("==========STAGE 4==========")
    nested_switch_method_name.append(astring)
    glory = astring + coolstring#[0] #now it's a list
    print("glory shows")
    print(glory)
                #method name in list     #nested method name + rest of lines in case
    egg[0] = nested_switch_method_name[0] + egg[0] #coolstring
    print('from list now') #string add_this
    print(egg[0])
    #bottom.append(glory)
    #print("now printing from the list bottom[0]")
    #print(bottom[0])
#   def add

#then replace first line with new line methodnested name
#    then add paste first line to new beginning of string
#print('copy string from line 2 bbs')
#fudge()















###################################
## copy one line inside of case (x)
####################################
def copy_one_line_inside_case(x):
    print("copy one line inside case()")
    astring=''
    soupstring=''
    line_counter =0
    #print(case_guts)    
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == x:
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print(' line',x,' string=',astring)
 ####################   
 #copy just the line entered within the case body



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========








################################################
##  get_below_after_method_insertion()
################################################
def get_below_after_method_insertion(y):
    newstring=''
    coolstring=''
    line_counter =0
    #this copies 2nd string to string n (the rest)
    for line in case_guts.splitlines():
        if line_counter >= y:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
    print('below after method insertion',y)   
    print(newstring) #this copies all of the lines into newstring
    #this is the switchm

egg=[]





 
  
  
  
  
  
           
 



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






##### this makes the input for zoo[1] lowercase
###############################
## make_input_lower_case() ####
###############################
def make_input_lower_case():
    answer = zoo[1]
    answer = answer.lower()
    zoo[1] = answer    

# what i doing here is putting the dynamic built inners switch python code into a list.
# this is just beautiful and brilliant.







#right here 

## add this to it:  
#def inner_switch_3(n): # 
samplecode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n) #3 
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''

#modified on november 12th 2021 friday to get this sucker working 
##====================================
##  get_switch_number_in_comment()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
#this looks ofr the first switch at 3 tabs need to modify it to 1 tab depth. aha 
def get_switch_number_in_comment_in_output_python_code_string(stringname): #this might be for when
	print("get_switch_number_in_comment_in_output_python_code_string(stringname)")
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number_in_comment_in_output_python_code_string() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	#for line in stringname.splitlines():
	#	print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0 #this looks for inswitch at 1 tab depth length 
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "inswitch" in line and "end" not in line and tablength == 1:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number ",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;



flynow=[]
###============================================================================
##  put_output_python_nested_switch_code_into_def_inner_switch_numbered(string):
##==============================================================================
#try this november 12th struggling here 
#I want to see this
'''
def inner_switch_3(n): 
    print("=======inner_switch called==3==",n)
    casetest1 = ['test5','test6']
    #this is switch inside of inner_switch
    inswitch(n)                           #<<====== inswitch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "test1":
'''

def put_output_python_nested_switch_code_into_def_inner_switch_numbered(stringname):
	print('===== TESTING RED ALERT ======')
	print("put outpout python nested switch code into def inner switch numbered")
	#this calls a method to get this switch number to use to number this nested switch
	thenumber= get_switch_number_in_comment_in_output_python_code_string(stringname) #use other code similar to this
	#print("the number it returned is",thenumber) #thenumber=22 #for testing
	string_to_add= "def inner_switch_" +thenumber.strip() +"_(n):\n"
	concatstring = string_to_add + stringname;
	#print("lets see if it actually worked or not and concatted it correctly")
	##################################
	#for line in concatstring.splitlines():
	#	print(line)
	flynow.append(concatstring) #so the resulting string modified exists.
	#########################

#thenumber=22
#string_to_add= "def inner_switch_" + str(thenumber) + "(n):" 
#put_output_python_nested_switch_code_into_def_inner_switch_numbered(samplecode)
#makeitso = string_to_add + samplecode;

def testit():
    print("testit called to see if I put def nested method at top of string")
    print("doing samplecode first in virgin form")
    #for line in samplecode.splitlines(): #unchanged original output string
	#    print(line)
    print(":")
    print("end of test run....")
    print(":")
    print("and now after putting def nestd switch numbere at top")
    print("did this sucker work....please...")
    #for line in makeitso.splitlines():
	#    print(line)
#testit() 
    
dumbstringcode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
			
	switch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			fallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print (" case behavior works in Python now!")
			print("")
			fallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			fallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested  ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner  1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''


fridge=[]
fridge.append(0)




#for line in dumbstringcode.splitlines(): #switch case in JS
 #   #print("smartcounter =",smartcounter)
 #   
 #   if "\t\t\tswitch" in line:
 #        umbrella += "inswitch(n)\n"
 #   if "fallthru" in line:
 #       umbrella += "infallthru(
 #       
 #              
       #this is the range I want to print



#this is where the swo string is I was looking for.


#find_nested_switch_game ='''
#clever('4')
swo ='''
	switch(exp) { #first true test 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  rrr')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     # inner s w i t c h      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#this one has two nested switches that I will try next. 
swo_next ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  ggg')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # inner s w i t c h     =============  
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #=========================
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 28    ===============   
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch   #38===================================
			fallthru
		
		default:
			print('the end')
}
'''	
# I seem to recall a bug usin

#this is testing sensing a multiline switch with more than one switch
####===============
#testing moved here for safety
# CHECK FOR THE NUMBER OF SWITCHES WITHIN THE INPUT STRING
nested_switch=[]
nested_switch.append(0)
nested_switch[0]= False # by default
################################################################################
#determines if a string input is a nested switch with at least one inner switch
################################################################################



###################
##  jumanji(y)       tests if string input has at least one nested switch
###################  sets nested_switch[0] = True
def jumanji(y):  #instead of this I just do a count for endswitch which is just one line of code. 
	print("--------------------------")
	print(" --- J U M A N J I -------")
	print("--------------------------")
	
	#print("get count of lines startingwith switch in the string")
	#this counts switch number in the string
	switchcounter=0
	for line in y.splitlines(): #determine if switch is in line
	#this looks for switch in the line but endswitch can't be in this line
		if "switch" in line and "end" not in line:
			switchcounter += 1  ## SWITCH COUNTER
			#print("switchcounter=",switchcounter)
			#print("yea this starts with switch")
			continue
		else:
			continue
	print("total switches =",switchcounter)
	
	##============================
	#this counts endswitch number in the string
	print("get count of lines startingwith endswitch in the string")
	endswitchcounter=0		
	for line in y.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line: 
			endswitchcounter += 1  #END SWITCH COUNTER
			#print("endswitchcounter=",endswitchcounter)
			#print("yea this starts with endswitch")
			continue
		else:
			continue
	print("TOTAL endswitches =",endswitchcounter) #endswitchcounter
	#print("end of this checker ===========")
	print(" total switches",switchcounter, "and total endswitches",endswitchcounter)
	
	#this sets the flag in nested_switch[0] if at least one nested switch
	#===============================================
	#if one or more switch and one or more endswitches
	if switchcounter > 1 and endswitchcounter >=1: #actually if endswitchcounter 1 it's True
		nested_switch[0] = True
	else:
		nested_switch[0] = False
	
	#print("the result of this test for if this has nested switch(es)") 
	#print("this is the list with the critical nested_switch[0] value")
	#print("WHAT DOES THIS SAY --  it should be True")   
	print("nested_switch[0] = ",nested_switch[0])
	#print("=================")
	#print("=================")
	#print("this  below this is dog breath that doesn't work")
	#print("====== end of this initial switch counter filter that will eventually")
	#print("=== trigger bypass205 to do multiple switches ====")
	
	
#end jumanji()  ===================||	
	
#jumanji(swo)  #called here to test it
#print("just called jumani with swo and if nested switches below will be True")
#print("looking in string swo we have",nested_switch[0])
#this should be the output the nested switch copied
#jumanji(swo_next)
#print("nested switch[0]",nested_switch[0])
#this detects if nested switches in a switch string with nested_switch[0] == True







#this is still using endswitch they aren't swopped out yet

## July 5th, 2021  testing Monday July 5th line number 1593
# July 18 added a second nested swithch to test on lines 28 to 38
samplestring ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  yes')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======28       
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch  #======== ============38
			fallthru
		
		default:
			print('the end')
}
'''	


samplestringzoo1 ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown zoo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			print('hello world')
			switch(exp){  # ===== 24===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'rats':
					print("do autumns")
					print("yep")
					fallthru
				case 'more':
					print("badness")
					break
				default:
					print("we tesla done here")
			endswitch  #========== 34  ==========notice this for it is key 
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======39       
				case 'autumn':
					print("falling leaves")
					print("a night on the town ")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much cranberries")
			endswitch  #======== ============49
			fallthru
		
		default:
			print('the end')
}
'''	


#######################
#### testing ######
### samplestring with switches taken out ####
#### and nested methods replacing it ########
######## july 22 ###testing #####
##### this represents the accurate main switch with proper indentation
samplestring_main ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ff')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			nested_switch_1(n)
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			nested_switch_2(n)   #this is new 28       
			fallthru
		
		default:
			print('the end')
}
'''	


#nested_switch_2(n)
#july 21st 2021 get teh number of lines in the string
# count endsswitches to get number of nested switches
# do the main switch last which erases(skips) the nested switches
#here I count the number of lines in the string to get last line 
# the tricky part was figuring out when to grab the main switch but I couuld actually
#do it first it doesn't matterand make a copy of it and modify the copy





# ibm list is used for holding switch strings 
ibm=[]
ibm.append(0)

use_number=[]
use_number.append(0) #[0]

#def between(x,condition,y):
    
#experimentatl copy the nested switch ignore the rest and only Do one.


#this only copies one nested switch within the main switch
#this i pased on knowing the input 
#these are hard coded here

#just put this here to see if it works correctly
# saturday july 17th, 10:11 am starbucks
#print("STARBUCKS CRUCIAL testing saturday morning")
'''
this is first emptyhing the switch and endswitch locations lists
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





#print("the one below this line should produce 2 switches and one with 10,20")
#this find the location one one pair of a nested switch and end switch

#this gets the start and end from samplestring
#empty_switch_and_endswitch_list_locations()



#print("=== shazam level about to try fancy stuff ====")

#loop
#pairlist is actually a list 
pairlist=[];theforce=[]
#this would just add the switch location
alpha='';beta ='';counter =0;jedi='';
#this reads in data from switch_location
#               and from endswitch_location
#======================================================
# fill_pairlist_with_switch_and_endswitch_pairs(yy):
#======================================================
def fill_pairlist_with_switch_and_endswitch_pairs(yy):
    #print("====fill pairlist with switch and endswitch pairs()=====")
    #print(" godzilla ruled over rodan ")
    get_switch_and_endswitch_locations(yy) #===== using sample stringh 
   # print("this is grabbing the switch locations which are dynamically added to a dictionary for pairlist")
    print("the length of switch location =",len(switch_location))
    print("the length of end switch locatoin =",len(endswitch_location))
    print("==============...............============")
    # loop thru list switch_location ==============================
    counter =0;allpha='';beta='';           #so this is one small set switch and endswitch line numbers
    for item in switch_location: #this loops thru the list switch_location          
        alpha = switch_location[counter]
        beta  = endswitch_location[counter] #they should be the same length 
        #here the positions are appended to pairlist dictionary
        pairlist.append([alpha,beta])       #always in sets of 2 #adds alpha and beta as list into pairlist  list
        print("pairlist=",pairlist)
        counter += 1
    print("======================")
    newcounter=0
    print("the length of the pairs =",len(pairlist));print('let me see what is in pairlist')
    print("pairlist=",pairlist)
    for item in pairlist:  #this is the combined pairlist
        print(item)
        sosmart = pairlist[newcounter] #here I access first and second numbers in pairlist
        print(sosmart[0]);print(sosmart[1]) 
        print("====== JEDI TEST ========")#not to be confused with jumanji above 
        #this takes in data from switch_location list and endswitch_location
        # and glues them together into a new pair list into 
        # list called theforce
        #this is constructing filling the data in the dictionary pair values
        jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
        print('jedi=',jedi) #like this [12,16]
        
        #put pairs into list into jedi and append to theforce
        theforce.append(jedi) #the pair is added  to theforce list
        turbo  =theforce[newcounter]
        newcounter += 1
    print("theforce=",theforce)
    print("the length of theforce list =",len(theforce))
    #print("did we make it this far... in a galaxy")
    #adding loop here to test this
    #print("doing a newest test  christmas tree of the pairs in list theforce")
    acounter=0
    print("====magic brew time=====")
   # print("== the filled list with pairs of switch endswitch is called theforce ===")
    for item in theforce:
        print(item)
        #print("=======")
        cool =item
        print("cool=",cool)
       
        print("acounter=",acounter)
        x=''
        x = cool.split(",")  # see if this trick works
        print(x[0], x[1]) # see if this trick works
        #print("end game")
        acounter += 1
        continue
    #print("end of printing each item in theforce")
###=====





thisdict ={}


def cleanse(x):
    x = eval(x)
    return x;
    
#modified this method on august 11th wednesday, 1:11pm
############################################
##     adding data list to dictionary
############################################
def adding_data_list_to_dictionary(dictname,key,newdata_list):
    #print("LOOK AT THOS at input params see if they are right first")
    print(dictname)
    print(key)
    print(newdata_list)
    return #temporarily halts this from running
    
    print("called adding data list to dictionary")
    #tryit =eval("" + dictname + "[" + key + "]" + "= " + newdata_list +"")
    #tryit =eval("" + 
    angel =dictname
    thekey= key
    newdata_list
    print(angel)
    print(thekey)
    print(newdata_list)
    print("====>>>====>>>end of games...")
    #print(tryit) #to see what it sees
    
    #thisdict["4"] = "[12,22]" #adding data list as string to dictionary
    
    #eventually I will add 1 to dictionary length
    
    ##########################################
    #dictname + key + [12,22] input format 
    ##########################################
    #dictionary name should be known
    print(thisdict)
    for item in thisdict.values():
        print(item)
    print("testing getting value in dictionary by key")
    x = thisdict["4"]
    
    #x = thisdict.get("4") #this should work also
    print(x) #together
    x = eval(x)#just dreamed this up and it worked
    print("this represents getting the x and y for a nested switch locations")
    print("first number",x[0])#seperate
    print("second number",x[1]) #separate
    
    
        


# october 28th, 2021 thirstday
# I need to go thru combined pair list three + five + seven and feed it into a dictionary

## its really get index pair in struct
#### get_number_in_struct(x)   THIS WORKS!!!!!!!!!!! oct 26th



pair_returned=[]

##======================================
##  get_number_in_struct(x):
##==================================
def get_number_in_struct(x):
    print("get_number_in_struct(x) called")
    print("the input was x",x)
    print("get_number_in_struct(x) called too cool")
    print("get ",x)
    #using eval() to do thisdict.get(x)===###################
    apple_pie=eval('thisdict.get(x)')
    print("=====///get number in struck(x) called---------///")
    print("get number ", str(x), " in struct with x called")
    print("apple-pie=",apple_pie)
    super = apple_pie
    if apple_pie == None:
        print("it is None")
    else:
        print("why not",super[0],super[1])
        print("now splitting it into the two numbers within the pair of switch endswitch")
        print(super[0])
        print(super[1])
        #doing this to have common lists for passing on to other functions later
        pair_returned.append(super[0])
        pair_returned.append(super[1])
        print("pair_returned at this point has",pair_returned)
#=============================================




#=======================
#add data to struct
#======================


# this method works on oct 26th 2021
##==============================================
## add_data_to_struct(thisdict,numb,aset)
##====================================================================
def add_data_to_struct(thisdict,numb,aset):
    return #abandoning this too confusing going with just a list of lists
    print("add data to struct")
    print("numb=",numb)
    print("aset=",aset)
    #numb='12' #the number will keep a rolling total and added automaticaly
    thisdict[numb] = aset  #this just seems too simple.
    print(thisdict) 
    
#add_data_to_struct(thisdict,numb,aset)
##============================

gooddata=[]
##==========================================
## get value in dict (name ofdict,x)
##==========================================
def get_value_in_dict(name_of_dict,x): # we will know the dict it won't change
    return #abandonning this for being too confusing and unworkable at this time
    print("plumtree=",plumtree)
    print(thisdict)
    print("get value in dict",x)
    nn = plumtree.get(str(x))
    print("================")
    print("using key",x,"it retrieved from the plumtree dictionary",nn)
    print("================")
    # I was assuming (wrongly) that all keys input would be in dictionary; unknown
    if x in thisdict: #it can't be this simple
        y=eval("plumtree[x]")
        print(y)
        del gooddata[:] #clears it out 
        print(y[0],y[1])
        gooddata.append(y[0])  #this returns with the index[0][1]
        gooddata.append(y[1])
    else:
        print('x',x,'is not in dictionary plumtree')
    

##==========================




#print(apple_pie[1]) # = 47
#apple_pie=thisdict.get('GTI') #should return [23,47]
#print(apple_pie)




'''
plumtree={} #new dictionary
####=======================================================
#feed list of pairs into dictionary (such as blueberries)
print("testing looping thru list")
#this represents a list of sublists of the switch,endswitch pairs
#I need to make testlist
testlist=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]

returnlist=[]
returnlist.append(0)
#I can make my own custom methods to get from list
#the list is actually referenced starting from 1 where I start the counter
'''
##==============================================
##  get_pair_from_testlist(x):
##==============================================
def get_pair_from_testlist(x):
    print("=========get_pair_from_testlist=========")
    print("testing get_pair_from_testlist",x)
    counter = 1
    print("inside the loop we see for x this ",x)
    for item in testlist: #it doesn't really loop, it's a one pass loop
        #if number entered bigger then length of list warn then break    
        if x > len(testlist): #error detection bypass worked 
            print("ERROR went beyond number length in list")
            print("please enter a number less than ",len(testlist))
            break
        #if number entered less than 1 warn then break
        if x < 1: 
            print("ERROR number must be 1 or higher")
            break
        if counter == x: #it matched with a doable number
            print(item)
            alpha = item[0]
            beta  = item[1]
            print(alpha,beta)
            returnlist[0] = [alpha,beta]
            print("returnlist[0] =",returnlist[0])
            break
        else:
            break
##==============================================================



#Okay. I need to fill the testlist from the threetabs, five tabs seven tabs nine tabs



#the list with the pairs is in testlist

#this dictionary is being abandoned for over complexity and confusion
# november 3ed 10:03 am morgan hill

#this reprents looping thru the testlist and filling data into the dictionary and populating it
##====================================================
##  fill_the_struct_dictionary_with_the_list()
##====================================================
def fill_the_struct_dictionary_with_the_list():
    return
    print('fill the struct dictionary with the list')
    counter=1
    # loop
    for item in testlist:
        print(item)
        aset=[item[0],item[1]]#this creats teh apirs 
        numb=str(counter) #making it a string here . clever
        thisdict=plumtree
        #add_data_to_struct()
        add_data_to_struct(thisdict,numb,aset) ###==============
        print("=======")
        counter += 1

        print("plumtree DICTIONARY now looks like this")    
        print(plumtree)
        print("here we go time to see it work===looping thru plumtree struct=====")
        for x in plumtree.values():
            print(x)
    
        print("===========")    
        for k, v in plumtree.items():
            print(k, v)







def testing_pair_list():
    return #not testing this right now
    print("length of theforce=",len(theforce))
    print("together_pair=",together_pair)
    print("======testing pair list() == fireworks time in tahoe ====")
    print("theforce[0]=",together_pair[0]) #first pair coordinates start stop
    print("theforce[1]=",together_pair[1]) # second pair coordinates start stop
    print("===starting loop thru list theforce =======")
    newcounter=0
    print("dog breath test")
    for item in together_pair:
        print(item)
        #this only works for two numbers 2 number long currently
        dog = together_pair[newcounter] #here I access first and second numbers in pairlist
        x = dog.split(",")  # see if this trick works
        print(x[0])
        print("doing surgery cutting off first character")
        charlie=''
        charlie = x[0]
        super=x[1]
        print("super=",super)
        print("=====")
        charlie = charlie[1:]
        print("charlie =",charlie)
       
        super =super[:-1]
        print("super=",super)
        print("===...=.=.=.=.=.=.=.=.=.=.")
        print("===...=.=.=.=.=.=.=.=.=.=.")
        charlie=''
        charlie = x[0]
        charlie = charlie[4:]
        print("charlie =",charlie)
        #print(x[1])
        print("==========")
        newcounter += 1 #python doesn't have ++
        
    print("=== end of looping thru list =======")
    
    


















##============================================================
#these are in switch_location and in endswitch_location


######################################################
list_of_switch_range=[]
list_of_switch_range.append(0)
list_of_switch_range.append(0) #was 10 hard coded 
list_of_switch_range.append(0) #was 20 hard coded

#list_of_switch_range[1] = switch_location
#list_of_switch_range[2] = endswitch_location
##############################################################



###########################################============
#experimenting on nov 4th thursday 



# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)
got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname):
##====================================================
def get_switch_number_at_top_of_string(stringname):
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		#print(line)
		print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;


# here I would add the strings in quail after they have been separated
# and they are in the list mytestlist. I then apply a method to each
# string to get teh switch number at the top and append it 
# to the list got_the_number
 # I will need to loop thru the quail list of the seperated switch strings
 # and append the strings within to mytestlist
 #so actually I would loop thru quail list and call get switch number


#loop thru list with thes trings
#feed the strings into method get switch number at top first switch
##=====================================================
## get_first_switch_number_from_all_strings()  fly jets
##=====================================================
def get_first_switch_number_from_all_strings():
    #print("get_first_switch_number_from_all_strings()")
    for item in mytestlist: #this will be quail list before parser
        get_switch_number_at_top_of_string(item)


#get_first_switch_number_from_all_strings()
#print("really got_the_number=",got_the_number)
# this will be my so-called twin list
# that I will use 
# for the python outoput strings in the stanford list
# to use to make the nested_method names for the defs


#exit();

#
'''
 this transfers the line location of switch and endswitch
 to list of switch range 1 and 2 from 
 switch_location and endswitch_location
'''
#28,38 for second string
# I am skipping using this now NOT using this method 
##################################################
##  get_one_nested_switch_start_and_finish()
##################################################
def get_one_nested_switch_start_and_finish():  # this gets the input from switch_location[0]
    print("get_one_nested_switch_start_and_finish()")
# and from  endswitch_location[0]

## this takes in the two lists of list_of_switch_range[1] and list_of_switch_range[2]
    print("=== ||=== get one nested switch start and finish line numbers")
    #force feeding it the second nested switch location input data 
    #these are hard coded for testing 
    #switch_location[0]    = 28  #july 18th testing 2nd nested switch
    #endswitch_location[0] = 38  #july 18th testing 2nd nested switch 
    list_of_switch_range[1] =switch_location[0] #force it in here
    list_of_switch_range[2] =endswitch_location[0]
    #list_of_switch_range[0]=0
    #list_of_switch_range[1]=10
    print(list_of_switch_range[1])
    print(list_of_switch_range[2])
    #list_of_switch_range[2]=20


the_nest_string= fridge[0] 




testing_string_list=[]

'''
#this is what has the string_with_nested_switches in it
# THIS TAKES TABS OUT OF THE ENTIRE NESTED SWITCH 
'''
teststringgonow='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''
funky='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch 
'''

###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	#print("======starter engine called======")
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #had "not"
			tabdepth = line.count("\t")
			n= tabdepth;n = n-1  #need to have one tab in front
			break
	passthis[0]= n;print("n =",n)
goldtime=[]
goldtime.append(0)
##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    return
    #print("====modern tab shifter to left=======")
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
    #print("output of concatted string in goldtime[0]")
    #for line in buildstring.splitlines():
    #    print(line)
  





#=================================== friday nov 19th =============================
# this is where I am applying a method to each item in input switch strings list
###===============================================================================
#









##########################################
##  take_out_x_tabs_from_front_of_line(n):
##########################################
def take_out_x_tabs_from_front_of_line(the_nest_string):
	starter_engine(the_nest_string);n=passthis[0]
	#print("take out ",n," tabs from front of line - of string")
	#print("take_out_x_tabs_from_front_of_line(n)") #make this is into a method 
	#print("n=",n)
	#get tab count in line with switch and counter =1
	#should be governed by the first line with switch 
	
				
	wildness=''
	print('half way down n =',n)
	for line in the_nest_string.splitlines(): #nest_string
		
		newline = line[1:]
		print(newline)
		
		if n == 4:
			wildness += line.replace("\t\t\t\t","\t") 
		if n == 3:
			wildness += line.replace("\t\t\t","\t") #strips one right
		if n == 2: #this leaves 1 tab in front of each line
			wildness += line.replace("\t\t","\t") #strips one right
		if n == 1: # we only one one tab in front of the switch word as the guidepost
			pass #do nothingwildness += line.replace("\t\t","\t") #strips one right
		wildness += "\n"
	#print("after minor surgery see if this works")
	#print(wildness)
	fridge[0] = wildness
	return wildness # this worked

#3 take out 2
the_string='''
				switch(exp){ #  54
					case 'blable':
						print("do something")
						print("yep")
						fallthru
					case 'more':
						print("nice")
						switch(exp) # 98
						break
					default:
						print("we are done here")
				endswitch 
'''

#2 take out 1
the_second_string='''
		switch(exp){ #  54
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				print("nice")
				switch(exp) # 98
				break
			default:
				print("we are done here")
		endswitch 
'''

#store in a dictionary each pair of switch and end switch params
# then I loop thru it with the numbers

####============ july 19th 2021  Monday ===================
# I already have the code to build a list of all switches and endswitches
# but I need to put them into a dictionary when I do that search to capture them as pairs

##================================


#print("testing dictionary to hold switch endswitch pairs (pear tree)")
#print(" ==== testing using a dictionary now ==== mayflower ship===")





### successful test for between macro ################### july 19th, 2021 ########## 

#print("testing between macro and how it will work")
mylist=[]

mylist.append(3)
mylist.append(4)
mylist.append(5)
mylist.append(6)

testlist =[]
testlist=[1,2,3,4,5,6,7,8,9,10]
#####################
##  between test()
#####################
def between_test(): #between macro 
    return #it would have to be like this
    #if a between(x,y)
    print("BETWEEN TEST HERE ----")
    print("bla bla bla")
    print("between test")
    #x = 7
    print("the final outcome..")
    # if x >= switchline and x <= end switchline  #meaning  from start number thru endnumber
    #if x is between switchnumber and endswitch number
    #the list would contain the start number thru the stop mumber 
    # if x is between startnumber and endnumber:
    counter=0 #the logic is to be between x and y it's inclusive of x and y also
    for item in testlist: #so we look for a narrow range within the large input range
        if item in mylist:
            print("yes",item)
            counter += 1
            
        else:
            print("nope",item)
            counter += 1

#print("=====do test of between macro proof of concept=====")
#between_test() #this tests if we have a list of numbers 1 to 6

#print("testing this with between")
zoo = 4
#if zoo between 1 and 6:
alist=[]
alist=[1,2,3,4,5,6]
#print("======= BEtWEEN TESt ========")
#print("testing the replacement for using betwen")


###=========================
##   between() macro
##==========================
def between(x,y,z):
    return
    print("between called for if x in list between y and z")
    if x in alist: #1 thru 6
        print("True yes ",x, "between ", y, " and ",z)
    else:
        print("False,",x," is not between ",y," and ",z)





#also next add
##==================
##  after macro
##  before macro
##================

############## testing using  a dictinary to store
############## pears of switch and endswitch pairs

#this will be generated. but I think that
# I might have the dictionary pears already existing.

###====================== dictionary storage area =================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================

#dictionary called pears
peartree = {}  


#given name peartree of dictionary
def get_value_of_key_original(x): #peartree hardcoded in
    car=eval("peartree.get('" + str(x) +"')")
    print(car)
    return car #so if it is a list it should return a list right?z

#given name peartree of dictionary
def get_value_of_key(dict,x):
    car=eval("" + dict +".get('" + str(x) +"')") #maybe
    print(car)
    return car #so if it is a list it should return a list right?z


########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists
####################################################################||
### PRACTICING ADDING DATA TO A DICTIONARY CALLED PEARTREE  
#####################
## do this baby 

#what I need to do is add to a dictionary dynamically 
#####################
def do_this_baby():
    print("do this baby caled")
    print("===do this baby() adding data to peartree dictionary called ......====")
    print("practicing ADDING data to see if it works (this will be done dynamically later")
    peartree['1'] = [10,20]
    peartree['2'] = [28,38]  #uses small anonymous list for data
    print(peartree)
    x = peartree.get("1")
    print("x=",x)
    
    
def add_data_to_peartree(x,z):
    answer =''
    answer = "peartree['" + str(x) +"'] = z " #[10,20]
    print("just before exec add data to peartree")
    print(answer)
    exec(answer)
    
fool_on_hill= '[10,20]'
print("TESTING adding data to a dictionary")
add_data_to_peartree(1,fool_on_hill)
print("peartree has in its contents=")
print(peartree) 







#testing adding data record to dictionary dynamically.
#Declare a dictionary (empty) 
print("dynamiclaly add data to dictionary = DRIVE THRU ")
print("testing dynanmically adding data to a dictionary Drive Thru")
data = {'a': 1, 'b': 2, 'c': 3}
print(data)
data.update({'d':3,'e':4})  # Updates 'c' and adds 'd'
print("====after adding d and e dictioanry data======")
print(data)

fun={} #dictionary called fun
print("first the fun dictionary is empty")
print(fun)
#input values to dynamically add data for teh switch endswitch to dictionary

print("adding data to drivethru dictionary ")
print(" RED WHITE AND BLUE ")
drivethru={}
#drivethru.update('1': '[10,20]')
#drivethru.update('2': '[30,40]')
#3drivethru.update('3': '[50,60]')
#drivethru.update('4': '[70,80]')
#print(drivethru)

#zerohour=get_value_of_key(3)
#print("zerohour=",zerohour)

cherish=[10,20]
skyblue =[28,38]

def get_dictionary_size(x): #length
    shit= len(x)
    print("size of this dictionary",x," is",shit)
    print("so the result is ",shit)
    return shit;
    


print("This is doing an update here --->")
fun.update({'1':cherish,'2':skyblue})
print("hard coded here printing out the dictionary fun")
print(fun)
print("========")
num1='3'
num2='4'
silver =[42,46]
gold =[50,52]

#put these into a list also
crystal=[]
crystal.append(0)
crystal.append(num1)
crystal.append(num2)

dust=[]
dust.append(0)
dust.append(silver)
dust.append(gold)



#=
##==============================
def dynamically_add_data_to_dictionary(a,x,y):
    print("testing... dynmically add data to dictionary a, x, y")
    print("Tesitng using lists now which are changeable on the fly")
    a.update({crystal[1]:dust[1],crystal[2]:dust[2]}) #totally dynamic attempt here
    print(a)

#modidfy this get value to use dictoinary name as parameter  
print("here we are testing get_value_of_key(dictname,keynumber)  (fun,3)")  

##===============================
## get_size_of_dictionary  (name of dictionary)
##===============================
def get_size_of_dictionary(zoo):  #this is so I know what next record should be
    print("get_size_of_dictionary")
    answer = len(zoo)
    print("get size of dictionary zoo",answer)
    #how do I loop thru a dictionary
    print(":this is printing out peartree ")
    for x in peartree:
        print(x)
    print("====")
    print("")
    print("this loops thru dictionary thisdict")
    for x in thisdict.values():
        print(x)
    print("")   
    print("===loop thru dictionary== this.dict ==")
    for x, y in thisdict.items():
        print(x, y)




car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

def playing_with_dictionary_structs():
    print("playing with dictionary access...")
    x = car.get("model")
    print("testing getting car model")
    print(x)

#playing_with_dictionary_structs()

   
#but I just thought I can have a running total in a list too
def do_something():
    print("Muppets Animal")
    result=''
    do_this_baby() # I think that the list peartree was empty when I was testing it
    print(peartree)
    print("get size of dictionary ... a test")
    #how do I determine if a list is empty
    if len(peartree) > 0:
        result= len(peartree)
        print("length of peartree =",result)
    else:
        print("peartree is empty and equal to 0")
        print(len(peartree))
    print(result)
    return result
######################################
#do_something()

    






###############################################
## dnanmically add one record to dictionary
###############################################
def dynamically_add_one_record_to_dictionary():#will need some params
    print("starbucks morgan hill checking this out")
    print("dynamically add one record to dictionary ()") #what about input param
    #first pass go thru dictionary to determine it's current length put that into a list
    super=''
    super=get_size_of_dictionary(peartree)
    #so to add 1 to super for next record
    testtheory='[42,60]' #this is hardcoded here but testing at this stage so it's ok
    #super += 1
    #combine = firsthalf + secondhalf 
    #print(combine)
    #eval(combine)
    #print(combine) 
    #hard coded adding data to dictionary here obviously
    
    peartree['3'] = [42,60] #there would have to be 4 slots already to work
    print(peartree)
    get_size_of_dictionary(peartree)
    print("now yellow BIG BIRD test =========")
    ### look here this is correct below that owrks 
    fish =  "peartree['4'] = [66,80]"
    exec(fish)
    print("experimenting here adding new item to dictionary peartree for testing")
    ##======================================
    thenumber = 5; 
    y1 = 82; 
    y2 = 94
    salmon =  "peartree['" + str(thenumber) + "'] = [" + str(y1) +","+ str(y2) + "]" 
    #this would be blueberries 
    print("salmon=",salmon)
    #salmon= "peartree['5'] = [82,94]"
    #salmon= peartree['5'] = [82,94] #this one is correct
    exec(salmon)
    
    #and I can use 'peartree' as a var and connect it will try that next. 
    #what I built up above needs to look like this string 
    
    ###==========================
    #I need a database for each function that is searchable
    #with a tag of what it does - behavior
    #I could do it in javascript with my switch case
    ###=============================
    
    
    get_size_of_dictionary(peartree)
    print("is peartree 4 here with 66,80")
    print("looping thru dictionary peartree here on oct 23rd")
    for x, y in peartree.items():
        print(x, y)
    #output
    #output='''   
    #    1 [10, 20]
    #    2 [28, 38]
    #3 [42, 60]
    #4 [66, 80]
    #5 [82, 94]
    ##########################
    num = 5
    numb1 = 200
    numb2 = 280
    firsthalf  = "peartree['" + str(num) + "'] ="
    secondhalf = "[" + str(numb1) + "," + str(numb2) + "]"
    print('look here very carefully....')
    print('secondhalf=',secondhalf)
    together = firsthalf + secondhalf
    print("look at below this line does it look right GROUCH")
    print(together)
    exec(together)
    
    
    
    get_size_of_dictionary(peartree)
    #print(peartree['5'])
    print("get value of 5",peartree.get('5'))
    ###########################
    '''
    loop thru peartree:
        print(item)
    '''
    for item in peartree:
        print(item)
        
    for x in peartree.values():
        print(x)
        
    print("chocolate somores. ")
    sweet =get_value_of_key_original(1)
    print("sweet key 1 =",sweet)
    
    get_value_of_key_original(2)
    get_value_of_key_original(3)
    get_value_of_key_original(4)   
    get_value_of_key_original(5)
   

#this will be used to take in a set of two numbers switch endswitch
#to add to the pears dictionary
#### makes [24,34] from ab and returns it
#### make list with two pieces of data (ab)
def make_list_with_two_pieces_of_data(a,b):
    jedi=''
    jedi = "[" + str(x) + "," + str(y) + "],"  #notice it adds the comma on the tail
    return jedi
    
#making peartree['1'] is not tough

#what about this



# test input
# this adds a datum to peartree
# this is the method to add a 
# new switch pair to dictionary peartree

#it was add_this <<=========
# now it's this
#####################################
## add_data_to_pears()
#####################################
### the dictionary name is hardcoded as peartree


###############################

# output 
'''
add_this called
{'1': [10, 20]}
add_this called
{'1': [10, 20], '2': [28, 38]}
access switch called
[10, 20]
10
20
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 10 second 20
access switch called
[28, 38]
28
38
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 28 second 38
'''
#<href="https://discover.cs.ucsb.edu/commonerrors/pythonerrors.html"> python common errors UC Santa Barabara</a>

########

    
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    
    #this is where I access the dictionary
    # and call the code to get the nested swith

#this is for the numbering and access to the nested switches
# and governing them and number the nested_switches and managing it all perfectly.
#================ thursday, august 19th, 2021 solution =============================
#so with this approach number is simple 1 to n for each tab level
#only thing that I change is level depth of indentation
#so if we have main switch and then 3tab depth then 5tab depth
#level0, level1, level2
#level stands for nested switch depth
#so I can use the numbering 1 thru n for each switch
#and use the numbering system and just add the level[0] in a list
#level[0] is main 1, 2, 3, 4, 5 #nested numbering
#level[1] tab depth 5 is first level nested switch if nested within 1, 2, 3
#level[2] tab depth 7 is second level nested with , 1, 2, 3
#level[3] tab depth 9 is third level 
#def loop thru pears dictionary and call  nested switch
#==================================================================

#this calls the method above:        
#accessing_data_in_peartree_dictionary()

### this would be after filling this with switch_location and endswitch_location method

print("practicing with this hardcoded input data for switch and endswitch to prove it works")
print("down at pears tree here hard coded ")
# this represents a dictionary called pears already loadded with data
#=================================================
########################
##  PEARS DICTIONARY
########################
#pears =	{  #for pear tree in backyard (2 of them)
#  "1": [10,20], # I can make these now 
#  "2": [28,38],
#  "3": [1,44]
#}

#testing with this new data multiple nested switches

#this hardcoded I put this in here. it's not automated yet
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently

}

#for red_robin
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now  1 tab level start and stop
  "2": [11,60], #3 tabs
  "3": [15,51], #5 tabs
  "4": [23,46], #7 tabs # yes it is a stacked at 3 tab level already 
  "5": [31,41], #9 tabs
  "6": [62,86], #3 tabs
  "7": [66,77]  #5 tabs
 #no comma after last data piece apparently
}


#nest_string has pears
#and then blueberries added. 
#solved it.
 
#da = blueberries.get("2")
#print("getting data in blueberries")
#print(da)

'''
11 is in 1
62 is in 1
15 is in 11
23 is in 15
31 is in 23
66 is in 62
'''


def lametest():
    print("doing lametest()")
    if 11 in range(1,86):
        print("true")
    else:
        print("false")
    
#lametest()

#new pears

#creates this

#this string already has numbered switches with comments 
#note that the numbering of the switches isn't starting from 1 down.
#testing this sep 30  #switch11 is the main switch

# what this does is add ..  # 66  the line number after each switch(exp){

print("TWIN LIST let's take a look and see what's in it")
#print("let's look inside of twinlist",twinlist)
#they have to be in the same order as the actual switch cases

'''
##================
======1:3==========                   switch1 > switch11 and switch49  =========
switch1
     switch11 method 3 tabs first number from pair 11,47
     switch49 method 3 tabs first number from pair 49.73
end73
#==============================       switch11 > switch15  =======
only switch at 5 tabs between 11 and 47
#minor 3 tab to 5 tabs  Copy 11 thru 47 TWO
switch 11  3 tabs
     switch 15#method  5 tabs   must be between 11 and 47
switchend47
#=============================         switch49 > switch53    ======
#minor 3 tab to 5 tab   THREE
only switch at 5 tabs between 49 and 73
switch 49
     switch 53 method must be between 
endswitch73
##====================  FOUR           switch15  > 23 =======
#minor  5 to 7 tabs   
only swith at 7 tabs between 15 and 38
switch 15
     switch 23 method
##====================  FIVE           switch23  none ======== by itself
#minor none 7 tabs not nested because no 9 tabs its an end tail
switch 23      
$$$$$$$===================================================$$$$$$$$
# I need to be able to generate the pattern
if tab depth == 3 then
first number of pair[0] is nested switch 11 and 49
     switch11 method  first number from pair 11,47
     switch49 method 
     
=======3:5
if tab depth == 5 then
first number of pair[0] 15 goes inside minor 
three tabs to five tabs
switch 11
     switch 15#method   must be between 11 and 47
switchend47
===== 3:5
[49,73],[3]=== [53,64],[5] if secondpair[0] > firstpair[0] and 
switch 49
     switch 53 method must be between 
endswitch73
#testing this
combinedtabs=[]
combined_tabs = threetabs + fivetabs + seventabs
#threetabs= [11, 47, 49, 73] done 
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]
'''
print("testing merry christmas code")
print("obviously this is a thinking and engineering problem")
threetabs = [[1, 2],[3, 4]] 
fivetabs  = [[5, 6],[7, 8]]
seventabs = [[9, 10]]
#testing this
fuel=[threetabs,fivetabs,seventabs]
combinedtabs_jazz=[]
combine=''
fulllist=["threetabs","fivetabs","seventabs","ninetabs","eleventabs","thirteentabs","fifteentabs"]

#def grab_these_tabs(x):
    


upto7 = "threetabs + fivetabs + seventabs"
combined_tabs_jazz = eval(upto7)
print("combined_tabs_jazz=",combined_tabs_jazz)
for item in combined_tabs_jazz:
    print(item)
    

#laketahoe
combined_tabs=[]
##========================================================
threetabs= [[11, 47],[49, 73]] 
fivetabs = [[15, 38],[53, 64]]
seventabs= [[23, 33]]
#this combines the theetabs, fivetabs and seventabs
combined_tabs = threetabs + fivetabs + seventabs

counter=1 #looping thru combined_tabs list
for item in combined_tabs:
    alpha = item[0];beta  = item[1]
    print("pair=",item," "," counter=",counter,", first=",alpha,", second= ",beta)
    print("=========================")
    counter += 1
print("did she work")

for item in combined_tabs:
    print(item)
    
#output
'''
pair= [11, 47]    counter= 1 , first= 11 , second=  47
=========================
pair= [49, 73]    counter= 2 , first= 49 , second=  73
=========================
pair= [15, 38]    counter= 3 , first= 15 , second=  38
=========================
pair= [53, 64]    counter= 4 , first= 53 , second=  64
=========================
pair= [23, 33]    counter= 5 , first= 23 , second=  33
=========================
did she work
'''
    
#this is what is in combined_tabs now
print("showing off combined tabs list")
for item in combined_tabs:
    print(item)
print("===================")    
#see if this works
#=================================================


table=[]
table.append(0)
#============================================================
## check_if_nested_switch_inside_this_switch(astring): 
## returns table[0] = False or True
# coded on dec 6th monday 12:== noon ish

#==========================================================
def check_if_nested_switch_inside_this_switch(astring):
    print("check if nested switch inside this switch")
    counter=0
    table[0] = False
    for line in astring.splitlines():
        tabcount=line.count("\t")
        if tabcount == 3  and "switch" in line and "end" not in line:
            table[0] = True
            print(line) #proof is in the pudding - how good is it
            break
            
            
            
            
            
##### this does absolutely nothing 
# I need to make a method to add main switch to string list
def add_main_switch_params_to_dictionary():
    print("how it will work")
    #methods count end switches
    #Take answer add 1
    #loop thru input switch string get total number of lines
    #"3" : [1,44],  #is the result
    #call method to add it to dictionary


#pears['3'] = [4,7] #example
# 38-15+ 1=24  formula end number - first number = x then x + 1
#first number keep, skip out to 23 lines (length of string of nested switch)

#print("====dictionary pears====")
#print(pears)
#print("==========")
#print("====dictionary peartree====")
#print(peartree)

#print("==== practicing with dictionary called pears ========")
#access the dictionary one key in particular to get the value
#print('pears[3] which is the key number')
#x = pears["3"]
#print("x = ",x) #this should be 4,7
#print("============")
 
 
def say_something(x):
    print("say something test here")
    print('cool[0]=',x[0], "cool[1]=",x[1])
     

'''
print("PRACTICING LOOP THRU THE PEAR DICTIONARY WITH HARD CODED DATA FOR TESTING")
print("============")
print("== PEARS  dictionary now LOOPING THRU IT===")
print("listening to teh Beach Boys to see if it works ----")
'''

#looping thru dictionary called thisdict
'''
for x in pears.values(): #looping thru pears dictionary holding switch and end switch pairs locations
    
    print(x)
    cool = x
    #print(cool[0])
    #print(cool[1])
    print(cool[0],cool[1])
    #say_something(cool)
    copy_one_nested_switch_string(m82)
    print("========================")
       
''' 
#this will be a method but of course
'''
for line in inputstring.splitlines(): #	
		#this will be the second loop======
		# if counter is between start and finish #just after start and less than = to finish
		if counter > start and counter <= finish: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
	print("===output from skipping some lines====")
	print('it created this string')
	print(concatthis)
'''	
	


#######=========================================
#
##==============================================
def do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring):
	print("do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up")
	#this 
	genius[0] = inputstring
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	
	


#testing
spilled_coffee ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 ==========
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 ===============
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #26 ==============
			
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



skitahoe ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
		case 'more1':
			switch(exp) 16
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #23
			print('party time')
			switch(exp) #25
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #32
		case 'more2':
			print('more parties')
			switch(exp) #34
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #41
			print('are we there yet')
			switch(exp) #43
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #50
			print('how many this week')
			switch(exp) #52
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
				print('bye')
			endswitch #59
			print('what the..')
			break
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



flag_test=[]  
toosmart=[]
toosmart.append(0)
baton=[]
baton.append(0)
 
flag_test.append(False) #set flag_test by default to False
#flag_test[0]
# x is the name of the string to be modified
switch_list=[]
endswitch_list=[]
thenewpairs=[]

##============================
##  buildpairlist()  created nov 21st, sunday to manage doing the main switch 
##============================  and cutting out switches at three tabs for main switch 
def build_pair_list(stringname):
	print("====== build_pair_list called ======")
	counter =0
	#flush lists
	switch_list=[]
	endswitch_list=[] #should reset them both 
	#thenewpairs=[]
	#del endswitch_list[:]
	#this fills up the switch_list line
	#===================================
	# LOOP FILLS UP SWITCH_LIST 
	#===================================
	#loop thru stringname and fill up switch list
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line:
			switch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	counter =0
	#loop thru stringname and fill up endswitch list
	#this fills up the switch_list line
	# =======================================
	# LOOP FILLS ENDSWITCH LIST 
	#========================================
	if len(endswitch_list) > 0: #needs to be emptied first
	    endswitch_list[:]
	else:
	    pass
	 ##=============================== new jan 3rd 2022   
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "endswitch" in line :
			endswitch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	del switch_list[0]     #delete first switch number which is on line 1
	del endswitch_list[-1] #delete last number endswitch which is end of entire string
	print("after deleting first and last switch we have..")
	print("switch_list=",switch_list);print("endswitch_list=",endswitch_list)
	counter=0 #build the pairs and put them into sweet; then append sweet to thenewpairs list
	#===================================================================================
	# LOOP FILLS THENEWPAIRS LIST WITH SWEET WHICH HAS SWITCH,ENDSWITCH LINE NUMBERS
	#===================================================================================
	for item in switch_list:
		sweet=[switch_list[counter],endswitch_list[counter]]
		thenewpairs.append(sweet)
		counter += 1
	print("this is what we want to see at starbucks")
	print("thenewpairs=",thenewpairs)
	#==================================
	# LOOP PRINTS OUT THE NEWPAIRS LIST
	#==================================
	for item in thenewpairs:
		print(item)
		print('stop here for now')
		#exit()
	#REVERSE THE NEWPAIRS LIST BECAUSE IT HAS TO BE DONE BOTTOM UP TO THE STRING 
	thenewpairs.reverse() #they have to be skipped bottom up to work properly
	print("thenewpairs=",thenewpairs)	
	print("resulting list of thenewpairs =",thenewpairs)



pinkpanther=''
##===========================================
##  skipping_some_lines() #this works
##===========================================
def skipping_some_lines(thestring,start,finish):#input string, switch number then endswitch line number  ....start line nest switch and finish  endswitch
	return
	print("METHOD  skipping_some_lines() called==========")
	print("======= skipping_some_lines() ================called",start,finish)
	# if I have a flag that it's been triggered then afterewards 
	# print("this is the input string used stating skipping_some_lines")
	# for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0]) =============================
	#if flag_test[0] == False: #meaning first pass  and what it's set to by DEFAULT
	smart=thestring;
	baton[0]=thestring #this is new
		#change it to True now
	flag_test[0] = True #this should now be tru e========================
	#else: #meaning TRUE this is run after first run of skipping_some_lines()======
		#what this does is use the new concatted changed string changed on the fly with each pass
		#for second and all subsequent passes it uses baton[0]
	thestring = baton[0]#====================
	#print('what is in baton[0]',baton[0])
	##==========================================================
	# the issue is that on the second pass it is using the original string
	# and it needs to be using the modified string
	# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
	# because the numbering system of the string starts from 1 too.
	### look that we have the counter here set to 1 by default 
	counter=1; concatthis =''; #finish = finish + 1 
	print("start=",start,"finish=",finish) #I took out x = 
	#smart=x;
	print("inside of skipping lines before going thru the loop this is the value of")
	print("the input string it will mess around with")
	#print(smart)
	print("=== ah now I get it these are the lines that it MUST SKIP and we want what is before and after this range to create the modified string =")
	print("it sees in start",start)   #this is a number
	print("it sees in finish",finish) #this is a number too
	##=================
	#so I would build pair list of inner switches at 3 tabs and then loop thru them to skip them
	#this is new on sunday november 21st 2021
	#what I want to skip on the fly without range data
	
	#------------------------------------------------
	#from switch at 3 tabs until endswitch at 3 tabs
	#skip the lines inbetween leaving switch word
	##----------------------------------------------
	
	
	##=============== this is a new addition to automate the grabbing of inner switches ====
	# this creates pairs of the switch, endswitch pairs 
	#if start == 1 and finish == 1: #meaning figure out pairs on the fly
	
		
	#exit()
	counter=0
	#for item in thenewpairs:
	#	start  = item[0]; print("start=",start)
	#	finish = item[1]; print("finish=",finish)
	#check thype
	print("checking tyhpe of thestring")
	print(type(thestring))
	print(thestring)  #it shows 0
	print("what is it?")
	print("starting baton[0] has teh initital input string in it")
	for line in thestring.splitlines(): #smart = x
			#this preserves the switch word and skips the rest of nested switch body including endswitch
			# if counter is between start and finish #just after start and less than = to finish
			#just added start +1 and finish + 1
			#tabdepth= line.count("\t")
			#if tabdepth == 3 and "switch" in line and "end" not in line:
			#		start = counter
			# use while loop of course
			#so it's upside down and backwards to create the same meaning.
			# probably need to do a prescan but maybe i can do it without doing prescan
			#get location of switch and endswitch at 3 tabs
			#while "endswitch" not in line:
			#####################==================
		if counter > start+1 and counter <= finish +1: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
		##=======================================
	baton[0]=concatthis;
	print("===output from skipping some lines====")
	#print('it created this string')
	#print(concatthis)
	print("how does it look===>>> by lettuce field")
	del ibm[:] #this should empty it
	print("this is the output result of skipping some lines")
	#print(concatthis)
	#what I am doing here is putting what has been concatted in the string into toosmart[0]
	#this has red_robin hardwired into the code 
	#just commented out line below november 10th, 2021 to see wehat happens 
	#toosmart[0]= red_robin #it did say toosmart[0] = red_robin
	#just commented these out thanksgiving
	#baton[0] = concatthis  #here the concatthis has been put into baton[0]=======
	#pinkpanther=concatthis==============
	##==========================================================
	### mocha test ### this is new November 10th, 2021  ########
	never_defeated[0]= baton[0]  #just added this line 
	###########################################################
	##==========================================================
	concatthis='' #this resets concatthis to empty-
	print('in baton here we have')
	#print(baton[0])
	print('==============')
	print("now the result is here....!!!!@@@@@$$$$$")
	print(never_defeated[0])
	#ibm[0] = concatthis	  #this has the switch string with the nested switch cut out
	#putting concatthis into ibm[0] here 
	ibm.append(toosmart[0])
	print("at the bottom of the skipping some lines to take out inner switch")
	print(" it sees this in ibm[0]")
	#exit()	
	#print(ibm[0])
		#just moved this over one tab	
#exit()
#end skipping_some_lines  ========================================================
print("Levels TEST on wonderful Monday winter wonderland ")
print("this will take out the inner switch between") 
never_defeated=[]
never_defeated.append(0)

#for line in skitahoe.splitlines():
#   print(line)




#it was previously this
def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
    return
    print('this one is sooo critical')
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    skipping_some_lines(stringname,start,finish)
    #this means that the output string should be placed into never_defeated[0]
    for line in never_defeated[0].splitlines(): #prints it after takening out. 
        print(line)
        

##===========================================================================
##  modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#this was redesigned and modified on sunday november 21st at 8:30am to 
# work with skipping some lines with no known locations of inner switches at 3 tabs
# and it calls method build_pair_list to find them and reverse them for input for skipping_some_lines
# and I have to subtract 1 from start and finsh
#this one is used to get the main switch and take out switches at 3 tab depth

# and loops thru list feeding start and finish  params and calling skipping_some_lines()
# #  the input for start and finish will be 1 by default but they will be overwritten
# #  by the build pair list on-the-fly.
#print('this one is sooo critical')
def modified2_cut_out_inner_switch_body_leaving_switch_word(stringname):
    #it is modified so it can change more than one inner switch into a switch, infinite
    #print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    ###======= this is ingenius=========
    #METHOD BUILD_PAIR_LIST(STRINGNAME) 
    if len(thenewpairs) > 0:
        print("==TRUE thenewpairs >0 it is ===== ",len(thenewpairs))
        del thenewpairs[:] #delete contents of thenewpairs list if it's not empty yet
    #end if
    #if len(never_defeated[0]) > 0:
    never_defeated[0]='' #deletes it
    build_pair_list(stringname)           # goes thru thenewpairs list and
    for item in thenewpairs:              # fills start and finish into skipping_some_lines params
        start  = item[0];
        finish = item[1]; # print("start,finish=",start," ",finish)
        skipping_some_lines(stringname,start-1,finish-1)#so close now 
        #the result of the concatting goes into never_defeated[0]
    #this means that the output string should be placed into never_defeated[0]
    print("let us see what we have jazz blues line 6166 ....")
    #so it's output is in  never_defeated[0]
    thisstring = never_defeated[0]
    return thisstring; #see if this works  it is important that we return the string
    print("let's see what it has in it and if it converts the inner switch bodies to switch word...")
    for line in thisstring.splitlines(): #prints it after takening out. 
        print(line)
    cat_scales[0]= never_defeated[0]
    print("now loop thru pinkpanther")
  
        
#manipulate_string(item) #shifts it to the left

# this is the one that is new as of november 21st and it does the main switch with
# inner switches at 3 tabs that it takes out leaving just the switch word.
#============ original============ modified2

#stringname=skitahoe
#mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)

#for line in mybaby.splitlines():
 #   print(line)
#exit()   
    
#print("===end of show on thanksgiving==attempt 2 =")    
#exit()


#exit()

'''
print("catscales=",cat_scales[0])
print("=====rats======")
print("never_defeated[0]",never_defeated[0])

goldring = never_defeated[0]
print("is this going to finally work or not")
output_list.append(goldring)
print("WHAT IS BELOW THIS DAM LINE")
print(output_list[0])
print("now loop thru goldring s")
for line in goldring.splitlines():
    print(line)

print("seeing if this works")
for line in never_defeated[0].splitlines():
    print(line)
    
#ram = never_defeated[0].replace("switch","rocks")
#never_defeated[0]= ram
#for line in never_defeated[0].splitlines():
#    print(line)
#exit()
'''
#==================================
#print("end of deifnitely working modifies2 cut out inner switch body.()")


#stringname=skitahoe; start=7; finish = 14; #this sucker was moving....    
#cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
#print("let us see what we have.")

#need to indent it I think.
#produces this output it is NOT indented yet 
goldfish='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
			print("nicely")
			break
		default:
			print("we are done here")
	endswitch 
'''
			
			
			

#print(" RED RED RED cut out switch body leave only switch word baby")
#print(" red alert testing cut out switch body leaving switch word tesitng 4 ..")    
#exit()

#this is testing with dummy data above in test_code_now
#taking out the inner switch body
#print("halloween is coming snoopy and woodstock test")

#print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1
#print("take out 10 thru 20") #but actually keep 10 and takeout including20
#x = test_code_now
#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
#print("rose test")








#modified so it doesn't matter where the inner switch is 
# they will all be at 3 tabs
#the first switch must be at 1 tab and inner switches need to be at 3 tabs one depth in
#THIS IS NEW CODE WEDNESDAY CODING...november 10th ........
##########################################################################################
#####################################################################################
 #creates first slot in list for string
	#print("actually this builds lists of switch and endswitch locations and makes pairs")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print(" checking to see if more than ONE inner switch at three tabs and ")
	#print("if so then put them into a list")
	#print("the first loop determines how many inner switches at 3 tabs")
	#print("the second loop will go thru a list of the pairs - ah yes but ")
	#print("not implimented yet ")
	
	#print("it sees in finish",finish) #this is a number too
	

# "actually this builds lists of switch and endswitch locations and makes pairs")
# what it does: creates pairs set of start, finish after getting list of switch and endswitch lines
# then it will loop thru pairs set in reverse order and cut out switch bodies bottom up 


## new november 10th 2021 !!:37am
#JUST TRY IT


#this requires this function below to be called first though
#  smart_cut_out_inner_switch_bodies_at_three_tabs(samplestring)
pairset=[]
genius=[]
genius.append(0)

never_defeated=[]
never_defeated.append(0)
list_of_inner_switches_at_three_tabs=[]
list_of_inner_endswitches_at_three_tabs=[]




##========================================================
## loop_thru_pair_set_and_call_skiplines(samplestring)
##=========================================================
def loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring):
	print("len(never_defeated) =",len(never_defeated))
	#never_defeated[0] = thestring #this takes the initial string put into never_defeated[0]
	never_defeated.append(thestring) #maybe this is what I need to do to fix this bug
	print(never_defeated[0]) 
	counter =0
	#loop thru pairset of sets of switch,endswitch (already reversed to go bottom up)
	for item in pairset: #the pairset list was filled in smart_cut_out_inner_switch_bodies_at_three_tabs
		alpha = item[0];beta  = item[1];print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		#METHOD skipping_some_lines()============= uses never_defeated[0] stirng in list
		skipping_some_lines(thestring,start-1,finish-1) #added -1 on Mon Nov 22nd 2021 9:00 AM
		#doing this to see if it cut out the inner switch body 
		print("this is showing the changes reducing switches in never_defeated[0]")
		mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
		print("this is what the switch string looks like after taking out a switch body")
		counter += 1
	








##====================================================================
##  make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring)
##====================================================================
def make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):
	print("METHOD make_Pair_set_of #### called  ... make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):")
	counter =0
	print('let us look at this string to see what it sees')
	print("========//////////==========///////==============")
	for line in inputstring.splitlines():
		print(line)
	print("========//////////==========///////==============")
	for line in inputstring.splitlines(): #smart = x
		#this preserves the switch word and skips the rest of nested switch body including endswitch
		#for this line get tab_depth
		#print("this is where I add the switch line number to list of inner switches at three tabs")
		tab_depth= line.count("\t") #but this presumes just one inner switch there could be more
		#if 3 tabs True AND switch in line and end not in line and counter > 1 
		if tab_depth == 3 and "switch" in line and "end" not in line and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_switches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)		
	#second new loop but looks for endswitch locations at 3 tabs 
	counter =0
	for line in inputstring.splitlines(): #smart = x
		print(line)		
		tab_depth= line.count("\t")
		#print("this is where I add the endswitch line number to list of inner switches at three tabs")
		if tab_depth == 3 and "endswitch" in line  and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_endswitches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("==================")
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)	
	print("list_of_inner_endswitches_at_three_tabs=",list_of_inner_endswitches_at_three_tabs)		
	print("===================")
	print("===== end of phase 1 =====")
	##======================================================================================
	print('doing Friday debugging oh what fun it is to ride in a one horse open sleigh')
	if len(list_of_inner_switches_at_three_tabs) == 1:
		print("this means only ONE dam pair")
	else:
		print("the length is =",len(list_of_inner_switches_at_three_tabs))
		cat = len(list_of_inner_switches_at_three_tabs)
		print("the length of inner switches at three tabs is ",cat)
	###=================================================================	
	print("now I need to make pairs")
	get_number = len(list_of_inner_endswitches_at_three_tabs)
	
	if get_number == 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	##3=======================================================================		
	if get_number > 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	else:
		pass #print("there is only one switch endswitch so do regular mode just one inner switch at 3 tabs ")
	if get_number > 1:
		pairset.reverse()  # REVERSE PAIRSET SO THAT I CAN CHANGE THE INNER SWITCHES BOTTOM UP
	
	print(pairset)
	print("loop thru pairset") #to go thru input string and reduce inner switches to just switch word bottom up
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
	##======================================
	print("method to go thru pairset and call skipping_some_lines(start,finish)")
	do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring)
	#########====================================
		#skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	#skipper needs to cut out from bottom up 
	#skipping_some_lines(x,start,finish):
	#it will call a method

#this must be called after one switch string has had it's inner switches reduced to switch word
#def reset_to_initial_conditions(): #brainchild on NOv 11th, Thursday morning#
#	print(" ====reset_to_initial_conditions()======"#)
#	never_defeated[0] =""
#	list_of_inner_switches_at_three_tabs=[]
#	list_of_inner_endswitches_at_three_tabs=[]
#	pairset=[]
#	baton[0]= "" #should clear it out
    

#def show_output_string_after_changes():
#    mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
#		print("this is what the switch string looks like after taking out a switch body")
#		print('resulting string change is for counter',counter)
#		for line in mouse.splitlines():
#			print(line)    
#this makes pairset list of switch and endswitch 
#this is only run ONCE
fullhouse=[]
##============================================================================
##  take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word
##----------------------------------------------------------------------------
##  Methods: make_pair_set_of_inner_switches_at_three_tabs_depth(thestring) oh wow genius here
##  Methods: loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
##  Methods: skipping_some_lines(x,start,finish)
##  Methods: determine_if_inner_switch_inside_of_this_switch_string(weasel)
##  result of modified string put into  fullhouse.append(never_defeated[0])
##============================================================================
def take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring):
	return
	print("THIS NEEDS TO WORK NOW==")
	print(" take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring)")
	baton[0]=thestring
	print("called ....take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestring)") 
	make_pair_set_of_inner_switches_at_three_tabs_depth(thestring)
	print("this is scenario where if one inner switch it's not filling the pairset")
	print("pairset=",pairset)
	loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
	print("list_of_inner_switches_at_three_tabs=", list_of_inner_switches_at_three_tabs)
	print("list_of_inner_endswitches_at_three_tabs=", list_of_inner_endswitches_at_three_tabs)
	print("pairset=",pairset)
	print("this should be the result of the switch with inner switches cut to just switch word, bodies gone")
	for line in never_defeated[0].splitlines():
	    print(line)
	##################################################
	## adding resultof output of methods of taking out inner switches into never_defeated[0]
	## which is put into list fullhouse using append
	### this is where the result of the change string put into never_defeated[0]
	### is appended to list fullhouse
	fullhouse.append(never_defeated[0]) #needs to be here obviously
	#-------------------------------------
	#if it is here then it's called ONLY after the first one has completed and thereafter
	#==================================================
	## this resets super important lists utilized 
	never_defeated[0]=''
	list_of_inner_switches_at_three_tabs.clear()
	list_of_inner_endswitches_at_three_tabs.clear()
	pairset.clear()
	baton[0]= ""
	



#print("====STARTING ATTEMPT 1====== charlie brown music is the best jazz ====")


#take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(spilled_coffee)


#exit() 
#print("this is after the first string and taking out inner switch bodies...")
#print("====STARTING ATTEMPT 2====== charlie brown music is the best jazz ====")
#reset_to_initial_conditions()
	##==========================

##=======================
#take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestringzoo1)


#reset_to_initial_conditions() #this must be done after each transformation
#print("the final OUTPUT is here ...")
#print("length of fullhouse should be 2 is now",len(fullhouse))


#for item in fullhouse:
#    print(item)

####################################################
#print("size of FULLHOUSE is..",len(fullhouse))
#for item in fullhouse:
#    print(item)

#print("time to go sledding")
#exit()


#print("now I will try to do a few stings with it.") 
#print("end of this initial test of ")
result_of_check_if_inner_switch=[]
result_of_check_if_inner_switch.append(0)

#coded on november 19th friday at 10:48 am morgan hill starbucks
##====================================================================
## determine_if_inner_switch_inside_of_this_switch_string(weasel):
##====================================================================
def determine_if_inner_switch_inside_of_this_switch_string(weasel):
    print("determine_if_inner_switch_inside_of_this_switch_string(weasel):")
    ## START INNER LOOP ======= devised on nov 19th friday 10L30 am ===========
    innerswitch= False #this must be set to False before each call below 
    result_of_check_if_inner_switch[0] = False
    for line in weasel.splitlines(): #this looks for an inner switch at 3 tabs depth
        tabdepth = line.count("\t")
        if tabdepth == 3 and "switch" in line:
            print("where's the party THIS string has an inner switch ")
            innerswitch = True
            result_of_check_if_inner_switch[0] = True
            break
        else:
            continue
        print("....")
    print('this has to be called after the loop is done')
    print("result_of_check_if_inner_switch[0]=",result_of_check_if_inner_switch[0])
    #end loop ===================


funtestlist=[]

#print("big bird for prez")
#print("testing in my mind wed november 10th test ..going thru list and calling take out switch bodies.")
#funtestlist=[samplestring,samplestringzoo1] #samplestringzoo1
#use the list I made earlier catching_first_change

# what this does is loop thru the seperated switch strings and 
# applies a method take out nested switch bodies leaving switch word


#ratmaze_list=[]
#=====================
#  try_the_mocha()
#=====================
# method determine_if_inner_switch_inside_of_this_switch_string(stringname)
# method take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
#=====================
def try_the_mocha(): #this has the separated strings in it (that's helpful)
    print("try the mocha() testing.......... running the rat maze and learning it...")
    fullhouse.clear()
    print("let us see the SEPARATED strings in this list")
    for item in catching_first_change:
        print(item)
    print("===== okay is this it ===")
    
    print("length of catching first change should be 6",len(catching_first_change))
    counter=0  #this is running the method for second stage of chain_methods
    for item in catching_first_change: #funtestlist: #strings in funtest list
        weasel = item
        ## determines if there is an inner switch in THIS string ==========
        determine_if_inner_switch_inside_of_this_switch_string(weasel)
        innerswitch= result_of_check_if_inner_switch[0]
        print('innerswitch if true or false it is .. =',innerswitch)
        if innerswitch == True:  #if there is an inner switch then apply the method below  
            ######## this method  cuts out all inner switch bodies ######################
            take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
            #fullhouse.append(never_defeated[0]) this line is at bottom of method take_out_nested..
            #never_defeated[0] #this string is the result of the method above in never_defeated[0]
            #############################################################################
        else:
            fullhouse.append(weasel) #so the original string unchanged is added to fullhouse llist
            #this means no innerswitch in this switch string 
            #it's False no inner switch
        counter += 1
        
        ###=========================================================
    print(" end of double loop ")
    print("after going thru catching first change list it should be 6 for counter")
    print("counter =",counter)
    print("len(fullhouse)=",len(fullhouse))
    print("let us look in here if switch stirngs with no inner switches okay and exist at least")
    for item in fullhouse:
        print(item)
    del catching_first_change[:]
    #this fills the output list into catching_first_change list 
    for item in fullhouse:
        catching_first_change.append(item)
        
    print("now big test of second chain method #taking out switch bodies")
    print("this should print out 6 stritngs")
    counter=1
    for item in catching_first_change:
        print("counter=",counter)
        print(item)
        print('=========')
        counter += 1
        
    

#print("this is for all of the marbles out of style")
#try_the_mocha()    
#print('did it work razzle dazzle pumpkins')



#exit()





#modified to get nested switch #so after the first switch in the string 
#so it gets the switch that is nested.
###============================
## get second switch number
##=============================
def get_second_switch_number(stringname): #this might be for when
# I create copies of the switch body strings
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		if "switch" in line and "end" not in line and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;
	
	
#input1 = rose[0]
#input2 = rose[1]
#print(input1)
#print(input2)
bigstringtest='''
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
    										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch #tail
							
									break
								default:
									print("we are done here")
							endswitch #46  2
'''

#print('output should be it shoud return this string')
'''
							switch(exp){ #23
      								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2
							'''
							
#print('october 12th testing doing actually test taking out inner switch')

bigstringtest1='''
	switch(exp){ #1
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #9
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch #tail
							
			break
		case 'tahoe bound':
				print('fun time now')
				exp ='fishy'
				switch(exp){ #25
					case 'fishy':
						print("do something")
						print("yep")
						fallthru
					case 'where now':
						print("nice")
						break
					default:
					print("we very done")
				endswitch #tail
				print('end of the game time')	
		default:
			print("we are done here")
	endswitch #46  2
'''

#start = 10 #rose[0]+1
#finish=20 #rose[1]+1
#total = finish -start; #gives us 10
#x= bigstringtest  #string name to cut out the range from 10 to 20 
#skipping_some_lines(x,start,finish)
#print(toosmart[0])
#print('leaving this November 10th test now for skipping lines in string')
#exit()







peachtree=[]
several_three_tab_switches_list=[]
## get second switch numbers check if many #returns list of inner switch id numbers
##########################################################
## get_second_switch_numbers_check_if_many(stringname):
############################################################
def get_second_switch_numbers_check_if_many(stringname): #this might be for when
	print("get_second_switch_numbers_check_if_many(stringname): Grinch stole christmas")
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter=0
	targetswitch =0
	for line in stringname.splitlines():
		tablength = line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:
			targetswitch += 1 
			counter += 1
		else:
			counter += 1
	#end loop
	print("this should return 2")
	print("number of switches at 3 tabs meaning first level =",targetswitch)
	
	#first check if tab length == 3
	counter=0
	smart=False #default setting
	for line in stringname.splitlines():
		tablength=line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3 and counter > 1 and "#" in line:
			x = line.split("#")  
			y = x[1];print(y)
			if ":" in y:
				y=y.replace(":","")
			print(y)
			several_three_tab_switches_list.append(y)
			peachtree.append(several_three_tab_switches_list)
			smart= True
			counter += 1
			continue
		else:
			counter += 1
			continue
		#print if the list is empty put a 0 in it
		print("special case test")
	if smart != True:	
		several_three_tab_switches_list.append(0)
		peachtree.append(several_three_tab_switches_list)
	#end loop
	print("this is key its NOT LOOKING FOR DEEPLY nested but only at 3 tabs >>")
	print("we are here now after filling switch list with inner switches at level 3 tabs")
	#print("several_three_tab_switches_list=",several_three_tab_switches_list)
	#print("this should return a list whith these two numbers in it 11 62")
	#for item in several_three_tab_switches_list:
	#    weasel=get_switch_number(testcode)
	#   


##==========================================================
# the issue is that on the second pass it is using the original string
# and it needs to be using the modified string
# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
# because the numbering system of the string starts from 1 too.
	
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1	
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)
#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##===========================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##===========================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)



def modern_take_out_endswitch(inputstring):
	print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():




test_string1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie yyy')
			fallthru	
		case 4 to 7:
			print('kangaroo hop hop!')#
			#############1
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################5
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default
											print("we very done") 
									endswitch 
							#############k
									break
								default
									print("we are done here")
							endswitch #46  
							#############k
							break
						default
							print("we are done here")
					endswitch #51   
					#############)
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #60  
			exp = 32
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #86   
			##############)
			print('taught me how to write code')
			fallthru	
			 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		default
			print('the end')
	endswitch #100  
'''
test_string2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #23
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #31
								case 'fishy':
									print("do something")
									print("yep")
									fallthru
								case 'where now':
									print("nice")
									break
								default:
									print("we very done")
							endswitch 
					#############
							break
						default:
							print("we are done here")
					endswitch #46  2.......
					#############
					break
				default:
					print("we are done here")
			endswitch #51   3 ...
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''

test_string3='''
	switch(exp){ #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #23
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #31
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'where now':
							print("nice")
							break
						default:
							print("we very done")
					endswitch 
			#############
					break
				default:
					print("we are done here")
			endswitch #46  2.......
			#############
			break
		default:
			print("we are done here")
	endswitch #51   3 ...
'''

test_string4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  .
'''

test_string5='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch #41
'''

test_string6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'snow fire':
					print("nice")
					#############
					break
				default:
					print("we are done here")
			endswitch #77 5 .....
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86
'''

test_string7='''
	switch(exp){ #66
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'snow fire':
			print("nice")
			#############
			break
		default:
			print("we are done here")
	endswitch #77 5 .....
'''
# instead what if I feel a list of switches at 3 tabs and endswitches at 3 tabs
# and make pairs and then use the skip robe which already works and that way 
# I will reuse working code and based on the length of the switch list I just
# look in both lists at the same location position 0 and then 1 etc.
print("big test....starbucks morgan hill ========")

switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	
#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	print("end of line...")
	########################======
	
	########################==========
#print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function

#print("should be 1 for this test")
#del switch_list[:]
#del endswitch_list[:]
#print('real test now i really need this puppy to work')





#del total_switches_at_3tabs_depth[:] #empty it first 
#del switch_list[:]
#del endswitch_list[:]
#print('real test now in string with more than one inner switch at 3 tabs should be 2')
#get_switch_and_endswitch_locations_in_string(test_string1)
#mylist=[]
#mylist.append(5)
#print("did it even work or not?!")
#exit()

'''
print("======experimenting with test_string1========")
if total_switches_at_3tabs_depth[0] > 1:
    number_to_loop = total_switches_at_3tabs_depth[0]
    print("number to loop=",number_to_loop)
else:
    print("nope only one inner switch at 3 tabs")   
if number_to_loop == 2:
    print("True that number to loop = 2")
    print("1st loop == ")
    x = 0
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
    print("2nd loop === ")
    x=1
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
#end if
'''      
#mylist.append(17)
#print("doing test_string6")

#print("halloween is nearly here test======..........")
#print("switchlist =",switch_list)
#print("endswitchlist =",endswitch_list)
#print("==============")
#start  = switch_list[0]
#finish = endswitch_list[0]
#currently skip rope method only does one switch to endswitch set so I would use a loop
#and put skip rope in it to do multiple ones


# input 62, look in dictionary to get the 86
# input 11, look in dicitonary get the 60 
#print('testing test_string2 ...')
#start = 5
#finish = 41
#this needs to be called first 
#print('testing test_string2')
###====-=====================================================
#print("this has to be done fifrst need to get switch and endswith lcoations")
#print("=======")
#delete_helper_lists_first() #trying this out

#print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
#get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string

#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#print('........... what do the lists say above ....')
#start  = switch_list[0]  #5
#finish = endswitch_list[0]  #41   #below this means that it's empty, False to set flag
#string_after_cutting_out_inner_switch_body[0]= False #set this to False first
#print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
#print("======testing string2======")
#skip_rope_skipping_some_lines(test_string2,start,finish)
###=======================================================
#exit()
###======================================================================
#print("=======testing test_string6======")
#this is only designed to cut out ONE inner switch 
#print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
#skip_rope_skipping_some_lines(test_string6,start,finish)

#print('now string1 with 2 nested switches=== star trek time====')
#print("testing 1..")
#need to find the switches locations and work from the bottom up so do second inner switch first
#that's how the macros work bottom up that way I can use the numbering input correctly. 


### here it has to do the cutting out in reverse since more than one inner switch to cut out
### I learned this trick from my macros solution
#### relooking at this on oct 22nd friday, at 10:46 am 2021
###=========================================================================
#this will be a special method for dealing with reducing down 2 or more inner switches to switch word
#print("PUFF THE MAGIC DRAGON === THIS SHOULD ALREADY WORK== ")

# need to make this into a method that has some fuzzy logic
#print("TESTING WITH 62 AND 86 SKIPPING ROPE")
#this needs to be put into a method 
#this needs to be set to False to work correctly.
#first we set it to False


#what this does is go thru a list that is in reverse order to cut out thru skipping
# a string to take out inner switches at 3 tab level.  it actually works.
# I need to have a modified one if only one list 

#we will have a loop ::; put this together on Friday, October 22nd, 2021 at 11 am
#string_after_cutting_out_inner_switch_body[0]= False 
#if len(inputlist) == 1:  good if only one list and reverse calls it does nothin
#what this does is loop thru a list of switch endswitch at 3 tabs and does more than one


###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    return
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 #where am I filling inputlist?
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
        print("counter=>>",counter)
        print("=====================")
    #print("at bottom of converts  with more than one inner switch at 3 tabs")
    #print("testing if weasel is returnable at the end of the function")
     #this is after it's done
    #for line in weasel.splitlines():
    #    print(line)
    #return weasel 

#=======================	
#print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
#inputlist =[]
#inputlist.append([11,60])
#inputlist.append([62,86])
#print(inputlist)
#inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#print("after reversing the list we now have===")
#print(inputlist)

#======== just commented this out up to above line like this one =================
#print("convert switch with more than one inner switch at 3 tabs(stringname)==== string1")
#get_switch_and_endswitch_locations_in_string(test_string1) #presumes one inner switch 
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("====real deal here ===GET SWITCH AND ENDSWITCH LOCATIONS========")
#print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
#get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#it needs to make these [[11, 60], [62, 86]]
###testing nov 27th at 10:46am starbucks
#print('important testing on Saturday morning')
trialinputlist=[]
inputlist =[]

#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================
#this is also in starship best to keep it in starship
'''
def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]
	#print("build_trail_inputlist()..")
	counter=0;
	pair=
	for item in switch_list:
		pair=[switch_list[counter],endswitch_list[counter]]
		trialinputlist.append(pair)
		counter += 1
		
	#print("look for the ball on the green")
	print("trialinputlist=",trialinputlist)
	for item in trialinputlist:
		inputlist.append(item)
	print("inputlist=",inputlist)
	for item in inputlist:
		print(item)
	inputlist.reverse() #is this needed here or not 
'''
	
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
#print('end of the show sunday morning blues coding')
#print("Super silly string 1 PHASE 1 taking out two nested switches at 3 tabs location bottom one first")
#print('end of the show sunday morning blues turkey day 2')
#print('doing the same string a 2nd time to see if it works')
#print("............................................")
#print("now trying test_string2")
#del switch_list[:]
#del endswitch_list[:]
#print("do you see what I see??")
#inputstring=test_string1
outputstring=[]
outputstring.append(0)
snowboarding=[]
##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	#print("take_out_switch_body      today is november 28th sunday  4:29 pm ")
	#right here look if a switch at 3 tabs if not skip below
	####=== new as of monday december 6th, 2021 =========================
	#determine if 
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
			#print("yes switch at 3 tabs in line")
			#print("frosty says switch at 3 tabs confirmed")
			nestedswitch= True
			break
	#print("frosty the snow man light test for nested switch")
	#print("nestedswitch=",nestedswitch)
	#print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
		#add input into output  this means no changes were done to the switch string
		#print("this switch string DOES NOT have an inner switch")
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	#print("frosty snowboarding")
	#december 6th looking where I am not adding31 and 66 
	
	#print("this is new code now today is Monday november 29th now Dec 6th.")
	#print("what is in lightning[0] now")
	#print(lightning[0])
	
	#print("resulting final output of take_out_switch_body:") 
	snowboarding.append(lightning[0])  #this is new dec 6th monday
	#for line in lightning[0].splitlines():
	#	print(line)


''' 
print("========TAKE OUT SWITCH BODY()========")
take_out_switch_body(test_string1) #the first one has more than one inner switch it takes out
take_out_switch_body(test_string2)
take_out_switch_body(test_string3)
take_out_switch_body(test_string4)
take_out_switch_body(test_string5)
take_out_switch_body(test_string6)
take_out_switch_body(test_string7)
'''
#gotta take out } in switches 
'''
counter=1
for item in snowboarding:
    print("counter=",counter)
    print(item)
    print("========")
    counter +=1
'''    
    

#exit()
'''  
#def finally_reduce_inner_switches_at_three_tabs_into_switch_word(inputstring):
print("where is the christmas tree test===== doing test_string  1 ===========")
get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
build_trial_inputlist()	 #this is new 
print("right here what is in inputlist=",inputlist) #needs to be reversed
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
print("end of christmas tree test test string 1 with 2 nested switches at 3 tabs")
#exit()

print("where is the christmas tree test===== doing test_string   2 ===========")
get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string2)
print("anotehr one 3")
print("where is the christmas tree test===== doing test_string  3 ===========")
get_switch_and_endswitch_locations_in_string(test_string3) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)
'''
'''
print("where is the christmas tree test===== doing test_string  4 ===========")
get_switch_and_endswitch_locations_in_string(test_string4) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)


print("testing another one now===== doing test_string  6 ==========")
get_switch_and_endswitch_locations_in_string(test_string6) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)
'''
#exit()

# method chaining
# getone.getteo.getthree()

#=======
#Bottom of chain methods result if methods goes into
#output[0]

#Where is transform_string() called

#https://www.google.com/amp/s/nypost.com/2021/11/11/ufos-buzzing-us-warships-may-be-aliens-top-spy-chief/amp/

#Good stuff

#https://m.youtube.com/watch?v=azZ4XAZuVk4




#print(inputlist)
#inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#exit()

#inputlist =[]
#inputlist.append([10,36])

'''
#get_switch_and_endswitch_locations_in_string(test_string3)
print('end of the show sunday morning blues turkey day 3')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)

#rint('end of the show sunday morning blues turkey day 4')
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)
inputlist =[]
inputlist.append([5,16])
print('end of the show sunday morning blues turkey day 6')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)
print("wow wow")
'''

#string_after_cutting_out_inner_switch_body[0]= False  #just filler but a flag meaning empty

#exit()
#print("testing input 62, 86 skipping rope")
#start=62; finish=86  #[62,86] #input values fed into it 
#skip_rope_skipping_some_lines(test_string1,start,finish)#62,86

#start=11; finish=60  #[11,60]
#skip_rope_skipping_some_lines(test_string1,start,finish)#11,60
'''
print(" super silly string 2 PHASE 2 taking out 2nd nested switch (the higher first one done second) at 3 tabs")
print("TESTING WITH 11 AND 60 SKIPPING ROPE")
print("testing 11,60 inputs for skip rope skipping some lines ")
print("testing 2...") 
'''






#print("after doing this which needs to be made into a function with a loop")
#print("it will need input of [[11,60],[62,86]] that I reverse if more than one in it")
#listname.reverse()
#so I can use teh same string to do both cuts out of inner switches 
#first     62,86
#second is 11,60

#exit()
#skip_rope_skipping_some_lines(string_name,start,finish)
#critical_list= [[11, 62], [15], [23], [31], [0], [66], [0]]
#end of show

# tuesday, october 19th, 2021  time 9:52 morgan hill starbucks
#==================================
# cut_out_switch_body_no_params   october 19th tuesday
#==================================
#abandoned this appraoch 
# objective is to go through string and take out switch bodies without inputs
'''
def cut_out_switch_body_no_params(string_name):
	print("cut out switch body no params===")
	counter=1; concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#start  = input_to_get_inner_switch[0]
	#finish = input_to_get_inner_switch[1]
	
	#what about a quick search for locations of switch and endswitch
	for line in string_name.splitlines(): 
		if "switch" not in line and "endswitch"  not in line and tabdepth != 3:
			print(line)
		#notice start +1 based on line number 
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line and tabdepth == 3:
		#actaully I don't want 
			concatthis += line + "\n"; counter += 1; continue
			print(line) #it won't print the switch word since it's skipping it
			
		 else: 
			 counter += 1; continue
		if "endswitch" in line and tabdepth == 3:
			print(line)#get current line then break
			concatthis += line + "\n"; counter += 1; continue
			#break
	print("===output from skipping some lines====")
	print('it created this SILLY STRING === multi colored silly string=')
	print(concatthis)
	for line in concatthis.splitlines():
		print(line)
	print("=======")
	print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
##========== new version 
	print("here we have the halloween special START SKIPPING ROPE...")
	print("the output string looks like this")
	weasel=string_after_cutting_out_inner_switch_body[0]
	for line in weasel.splitlines():
	    print(line)
'''	
	
	
#print("testing cutting out the inner switch bodies to see if it works")	
#cut_out_switch_body_no_params(test_string6)
### this is now working correctly taking into account
# that lines start from 0 not 1 and I need to skip and include the switch word


#next go thru list of stirngs and take out inner switches bodies


#Never theorize before you have data.Invariably you end up twisting facts to suit theories instead of theories to suit facts. -Sherlock holmes.
#There is nothing more deceptive than an obvious fact


##================================= testing at starbucks gilroy christmas tree
#####transform_string() #12379






##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
def next_metamorphosis_take_out_inner_switch(string_name,switch_number):
	print("==next_metamorphosis_take_out_inner_switch)====")
	switch_tab_depth=''
	counter=1 #look we are starting to count from 1
	startcount =0
	endswitchline=0
	end_switch_tab_depth=''
	#get inner switch location all we know is the switch line number 31 in this case 
	#get switch_tab_depth
	print("the switch_number=",str(switch_number))
	for line in stringname.splitlines():   #switchnumber 31
		if "switch" in line and  "end" not in line and "#" in line and str(switch_number) in line:
			print("31 in line and switch in line and end not in line and # in line ALL TRUE")
			switch_tab_depth = line.count("\t") #gets tab depth
			startcount= counter
			end_switch_tab_depth=switch_tab_depth #see if this works now
			break
		else:
			counter += 1
			continue
	#get endswitch location
	print("startcount =",startcount) #targer switch line number 
	print("target switch_tab_depth =",switch_tab_depth)
	print("END OF PHASE 1 ...")
	
	#get endswitch tab depth
	print("============================")
	counter = 1 #get endswitch tab depth
	for line in string_name.splitlines():
		this_line_tabs= line.count("\t")
		if "endswitch" in line and counter > startcount:
			this_tab_depth = line.count("\t")
			if counter > startcount and this_tab_depth == switch_tab_depth: #this means endswitch must be AFTER switch
				endswitchline = counter
				#the tab depth MUST be the same as the target switch tab depth 
				break
			else:
				counter +=1
		else:
			counter += 1
			continue
			
	print("end_switch_tab_depth=",end_switch_tab_depth)
	print("the end switch line=",endswitchline)
	print("=============================")
	print("END of PHASE 2...")
	counter =1
	for line in string_name.splitlines():
		if "endswitch" in line and counter == endswitchline:
				endcount = counter
				break		
		else:
			counter += 1
	
	startcount = startcount-1 #because we skip switch and keep it. 	
	print("output of next_metamorphosis()")
	print("startcount=",startcount) #oh this is brilliant
	start = startcount
	print("the endswitch line =",endswitchline)
	finish = endswitchline
	print('start=',start)
	print('finish=',finish)
	input_to_get_inner_switch.append(start)  #[0]
	input_to_get_inner_switch.append(finish) #[1]
	print("start=",input_to_get_inner_switch[0])
	print("finish=",input_to_get_inner_switch[1])
	print("switch_tab_depth=",switch_tab_depth)
	#now I can run the skip lines code that requires the start and finish range numbers
	print(" END of PHASE 3 ...")
	print("again this doesn't modify the switch string it just gets input data")
	print("for the next phase which is skipping rope")
	
#notice start +1 based on line number 
#		#because numbers are off by 1 since starting at 0 not 1 in counting
#		#if counter > start +1 and counter <= finish: 
#		if "endswitch" not in line and this_tab_depth == switch_tab_depth: 
#			print(line) #it won't print the switch word since it's skipping it
#			counter += 1; continue
#		else: 
#			concatthis += line + "\n"; counter += 1; continue
#	print("===output from skipping some lines====")
#	print('it created this SILLY STRING ====')
#	print(concatthis)
	
#for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0])
	#if flag_test[0] == False or flag_test[0] == None: #meaning first pass  and what it's set to by DEFAULT
	#    smart=x;
	#    #change it to True now
	#    flag_test[0] = True #this should now be tru e
	#else: #meaning TRUE this is run after first run of skipping_some_lines()
	#    x = baton[0]
	### look that we have the counter here set to 1 by default 
	



#===========================
#print("HERE WE START METAMORPHOSIS ENTERING THE MATRIX...")
#this one has to be called first since it creates the start and finish lines for this string
#based on what the switch number is in the comment which it will look for
#and the inner switch line numbers will be known beforehand
#because they are automatically added 

#def take_out_inner_switch_bodies(thestring):
#first I need to get the nested switch number (assuming one at this point)
## I need to make this into a method witht he two functions below
#working on this october 14th, 2021 gilroy 6:55pm

#I need to get the inner commented switch number 
###=====================================================

'''
print("three, two,one, blast off===>>>")
string_name= bigstringtest # <=== string is in here 
#I need to put the method here that gets the switch comment number
#switch_number=31 #I need to get this number automatically
#this will be different if there are more than one inner switch at 3 tabs length
#I still need to clean up the copied switches so the first switch is at 1 tab
#and the next next level switches start at 3 tabs
#for this first attempt we will limit the inner switches to just one
axis=get_second_switch_number(bigstringtest) #returns 31
#should be 31 
print("axis should be 31",axis)
switch_number = axis #finally getting closer to victory
'''


####===============================
#I have code that get the inner switch number if only one
#and I have code that can find all inner switches at 3 tab level depth 
#what this does is rip out the nested switch body leaving the switch
# word in the nest_list after separating the switch bodies
#this is an important step and I just figured out how to
# detect if more than one inner switch at the three tab level depth
## make this into a method now

# I also got the code to get the second switch in a string line number  in the comment
#which will invariably be different from the true line number, but that's okay.
#=================================================

#I need to go thru each string and count the switches at 3 tabs
#do the loop jazz too.
##=========================================================
##  count_inner_switches_at_first_level(inputstring)
##=========================================================
def count_inner_switches_at_first_level(inputstring):
	print("=====count inner switches at first level=== so at 3 tabs ==")
	counter =0
	innerswitch = 0
	for line in inputstring.splitlines():
		tabdepth = line.count("\t") #added and "end" not in line to eliminate endswitch bug
		if "switch" in line and "end" not in line and tabdepth == 3:
			print("the line number is ",counter)
			linewithswitch =counter
			innerswitch += 1
			counter += 1
		else:
			counter += 1
			
	print("innerswitch count at 3 tabs in this string=",innerswitch)
	print("the line number of the sole inner switch is",linewithswitch)
	return innerswitch;

#inputstring = bigstringtest1
#this counts inner switches at 3 tabs indentation in a switch string
#total=count_inner_switches_at_first_level(inputstring) #calls the method above

'''
print(" we are done here, of the number of inner switches at 3 tabs = ",total)
#where do I get the inner switch number??
print("=========.........")
print("=========....halloween pumpkins are coming.....")
print("=========.........")
 #this calculates the start and finish of one nested switch 
string_name=bigstringtest1 #I need to find the get switch number for inner switch
switch_number=several_three_tab_switches_list[0] #this presumes only one inner switch
switch_number = int(switch_number) #right here a miracle occurs==== 
print(type(switch_number)) #this gets the start and finish numbers for inner switch to cut out
next_metamorphosis_take_out_inner_switch(string_name,switch_number)
print("it should be 9 and 20 and it shows...")
#all this does is create the start and finish line numbers of one inner switch
print(input_to_get_inner_switch[0])  
print(input_to_get_inner_switch[1])
print("string_name=",string_name,"start=",start,"finish=",finish)

print("go for the gold medal===================")
string_name= bigstringtest1
#I am feedingit 9 and 20 to start with here 
#here the inner start and finish of an inner switch is inserted
start =input_to_get_inner_switch[0]#9  #=input_to_get_inner_switch[0]  #9 #1 after switch line number so it really does 10 compensating 
finish=input_to_get_inner_switch[1]#)20 # =input_to_get_inner_switch[1] #=20
print("SKIPPING ROPE NOW to modify the string and cut out inner switch")
skip_rope_skipping_some_lines(string_name,start,finish)
#skip rope takes out the inners switch leaving the inner switch word.
print("The GREEN EXIT SIGN NOW")
#exit()
'''
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================

#skip_rope_skipping_some_lines(string_name,start,finish)
#it needs to return values to start and finish as input for 
#skip_rope_skipping_some_lines(string_name,start,finish)

#now I need to count switches in a string
#and as a backup safety count endswitches also.


#I can work on these separately actually 
################
teststring1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the awesome dog house!")
			print('first prize')
			print('you smart coder head Charlie Brown  hhh')
			fallthru
			
		case 4 to 7:
			print('kangaroo hippity hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do this is sw 15")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do this is sw 23")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do this is sw 31")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  
							#############
							break
						default:
							print("we are done here")
					endswitch #51   
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   
			exp = 3
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do this is sw 66")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86   
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
	endswitch #100  
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [11, 60]
#counter= 2
teststring2='''
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [15, 51]
#counter= 3  THIS IS 5 TABS IN FIRST LINE 
teststring3='''
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
'''


#==========-----------seperated nest strings -----------------
#getting data in blueberries [23, 46]
#counter= 4 this one works 
#I have to reduce these downto first tab and then three tabs
teststring4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch 
			#############
			break
		default:
			print("we are done here")
	endswitch #46  2.......
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [31, 41]
#counter= 5
teststring5='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [62, 86]
#counter= 6
teststring6='''
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [66, 77]
#counter= 7   THIS IS 5 tabs in first switch line 
teststring7='''
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 5 .....
'''

#==========-----------seperated nest strings -----------------

'''
print("moving tabs out.")
print("testing moving extra tabs out of a string")
print("this is looping thru teststring3 ")
print("Grand Canyon test Friday")
print("I will take out 5 tabs from the front of each line")
for line in teststring3.splitlines():
    print(line)
print("end of test of printing out teststring3")
print(" ")
counter =0
switch_actual_tabs=[]
switch_actual_tabs.append(0)
import re
onetab="\t"  # here is onetab declared with one tab inside of it
fishbowl=[]
fishbowl.append(0)
'''



#sunday confirmation number sundayoct 17th, 2021
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''
#this swaps endswitch with }
#what this does is replace endswitch with '}
###===================================
##  take_out_endswitch(stringname)
###===================================
def take_out_endswitch(stringname):
	print("take_out_endswitch()  called=====")
	answer=''
	galaxy = stringname
	print(galaxy)  #using replace endswitch with }
	#this replaces all endswitch(es) to }
	holdthis[0] = galaxy.replace("endswitch","}") #added here
	#bug what if there is already a curly brace but no endswitch
	print(holdthis[0])
	#move it to left
	answer = holdthis[0]
	newstring=''
	for line in holdthis[0].splitlines():
		if "}" in line and "\t" in line:
			line = line.lstrip()
			newstring += line
		else:
			newstring += line + "\n"
			
	holdthis[0] = newstring
	
	print(holdthis[0])
	for line in holdthis[0].splitlines():
		print(line)
		
	#return answer;
	
	#galaxy = holdthis[0]
	#holdon[0] =holdthis[0]
	#return galaxy
	
	
	
	
	

##==========================================
## shift_nest_string_to_left(stringname)   made on oct 15th, 2021 8:57 am
##==========================================
def shift_nest_string_to_left(stringname):   #cuts out tabs and adds new tabs automatically
    print("========= shift_nest_string_to_left(stringname ===... =====")
    #for line in stringname.splitlines():
    #    print(line)
    #print("this is th einput string====")
    newline=''
    counter=0
    thismatters=''
    print("shift_nest_string_to_left() called")
    for line in stringname.splitlines():
        tabslength = line.count("\t") #this is set up for string3 initially. 
        print("tabslength=",tabslength)
        #counter +=1
        if counter == 1 and "switch" in line: #just added this oct 15th 
            #print(line)
            #print("we care about THIS ONE",tabslength)
            switch_actual_tabs[0] = tabslength
            #print("switch_actual_tabs[0]===",switch_actual_tabs[0])
        else:
            print("he well")
        print("=================>>>=======")
        #For teststring3  if 5 tabs in first line then tabslength-4  because it has 5
        ##==================================================================
        clever=0 #starting give it default value of 0 
        #this one works
        if switch_actual_tabs[0] == int(5): #5-4
            clever = 4
            #print("let's see if clever is an int here")
            #print(type(clever))  
            
        #for some reason this if below is not working right    
        if switch_actual_tabs[0] == int(3): #3 - 2 #reducing to 1 tab on first line
            clever = 1
            #print("let's see if clever is an int here")
            #print(type(clever))  
        #so if 5 -4 giving us 1
        #if 6 -5
        #if 7 -6 giving us 1
        #if 4 -3
        #if 3-2
        #if 1 do nothing
        #this is based on it having 5 tabs in line one and minus 4 tabs
        #if tabslength == 3:
        #    tabslength = 1; #which is -2
            
        #if tabslength == 5:
        #    tabslength = 1 #which is -4
        #I think what I need to do is determine indentation before first switch to gauge it    
        print(" switch_actual_tabs[0]=", switch_actual_tabs[0])
        #total_tabs_to_add=''
        ##########################################
        #if 5 tabs then -4
        #if 3 tabs then -2
        total_tabs_to_add=''   #this was 4 changed it to celver
        print("at this point what is the value of clever",clever)
        total_tabs_to_add =int(tabslength) - int(clever) # reducing it to 1 taking 4 tabs off  #right here 
        print("====")
        print("at this point what is the value of total tabs to add",total_tabs_to_add)
        #print("position 1 type test")
        #print(type(total_tabs_to_add))
       
        #this is what I took out above and replace with below 
        #total_tabs_to_add = ''
       # print("testing boolean condition here ....")
        print("tablength in first switch line =",tabslength)
        #====== if tablength = 5 -==========================
        if tabslength == 5:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 4 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
        #end if
        print("====")
        #number one rule code does exactly what you tell it to do. 
        #====== if tablength = 3 -==========================
        if tabslength == 3:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 2 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
            
        #print("position 2 type test")
        #print(type(total_tabs_to_add))
        
        #if tabslength == 3:
        #    total_tabs_to_add = tabslength - 2 
        #end if
        #print("=====")
        #print("position 3 type test")
        #print(type(total_tabs_to_add))
       
        #print("so this line will have this many tabs in front",total_tabs_to_add)
        total_tabs_to_add = total_tabs_to_add * onetab #times 1 tab #0 x 1 = 0
        print("RESULT= total_tabs_to_add to each line",total_tabs_to_add)
        myString = line
        output   = re.sub(r"[\t]*", "", myString)    #takes all tabs out of this line
        newline += total_tabs_to_add + output + "\n" #this puts the tabs in front of the stripped string line
        counter +=1
        continue
    #print('the result is..')
    print("this prints out the output what the changed indentation shift to left looks like")
    #return newline
    fishbowl[0] = newline  #the output of shifting to left 
    for line in newline.splitlines():
        print(line)
#print("drink coca-cola test")
#print("TESTING 3")    
#print("starbucks breakfast of friday testing..")
#print("testing indenting correclty teststring3")
#shift nest string to left

'''
shift_nest_string_to_left(teststring3) #good 5 TABS DOWN TO 1
print("red alert test 3 shift nest stirng to left side ... test 3 ")
print("look carefully at this and make sure that it's right with just one tab at top")
print("testing with string skitahoe")
shift_nest_string_to_left(skitahoe) 
print('first we will do this simple test with no tabs see if it returns 0')
practicestring='''
#switch(exp){
#    case 1:
#        print('hello')
'''
tabsinthisline =''
for line in practicestring.splitlines():
    if "switch" in line:
        tabsinthisline = line.count("\t")
        print("tabsinthisline=",tabsinthisline)
        break
        
print("TESTING string 7 now indenting it to the left")
shift_nest_string_to_left(teststring7) #good 5 TABS DOWN TO 1
print("red alert testing shift string to left")
'''



	
	
	
#exit()

#exit()
#print("end of testing of doing indentation shifting to string")
#print("oct 26th nearly done with this.. line 6127 ")
#exit()

#print("this is where I am indenting the switch strings already in a list")
#print("I need to indent them to work on them further to prepare them for the parser")

gold_list_results=[]
newstring=[]
newstring.append(0)
##=================================
##  manipulate_string(addstring) #this appends the changed switch strings to gold_list_results
##=================================
#print('testing taking out 2 ')
def manipulate_string(addstring):
    #print("======manipulate_string() called line 8524=======")
     #the objective is to reduce tabs so only 1 tab in front of first switch in string
    cutout=''
    #print("let us ORIGINLAL INPUT STRING HERE look at the starting input string before modifying it")
    #for line in addstring.splitlines():
    #    print(line)

    #print("== red white and blue ==============")
    #print("=======pinpointing bug on november 30th =============================")
   # print("getting tab count in front of first switch here")
    for line in addstring.splitlines():
        if "switch" in line and "end" not in line:
        #this determines the number of TABS in this line
            tabsinthisline = line.count("\t")
            #print("tabsinthislines=",tabsinthisline)
           # print("the tabs in front of first switch are",tabsinthisline)
            #the objective is to have only 1 tab in front of first switch
            # which then propogates down the length of the entire string
            if int(tabsinthisline) > 1:    #example
                cutout = tabsinthisline -1
                #print("tabsinthisline =",tabsinthisline);
                #print("cutout =",cutout)
                break
            if tabsinthisline == 1: #which means do nothing we want just 1 tab first
                cutout = -1; #this is using -1 as a flag
                break
            if tabsinthisline == 0:
                break
            # do nothing   193241613
     #take out just 2 tabs
    #print("now doing ===== SECOND PHASE ======of manipulate_string")
    #print("now doing ===== SECOND PHASE ======of manipulate_string")
   # print("now doing ===== SECOND PHASE ======of manipulate_string")
    super=''
    lastchar=''
    for line in addstring.splitlines():
        #if "switch" in line and "end" not in line:
        tabsinthisline = line.count("\t")
        #it does all lines of the string taking out the first 2 tabs which are chars
        if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
            sliced = line[cutout:] #this can be a variable
            #print("sliced sees",sliced)
            #phase A ============================
            
            #print("================================")
            #print("======phase A sliced=",sliced)
            ### bug fix ##===========================
            #reput in on dec 5th sunday 
            #print('this fixes the bug that was putting junk after each line')
            #print('adding extra : ) u #')
            #print('see if it works ... again')
            ###############################
            ###### testing bug fix dec 5th sunday ######################
            #this tests if last character is #,),u,:
            #print("the last char is sliced[-1]",sliced[-1])
            #tail = sliced[-1]
            #looklist=[]
            #looklist=["#",")","u",":"]
            #if tail in looklist: 
            #   print("yes last char is either #,),u,:")
            #   sliced=sliced[:-1]
            #else:
            #  print("none of the garbage characters are the last char")
            #   pass
            ################################
            ################################    
            ##========================================
            
            
            #if len(sliced) >0:
            #    lastchar=sliced[-1]
            #    #print("lastchar =",lastchar)
            #   # print("TRUE weird last character",lastchar)
            #    if lastchar == ":" or  ")" or  "u" or   "#":
            #        sliced=sliced[:-1]  
            #========================== bug fix on nov 30th Tuesday hollister starbucks===============================    
            #    sliced=sliced[:-1]
            #else:
            #    print("last char must be 0")
               # print("length of sliced =",len(sliced))
            #print("after teh change the line looks like ",sliced)
            #print("====did it work or not=============")
            
            
            ################################################################
            ## this takes out the last char at end of the line
            #get last character
            #=============================
            #sliced=sliced[:-1]
           # if any of these are True  :),u,#
            #print("====  testing if last character : ) u # ==== ")
            #if lastchar == ":" or  ")" or  "u" or   "#":
             #   print("TRUE weird last character",lastchar)
            #    sliced=sliced[:-1]
            #else:
            #    print('current last char is',lastchar)
                
               
                
            #if sliced[-1] == ":" or  sliced[-1] == ")": or sliced[1] == "u": #
            #    sliced=sliced[:-1]
            #end if
            #===============
            
            #sliced=sliced[:-1] #this is new but when does this occur and why?
            #this is new nov 30th, tuesday hollister starbucks
            
        else: #this means its equal to 0
            #scenario zero tabs in front of first switch starting
            if tabsinthisline == 0:#this handles if there are zero tabs in front of switch line
                sliced = "\t" + line; # add one tab if zero tabs.
                #phase B ============================
                
                #print("================================")
                #print("=====phase B sliced=",sliced)
            else:
                #phase C ===================
                sliced =  line; #maning this has at least 1 tab already
                
                #print("================================")
                #print("=====phase C sliced=",sliced)
        super += sliced + "\n" # this does all lines in the string
        #=== super 1 ==================
        #print("SUPER 1 =",super)
        #scenario if it's already perfect at 1 tab length in front of switch
        if cutout == -1:  #this means tabs in this line determined to be 1
            super += line 
            #super 2  =====================
            
            #print("================================")
            #print("SUPER 2 sliced=",super)
        #end if
   # print("================ taking out 2 tabs quickly and dirtily")    
   #print("this is the output SUPER lines to see the result")
   # print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
   # for line in super.splitlines():
   #     print(line)
    return super #this should do it now this is what is returned a string called super
    
    
    newstring[0]= super #shift_nest_string_to_left(string)
    #this appends the super string to gold_list_results list 
    gold_list_results.append(super)
    #the string sare in gold_list_results
#print('testing cutting out first two tabs from front of string')
#print("===TESTING CUTTING OUT FIRST TWO TABS FROM FRONT OF EACH STRING OF CODE==")
#print("moving everythign to left side for formatting this sucker see if gold nears")


#print("=====testing in theory method chaining ======")
#print("=====testing in theory method chaining ======")
#print("=====testing in theory method chaining ======")
#print("=====testing in theory method chaining ======")
#print("=====testing in theory method chaining ======")
#output=[]
#output.append(0)
#myinput=[]
#myinput.append(0)
#print(" chain methods test with 3 methods that hand off output as input to next method")
#print('testing 3 methods in a row november 23rd santa cruz avenue menlo park ')
#print("==================================")
#print("first let us see the string in the starting representation") 
#for line in teststring6.splitlines():
#    print(line)
#print
#output[0]='' #to shift string identation to the left
'''
print(" **  method 1  **  indent to left   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
'''

#del myinput[:]
#myinput.append(teststring6)
#input[0] = teststring6
############===============
#manipulate_string(myinput[0]) #indent to left  what is the outpout put into 
############==========
#output[0]=newstring[0] 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#razzle = output[0]
#myinput.append(razzle)
#3toosmart = razzle
#mystringname= toosmart #spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#print(" **   method 2  ** cut out sitch bodies  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#right here it can't read the stringname
#print("==========starting point======================")
#print("================================")
#print("stringname=",mystringname)
#for line in mystringname.splitlines():
#    print(line)
    
#print("checking cat scales list [0] now===========")
#for line in cat_scales[0].splitlines():
#    print(line)
    
#mycat = never_defeated[0]
###################==============
#stringname=mycat;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)

#print(never_defeated[0])
#start=1,finish=1;
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
###################==========
#print("please work now did this sucker work tuesday november 23?") 
#print('result of taking out inner switches ') 
#output[0]=cat_scales[0]    #outoput 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#del myinput[:]
#myinput.append(output[0]) #does this one work  
#print(" **  method 3  ** testing take_out_endswitch()")
#print(" **  method 3  ** testing take_out_endswitch()")
#print(" **  method 3  ** testing take_out_endswitch()")
#print(" **  method 3  ** testing take_out_endswitch()")
#print(" **  method 3  ** testing take_out_endswitch()")

#################==========
#take_out_endswitch(input[0])
#################===========
#outoput in holdon[0]
#output[0] = holdon[0]
#print("result of taking out bottom endswitch ")
#for line in output[0].splitlines():
#    print(line)

#print("above this line is the totally modified string from 3 chained methods ")


###============= test nov 24th wednesday 2021 target parking lot

test_string4='''
	switch(exp){ #44
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #51
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  
'''

#You can use double or single quotes:
#testing on my iphone. last night. 
testingthis='''
	switch(exp) #23:
		case 'tahoe':)
			print("do something"))
			print("yep"):
		case 'fallen leaf lake':)
			print("nice")#
		####################1
			nested_switch_31:(exp) #31:
			#############k
			break:
		default:)
			print("we are done here").
} 
'''

moregarbage='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize'))
			print('you block head Charlie Brown   ooo')
			fallthru	
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############1
			nested_switch_22:(exp) #22
			exp = 32
			nested_switch_33:(exp) #33
			##############)
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:)
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
} 
'''

trythisone='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown---')
			fallthru	
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			nested_switch_11:(exp) #11
			exp = 32
			nested_switch_62:(exp) #62
			##############)
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
} 
'''

##==============================
##  remove_garbage_on_right_margine(inputstring):    called after manipulate_string
##==============================
#removes garbage on right margine and takes out : in nested_switch if it exists
def remove_garbage_on_right_margine(inputstring): #this fixes garbage characters afterwords
	#print('----------cherry on top called----------------------')
	cutout=''
	#print("let us ORIGINAL INPUT STRING HERE look at the starting input string before modifying it")
	#for line in inputstring.splitlines():
	#	print(line)
	return  ##  this stops the method cold ===========
	##=========
	counter=0
	print('starting to enter cherry on top really serious need to get it working')
	adder='';last_char=''; result = False
	for line in inputstring.splitlines():
		#print(line) #if "switch" in line and "end" not in line:
		#need test if last line is a number then don't chop it off
		
		#print("length of line=",len(line))
		#if length of this line is more than zero
		if len(line) > 0:
			last_char = line[-1]; #returns a character or number or space whatever it is 
		#ourstring = "switch(exp){ #22"
		last_char_in_line_is_number = last_char.isdigit()
		#  checks if last char in line is a number
		#############################
		if last_char_in_line_is_number == True:
			#print("last character is definitely a number")
			##########################################
			#print("last_char a number is",last_char)
			#if anumber == True:
			#print("SECOND SCENARIOthe last character is a NUMBER")
			adder += line + "\n"
			#print("last_char=",last_char)
			continue
		
    #need to ahve it check for "))"
		################if line ends with junk ==========================
		if last_char == ":" or last_char == ")" or last_char == "u" or  last_char == "#": #maybe any character
			#need to check if last 2 are )) only cut off one, otherwise
			# if it's only ) and then don't cut it off
			
			#print("FIRST SCENARIO :, ),u, #")
			adder += line[:-1] + "\n" #this deletes the last character from the line
			#print("last_char=",last_char)
			
			
		########### if line ends with a space 	
		if last_char == "": #meaning it is an empty space
			#print("THIRD SCENARIOlast char is a SPACE")
			adder += line + "\n"
			#print("last_char=",last_char)
			
			
			######## this handles if the line ends with a number
			#elif last_char.isdigit():   
			#	print("SECOND SCENARIOthe last character is a NUMBER")
			#	adder += line + "\n"
			#	print("last_char=",last_char)
		#print("counter=",counter)
		counter += 1
	###########################################################
	############################################################	
	#decided to get rid of : inside of nested_switch here
	#this fixes this bug  >>  nested_switch_11:(exp) #11:
	#print("NOW remove dots inside of nested_switch line if they exist")
	
	verycool=''	
	
	
	for line in adder.splitlines():
		#check if nested switch in this switch string
		if "nested_switch" in adder:
			#print("TRUE nested_switch in line")
		
			if "nested_switch" in line and ":" in line:
				#print("nested switch is True")
				verycool += line.replace(":","") + "\n"
			else:
				verycool += line + "\n"
			
		else:
			verycool += line + "\n"
			#print("no nested_switch in this switch string")
			pass	
	#print("FINAL OUTPUT FOR THIS STRING======>>>>>")
	#for line in verycool.splitlines():
	#	print(line)    
	#print('afterwards not working yet just trying to get last char of each line')	
	#print('resulting fixed removed garbage looks like this.....')
	
	
		#it does all lines of the string taking out the first 2 tabs which are chars
		#if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
	newstring[0]=verycool #bug was right here.	
	inputstring=''
 ################################ 
	#print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
	#for line in super.splitlines():
	#	print(line)
	#newstring[0]= super 
	#print('the final output with cleaned up garbage should be here')
	#print("outpout of cherry on top ==== attempt 1 ")
	#for line in newstring[0].splitlines():
	#	print(line)
	
#print("STARTING test 1")
#print("take care of garbage on right margine and remove : in inner nested_switch")


#remove_garbage_on_right_margine(moregarbage)
#for line in newstring[0].splitlines():
#    print(line)
#exit()    
    
#print("next one")
#print("STARTING test 2")
#remove_garbage_on_right_margine(trythisone)
#for line in newstring[0].splitlines():
#    print(line)

#print('what about this one')
#print("STARTING test 3")
#remove_garbage_on_right_margine(test_string4)
#for line in newstring[0].splitlines():
#    print(line)
#print("STARTING DONed")
#exit()











def method1(inputstring):
     return;
     concat =''
     print("==method1==")
     concat += inputstring
     concat += " fish"
     print(concat)
     return concat

def method2(output1):
     return;
     concat =''
     print("==method2==")
     concat += output1
     concat += " mice "
     print(concat)
     return concat

def method3(output2):
     return;
     concat =''
     print('==method3==')
     concat += output2
     concat += " \nrain fall heavy"
     return concat

print("above the rocket launch")


####===========================================================
def try_these_chain_methods(inputstring):
    #print("=====try_these_chain_methods=====")

    #print("looping through inputstring to see the starting state")
    #for line in inputstring.splitlines():
    #    print(line)
    ##==========    
    #print("==trying these three methods and see if it works or not==")
    output1 = manipulate_string(inputstring) #shift string to left
    #print("reached after first method called")
    #print("mOnday morning Blues testing of manipulate_string method")
    #print(newstring[0])
    
    #takes out extraneous :, ),#,u on right side AND removes : inside of nested_switch word
    remove_garbage_on_right_margine(output1) #this should work now Takes out garbage on far right
    output1 = newstring[0] #extranious #: ) empty lines have : u
    #for line in output1.splitlines():
    #    print(line)
        
    #return    #stoppinghere 
    ##=========
    start =1; finish=1;
    output2 = modified2_cut_out_inner_switch_body_leaving_switch_word(output1,start,finish,)
    #print("reached after second method called")
    ##=========
    output3 = take_out_endswitch(output2)
    #print("reached after third method called")
    #print("this is the final output string from the three chain methods",output3)
    ##=========
    #for line in output3.splitlines():
    #    print(line)
#print("serious three raptor engine test launch")        
inputstring= teststring6        
#try_these_chain_methods(inputstring)
#print("finishing calling test chain methods")
#print(" end of today's test ")
#exit()    
#starting teststring6
#take the string to test it
#shift_nest_string_to_left(string)
#manipulate_string(item) 







	


	
##=====================================
## swap_endswitch_with_curlybrace() this uses the method take_out_endswitch()
##======================================
##=presumes that quail list already filled up with seperated strings
devious_list=[]
peachtree=[]
#so this function loops thru quail list and checks if endswitch in a string in quail
def swap_endswitch_with_curlybrace(): #using testlist_of_strings
    print("=== swap_endswitch_with_curlybrace() ===========")
    print("this requires that quail list must already be filled with switch strings")
    counter=0
    #assert len(quail) > 0 #it did say quail list 
    if len(gold_list_results) > 0: #meaning there is something in quail list
        #looping thru quail list
        for item in gold_list_results:  #notice that this works by looping thru quail list and changing strings with endswitch
            if "endswitch" in item:
                print("yes endswitch is in this string")
                #it happens here TAKE OUT ENDSWITCH(ITEM)
                take_out_endswitch(item) #calling take_out_endswitch saved to holdon[0]
                #print(holdon[0])
                print("its appended to devious_list here via holdon[0]")
                devious_list.append(holdon[0])#this line just might not be working correctly need to look at it further
               # testlist_of_strings[counter] = holdon[0] #this puts it back into testlist slot
                holdon[0]=''
                counter += 1
                continue
            else:
                print("nope no endswitches")
                counter += 1
                continue
    else:
        print("testlist_of_strings list is empty so can't do swap endswitch with curylbrace")
    print("let's see if this works or not does this thing actually work")
    print('strawberrie fields are forever')
    # see if it takes endswitch out and puts } in its place
#end function



#three test in a row here of method calls 



  
testlist_of_strings=[]
testlist_of_strings.append(teststring1)
testlist_of_strings.append(teststring2)
testlist_of_strings.append(teststring3)
testlist_of_strings.append(teststring4)
testlist_of_strings.append(teststring5)
testlist_of_strings.append(teststring6)
testlist_of_strings.append(teststring7)


##======================================================
print("===== testing this using a loop =====")
print("this left shifts and indents each switch string to prepare for going thru bypass205()")
counter=0  #this shifts (indents) the whole switch string to the left with 1 tab in front of switch
print("this prints out the switch strings after left Red Shift== to one tab")
cow_hide=[]
fuel=''
##==============================================
##  starting_what_switch_strings_look_like():
##==============================================
def starting_what_switch_strings_look_like():
    return #print("starting we have...")
    #for item in testlist_of_strings:
    #    print(item)

##==============================================
##  left_shift_all_switch_strings():
##==============================================    
def left_shift_all_switch_strings(): #this goes thru testlist_of_strings
    print("now we will shift the switch to the left margine")
    counter=0
    for item in testlist_of_strings:
        print("counter =",counter)
        manipulate_string(item) #this calls manipulate_string(item) to shift the switch string to the left
        #adds change to axis put into newloop appended 
        counter += 1
#output is in gold_list_results list
#print("   ")
#print(" this is AFTER the switch strings have been seperated and put into a list")
#print(" called testlist_of_strings  ")
#print(" testing  ==left shift jazz== ")
starting_what_switch_strings_look_like()
left_shift_all_switch_strings()



print("DID IT WORK OR NOT the changes stick is it still === LEFT SHIFTED=====")

print('we are here now nov 23rd tuesday morning morgan hill.')




#for item in devious_list:
 #   print(item)
critical_list=[]
print('plum tree test') #hours spent getting this tow ork oct 17th, 2021 9;52pm
def goodtimes():
    #requires gold_list
    print("good times()")
    print("looping thru gold list results list")
    for item in gold_list_results:
        print(item)
        del several_three_tab_switches_list[:] #delete it first to erase the chalkboard
        stringname=item
        get_second_switch_numbers_check_if_many(stringname) #output here
        print("several_three_tab_switches_list=",several_three_tab_switches_list)
        print(several_three_tab_switches_list)
        why= several_three_tab_switches_list
        print("why=",why)
        print(type(why)) #gets the type of var why is.
        results=list(map(int,why)) #changing the string numbers into ints then it works
        #this adds to this list the inner switch numbers for each switch string
        print('results=',results)
        #some will have none, some will have 1, and some will have more than 1
        critical_list.append(results)
        print('critical_list=',critical_list)
        #print(peachtree)
goodtimes()    
print("end of show")    
print("resulting three tab inner switches in each of the switch strings")


def cool():
    print('==========cool function==== is this working yet====')
    for item in critical_list:
        print(item)

cool()

   
    
    

      
# ==================================================================================
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1
# =================== thursday coding ================================================

#so the formula is whatever never it starts from subtract that
#so if it starts at line number 11 at beginning of string with switch
#so if we do 31 down to 41 we subtract 11 from first number and second number
#so it's really 20 down to 31
#or I could have it start #31 in line and switch in line
#loop until same tab depth and "endswitch" in line




#######================================================================#########==========

#######================================================================#########==========
rose=[]
rose.append(0)
rose.append(0)

#######================================================================#########==========



#always do one nest. Just change the switch start and stop sooo simple


## MAIN TRIGGER FOR TESTING THIS CODE OF EXTRACTING NESTED SWITCH STRINGS 
###################################################
## #this means I need to feed in the one switch location and one endswitch location
## that need to have been already figured out



##  copy_one_nested_switch_string(m82)   <<=======     this is the main trigger for the test july 18th 
##  I will need to add another paramter to determine which nestd switch is grabbed 
def extra(): # does nothing
	print("did it work??")
	
	print("#method  get_switch_and_endswitch_locations()")
	######### just commented out line below july 19th 1:10 pm
	
	#get_switch_and_endswitch_locations(m82) # presumes only one nested switch inside param would be passed here to to pass thru this is new  method call
	######## I will need to take out this method above out of this function
	######## this currenlty only takes in the first switch by design 
	#this builds a list of switch_location and endswitch_location all of them
	# but this function conpy one nested stirng ONLY USES the first switch and first endswitch
	###################################################################
	#this gets switch_location[0] and endswitch_location[0]
	print("copy one nested switch string ()")
	print("get start of nested switch and end of nested switch")
	print("#method get_one_nested_switch_start_and_finish()()")
	#get_one_nested_switch_start_and_finish() # method call 
	#this just copies the locations of switch and endswitch into 
	
	
	
nest_string=[]	
######################################################
##  def copy_one_nested_switch_string(m82,zebra,cow)
######################################################
#this fills nest_string list with copies of the switch body strings
#and takes out front two tabs from string
def copy_one_nested_switch_string(m82,zebra,cow): #so I would add a param to determine which nest to grab july 18th 
	#print("==== copy_one_nested_switch_string() =====")
	#print("===========.................==============")
	#print("let's look at the input")
	#print(m82)   #main string name
	print(zebra) #switch    location
	print(cow)   #endswitch location
	
	#print("========COPY ONE NESTED SWITCH STRING()== called=====")
	#input_string[0]=samplestring
	counter=0		
	buildstring=''
	print("printing samplestring first")
	#print(m82)This ONLY GRABS the first position which is 0 for switch and endswitch
	#when I loop thru this in the peartree dictionary I will put the current pair into 
	#switch_location[0] and endswitch_location[0]
	######################################################
	#print("WHAT ..... is in these two lists position 0 swith and endswitch")
	#print("it sees in y",y, "well how does it look")
	####################################
	#print("passing the params for switch and endswion and endswitchlcoation")
	del switch_location[:] #these were passed as params that govern grabbing the right string
	switch_location.append(zebra)
	#print(switch_location[0])
	del endswitch_location[:] 
	endswitch_location.append(cow)
	#print(endswitch_location[0])
	#print("switch_location[0]",switch_location[0]) #10
	#print("endswitch_location[0]",endswitch_location[0]) #20
	#print("what it sees in switchlocation0 and endloaction0")
	#print("===========================================")
	# LOOP thru string
	###=================
	fridge[0]='' #empty this sucker just in case oct 5th 2021
	#print("list_of_switch_range[1]",list_of_switch_range[1]) #10
	#print("list_of_switch_range[2]",list_of_switch_range[2]) #20
	for line in m82.splitlines(): #determine if "endswitch" is in line
		#this by default starts copying the string once line greater than 2
		#this says if counter between 10 and 20 including start number and finish number		
		#############################################
		#if "switch" in line and "endswitch" not in line: #this shows just switch
		#	print("switch in this line",counter)
		#if "endswitch" in line:
		#	print("endswitch in this line",counter)
		##############################################	
		#right here if counter is between min line number and max line number
		alpha = int(switch_location[0])
		beta  = int(endswitch_location[0])   
		#this loops thru string and copies lines to buildstring
		if counter >= alpha and counter <= beta: #if counter between(within) alpha and beta:
			buildstring += line + "\n" #I need to start at the 10th line
			counter += 1	
			continue
		else:
			counter += 1 #wasn't adding to counter
			continue #really
	#print("the new creation concatted should be buildstring=")
	fridge[0]=buildstring  #here buildstring is stored in firdge[0]
	#print("what is in the fridge[0] the nested switch copied")
	#print(fridge[0]) #the copied nested string is in here  fridge[0]
	#############################################
	#newstring='';cool_string = fridge[0]
	#print("#method take_out_x_tabs_from_front_of_line()")
	#calls method take_out_x_tabs_from_front_of_line
	#it was cool_string which is now m82  was (2,cool_string)
	newstring=take_out_x_tabs_from_front_of_line(m82) #this is running #takes off 2 leading tabs
	fridge[0] = newstring
	
	#print("final outcome Tron")
	#print(fridge[0]) #this results in the nested switch string with  2 tabs taken off front of each line
	################################################
	# July 21st, 2021 4:16 pm Gilroy Starbucks
	#this copies the string just copied and put it into nest_string
	#its added to nest_string right here 
	#####################################################
	# the copied switch body string goes into fridge[0]
	# and then is added to nest_string list
	######################################################
	nest_string.append(fridge[0]) ##<<<===== right here the nested string is added to nest_string
	#this is filling nest_string with the contents of each nested string
	#then fridge[0] is added to the list nest_string
	#print("nest_string length=", len(nest_string))
	#print("line 4315 nest_string here has this in it",nest_string)
	#print("trying to loop thru nest_string to figure this out")
	#print("pumpkin pie")
	#for item in nest_string:
	#	print(item)
	#	print("==========")
	
	#need to delete teh first three tabs
	fridge[0] ='' #this empties fridge[0]
	#print('trying to empty nest string here on line 4330 see what happens ')
	#del nest_string[:] 
	#print("length of nest_string at this juncture is now",len(nest_string))
	#################################################
	#print("copy a nested string and output it") #august 5th, 2021
	#print(nest_string)
	
#print("====TESTING COPYING A NESTED STRING ======1 2 3 A  B C===....")	
#print("====STAR TREK ENTERPRISE ===....")	
#print("this is where I call the function to copy JUST ONE nested switch")
# july 18th I would need to add another paramter here like 2, for second nested switch 
#copy_one_nested_switch_string(samplestring) #reads sample string here 
#output into fridge[0]

#this should just call one nested string
# I will put the loop to go thru peartree dictionary
#and call copy_one_nested_switch_string(samplestring)
#and have it added to a list


# I will need to append it 


#this calls in order these methods
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [10,20], # I can make these now 
  "2": [28,38],
}
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========




smart_switch_numbers=[]
#the purpose of this is the switch ID number is it's initial line number
#NOTE: no spaces inbetween switch(exp){ otherwise replace doesn't work right 
#testing adding the comment and line number for switches

###=====================what I need to do =====================
# important sept 30th
# all I gotta do is make each nested switch like
# the main switch template and take out inner switch bodies
# then using the line number put in the generated method in it's place
# be sure that I add the line number as a comment I have that code
# and then make sure I get that switch line number to
# make the nested method to replace it
#####================================================================
#this one is all new and not tested september 30th musing
#testing adding the comment and line number for switches
#this is new not currently used or tested 

testcode='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''
#I am testing with this string the inner swithc is at 3 tabs, first switch at one tab.
#this was teststring6 also added 0 to end
teststring60='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


#so I will know what switch body I am dealing with so I can juggle them and manage them					
#when I get a string that I have copied I just need the switch at the top
##====================================
##  get_switch_number()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
def get_switch_number(stringname): #this might be for when
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	#for line in stringname.splitlines():
	#	print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			print("switch number is==>>>>>",y) 
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;

#skip 16 thu 38
print('this is testing october 12th to get the inner switch line number as a comment ')
weasel=get_switch_number(teststring60) #so this figures out what switch is in a list slot
print("number of this switch string(should be 66 ..",weasel) 
print("ending program here....")



	#testing here 
axis=get_second_switch_number(teststring4)
print("you can always try..")
print("should be 31 ... ",axis)
# get second switch numbers check if many
#experimental new october 14th, thursday, 8:06pm 


print("get second MASH switch number (the comment number after teh inner switch")
print("testing to see if it correctly retrieves the number 66 in the nested switch")
weasel=get_second_switch_number(teststring60)
print("should return 66")
print("weaseL=",weasel)		


weasel=get_second_switch_number(teststring3)
print("should return 23")
print("weaseL=",weasel)		

weasel=get_second_switch_number(teststring2)
print("should return 15")
print("weaseL=",weasel)		



			
#keep line #15 del til = #38
################# creation of loopstring list to hold string that will hold the nested switch string

loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
#loopstring[0]=waffles #was red_robin #   what it was previously ==samplestring #see if this works  #this is the mai nested string
print('big test here ')
print("loopstring[0]=",loopstring)
doves=[]
'''
#########################################
## loop thru pears dictionary
## and calls copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])
## to copy one nested switch at a time
    #it might just have to go thru once to fill pears
    # going thru a dictionary I need to designate which pair 
   
    ##########################################
    ## this loops thru the dictionary pears
    ##########################################
    print("about to loop thru pear values")
    #looping through dictionary pears 
      #say_something(cool) #this way the switch and endswitch locations are passed into the function
        ##########################################################
        ## this calls COPY ONE NESTED SWITCH STRING()
        ##########################################################
        print("about to start copy_one_nested_switch_string()")
'''






#https://www.youtube.com/watch?v=qtpxiNvGCp4
#########################################
##   copy_one_nested_switch_case_body()
#########################################
def copy_one_nested_switch_case_body(): #uses pears.values()
    print("======copy one nested switch case body () ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    counter = 1
    #using blueberries dictionary and not pears 
    #just changed this oct 6th wednesday 10am 2021 morgan hill starbucks
    
    # pears is a dictionary with values of start switch and end switch
    ## LOOP ######## this loops thru pears dictionary
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        #print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #great where does this copy of the string put into??
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
   
        

###=== this goes thru pears dictionary  and copies the nested switch strings
print("=== GODZILLA Time  ===")
#uses pears dictionary
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently
}
'''

print("here we go ... copy_one_nested_switch_case_body_blueberries():")
##====================================================
## copy_one_nested_switch_case_body_blueberries()
##================================================
#########################################
#this is using the string red_robin for testing purposes. 
  # pears is a dictionary with values of start switch and end switch
    #this goes thru the blueberries dictionary set of switch end switch pairs ===========
    ##===================================================================================
    ## LOOP ######## this loops thru pears dictionary
    #del nest_string[:] #empty this list
    #this is the blueberry dictionary 
    #it loops thru blueberries to copy a string
    #looping thru blueberries dictionary here 
    


    
loopstring[0]=waffles #red_robin #testing on oct 5th Tuesday
def copy_one_nested_switch_case_body_blueberries(): #uses pears.values()
    print("======copy_one_nested_switch_case_body_blueberries() ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    print("I think that at this point nest_string whould be empty")
    print("len(nest_string=",len(nest_string))
    #nest_string=[] #this reinitializes it 
    counter = 1
  
    #right here nov 6 2021 saturday change this to the list of sublists (time to ditch the dictionary
    print("showing contents of blueberries dictionary values the strings here.")
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #this copied string is added to nest_string list
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
##=============oct 5th musing how to maket his puppy work 
#I need to have switch numbers by line number
# associated with it's pair start stop
#===================   
print("testing blueberries dictionary list to get the string bodies printed out")
####################
#print("NEST_STRING line TAHOE CABIN Bears ione 4651 what is in nest_string at this point")
#print(nest_string)
counter =1  #so the nest_string would have the switch body strings in it
for item in nest_string:  #going thru nest_string of inputs I think
    print("counter=",counter)
    print(item)
    print("end of this switch string body")
    counter += 1
    print("======....=====")
    
    
del nest_string[:] #new just now putting this hear






#this is the resulting output of copying the string embedded in the main switch

holdthis=[]
holdthis.append(0) #creates the space to store it


teststring_brace='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''

#this swaps endswitch with }
# I need to count the "}" in the string, there should only be one, actually none
# if there is one it needs to be in the right place.
# I will have to loop thru the list to look if there is a brace in it already.
######################################
## take_out_endswitch(stringname)  #replaces endswitch with }
######################################
list_of_line_numbers_of_endswitches=[]
holdthis=[]
holdthis.append(0)
#the issue is that I need it to only do the bottom one 
def take_out_endswitch(stringname):
	#print("==========take_out_endswitch()and put brace in called=======")
	x='';x=stringname.count("endswitch") #should be 1
	#print(x)
	counter = 0
	for line in stringname.splitlines():
		if "endswitch" in line:
			list_of_line_numbers_of_endswitches.append(counter)
			counter += 1
			continue
		else:
			counter +=1
		continue
	#print("list of line number of endswitches=",list_of_line_numbers_of_endswitches)
	coffee =list_of_line_numbers_of_endswitches[-1] #last one
	#print("the last endswitch =",coffee)
	#print(stringname) #this takes out endswitch and replaces it with }
	stringname=stringname.replace("endswitch","}")
	#for line in stringname.splitlines():
	#	print(line)
	holdthis[0] = stringname#now galaxy gets what is in holdthis[0]
	#print(holdthis[0])#return stringname #and this is returned
	
#print("testing take out endswitch from string and replace it with a } ")
#take_out_endswitch(teststring_brace)
#outpout to holdthis[0]
#for line in holdthis[0].splitlines():#
#	print(line)
	



###===================================================
##   show_list_of_nested_strings_separated()
###===================================================
## july 21st 2021 349pm gilroy starbucks
#oct 5th this is a list of thes copied switch ends witch stings in nest_string
###=== this shows the nest_string list of nested switches
#this just loops thru nest_string which has the seperated nested strings
def show_list_of_nested_strings_separated():
    print("======show list of nested strings separated=====")
    print(" == StayPuff Marshmellow Man ==")
    counter=1
    for item in nest_string: #this has the nest strings in it ALREADY nov 6, 2021
        print("counter=",counter)
        print(item)
        counter += 1
    print('end of first simple test ')   
    #===========================    
    counter =0
    print("loops thru nest_string that we filled up in copy_one_nested_switch_string(m82,zebra,cow)")
    #this requires nest_string which is looped thru
    print("length of nest_string=",len(nest_string))
 
                
  
    #print(da)
    mycounter =1
    nest_string_size= len(nest_string)
    print("length of blueberries =",len(blueberries))
    ###############
    #this makes sure that the nest_string is equal in size to blueberries
    # to counter a bug of overflow junk that I will figure out later
    # oct 5, 2021
    print("blueberries",blueberries)
    print("")
    #this deletes excess data that is appended to nest_string inexplicably
    #this simple fix was solved on oct 5th tuesday at 11:30pm 2021=======
    #temporary getting excess from nest_string
    #so 
    while len(nest_string) > len(blueberries):
        del nest_string[-1] #last element in list is deleted
    print("all done")
    print("length of nest_string=", len(nest_string))
    print("yes finally works NASA is born")
    #get length of blueberries
    #then reduce size of nest_string to that number (figure it out later) weird bug
    print("nest_string size = ",len(nest_string))
    for item in nest_string:  #nest_string
            da = blueberries.get(str(mycounter))#gets string at this position
            print("getting data in blueberries",da)
            print("counter=",mycounter)
            print(item)
            mycounter += 1
            
            print("==========-----------seperated nest strings -----------------")
    print("==========")
    #now delete extra slots in nest_string
    




####===========================================================###
####===========================================================###
####===========================================================###
print("july 22nd 2021 additions...====")
###============== this is working correctly now ==========
## more_testing()
##========================================================================

#sprint("checking number of nested switches at three tabs")
#stringname=testingstring1
#get_second_switch_numbers_check_if_many(stringname)


######################
##  more_testing()
######################
def more_testing():
    #print("=== more_testing() == charisma ===method testing ")
    #this is adding samplestring with main to nest_string[2] to see what it will look like when working
    #print("let's see what is already in nest_string ===> SpaceX pretest ")
    #print("to see what is in nest_string")
    #for item in nest_string:
    #    print(item)
    #print("so slow 3 which is nest_string[2] has the main string in it")
    #let'see how it looks"
    #print("==== after simple test of contents of nest_string")
    #print("========")
    #print("here we replace it with what will be after I modify it. this is dummy data testing")
    #print("finished main string with nested methods added put into nest_string[2]")
    nest_string[2] = samplestring_main # the third one - putting in a different string premade
    #this is what is different right here in the line above
    
    #testing what the stages need to look like
    #to test what it should look like but doesn't yet
    #print(" now we will try it again and see how it looks ")
    #print(" after changing main string boo boo ")
    #loop thru nest_string
    #for item in nest_string:
    #    print(item)
    #    print("===========///======oct 5 tuesday 2021 testing  ========")
        
        
###==================================== oct 5 thinking how to do this. 
#for each switch number I need to know what ranges of it's inner switches are
#I need the range of the inner switch numbers start and stop
#so inner switch ranges for switches by switch line number

#more_testing()

####===========================================================###
####===========================================================###
####===========================================================###


### this works this takes the copied nested switch
### and sets the proper indentation for it
#so it takes out 2 really but we have to say 3
## july 17th 10:12am 2021 starbucks

#the eye opening= make a list of the methods sequence
#tuesday, August 10th, 2021 ====,,,,,,,,,,,==========




loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
loopstring[0]=samplestring #see if this works  #this is the mai nested string
print('big test here ')
print("loopstring[0]=",loopstring)
doves=[]
copy_one_nested_switch_case_body() # this calls the loop

print("pears dictionary",pears)
print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
print("pears now",pears)

#show_list_of_nested_strings_separated()
#show_list_of_nested_strings_separate()


###==========================================================

#def tab_swap(x,y):
#    replace(x,y)

########==============
#wilderness=
#def set_front_tabs(x):
#    wildness=''
#    for line in nest_string.splitlines():
#        wildness += line.tab_swap(3,1) #strips one right
#        wildness += "\n"
#    print("after minor surgery see if this works")
 #   print(wildness)






# copy line by line stripping all tabs
# and then based on if starts wwith swtich 1 tab
# if case 2 tabs
# if not switch and not case three tabs
# if endswitch one tab
# if default two tabs


#unless I make a new string _so I want to remove teh first 2 tabs only
alpha_string=''
str1=''
#for line in nest_string.splitlines(): 
#    #put line into list, del first three tabs then conver to string
#   aline = line.split() 
#    print(aline) 
#    str1 += str1.join(aline) + "\n"
#    #print(str1)
#    
#print("string now is...")
#for item in str1:
#    print(item)


 



#########################################==============
## === skipping_some_lines() ========   July 5th, 2021 ===============
#########################################
#this works for one nested switch right now
#this goes thru a nested switch and takes out the nested single switch.

### solution found for dealing with deeply nested switches
#I think that I can use this if I take out the innermost switch
## first and then it should work  
# so the plan of attack is to change(yes change) the inner most
# depth switch first
#and work back to the next level till I am at the first level of depth.


#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========

skip_range=[]
#skip_range.append(0);   
#skip_range.append(0) 
#july 5th, 2021
#so I still need to get the start and finish lines  switch and endswitch for input 
del ibm[:] #empties it
#print(ibm[0])
ibm.append(samplestring) #so in  ibm[0] this is putting samplestring into ibm[0]
#print(ibm[0])
#===================print testing on july 24th saturday  2021 at 9:36am =================
#print("at this point we have this in ibm[0] after taking out the first nested switch")
#del skip_range[:]
#print("LOOP TEST THRU RANGE LIST Goofy dog")
range_list=[]
skip_range.append(0) #slot [0]
skip_range.append(0) #slot[1]


#string,start,finish
#first it will just detect one nested switch , soon it will detect many

#this loops thru a string and makes a copy of the string
# but skips over a range example lines 10 thru 20
toosmart=[]
toosmart.append(0)
flag_test=[]
flag_test.append(False) #flag_test[0] set to False right here 
baton=[] #this is used to hold the concatted string that is changed on each pass 
baton.append(0)
baton[0]= "nada" #to start with to test this monstrocity


rose=[]
rose.append(9)  #testing purposes 
rose.append(19)
test_code_now='''
					switch(exp){ 
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){   #9 
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch  #19
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''








#this is testing with dummy data above in test_code_now
#taking out the inner switch body
#print("halloween is coming snoopy and woodstock test")

#print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1

#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
#print("===========rose test==== testing taking out inner switch body ===")
#the pair would go here 
input1 = rose[0]
input2 = rose[1]
#print(input1)
#print(input2)
#print("take out 10 thru 20")
x = test_code_now
start = rose[0]+1 #10 #TO PRESERVE INNER SWITCH TO REMAIN THERE
finish= rose[1]+1 #20 #TO GO ONE BEYOND ENDSWITCH WORD
#skipping_some_lines(x,start,finish)
#print(toosmart[0])
#print("=====end end end of show end of this dumb test==testing rose flowers ===")
# october 1st this will have to be a prescan first pass to get the locations 
# this will look for an inner switch after first line and get it's line number
# and find it's 'endswitch' or '}'
# and put the switch line number and endswitch line number into a pair
# and then append it and keep going and that way it figures out the location on it's own
coffee_switches=[]
end_coffee_switches=[]

combinedlist=[]
switchtabs=[]
endswitchtabs=[]

#this is not working right 
### mr coffee smart skipping lines 
## mr_coffee_smart_find_innerswitches bodies and skip them except for inner switch word


##======================================================
##  mr_coffee_smart_skipping_lines(inputstring):
##======================================================
def mr_coffee_smart_skipping_lines(inputstring):
	#print("======= mr coffee smart skipping lines ..this =======")
	#print(" makes pairs to find locations of switches and endswitches.")
	#print(inputstring)
	counter =0
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			tabdepth= line.count("\t")
			coffee_switches.append(counter)
			switchtabs.append(tabdepth)
			
			counter += 1
		else:
			
			counter += 1
	del coffee_switches[0] #deletes the first switch which is at the top 
	###=================================
	count =0
	#this looks for endswitch locations
	for line in inputstring.splitlines():
		if "endswitch" in line or "}"  in line:
			tabdepth= line.count("\t")
			end_coffee_switches.append(counter)
			endswitchtabs.append(tabdepth)
			counter += 1
		else:
			counter += 1
	#=====================================
	counter =0
	for item in coffee_switches:
		combinedlist.append("[" + str(coffee_switches[counter]) + "," + str(end_coffee_switches[counter]) + "]")
		counter += 1

	#print("zzzz the result list =",combinedlist)
	#print("switch tabs=",switchtabs)
	#print("endswitchtabs =",endswitchtabs)
	

#print("testing this using string red_robin to see if it works")
#print("this is only returning the range list of the switch endswitch pairs")	
#print("GO GO GO what that dog go")
#mr_coffee_smart_skipping_lines(red_robin2)
## it's chopping off this from the bottom
'''
fallthru
		
		default:
			print('the end')
}
'''
#print("TESTING SKIPPING LINES 16 THRU 38 IN RED ROBIN")
#print("testing skipping nested switch in red robin")
#print("today is thursday sept 30th...")
#print("testing...... sept 30 skipping 16 thru 38")

#So loop thru string and 
#get line number with # and 15 put into start
#and get line number with
 # and #38 and put into finish
'''
print("watching videos of starship. video time...")
print('length of nest_string',len(nest_string))
print("nest_string[1]) see if it works..") 
print(nest_string[0])
print("===============")
print(nest_string[1])
print("===============")
print(nest_string[2])
print("===============")
print(nest_string[3])
print("===============")
print(nest_string[4])
print("===============")
#print(nest_string[5])
#print("===============")
'''




#range_list=[[10,20],28,38]]  #that's right I do this backwards from bottom up!!!

'''
this goes thru the main switch string and makes a copy
of the main string in stages copying the whole thing
except for the range for each nested switch.
'''
## this means delete nested switches bodies except leave inner switch word only
##===================================================
#  REDUCE MAIN NESTED SWITCHES TO JUST SWITCH WORD
# debugged on august 5th 2021 gilroy starbucks
##===================================================
## this makes teh final main switch with the inner switch bodies stripped out
## just leaving the switch word where the nested switch was.
#range_list.append([10,20]) #these are added in order and then reversed
 # so that the nested switches are erased bottom up
addthis=[]
addthis.append([10,20])
addthis.append([28,38])
##========================
## add_to_range_list()
##========================
def add_to_range_list(): #uses addthis list 
    print("add_to_range_list() this is necessary to work")
    for item in addthis:
        range_list.append(item) #adding to range list
        
    #print("length of range list =",len(range_list))
 
 
 
 #i will need to add data to range list still 
##======================
##  feed_range_list()
##======================
def feed_range_list():
    print("=========feed_range_list() called=====>>>")
    print("=========feed_range_list() called=====>>>")
    range_list.append([11,24]) 
    range_list.append([26,38])
    print('range_list=',range_list)
    #the list has to be REVERSED to do the changes bottom up so the line numbers work correctly
    range_list.reverse()#reverses it NOTICE WE REVERS THE LIST TO CHANGE IT BOTTOM UP
    #this is so the bottom is done first 
    print("length of range list =",len(range_list))


    
#Yes I am reversing the range_list to do the changes bottom up so they don't lose their place
print('printing the range_list')
print(range_list) #should be [28,38],[10,20] to do from the bottom up

#this takes out the inner switches except for the switch word
#so what this means is it removes the body of the nested switch but leaves just switch word.
### this uses range_list!!!!!!!!!!!!!!!!!
#between 11 and 47
#if first switch detected keep going so use switch counter
#it needs to only include the switch word of tab depth 3 switches
#before doing any changes it looks like this 
REAL_STRING='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep  (( 5 tabs ))depth 3 detector       Level 2    
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################==== this one should be deleted 
			switch(exp){ #23  #third level deep  (( 7 tabs ))   Level 3    =====
				case 'tahoe':=========
			print("do something")=======
			print("yep")
			fallthru
				case 'fallen leaf lake':
			print("nice")
			break
				default:
			print("we are done here")
			endswitch #33
			#############
			break
		default:
			print("we are done here")
			endswitch #38==========
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #47
			exp = 3  #note that this switch is stacked below the bottom stack at 3 tabs
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''
'''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep          Level 2    
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					break
				default:
					print("we are done here")
			} #38
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	
#after changes it should look like this after getting rid of inner switch body one indentation

#this is what the end result should be
endresultshouldbe='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			switch(exp){ # 15  #second level deep          Level 2    
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	

#I think that I need to go thru tab length3 first 
#then go thru tab length 5 
#then go thru tab length 7
#this is the input for the reduce_main_nested_switches_to_just_switch_word(

oldschool='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown nn')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					#################### del after line with '#' and  '15' in it till 38 in it
					switch(exp){ #15
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			exp = 3  
			switch(exp){ #26
				case 'burger':
					print("do something")
					####################
					switch(exp){ #30
					print("gosh")
					fallthru
				case 'porsche':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
} #51
'''
#the output should be
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #====
			exp = 3  
			switch(exp){ #====
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''


starbucks_code_main_test ='''
	switch(exp) { #main 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown 8888')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					break
				case 'please work':
					print('nice')
					fallthru
			endswitch	 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#The change that I need to make here is to cut out switches greater than 3 tabs  tabdepth > 3
##======================================================
##   reduce_main_nested_switches_to_just_switch_word():  #I think that this does all switches no matter their depth
##=======================================================
def reduce_main_nested_switches_to_just_switch_word(astring): #11 - 23 and 25-37
    print("starting this method to see what is in the string")
    #for line in astring.splitlines():
    #    print(line)
    print("===reduce_main_nested_switches_to_just_switch_word()== Tron approaches")
    print("C3Po")
    print("=====reduce_main_nested_switches_to_just_switch_word()====0000000000000==>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("what is in astring the input param")
    print(astring)
    print("end of the input string to see what is going into the function")
    print("reduce main nested switches to just switch word()")
    
    #feeding range list()
    #add_to_range_list() #this is new to put switch and endswitch lines into range_list
    feed_range_list() #added on wednesday, September 15th, 2021
    flag_test[0]== False #this flag is new this is the default setting for this flag
    print("flag_test[0]=",flag_test[0])
    #when flag_test[0] = True that means it's doing 2nd and subsequent loops (changes) and use baton[0] for concatting string
    #print("==reduce_main_nested_switches_to_just_switch_word(astring)==")
    #print("= R2D2 ==## $$ ## == reduce main nested switches to just switch word()==========")
    #print("this cuts out the nested switches bodies leaving just the word switch")
    #print("starting ibm[0] with samplestring")
    #print("what we are starting with for input in ibm[0]")
    #print(ibm[0])  #the key is the range_list
    #print('range_list=',range_list)  ### this is the dependency the range_list necessary for this to work
    #loop thru range_list
    #print("we loop thru the range_list here")
    #print("let's see what RADAR is in the range_list",range_list) #see if it's reversed or not
    #loops thru range_list with pairs of switch end and endswitch
    #print("length of range_list of pairs=",len(range_list))
    #print("range_list=",range_list)
    counter=0
    # loop thru range_list
    #print("before starting let's look into the range_list",range_list)
    #print("============")
    #print("perhaps I need to go thru the 7th tab first, then 5th tab, then 3rd tab")
    #print("thinking outloud how to do this.")
    #print("range_list=",range_list) #just added this sept 30 2021 testing cafe borrone
    
    for item in range_list: ##range_list=[[10,20],28,38]] ==========================
        #print("**",item, item[0],item[1])
        #print("inside of loop thru range_list :: COUNTER HERE=",counter)
        skip_range[0]= item[0]; 
        skip_range[1]= item[1]
        #item[0]='',item[1]=''
       # print(item[0],item[1])
        print("skip_range=",skip_range)
        #this builds a new string by skipping the nested switch sections
        #but leaves the inner switch (switch(x) word intact
        # skipping_some_lines() called here 
        # ibm[0] has the samplestring in it from above
        toosmart[0]=astring #this might work
        #this is called before skipping some lines
        #the problem is that on the secondpass it's not taking in the changed toosmart[0]
        #====================================
        #SKIPPING SOME LINES()===============
        #====================================
        #this is governed by flag_test[0] which is set to default False above the loop
        skipping_some_lines(astring,skip_range[0],skip_range[1]) #this makes a new string skipping guts of inner switch
        counter += 1
        
        #skip_range[0]='';skip_range[1] ='' #just added this to see if it helps
        #del skip_range[:] #this clear it out afterwords to wipe the slate clean
    #print("this is the final output of the transformation halloween approaches")
   #print("output of = R2D2 == taking inner nested switches body out and putting just keeping swithc word")
   # print("the star destroyer was moving fast")
    #print("should be only two nested switches and only switch word remaining NOT 3")
   # print("end of this picture show")
    #print(ibm[0]) #this prints out the result 
   # print("=====================")
##======================================================

#here we go  
#print("the goofy dog test")  
#print('we start with this string')

#print(ibm[0])
#print("OLYMPICS BLAZING... gold medal time")
#print("=====calling reduce main nested switches to just switch word(========)")
#print("HERE NOW...this should be the sample string with the nested switches")
#print(" cut out leaving just switch word")
#print("we are ==== STARTING ==== with this dam string legal eagle")
#bypass here on thursday sept 30 testing at cafe borrone
#print("September 30th testing at cafe borrone")
#ibm[0] = red_robin
#print(ibm[0])
#inputnowstring= ibm[0]
#print("starting input before doing changes")
#print(inputnowstring)
#print("about to reduce main nested swithces to just switch word which work previously without incident")
#print("line numbe 4162")
#print(" FIRE BREATHING DRAGON NOW ")
#flag_test[0]== False #see if this works 
# I am right here today  LOOK RIGHT HERE OCTOBER 1ST 2021 
## this is the key method here ====

#reduce_main_nested_switches_to_just_switch_word(oldschool) # I didn't notice this way down here
#print("red alert test 2 reduce main nestd swith to switch word test 2 ...")


#print("good times saturday night live test ")
#del range_list[:]
#reduce_main_nested_switches_to_just_switch_word(starbucks_code_main_test)
#print("look above frosty snowman here")
#print("output from taking out nested switches in string inputnowstring")
#print("output of removing both nested switches")
#print("RIGHT HERE ====== OCTOBEr 1st what does this look like below this line")
#print(ibm[0])
#print("does it loop thru two times for that is how many times it should")
#print("==============")
#exit()



#exit()  






#print(ibm[0])
#print(" starting anew here doing it the old way")
#ibm.append(samplestring) #in ibm[0]
#print(ibm[0])
#print("that's all lemon tree software ==")
#print("about to exit the program after seeing the nested switches taken out of main string")
#exit()
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/ ghostly  /=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
#print("this is the SECOND ATTEMPT")
#skip_range.append(0)
#skip_range.append(0)
#print("does this work yet") #these are farther down  so I needto do them first 
#skip_range[0] =11
#skip_range[1] =24
#print("=============")
#print("skip_range=",skip_range)
#print("=============")
#print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
#print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
#print("what string is in ibm[0]=",ibm[0])
#ibm[0]=oldschool
#for line in ibm[0].splitlines():
#    print(line)
#skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 28,38 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
#print("now swap out the top inner switch hopefully")
#print("ibm[0]=",ibm[0])
#skip_range[0] =10
#skip_range[1] =20
#print("=============")
#print("skip_range=",skip_range)
#print("=============")

#skipping_some_lines(ibm[0],skip_range[0],skip_range[1])

#exit()

'''
skip_range[0] =10
skip_range[1] =20
print("=============")
print("skip_range=",skip_range)
print("=============")
skipping_some_lines(ibm[0],skip_range[0],skip_range[1]) 
'''

#print(ibm[0])
#fuse=[]
#fuse.append(0)

#del skip_range[:]

#skip_range.append(10)
#skip_range.append(20)

#I guess I can put the ranges into a list and then reverse it and 
#loop thru it.
print('at this juncture what is in ibm[0]')
print(ibm[0])
print("starting out we have this before stripping out the nested switches")
#ibm[0] = fuse[0] #to preserve changes made 
print("input values on 2nd pass =")
skip_range[0] =10
skip_range[1] =20
#print(ibm[0])
#print(skip_range[0])
#print(skip_range[1])
#print("========")
#print("skip_range=",skip_range)
#print("=========")

#print('==== make it dam happen == ')
#skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 10,20 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
#print(ibm[0])
#print(" where is it now lemonade stand ???")
del skip_range[:] #this has to be cleared out. 
#skip range needs to be cleared out for the next nest parameters here
##===============================
#print("==== the end===both nested switches should only have the switch word reminaing ===")



#print("===end of copying a string and skipping lines 10 thru 20===")   
#print("in ibm[0] we have",ibm[0])
#print("===== this is after running skipping_some_lines(smaplestring,10,20)")
#print("===========")

smart_number=[]
smart_number.append('starter')
smart_number.append(0)
smart_number.append(0)
smart_number[1] = '1'
smart_number[2] = '2'
#switch is on line 10 need to change it this is looking for the switch

#this is changing ALL OCCURENCES of switch at the 
#same time just just the one I want it to change.
# I need to localize is it to one line number.

#have it change one and then break starting on the line above


#The problem I have is if I replace each switch with the nested numbers
#then the other code won't work so perhaps I need to add a comment
#the issue is making the main strings which should only have the first level inner switches
#which is governed by tab depth of 5 representing the second level
# since tab level 3 is the first main switch.
# I could do number 1 thru n for each level initally and then change them
# or I came up with the number top down 1 thru n but level list solves the problem 
#That was my genius

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#in terms of faster programming it's about communication and control
# the lollipop is the what level but above that are higher abstraction levels
# where yet more speed can be achieved and sustained
##$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========
#I think I will do the one nest level for now and add the other nest levels afterwords
#decision made august 22nd, 2021 9:08 am

# I have the main module which has nested methods
# I can use this for making nested switches with nested switch methods too
# but right now I want to get the nested feature working before implimenting it
#######3==================================
#Actually I can do the main and the nested that have inner switch words not changed yet
#And then apply the conversion to numbered switches
##=====================
''' from above just pasted it here to keep track of its contents
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,86], # I can make these now 
  "2": [11,47],
  "3": [15,38],
  "4": [23,33],
  "5": [49,73],
  "6": [53,64]
 #no comma after last data piece apparently
}
'''

danumber=''

#testing this here to make sure that it's right 
ibm[0] = '' #this should delete it
print("ibm length=",len(ibm))
stringname =teststring60
#print('starting stage of string to manipulate')
#for line in teststring60.splitlines():
#    print(line)
#danumber= 66

#print("star wars begins now.")
##============================================
# swap_switch_for_nest_method_new(danumber)
#// inner switch(just the words) is swapped for nested method number")
#=============================================
#for this to work correctly I need to ahve already taken out the inner switch bodies that I copied
#print("about to do OPTIMUS PRIME === GO BABY GO ===")
def swap_switch_for_nest_method_new(stringname,danumber): # I will add more values later perhaps 3 or 4 for coordinates
	#print("#### ========= swap switch for nest method new  ========####")
	#print(" =======OPTIMUS Prime======")
	global abovenestedswitch
	#stringname=ibm[0]
	#stringname=ibm[0] #loading from ibm[0] good
	#print("called swap_switch_for_nest_method(n)")
	print("it is using this number in use_number[0]",use_number[0])
	acounter=0
	for line in stringname.splitlines(): #determine if "endswitch" is in line
		tabdepth = line.count("\t")
		print("the current tab depth in THIS line is",tabdepth)
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 check to make sure that switch and the comment line number in this line
		#this way it can ONLY make changes to switches at tab depth 3
		if tabdepth == 3: #this way it can ONLY access changing the string at 3 depth once
			#this way only if the tab depth is 3 can it manipulate the string
			if  "switch" in line and str(danumber) in line: #line with switch in it  
				#print(line)  #doing counter > 1 so it doesn't do the first line
				#this is where the string is changed
				stringname = stringname.replace("switch(exp){","nested_switch_" +str(danumber)  + "(n)")
				break
			else:
				acounter += 1
				continue
		else:
			acounter += 1
			continue
			
	print("the final outcome of the chagne is here:")
	#for line in stringname.splitlines():
	#	print(line)
	

# this takes in what is in ibm[0] and the outputs it to ibm[0] also, quite clever.   
print("let the judge state this is truth") 
#number_to_add=66 
#swap_switch_for_nest_method_new(teststring60,number_to_add) 
#ibm[0] = stringname
#print(ibm[0]) 

#where is th eone that grabs teh number automatically though

da='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
        
'''

data1='''
	switch(exp){ # 15
		case "1":
			print('hi')
			#isn't this special
			print('is this happening')
			print("what do we have here")
			break
'''

data2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

#the innerswitch must be at 3 tabs and the first top switch must be at 1 tab.
data3='''
	switch(exp) #62
		case 'burger':
			print("do something")
			####################
			switch(exp) #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


jazz6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #63  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #89  
			#############
			break
		case 'what':
			print("nice")
			####################
			switch(exp){ #455  
			#############
			break
			
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

jazz7='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
#replace_the_last_endswitch_with_brace
#print("I found the code I need - I think - we shall see - if it is the right code indeed")

#print("about to do thorough testing of chnage_switch_to_method_solved()")
#solved october 29th, 2021  NEXT get the number after comment just in time
'''
this builds a string called newstring replacing switches
at 3 tabs depth with nested_switch
with the comment id after # tacked onto
 the end of the nested_switch_22(exp) like so.
'''

   ##################################################            
       # if "}" in inputstring:  #have to cut "}" out of string      
       #     print("CONFIRMED there is a right brace in string")
       #     for line in templine.splitlines():
       #         if "}" in line:
       #             
       #              templine2 += line.replace("}","")
       #              templine2  +="\n" 
       #        else:
       #             templine2 += line +"\n"
       #    inputstring = templine2
       #     print("======testing if } taken out of string======")
       #    for line in inputstring.splitlines():
       #        print(line)
       #     print("======testing if } taken out of string======")
         #end if   
       # do nothing
       ######================================
       
''' ##################################################            
        if "}" in inputstring:  #have to cut "}" out of string      
            print("CONFIRMED there is a right brace in string")
            for line in templine.splitlines():
                if "}" in line:
                     templine2 += line.replace("}","") #this is where I was taking } out
                     templine2  +="\n"
                else:
                     templine2 += line +"\n"
            inputstring = templine2
            print("======testing if } taken out of string======")
            for line in inputstring.splitlines():
               print(line)
            print("======testing if } taken out of string======")
         #end if 
'''
        ########################################


innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    #print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
   # print('this now takes out the { brace after switch if it is there')
    innerswitch=''
    #print("this is what it sees when it starts change_switch_to_method_solved()")
    #for line in inputstring.splitlines():
    #    print(line)
    #print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        pass
        #print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    #print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
        #print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
       #check if } in this string an if so take it out
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
                #print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            pass
            #print("=====no { in string  ======")
            #end if
        #print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
        #check if } in this string an if so take it out #I have deactivated this since it's not needed
        
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
print("where is my mocha brainfreeze test october 30th...")



'''
print("==========testing string da===================")
print("=============================")
inputstring=''
inputstring = da         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
print("end of red alert change switch to method solved end of test 5..")    
print("=============================")
print("======= testing string data1======================")
''' 
print("testing goldfish which is NOT indented yet")
#testing a second method in chain right now for expiermentinting==
#the input string MUST BE indented and look like this LOOK LIKE THIS 
somedata2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''


gofigureit='''
	switch(exp){ #77
		case 'burger':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is chnaged to brace later
'''



#just check if switch at 3 tabs to determine if nested switch
#monday dec 6th thinking 
####$#$$##############========================


            

    

##==================




###================== cold brew linus and snoopy ================== saturday morning software  november 20th, 2021 ====
#this is testing adding the nested switch 
linus_and_snoopy=[]
##==================================
##   add_nested_switch_methods():
##==================================
def add_nested_switch_methods():
    print("add nested_switch_methods() in catching_first_change list")
    for item in catching_first_change: #<== list with strings after taking out inner switch bodies
        #print(item)
        #here calling method chaning_switch_to_method_solved swaps switch for nested_method_numbered
        fizz =change_switch_to_method_solved(item)#this is applying the method to add nested_switch method
        print("===== oh yeah =====")
        linus_and_snoopy.append(fizz) #this is adding the changed string to linus_and_snoopy list
        
        #for line in fizz.splitlines():
        #    print(line)



##================================================
##print_out_result_of_adding_nested_switch() to each switch string:
##================================================
def print_out_result_of_adding_nested_switch():
    counter =1
    #print('we made it to the top of the Donnor Summit ')
    #for item in linus_and_snoopy:
        #print("counter=",counter)
        #for line in item.splitlines():
        #    print(line)
       # counter +=1



#test with one string and do piping

#cut_out_inner_switch_body_leaving_switch_word(teststring)
##===========================================================================
##  cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
#    print('this one is sooo critical')
#    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
#    skipping_some_lines(stringname,start,finish)
#    #this means that the output string should be placed into never_defeated[0]
#    for line in never_defeated[0].splitlines():
#        print(line)

inputlist=[]
inputlist.append(0)
outputlist=[]
outputlist.append(0)
         
#put x in front so it's not used
#it must be indented properly to work daaaaa
xskitahoe ='''
		switch(exp){   #1 === line 10 beginning of single nested switch ======      
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				switch(exp) #7
					case 'funny':
						print('fun')
					case "da":
						print('yeah')
					default:
						print('bye')
				endswitch #14
				print("nicely")
				break
			default:
				print("we are done here")
		endswitch #this is key here =============line 20 end of nested switch ====
'''	


#testing 
print("testing printing out joy string")
joy='''
	switch(exp) #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp) #23
			#############
			break
		default:
			print("we are done here")
	endswitch #38
'''

hotmocha='''
	switch(exp) #3
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #11
			exp = 32
			switch(exp){ #62
			#############
			break
		default:
			print("we are done here")
	endswitch #86
'''
'''
for line in joy.splitlines():
    print(line)
'''


#testing doing 2 methods back to back piping output from first to input to second
#first method   
###==================
##  do_the_pipe()
###==================    
def do_the_pipe():
    print("do the pipe() called pipe pipe PIPE PIPE PIPE")
    print("outputlist[0]=",outputlist[0])
    inputlist[0] = outputlist[0]
    print("now put it into inputlist[0]")
    print("inputlist[0]=",inputlist[0])
    
    

#print('doing some pipe testing today')

#######################################
#######################################
#######################################
###====== saturday morning codeing ==november 20th, 2021 testing this puppy ====
## SHIFT NEST STRING TO LEFT INDENT THE PUPPY
#print("this is doing shift nest string to left() ======")
#print("=====================================================")


################################################
#################################################
##  CUT OUT INNER SWITCH BODY LEAVING SWITH WORD
#this one does not work (november 28th this is the hold one)so don't worrya bout it it works elsewhere got it working
# skipping rope yesterday.

'''
cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
outputstring=string_after_cutting_out_inner_switch_body[0]
print('after stage 1 first method call in chain we have this result')
for line in outputstring.splitlines():
    print(line)
print("end of first change to string")
outputlist[0] = outputstring
print("right here this is  after taking out th einner switch body")
'''
#MUST INDENT LEFT 
#do_the_pipe()
#print("do the pipe() called")
#item = inputlist[0]




#exit()


#playing with this
makeitso= '''
switch(exp) #62
		case 'burger':
			print("do something")
			####################
			nested_switch_66(exp) #66
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #86   
'''

newattempt='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
'''

##============================================
## get_top_switch_number_from_this_string(x)
##============================================
twinlist=[]
#testing with string directly above this line
def get_top_switch_number_from_this_string(inputstring):
    #print("get_top_switch_number_from_this_string")
    #print("there is NO REASON to send humans to Mars")
    counter=0
    x= y =''
    for line in inputstring.splitlines(): #it will be the first switch 06
        if "switch" in line and "#" in line and "nested" not in line  and counter < 2: 
            print("confirmed switchh in line ")
            #this is new getting the switch id number after # on-the-fly
            #get string to right of #, get right side,remove spaces
            x = line.split("#"); y = x[1];y = y.strip();
            #print("no drama this is what we have..")
            # print("y=",y)
            #print("now adding y to twinlist below")
            twinlist.append(y)
            break
        else:
            if counter > 3: #time to bail =too deep can't exist after first line actually
                break
            else:
                continue
                counter += 1
#grab first id number aftger switch 
'''
inputstring =makeitso
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)

inputstring =newattempt
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)
'''










print("== end of show ==== ")
#exit()
string_egg='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60 
'''


string_egg2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #33 
			#############
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''


pumpkins='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			switch(exp){ #34
			print("nice")
			switch(exp){ #45
			break
		default:
			switch(exp){ #66
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			####################
			switch(exp){ #35
			#############
			print("yep")
			fallthru
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew1='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

#add ability to get the comment number 15 and put that in automatically 
##=======================
##  funtime(y,x)
##=======================
# this is replacing the switch that is nested into 
# a method with the switch number

#building blocks are legos that are small behaviors inside
#of a function that can be assembled and connected in different
#configurations to make new functions without coding
#so interactively combined with a gui
#so chained methods really




#=====================================
# get inner switch number ()  only at the 3 tabs level depth though
#======================================
#so do this multiple times I would have to go thru a loop with the length of the count of switches at three tabs in a string
add_to_list=[]#and call this method get_inner_switch_number(stringname) #and change the counter number
thisline=[] #this also implies only getting one inner switch
def get_inner_switch_number(stringname): #implies at 3 tabs depth
	#print("======get inner switch number called=======")
	counter=0
	x=''
	#what this does is get the commented inner switch number after the # in switch
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tabdepth=line.count("\t")      #this is getting tabdepth for this line
		if "switch" in line and "end" not in line and tabdepth== 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			x = line.split("#")  #this manipulates the current line
			y = x[1];
			#print("switch number is...",y) 
			add_to_list.append(y)
			counter += 1
			#print(stringname)
			#break  #after the if condition above it stops 
		else:
			counter += 1
	#print("List add_to_list=",add_to_list)
	#del add_to_list[0] #should delete first one
	#print('now we have ',add_to_list)
	#return y;


##===================================
##  funtime(stringname)
## this calls the method get_inner_switch_number()
##===================================
## this replaces the inners switch at 3 tabs with a netsed method name with the id comment number
#this right now only deals with one but I can modify it so that
#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
#print("I just don't believe I coded this back on oct 22nd")
#print("morgan hill starbucks frosty74")
#===========================================================================
#  convert_inner_switches_into_nested_methods_numbered(stringname): 
#============================================================================
# it will access a list using a loop and they will be put in in sequential order top down
def convert_inner_switches_into_nested_methods_numbered(stringname): #this is feeding in the number looking for
	#print("======convert_inner_switches_into_nested_methods_numbered=====")
	x='';concatthis='';counter =0
	# using method get_inner_switch_number(string)#which is grabbed from 3 tab depth only
	#for line in stringname.splitlines():
	#	print(line)
	#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if  tabdepth == 3  and "switch" in line:
		# I just moved what was in a method into the loop where the action happens
			x = line.split("#")  
			y = x[1];       #it was str(ournumber)
			y = y.replace(" ",'')
			filler ="nested_switch_" + str(y) +"(exp)" #has to be a string
			#### this is new december 5th #######
			#print("inside of function convert_inner_switches_into_nested_methods_numbered")
			#print("###====line 11729 ===========##")
			#print("filler=",filler)
			if ":" in filler:
			    filler=filler.replace(":","")
			#end if
			#print("after fix  -- filler=",filler)
			#print("###===============##")
			######################################
			line = line.replace("switch(exp){",filler) #notice replace using var 
			concatthis += line + "\n"
			counter += 1
			continue
		else:
			concatthis += line  + "\n"
			counter += 1
			continue
	################	
	#for line in concatthis.splitlines():
	#	print(line)	
		

#print("testing this")
#print("convert inner switches without bodies inot nested methods numbered")
convert_inner_switches_into_nested_methods_numbered(brew) #line number of inner switch is in thisline[0]
#exit()

#def plan_c(inputstring):


#so we wouldn't need to enter the 5 we an glean that
#and we don't need to know the 15 number either it will grab it


#convert_inner_switches_into_nested_methods_numbered(string_egg2)

#convert_inner_switches_into_nested_methods_numbered(pumpkins)

#try none and try one
#convert_inner_switches_into_nested_methods_numbered(brew)
	
#convert_inner_switches_into_nested_methods_numbered(brew1)

#exit()
# I think that I will go through a string and 
# return a list of the locations of switches 
# (skipping the first switch)
# switch and endswitch line numbers
# was just thinking that it's obviously a switch otherwise
# we wouldn't be here so NO NUMBER for main switch (brilliant)
#it still matters but it's obvious that it is there. It's actually
# the main switch and the frame for nested switches. 

#ibm[0]=tuna #input of string into ibm[0]
list_of_nested_switches=[]
list_of_nested_switches.append(12) #these are just the line numbers here 12 and 32 
list_of_nested_switches.append(32)

#here I am using a list which has the line numbers of the inner switches locations
#print(list_of_nested_switches)  #so it would look like this 
#this goes through the input main switch and changes nested "switch" into a nested_switch numbered

#this is used for managing the nested switches by getting their location to know
#where to copy them when extracting them from a main switch
# today is july 17th, 2021 9:33 am

#print('testing this to make list of all switch locations and all endswitch locations')
#print(tuna)
switch_location=[]
endswitch_location=[]
#print("beginning === put location of switch and endswitch into lists")
#print("====---------------------- saturday coding ----------===")

ourcounter=0
#for line in abovenestedswitch.splitlines(): 
'''
for line in tuna.splitlines():
    
    if line.startswith("switch"):
        print("this lines starts with switch")
        switch_location.append(ourcounter)
    
    
    if line.startswith("endswitch"):
        print("this line starts with endswitch")
        endswitch_location.append(ourcounter)
        
    ourcounter += 1
    '''        
   



# july 24th, 2021 
#the input for this MUST be the already reduced main switch which
# has just the switch word in place where each nested switch thru endswitch was.


###  Thursday, August 19th, 2021 time 9:07 am
# I think that I just need to not worry about the other nested switches
# and just do the first level of nested switch since the others will just be in the other switches
# so let' say I have two nested switches deep
# I only have to have (for the main switch) the first level nestedswitch
# so then the situation becomes the numbering because in this first level of nested switches
# they would be numbered in sequence 1, 2, 3 etc  
# if say there are two nested in teh first main swith then sub1
# but for the inner levels (the next tab level) I would have to do 4,5,6 I suppose
# so continuing sequence or 1.1 and so forth
# I need to come up with a simple numbering system maybe Alpha first level Alph
###
#what if I have pairs, simple numbering but 
##===========================================	
## number_nested_switches_in_sequence()
##===========================================
#put the input I just created into ibm[0]
#this would be the main string after the nested switches are taken out  leaving switch word
forcedinputstring='''
	switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown kkk')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     #  this would be 10  for line number      
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 18 but it said previously 28      
			fallthru
		
		default:
			print('the end')
}
'''
#this is input for add counter to switches
trouble=[]
trouble.append(forcedinputstring)


#this is using preset nested switch starting locations 11 and 29 for this test
# this is for making the nested switch numbered method 



#this swaps switch with nested_switch_" n
##########################################
## number_nested_switches_in_sequence():  #this is using hardcoded input for testing
##########################################
def number_nested_switches_in_sequence(): # list_of_nested_switches[11,29]
	#print("=R2D2= NUMBER_nested_switches_in_sequence()  ====== ajax =====")
	newcount=1  #number of nested switches starts from 1
	## wait do I loopthru it get the position of the inner switches now why not
	## modification on july 24th 
	#print("to see what it sees first")
	#this is string above called forcedinputstring
	#print(trouble[0])  #it was ibm[0] which I will change it back to later
	mystring=''
	mystring = trouble[0] #putting the string into trouble[0]
	newcounter=0
	foundone=[]
	# this gets the inner switch locations after the inner switch bodies have been stripped out (deleted)
	##===============================
	for line in mystring.splitlines():  #this fills list foundone with switch line numbers
		if "switch(exp)" in line:
			#print("true we found switch")
			foundone.append(newcounter) #this fills the foundone list of line numbers with switch in it
			newcounter += 1
			continue
		else:
			newcounter += 1
			continue
	#=== end loop ========================
	#print("we are done looking for the inner switch locations")
	#print("====================")
	#print("thefoundone llist has",foundone)
	#print("the length is", len(foundone))
	#print("========........======")
	#print(" ") #below we delete the first switch which is on line 1
	del foundone[0] #this should delete the first switch we don't need 
	#print("now we have for foundone list",foundone)
	## end getting inner switch lcoations
	##======================================
	
	#shiney= ibm[0] #so it will skip the first few lines skipping the first switch 
	thecounter = 0 #tracking lines in the string   oh it's using preset numbers
	#print('the list of nested switches starting line',foundone)
	switchcount=0
	magic_string=''
	seagull='' #WAS shiney.splitlines()
	for line in trouble[0].splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 #IT HAS TO BE AFTER THE FIRST 2 LINES TO SKIP THE FIRST SWITCH
		#if  switchcount > 0  and thecounter in foundone:
		# if thecounter in founderone
		if  thecounter in foundone:  #this must be line numbers of inner switches
		#this line of code is absolutely beautiful and elegant 
			#print("thecounter=",thecounter)
			#print("switchcount=",switchcount)
			########We know the line numbers do it on one pass perhaps
			# it should only go to the lines in the list of nested switches
			gettabcount=line.count("\t")
			line = line.replace("switch(exp){","nested_switch_"  + str(newcount) +  "  " +str(gettabcount) + " tabs " +"(n)")
			magic_string += line + "\n"
			#NEW line above
			newcount += 1  #break #because we are only doing it once to replace only ONE switch #start  = thecounter #this resets the range n to skip what it just did.
			thecounter += 1 #this adds to the neste switch counter
			continue    
		else:
			magic_string += line + "\n"
			# new ling e
			thecounter += 1
			continue
	#print("=====-----======-----======------=====----====----====---")
	#print("magic_string=")
	#print(magic_string)
	#print("========")
	#for line in magic_string.splitlines():
	#	print(line)
		
	#print("were the changes made - this is kind of important at this stage RED ALERT")
	#trouble[0] = magic_string #here it's fed into trouble[0] so it's in a list now
	#print("did I rip out the nested switches or are they still intact???")
	#print("trouble[0]=",trouble[0])	
	#ibm[0] = shiney
			
####================================			
'''
print('about to call number-nested_switches_in_sequence() to test it extendo bus just passed')
#number_nested_switches_in_sequence()
print("it should have ran already testing bugs bunny here ")
print("the nested switch words should be nested numbered methods now")
print("just ran this function number_nested_switches_in_sequence()")
print("original mac computer")
'''
			
#exit()










#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





			
###============== Sunday July 25th, 2021  10:19 am Cafe Borrone ===============
# the idea is to put the information for each nested switch case
# into the dictionary in terms of it's exact information
# so to fill the data into the nested switch dictionary I will need
# to loop thru the switch string and gather the data for each switch location
# and it's particulars and add it to the dictionary (this should be done first')
# the idea occurred to me since each nested switch has a specific location
# and juggling them can get quite confusing so this way I know which is which
# and where it is.
#=======================================================================
####################
## DICTIONARY HERE 
####################
#putting a named list inside of known dictionary
nest_data=[]
# I probably won't need this.
nested_switch_data =	{  #for pear tree in backyard (2 of them)
#key [level tab depth,number case,  line number, series number
"1": [3,2,23,1], # I can make these now 
"2": [3,3,43,2],
}

print(nested_switch_data)

result=[]
result.append(0)

###############################################################
## RAM LIST TO HOLD TEMPORARY DATA FROM LIST WITHIN DICTIONARY
###############################################################
ram_list=[]
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)

########################
## get_nest_data(key)
########################
def get_nest_data(x): #puts it temporarily into result[0]
	#print("get nest data called",x)
	#this grabs the value from the key and puts it into result[0]
	#these are teh parameters for tehe signature for this nested switch
	result[0]=nested_switch_data.get(x)
	#s- there would be a list within result[0]
	#why not instead populate a list
	#print("this is what is in result[0]")
	#print(result[0])
	for item in result[0]:
	    ram_list.append(item) #see if this fills it or not
	#print('ram_list=',ram_list)
#############################		

  #test data input
############################
##  add_to_nest_data(x,y)
############################
cool_list=[]

# what is missing is the meaning of the code and the beahvior that it creates
# when it's running and knowledge
# how it works and what it does at levels

x = cool_list
def add_to_nest_data(x,y):
	#print("====add to nest data() called with ", x  ,"and",y)
	nested_switch_data["my_list_" + str(x) ] = y

#print("my_list_1[0]",my_list_1[0])
#print("gosh")
######====================================














################################
##  NESTED_SWITCH_INFO
###############################	
def nested_switch_info(x):
	get_nest_data(x)
	#this will get the info from the dictionary		
			
			
			







################
# the skipping is done by the main switch when I cam copying it and taking out the 
# nested switches below but keeping the switch word that I then convert to a method nested numbered
#################
### TESTING 
#NUMBERING OF NESTED SWITCH HAS TO BE DONE BOTTOM UP SINCE WE ARE RIPPING OUT THE NESTED SWITCH AFTER THE SWITCH WORD
#oh I will have to do this bottom up so the line numbers are correct.








#go thru a number the switches numerically top down

























hawaii ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown nnnmnn')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#######
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					######
					switch(exp){          
						case 'blable':
							print("do something")
							print("yep")
							fallthru
						case 'more':
							print("nice")
							break
						default:
							print("we are done here")
						endswitch 
						######
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			######
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			#######
			switch(exp){          
				case 'fish':
					print("do something")
					print("yep")
					fallthru
				case 'trout':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			#######
			fallthru
		
		default:
			print('the end')
}
'''	
get_switch_and_endswitch_locations(hawaii)
#print("this would have just gotton the switch and endswitch line number locations above...")
#print("I found it, I was looking for this code")
#empty_switch_and_endswitch_list_locations()

#get_switch_and_endswitch_locations(tuna)
###======================================================
#july 19th 2021 testing this feature now morgan hill starbucks
########################################################
#empty_switch_and_endswitch_list_locations()
#print("the one below this line should produce 2 switches and one with 10,20")
#print("why is this wrong")
#get_switch_and_endswitch_locations(samplestring) #samplestring 
#get switch and endswitch lcoations for one nest
#it's off by one says 11,21
#input is 10 and 20 and yet this says the line number is 11 and 21 for nested switch

empty_switch_and_endswitch_list_locations()
#print("the one below this line should produce 2 switches and one with 10,20")
#print("why is this wrong")
#print("get result of get switch and endswitch locations from samplestring")
#print("earth is over level ======")
#print("earth is over level ======")
#print("=== tea time =============")
get_switch_and_endswitch_locations(samplestring) # sammplestring


###  july 14th wednesday 2021 working on this
#real number is count endswitches and add 1 for total switches

#endswitches number is how many nested switches

# this empties the lists storing the switch and end switch locations

#del switch_location[:]
#del endswitch_location[:]

#get_switch_and_endswitch_locations(hawaii)

#print("this is the string with two nested switches")
#print("here we go wednesday coding - the bicycle gloves are great")
#print("first clearing out the lists that hold the locations of the switch and endswitches")
#print("this clears out the swith and endswitch locations in the list so it starts empty")

#I was deleting the crucial lists so the code down below couldn't behave correctly

#del switch_location[:]
#del endswitch_location[:]
#feed the string into the method to get the switch and endswitch locations
# but delete the first switch details which isn't important at this point.

#get_switch_and_endswitch_locations(tuna)
#this creates a list that can be of any size and then I can subtract the first switch
#and then divide the number by 2 to get teh number of switches or just count teh switches
'''
nest1=[]
nest1.append(switch_location[0])
nest1.append(endswitch_location[0])
nest2=[]
nest2.append(switch_location[1])
nest2.append(endswitch_location[1])
#wait a  second with each pass the output will be teh same unless I have 
#a list of say ten spaces tol hold locations to be proactive.
#####################################################
print("nest1=",nest1)
print("the two values in nest1 are",nest1[0],nest1[1])
print("nest2=",nest2)
print("the two values in nest2 are",nest2[0],nest2[1])
'''


#++++++++++=========================================================
### july 7th 2021 experimenting 
### testing cutting out two nested switches one at a time
### and replacing the switch location with the nested method with a number
# I need to do these separately first to make that they work
##===========================================
##===========================================
#skipping_some_lines(tuna,nest1[0],nest1[1])
#swap_switch_for_nest_method_new(1)

#and I need to make sure that the resulting string to modify the second phase is correct
#skipping_some_lines(tuna,nest2[0],nest2[1])
#swap_switch_for_nest_method_new(2)
##============================================
##============================================
# what I will attempt it going thru the double nested switch with two nests
# and delete the two nests and put nest methods in the location of the inner switches.
# and then after that is figured out I will first copy each inner switch
# Based on the nested switch locations I find I can determine how many nested switches
# espcially with teh endswitch count 



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========


















def end_program():
    #print("ending program")
    return

## method chaining nov 13th, 2021 &:45 am
#print("======= chaining methods =======")

'''
I was going to do method call
Loop thru all slots in list
====================
Then do next method call to all items in list
Chaining input to output is input fir next method
Then realized if i chained
Sequence of methods only go thru loop once (genius)
'''


# 48-C battery volvo 2002 s60
# 1 800 222 4357
# 
# 1041 Cochrane road, morgan hill starbucks

## chain methods code  chain methods chain methods CHAIN METHODS 



#A method that calls a series of methods really utilizing output from previous method

#these might have been created above but I am doing them again here just in case.
input=[]
input.append(0)

output=[]
output.append(0)


##=====================
##   get_final_finished_string()
##=====================
def get_final_finished_string():
    #print("===get_final_finished_string():===")
    #print("output[0]=",output[0])
    #print("=== result is in output[0] ===")
    return
    
# passing the baton in the relay race 
##=====================
##   so_pipe()   #this feeds output[0] into input[0] to be used with next method
##=====================
def do_pipe():
    #print("==== do_pipe() ====")
    #put output[0] into input[0]
    input[0] = output[0] 


##=====================
##   initialize_lists()
##=====================
def initialize_lists():
    #print("====initialize_lists(): ====")
    input[0] =''
    output[0]=''
   


old_string_test='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown ppp')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
endswitch
'''

  
holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			#location = line.index("#")    #gets location from left where position of #
			#line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			#line[0] = first #this is new to slice off right of brace
			line = line[0]#first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():
	#    print(line)
	    
	##===========today sunday coding
	
	#then look for this } and reposition it
	'''
	testingthis=''
	for line in holdthis[0].splitlines():
	    
	    if "}" in line:
	        line= line.lstrip()
	        testingthis += line
	    else:
	        testingthis += line
	holdthis[0] =testingthis
	print("now testing if this change worked shifting } to far left")
	for line in holdthis[0].splitlines():
	    print(line)
	'''       
	#this is what I need to modify.
	#so the whole modified string after ripping out endswitch is now in holdthis[0]
	
	#print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
	
#print("testing taking out endswitch and putting in brace")
#take_out_endswitch(old_string_test)
#print(holdthis[0])


    
##======================================================================================
#the result of each of these methods will put their result in output[0]
#swap_feed_data then puts what is currently in output[0] into input[0] so it's a handoff of the baton
#each of these methods takes in input[0] as input with the result going into output[0]
#after each method we call do_pipe() which puts output[0] into input[0]
# string --> m1(input) => m2(input) => m3(input) => m4(input) => m5(input) 

##====================================================
##  first_method : manipulate_string  (left indent)
##====================================================
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    #print("manipulate_string left margin indent ===first message called..")
    #shifts string left to indent it properly
    astring=manipulate_string(astring) #I think that this does left shift indentation
    return astring

##==========================================
##  second method : take_out_switch_body  from inner switches
##=========================================    
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    #print("take_out_switch_body ...seconed method called...")
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #<== key this is new to see if it works=========
    #astring += " water"
    return astring


##=================================================
##  third method : change_switch_to_method_solved
##=================================================
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("change_switch_to_method_solved  swapto neested_switch method third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    return finalresult

##======================================
##  fourth method  : take_out_endswitch
##======================================
#take_out_endswitch(stringname)
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("take_out_endswitch  put in brace instead third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring)
    #astring += " bright"
    return finalresult
    
    
##=======================================================================================
#using descriptive names not true method names yet
# what this is doing is modifying a string in stages in a sequence 
# code name waterfall
output=[]
output.append(0) #so we can use output[0] below
##========================================
##  chain_methods()   this just does a sequence of methods piped  
##                    together so each method passes its output as input for next method
##=====================================
def chain_methods(item):#this is not called I don't think
    #print("==OFFICIAL== chain_methods called ====")
    firstresult  = first_method(item)         # manipulate_string(string)
    secondresult = second_method(firstresult) # take_out_switch_body(string)
    thirdresult  = third_method(secondresult) # change_switch_to_method_solved(string)
    fourthresult = fourth_method(thirdresult) # take_out_endswitch(string)
    output[0]    = fourthresult #this puts the result into output[0]
    #print("now we are looking in the frac output of fourth method")
    #for line in output[0].splitlines():
    #    print(line)
    #the resulting string is put into output[0]
    
    
    # I still need to rename the actual methods and put them above this section 
    #add comment number to all switches at the very beginning of initial switch string(not here)
    #add_comment_with_number_to_top_switch(input[0]);do_pipe();  #switch # 22 <-- line number added
    #shift_string_to_left_by_reducing_tabs(input[0]);do_pipe();  #subtract tabs # works nov 19th
    #cut_out_switch_bodies_at_3_tabs_depth(input[0]);do_pipe();  #reduce switch body to just switch word
    #swap_switch_with_nested_switch_number(input[0]);do_pipe();  #change switch to nested_switch_22(exp)
    #replace_the_last_endswitch_with_brace(input[0])             # endswitch becomes  }
    #get_final_finished_string() #in output[0] prints it out nest_list to see it




##=================================
## change_slot_string(counter)    this changes content of each slot in nest_list
##=================================
def change_this_slot_string(counter): #requires output[0] finished string
    #print("==== change_this_slot_string(counter) ====")
    counter = int( counter)
    nest_list[counter] = output[0] #I really need to test this one and see if it works 
    #this means that needs to have finished chained_methods put into output[0]
    
##============================
## transform_string()    uses nest_list with strings in it of switch case bodies
##============================
def transform_string():  #this calls chain_method(item) # separate switch string input
    #print("==== transform_string() ====")
    counter =0  #loop
    for item in nest_list:  #loop thru nest_list and each loop does the chain_methods
        chain_methods(item) # takes in string and does sequence methods puts into output[0]
        change_this_slot_string(counter) #changes slot string from output[0]
        counter +=1


##==================================================
## loop_thru_finished_list_of_prepped_strings():
##==================================================
def loop_thru_finished_list_of_prepped_strings():
    #print("==== loop_thru_finished_list_of_prepped_strings() ====")
    counter =0  #loop
    #for item in nest_list:
    #    print(item)
    #    print("counter=",counter)
    #    print("===========")
        


# loop_thru_finished_list_of_prepped_strings() took this out
# this hasn't been tested yet. Today is Sunday, November 14th, 2021 10:58 am Pacific Standard Time
# this goes thru nest_list and modifies all of the switch strings
# and fixed the indentation, and adds nested methods and a comment after each switch 
# with the number after it and cuts out the switch bodies at three tabs depth
# and it uses chain methods in a sequence on each string so the loop only goes ONCE !!!!!
##====================================================
##  prep_nest_list_of_switch_strings_for_bypass205()   STAINED GLASS WINDOW SECTION
##====================================================
## ATTENTION: I have the code for this working but the names are new and I need to 
# put the first two methods lists below in these names. This is SOOO COOL NOW 
#dec 5th sunday I don't think that this is called yet.not tested yet then.
#def prep_nest_list_of_switch_strings_for_bypass205():
#    print("====prep_nest_list_of_switch_strings_for_bypass205() ===line 13629=")
#    go_thru_input_major_switch_string_and_make_list_of_pairs_switch_and_endswitches() # made above
#    using_pair_list_make_seperate_switch_strings_and_put_into_nest_list()             # made above
#    transform_string() #DOES CHAIN METHODS  loops thru  nest_list modifies each separated string
#   loop_thru_finished_list_of_prepped_strings() #thru FINISHED nest_list
#    #the end result will be in nest_list with the strings ready to feed into bypass205
    
#this was a duplicate call of the same method prep_nest_list_of_switch_string_for_bypass205


holdingpattern=[]
holdingpattern.append(0)
##=========================================
## fixes_dots_in_nested_string(inputstring)
##=========================================
def fixes_dots_in_nested_string(inputstring):
    #print('testing very_clever')
    #    print(item)
    newline =''   
    for line in inputstring.splitlines():
        if "nested_switch" in line:
            newline += line.replace(":","") + "\n"
        else:
            newline += line + "\n"
    #print("this is the result of modifying and taking out : after nested_switch")        
    #for line in newline.splitlines():
    #    print(line)
    holdingpattern[0] =newline
     #I still need to change the slot in the string though 







input=[]
output=[]
output.append(0)

mystring = "smile "

def get_one(astring):
    astring += " a"
    return astring
    
def get_two(astring):
    astring += " water"
    return astring

def get_three(astring):
    astring += " bright"
    return astring

   
    
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    print("=====first method started..")
    #shifts string left to indent it properly
    #LEAVE THIS DON"T MEDDLE THIS WORKS
    # MODERN TAB SHIFTER TO LEFT IS PURE GOLD
    modern_tab_shifter_to_left(astring) #I think that this does left shift indentation
    astring= goldtime[0] #output from modern_tab_shifter_to_left
    #removes garbage on right side of switch strings (still testing)
    ########################
    print("check right here frosty")
    #print("newstring[0]=",newstring[0])
    
  
    
    ##################################
    #print("calling: fixes_dots_in_nested_string() method")
    #fixes_dots_in_nested_string(astring) #when it is nested_switch_22:(exp) removes :
    #astring=holdingpattern[0]
    for line in astring.splitlines():
        print(line)
    
    #return astring
 ######################################   
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    #print("=======seconed method started.take_out_switch_body..")
    #astring =newstring[0] #from first method above outoput
    #TAKE OUT SWITCH BODY METHOD
    #print("see what we are passing does it have something in it")
    #print(astring)
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #this is new to see if it works=========
    
    
    #print("==output from second method take out switch body==")
    #for line in astring.splitlines():
    #    print(line)
        
    #print("================")
    #astring += " water"
    return astring




 #converts inner switch into a nested_switch method numbered
############################################
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("=======third method started...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    #converts inner switch into a nested_switch method numbered
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    #print("===third method output==")
    # print("outoput from change switch to method solved")
    #for line in finalresult.splitlines():
    #    print(line)
    
    #print("what does it say right here")
    #for line in finalresult.splitlines():
    #    print(line)
        
    return finalresult    
    
    
    
############################################

#take_out_endswitch(stringname)  #this would do all of them regardless of number
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("third method startedc...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring) #replaces it with }
    #astring += " bright"
    return finalresult
    
hollister_list=[]
#take_out_endswitch(stringname)
##=========================================
##  simulated_chain_methods():  this is called for each switch string
#this is doing one string at a time. 
##===================================
def simulated_chain_methods(mystring): #starting point 
    #print("SIMULATED CHAIN METHODS () Rudolph the red nosed reindeer")
    first_method(mystring)
    fizz=goldtime[0] #output from first_method()
    #print("stage1 fizz =",fizz)
    
    #print("FIZZ TESTING CRITICAL 1ST METHOD output of first_method() ")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fizz.splitlines():
    #    print(line)
    
    ##############################==================
    fizzy = second_method(fizz)  #missing 66
    #print("stage 2 fizzy=",fizz)
    
    #print("FIZZ  TESTING CRITICAL 2ND METHOD to see what's in frac")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fizz.splitlines():
    #    print(line)
    
    #return   
    ##############################
    fuzzy = third_method(fizzy)
    print("stage 3 fruzzy=",fuzzy)
    
    print("FUZZY  TESTING CRITICAL 3RD METHOD to see what's in ")
    print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fuzzy.splitlines():
    #    print(line)
        
        
    ############################
    frac  = fourth_method(fuzzy)
    #print("strage 4 frac=",frac)
    #############################
    #print("now we are looking in the frac output of fourth method")
    #for line in frac.splitlines():
    #    print(line)
    #print('above this line is the Rudolph the red nosed reindeer final first test')    
    #print("line number 12502")
    #frac is the result
    #look at frac to see when  switch 31 and 66 are missing
    #print("FRAC  TESTING CRITICAL 4TH METHOD n frac")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in frac.splitlines():
    #    print(line)
        
    hollister_list.append(frac) #new on november 30th Tuesday 
    
    
    
    


#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########


#making this sucker work no matter what 

#print("the big test begins")
#planB()
#print("now simply loop thru the finished changes in the list")

#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop

result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]

#print("this is after the input stings have already been seperated")
###=====FIRST METHOD OF CHAIN METHODS ============
##======================
##  move_string_to_left_side()        first method modern tab shifter to left 
##======================
def move_string_to_left_side():
    #print("=====APPLE== modern_tab_shifter_to_left()=====")
    print("this might be it line 13534" )
    for item in testlist_of_strings:
        print(item)
    print("===========")
    counter = 1
    for item in testlist_of_strings:
       # print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
       # print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
   # print("result of shifting input strings to left")
   # print("=====APPLE==APPLE   APPLE   APPLE   APPLE   APPLE=====")
   # for item in result_of_first_method:
   #     print(item)
   #     print("=========")
   #     print("counter=",counter)
   #     counter += 1
    



###=====SECOND METHOD OF CHAIN METHODS ============
##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    #print("=====PLUM == take_out_switch_body(item)====")
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
       # print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
       # print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    #counter =1
    #print("result of taking out inner switch bodies")
    #for item in result_of_second_method:
    #    print(item)
    #    print("=========")
    #    print("counter=",counter)
    #    counter += 1
    

#good_plum()



###=====THIRD METHOD OF CHAIN METHODS ============

##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    #print("=====PEACH===change_switch_to_method_solved===")
    print("look at what is in result of second method line 13598")
    for item in result_of_second_method:
        print(item)
    print("====================")
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        #print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    #########################################
    #counter =1
    #print('result of 3rd method on string')
    #for item in result_of_third_method:
    #    print(item)
    #    print("=========")
    #    print("counter=",counter)
    #    counter += 1
    
    
 ###=====FOURTH METHOD OF CHAIN METHODS ============   
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
##=================================================================
def replace_endswitch_with_close_brace():
    #print("=======ORANGE=take_out_myendswitch===")
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
       # print("=======")
        fizz =  holdthis[0]
       # print('orange fizz =',fizz)
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        #print("===== counter =",counter)
        counter += 1
   #########################################
    #print('result of 4th method on string')
    #counter=1
    #for item in result_of_fourth_method:
    #    print(item)
#Santa_Cruz_Python_Preprocessor/fourth_of_july2good.py /

 
 
   
#import official_switch_case_silver
#from official_switch_case_silver  import *  
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 


# output is to inputstring[0]

passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)



##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
#############################################################
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	#print(" add_comment_and_line_number_to_all_switch()....this was just called .. ")
	#print(" == directive 1 ==    ADD the stupid comment and line number after each switch relaly simple")
	awesome='';counter =0;newstring='';smart_switch_numbers=[];#clears it out Dec 11th
	#print('baseline is red_robin starting appearance testing purposes')
	#print(inputstring)
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
			#end if
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	#print("=== jump off the cliff and fly in hang glider ==")
	#for line in newstring.splitlines(): #was redrobin.splitlines()
	#	print(line)
	#print("AFTER ADDING the line number as comments to the switches in red robin baby ")	
	#print(newstring)   #it prints red_robin switch combo string with the line numbers added in comments
	#print("smart_switch_numbers=",smart_switch_numbers)  #this is new here too 
	return newstring #this way I can capture the changed string





def too_swift():
    return
    #print("==========too_swift() called=======")
    #print("dirt stimple test showing lines with switch, end switch and }")
    #for line in waffles.splitlines():
    #   if "switch"in line:
    #        print(line)
    #    if "}" in line:
    #        print(line)
#too_swift()


quail=[]
# I am adding the quail list to practice filling it

print("testing add comment and line number after all switches")
#add_comment_and_line_number_to_all_switches(waffles)#was red_robin
#print("REd ALERT critical test first method  test first method ...")
#exit()


def empty_switch_and_endswitch_list_locations():
    print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter

switch_location=[]
endswitch_location=[]
together_pair=[]
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	return
	#return we START BUILDING
	#print("thbis is what I am testing now now now")
	#print("  get switch and endswitch locations###  called line 322 #####")
	#print("######get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#wrong='''	
		#rechecking to see if this works 
		if "switch" in line and "end" not in line:
			#print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		#if "endswitch" in line:
		#	print("look right here endswitch found",counter)
		#	endswitch_location.append(counter)
		#	counter += 1
		else:
			counter += 1 
	
	counter=0
	for line in z.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line:
			#print(line)
			#print("look right here endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1 
		#'''
	#print("at this point this is what we have...after testing BIG YELLOW BIRD go bird")
	del switch_location[0] #takes out first number not needed
	#print("switch_location=",switch_location)
	#print("endswitch_location=",endswitch_location)
	#test_string1exit()
	#print("this over writes the contents of these two lists ")		
	#hard coding it in here why 
	#switch_location    =[1,11,15,23,31,62,66]
	#endswitch_location =[100,60,51,46,41,86,77]	#might hav eto resverse these 	
	
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	#del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	#print(z)                #now I remember that is the first switch which doesn't matter
	#print("I deleted the first switch since I'm not bothering with it")
	#print("switchlocations=",switch_location)
	#print("on line 180 endswitchlocation=",endswitch_location)
	
	#print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	#print("this is how many nested switches are here")
	#print("now we should have this many nested switches to contend with",answer)
	#print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	#if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
	#	print("endswitch locations =",endswitch_location)
	#	print("out of curiosity print the number of endswitches", len(endswitch_location))
	#else:
	#	pass
	#print("I need to test that this part still works here in fourth of july 2 .py")	
	#print("this might be simpler to test and use actually======/////???????//////===")
	#print("======================================")
	#print(" ===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === ")
	#print("I need to delete teh first swithc location")
	
	#working on this on Saturday, October23, 2021 to get this stage done 
	#del switch_location[0] #ALREADY DELETING FIRST SWITCH ABOVE BECAUSE IT'S NOT NEEDED NOT NESTED
	#print("does this look right testing on Sunday gloomy rainy day")
	#print('switch_location=',switch_location)
	#print('endswitch_location=',endswitch_location)
	#the input is above
	
	
	#print("....")
	#print("the input for filling the blueberries dictionary are the lists switch_location and endswitch_location")
	#print("==================")
	#print("the enchanting world of making blueberry pie")
	
	
	
	
	##################################################################################
	############## working on this on saturday, october 23rd, 2021 ###################
	##################################################################################
	#print(" rain fall status ")
	counter=0
	#working on creating input list for blueberries dictionary: can't believe I didnt do this yet
	#print("what the hell is going on here")
	#print("switch_location=",switch_location)
	#for item in switch_location:
	#	print(item)
	#print("so how did that go...")
	
	#print("endswitch_location=",endswitch_location)
	#for item in endswitch_location:
	#	print(item)
	#print("so how did that go...")
	
	
	counter=0
	#print("starting at counter =0")
	
	#print("=============== starbucks morgan hill =====")
	#print(switch_location)
	#print(endswitch_location)
	#print("emptying together pair here")
	del together_pair[:] #delete it just in case to start with clear chalkboard
	#print("=======") #THIS FILLS THE TOGETHER_PAIR LIST OF SWITCH,ENDSWITCH 
	#print("this loop fills the together_pair list of switch,endswitch numbers")
	#print("this is so much dam fun oh yeah")
	total1 = len(switch_location)
	total2 = len(endswitch_location)
	#print("total1 =",total1)
	#print("todal2=",total2)
	#print("this is where we START BUILDING the ===TOGETHER PAIR =====")
	for item in switch_location:
		solution = "[" + str(switch_location[counter]) + "," + str(endswitch_location[counter]) + "]" 
		print("solution=",solution) #to see what it looks like 
		together_pair.append(solution)
		print("counter=",counter)
		counter += 1
		
		#this should prevent stack overflow of the list range added november 9th 
		if counter >= len(switch_location):
			#print("stack overflow called since counter > = len(switch_location)")
			break
		else:
			continue
			
	#print("now we will loop thru the together_pair to see that the pairs are in there")
	del endswitch_location[-1] #should delete 100
	#print("this is what is in TOGETHER_PAIR at line 254")
	for item in together_pair:
		#print(item)
		apple = item.split(",")
		#print("======")
		#print(apple[0])
		sweet1 = apple[0].replace("[",'')
		#print(sweet1)
		#print(apple[1])
		sweet2 = apple[1].replace("]",'')
		#print(sweet1,sweet2)
		#print("where's the party")
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	##################### end of method #################################3

############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced
old_coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown eee')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
}
'''
coffee_now='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
	
#this is coolstring with the nested switches already taken out for all levels+
coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown jj')
			switch(exp){
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){   #here        representings stripped out inner nest
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			switch(exp){     #heret 
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			switch(exp){
			switch(exp){
			fallthru
		default:
			print('the end')
}
'''

#working on this July 15th, 2021 10:16am Starbucks
#get_switch_and_endswitch_locations(coolstring)
#output to these lists
#switch_location #skips the first main switch not included
#endswitch_location (if any)
#get_switch_and_endswitch_locations(coolstring)
print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#this accesses coolstring august 5th, 2021
#this is to set the inner switch positions in the main switch input strings
#after the bodies of the nested switches have been stripped out

##########################################
##  put_switch_locations_into_switch_list()  #this is making the nested_switch_ number  
##########################################
def put_switch_locations_into_switch_list(inputstring): #just added param
    #print("##2### put_switch_locations_into_switch_list ###")
    #print("##2## put switch locations into switch list ###")
    #print("put switch locations into switch list")
    #### get swith and endswitch locations called here 
    get_switch_and_endswitch_locations(inputstring) #it's right here 
    for item in switch_location: #this is only going thru switch_location
        switch_list.append(int(item))  #was -1 on here #off by one in the string for some reason
    # print(" ");print("switch_list=")
    #print(switch_list)

#######################################
##  swap_switch_to_nested_method()  #this is making the nested_switch_ number  
#######################################
def swap_switch_to_nested_method(stringname,linenumber,series_num):
	#print("============== swap_switch_to_nested_method() ==========")
	#print("input: linenumber", linenumber)
	#print("input: series_num", series_num)
	
	#print("##4## swap switch to nested method - numbered ###")
	#print("##4## #swap switch to nested method - numbered ###")
	#print(" THIS IS BEING CALLED TO DO THE MAGICswap switch to nested method called....")
	str_list = stringname.split('\n')
	#print('changing line',linenumber)
	#series_num = number_series[0] 
	str_list[linenumber] = "\t\t\tnested_switch_" + str(series_num) + "(n)"
	stringname = "\n".join(str_list)
	genius[0]=stringname   #strings are immutable but lists are mutable(changeable)

######################################	

#this is the control center main that runs this operation
#this numbers the nested switch methods top down
#genius[0]=coolstring  #assignment here <<<==================


#######################################
##  loop_thru_switch_locations():
#######################################
def loop_thru_switch_locations(regularstring):  #looping thru  switch_list[10,18]
    #print("##1##loop thru switch locations ## line number 276 ####")
    #print("##1##loop thru switch locations ######")
    #trick put_switch_locations_into_switch_list
    #method called
    put_switch_locations_into_switch_list(regularstring) #method
    #print('this filles switch_list of switch line numbers')
    #print(genius[0])
   # print("what is the order of the switch_list I think it's reversed to do bottom up")
    #print(switch_list)
    #print("------------")
    #print("switch_list=",switch_list)
    le_number=1 #default numbering nested string 
    for item in switch_list: #loops thru switch_list WITH SWITCH LOCATIONS (LINE NUMBERS)
        print("item in switch_list",item)
        #string,switch,line number
        # swap_switch_to_nested_method here 
        #method this one is the holy grail that actually works
        ###############################
        swap_switch_to_nested_method(genius[0],item,le_number) 
        coolstring =genius[0]
        le_number += 1  #adding to the nested number here
    #print("#### end of loop thru switch locations() ####")
    #print('the EXIT sign is green')
#######################################



#print("STAR TREK TEST FULL PHOTON LASERS add numberednested method McCoy looks good now beam me up ")
#print("starting with this input main string with nested switch bodies cut out")
#print("tahoe dream")
##==========================================================|
## swap_nested_switches_with_methods_in_main_switch_string
##==========================================================|
def swap_nested_switches_with_methods_in_main_switch_string(inputstring):
    #print("===swap_nested_switches_with_methods_in_main_switch_string()== line number 309=") 
    loop_thru_switch_locations(inputstring) 
    #print("this is the output string of the transformation from input string")
    ## this is after loop thruw switch locations method is completed
    #print("this is the main input switch string after adding nested methods")
    #print("the output of this transformation of swapping switch for nested_method")
    #this is the input string transformed 

#this calls it
genius[0]=coffee_now  #assignment here <<<==================
#print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
#swap_nested_switches_with_methods_in_main_switch_string(coffee_now)
#print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
print(genius[0])

#this calls above
#print("=== begin tron test ==line 323 =TESTING september 1st here we go=-=== to see if this sucker works === august 27th ==== please work ==")
#print("this is testing the main switch string module changing nested switches")
#print("that already had their bodies cut out and swaping in a nested method")
genius[0]=coolstring  #assignment here <<<==================
#print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
#swap_nested_switches_with_methods_in_main_switch_string(coolstring)
#print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
#print(genius[0])
#print('end of test of swap nesetd switches with methods in main switch string ')
#print(" oh that's what this does...da ")
#print("====line 332 ==end of this tron test september 1st=====")
#print("======end of this tron test september 1st=====")
#exit()  #stop it here
	#string_change =coolstring
#stringname=coolstring
#print("now change the inner switches to the nested method numbered")
#swap_switch_to_nested_method(coolstring,10,1)	  #####======

#print("after first change ====>>>>>>>")
#coolstring =genius[0]                            #########==========

#series_num = number_series[0] 
#swap_switch_to_nested_method(coolstring,18,2)	  ########=========
#print("after the 2nd change ...")
#coolstring =genius[0]
##print(genius[0])                                ################============
#print("done with this test of the new method")
  #building the method to make this magic happen automatically


#-------------------  july 10th, 2021   11:03 pm  -------starbucks coding-------
#I am hard coding the location of the switch words. I need to have it search on it's own
# but I recall I have code that does that elsewhere
#now I need to find the code that makes the correct nested switch list locations

#they are being harded coded in here I should be getting them from above

#switch_list.append(11) #was 10,18,31
#switch_list.append(19)
#switch_list.append(32)## added a third switch to test it more thoroughly 

##============================================================================
#print("here put switch_locations into switch_list")
## this is new added Thursday july 15th 2021 prevents off by one error
## it takes input of nested switch line number locations from switch_location
## and puts them into switch_list (but again not the first main switch)   

#this one just commented out
#put_switch_locations_into_switch_list()
#print("about to test it with the loop thru switch method ====")
#print("today is july 22nd, 2021 thursday refining the algorithms and methods")
## calling LOOP THRU SWITCH LOCATIONS (INNER)

######======================
#loop_thru_switch_locations() #where to find the inner switches to replace with a nest method
######======================


#this one works just need to test it as a method above 
#str_list = coolstring.split('\n')
#print('changing line 11')
#str_list[10] = "\t\t\tnested_switch_1(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)

#print(string_change)
#stringname = string_change
#############
#str_list = coolstring.split('\n')
#str_list[18] = "\t\t\tnested_switch_2(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)


#what if I go thru a list to make teh changes
#=====================================================
#z = 'test4'

#choose to 'Update Now'
# when the newest MacOS Mojave 10.14. 6 Supplemental Update

#say we add it to first case 2nd line after case just bump down whatever
#is on that line. copy that line just for saftey and add it to the tail
#with \n at beginning and end of that line


### look for nested switch called    switch_nest()  
# get case number which case is it, first, second, third for this test
#then get line number of case section determine what line it's on.
#(the nested switch method)

output_string_test='''
 switch(x) #main switch    #<<====== switch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "one":
            print("this is the first case in the main switch")
            #switch_nest() #force feeding it for testing switch case function actually 
            ######################
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word')   
                     
        if case == "two":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word') 
            
        if case == "three":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
           
            
'''

######## testing 2nd and 3d level deep nested switch cases july 29th, 2021


# will mess around with this later. 

triple_nested_switchtest ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown iiii')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	



cicelyalaska ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown iiii')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ooo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	



snowman='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown pppppp')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									#################### this one is new 
									switch(exp){  #fourth level deep   Level 4    
										case 'obama':
											print("do something")
											print("good")
											fallthru
										case 'ufos are real':
											print("better")
											break
										default:
											print("nice job")
									endswitch 
							#############
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== interesting test here for just 3 here ==')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
		case 1 thru 3:
			print("where\'s this will be one match for 3, 5!")
			print('first prize')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
						default:
							print("welcome to the party") 
						endswitch
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									####################
									switch(exp){  #fourth level deep   Level 4    
										case 'coolish':
											print("do something")
											print("yep")
											fallthru
										case 'auburn':
											print("nice")
											#######################
											switch(exp){  #fifth level deep   Level 5    
												case 'coolish':
													print("do something")
													print("yep")
													fallthru
												case 'auburn':
													print("nice")
													break
												default:
													print("we are done here")
											endswitch 
											break
										default:
											print("we are done here")
									endswitch 
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	

'''
loop thru string
get switch locations and tabs coount
then make list of numbers of switches inside tab 3 switch
only thing that I cna think of.
make list with sublists
'''

#answer we seek is case section 2, line 2
################===============================
#33 june 28th, 2021 9:26 pm now 

#where I detect the nested switch  location and starting and ending point
# I copy the nested switch and delete it from the main switch
# I add a method where thes switch word is.
# My compromises to get it working faster are the nested switch
# must end with endswitch  and not a curly brace
# this makes it easier to get working and aids readability

#the switch main switch is chopped off at the begining of the inner switch
#the bottom after the nested switch ends with endswitch is copied
#to the top half but only after the nested method is added to th eline
#where the nested switch was 



# when code is running there is nothing to see.
# If we have moving behavior (which is invisible)
# that is what matters -but like what Fred Brooks says
# software is invisible. So I need to make it tangible and visable.

#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========



# starting testing here to see if I can reduce the code to make sense

 ####### august 10th 2021 testing commences.
 
find_nested_switch_game ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown mmm')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	

gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

print("what we are starting with the switch with a nested switch")
#print(find_nested_switch_game)
print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
print("this gets the line number of the line that the case starts")
print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
    print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
    print("case line numbers",pacman)    
    #print(pacman[2])  
    print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            print(item)
            print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
            #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            #print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    #print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    #print("x=",start_and_finish[1])
    #print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function

print("will do red robin string with the sets of pairs individually to verify it's right")
print("testing Sunday, NOvember 7th, just got 3rd booster shot ----")
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')

columbia_river=[]
gold_list=[]
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
   # print("= copy_a_nested_switch() called== just now 10;43 am ====")
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    #print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################


# add_comment_and_line_number_to_all_switches
# inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
# copy_a_nested_switch(water)
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]] 
#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]       
##=============================================================
##  split_up_big_string_into_nested_switches(myinputstring)
#  dependency requires gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]  
##=============================================================
'''
# I am adding comment with line number to all switches wonderful news.
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print("===boom boom boomsplit up big string into nested switches()===")
    water =add_comment_and_line_number_to_all_switches(myinputstring) #stringname goes here
    print("need to see that the comment and line number added after each switch")
    for line in water.splitlines():
        print(line)
    print("that is how we shall know")
    del columbia_river[:] #empties columbia_river; the inputstring name is now called water 
    #gold_list is prefilled here 
     #before the input string is modified  but after comment numbers added ; this is the original input string which is used for the main later
    print("gold_list=",gold_list)
    columbia_river.append(water) #this adds the mega initial string first for the main string
    print('at this point the length of columbia_river should be 1 and it is',len(columbia_river))
    for item in gold_list: #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
        copy_a_nested_switch(water)  #copy string based on switch,endswitch pair 
        print("====================")#puts resulting string into makeitwork[0] and output
        output = makeitwork[0]       #put nested string into columbia_river list
        columbia_river.append(output)
    print("length of columbia river =",len(columbia_river))
    counter =1
    #adding here the initial string which will be used to make the main switch
      #it is added just before looping thru i
    print("now loop thru columbia river to see the switch bodies seperated")
    for item in columbia_river:
        print("counter=",counter)
        print(item);print("===========");counter += 1
##================================================================        
'''


     
     
     
     
     
     
     
     
     
     
     
     
#######======================================== ## find_nested_switch_game
#the input is the whole string afgter having added comment of swithc line number in loopstring[0]
#x =11; y = 60;
##=======================================
##  testing_code_copying_string_adding_it_to_list()
##========================================
def testing_code_copying_string_adding_it_to_list(x,y):
    inputs_pair_to_copy_a_string(x,y)
    #water is the modified string with line number (but need to only add the line numbers once as comment
    copy_a_nested_switch(water) #this takes in switchstring with switch numbers added as comment
#######=========================================
    output = makeitwork[0]        #this would have to be after the call to copy a nested switch
    columbia_river.append(output)

#testing_code_copying_string_adding_it_to_list(11,60)


#print("now printing out columbia river")
#print("length of columbia river =",len(columbia_river))
#for item in columbia_river:
#    print(item)
    
#exit()
 





start  = 7  #hard coded beginning of nested switch
finish = 14  #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################
start_and_finish=[]
start_and_finish.append(0) #position [0] #ignore
start_and_finish.append(start) #position [1]
start_and_finish.append(finish) #position [2]
#so we have
'''
start_and_finish[1] = 7
start_and_finish[2] = 14
#############################
r=gameday
#linecounter=0
makeitwork=[]
makeitwork.append(0)
print('======SECOND ATTEMPT======')
#######========================================
copy_a_nested_switch(r) #this gets put into r as a parameter
#######=========================================
'''


#lines 1 thru 9 
 #this looks for the line number of endswitch for the nested switch
print("testing getting a COPY TOP HAT OF MAIN SWITCH")
print('this also grabs and displays the inner switch first line')
#the inner switch needs to be the last line of this string
##================================================
start = 1 #starting from 11 not 10
finish = 10
#linecounter=0
abovenestedswitch=''
#print("this was put into a function on July 15th, 2021 ===")
####################################
## copy_top_hat_of_main_switch(): #this grabs the string of the main switch above 
# the first nested switch in this case there is only on 
####################################
terriblysmart=''
def copy_top_hat_of_main_switch(): #this is grabbing the top of 
    #the switch case just above the first nested switch 
    #print("======copy top hat of main switch()====")
    global abovenestedswitch
    linecounter=0 #string name find_nested_switch_game
    for line in find_nested_switch_game.splitlines():
         # between >= 1 and <= 10
        if linecounter >= int(start) and linecounter <= int(finish):
            abovenestedswitch += line + "\n"
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result copy above  first nested switch case ")        
   # print(abovenestedswitch)
    terriblysmart = abovenestedswitch

#copy_top_hat_of_main_switch()  #not called yet

#print("end of copying top half above nested switch ")  
#print("it should end with switch which we will edit")

mystringtest='''
	switch() #7
		case 'funny':
			print('fun')
		case "da":
			print('yeah')
		default:
			print('bye')
	endswitch #14
'''					
					

####################
#replace switch

#linecounter= 0
newlist=[]
newlist.append(0)
#newlist[0]
# I just put this into a function to have control over it 
#COPY COATTAILS BOTTOM OF BIG SWITCH AFTER NESTED SWITCH END
################################################################
## copy_coattails_bottom_of_big_switch_after_nested_switch_end():
################################################################
def copy_coattails_bottom_of_big_switch_after_nested_switch_end():
    #print("copy_coattails_bottom_of_big_switch_after_nested_switch_end()")
    linecounter=0
    start = 21 #INPUT PARAMS TO GRB need to put these in a list for efficiency
    finish = 32
    outerswitch=''
    for line in find_nested_switch_game.splitlines(): #string looping thru
        #   IF BETWEEN line numbers 21 and 32 
        if linecounter >= int(start) and linecounter <= int(finish):
            outerswitch += line + "\n"
            linecounter += 1
        else:
            linecounter += 1
            continue   
        
    #print("testing getting a COPY COATAILS BOTTOM OF BIG SWITCH")
    #print(outerswitch)
    newlist[0]=outerswitch
##===================================================





#this is turning code into a function on july 15th, 2021
#######======
#copy_coattails_bottom_of_big_switch_after_nested_switch_end()
#######=======





#here is where i make this temporary list that I will put the
#input strings of the main switch and the one nested switch for testing

inputstringswitches=[]

###################
##    swap(a,b)
###################
def swap(a,b,c): #c = starbucks[1]
    cooler =c.replace(a,b)
    return cooler #starbucks[1] =string with changes made
    
    
  
#this puts the nest_method on the line selected in the tophalf of the string
#################################
## swap_switch_for_nest_method(n)
################################# 
def swap_switch_for_nest_method(n): # I will add more values later perhaps 3 or 4 for coordinates
    global abovenestedswitch
    abovenestedswitch=terriblysmart
    #print("called swap_switch_for_nest_method(n)",n)
    abovenestedswitch = abovenestedswitch.replace("switch(exp){","nested_switch_" + str(n) + "(n)")
    #print(abovenestedswitch)
    #print("===================")

#june 29th, 2021


def scan_input_string_for_number_of_switches():
    return
    #print('work on this')#I have this figured out now elsewhere
    
    
#commented this out on august 3rd testing making big method 
   
#this needs to be put into a method and called below actually
def fishfood(): #necessary testing that's all
    #print('about to try new swap method')    
    swap_switch_for_nest_method(2) #feeds it the number 2 for testing
    outerswitch=newlist[0]
    outerswitch= makeitwork[0]
    maybe=abovenestedswitch + outerswitch
    #print('we have stripped the nested switch from the main switch')
    #print("and inserted a method for now")
    #print(maybe)
    ######### put first main switch into inputstringswitches
    #print("adding main switch and nested switch taken out into list")
    #print("the next step will be to run it thru the silve_module")
    #print(" to create teh strings output in python")
    inputstringswitches.append(maybe) #should be position 0

    #print("and the nested switch is here before it's converted")
    # print(makeitwork[0]) #roadrunner
    #roadrunner = roadrunner.replace("endswitch","}")
    ######### put nested switch into inputstringswitches
    inputstringswitches.append(makeitwork[0]) #should be position 1
    #print("====== go for the gold =======")
    #print("this shows the resulting strings accessed thru the list that")
    #print("they were put into so I can access them now for running silve module")
    #print("==--------------==")
    # print("here is the result now")
    #print(inputstringswitches[0])
    #print("now the nested switch")
    #print(inputstringswitches[1])
    galaxy=''
    galaxy = inputstringswitches[1]
    #print(galaxy)
    #print("Now I replace endswitch with }")### replace endswitch with }
    inputstringswitches[1] = galaxy.replace("endswitch","}")
    #print("now looking into inputstringswitches[1] endswitch should be gone")
    #print(inputstringswitches[1])
    #print("==== end of first major step ==in process of transformation ==")

#################===========
#fishfood()
#################===========




#############################
##  get_inner_switch_line()
#############################
def get_inner_switch_line():
    #print("can we get serious here I mean really")       
    bronze=0     
    linecounter=0
    secondswitchline=0  
    for line in find_nested_switch_game.splitlines():
        if "switch" in line: 
            #print(line) 
            linecounter += 1 
            #print("switch line number = ",linecounter)
            secondswitchline = linecounter
            break
        else:
            linecounter += 1  
            continue
    #print("line with inner switch =",secondswitchline)
    #print("==================")
#the inner nested switch will obviously end within the same case it starts in.

###########==============
#get_inner_switch_line()  
###########===============


                
###########################################################

switcharoo=[]
switcharoo.append(0)

linecounter=0





#######################################
##  get_number_of_nested_switches():
#######################################
def get_number_of_nested_switches():
    #print("get_number_of_nested_switches()")
    linecounter=0
    #this looks for the line number of 2nd switch for now more later  
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "switch(" in line:  #grabs first line
            #print(line)
            switcharoo.append(linecounter)
            
            linecounter += 1
            continue  
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
              
            #if "switch_nest()" in line:
            #   print(line)
    #print("line number of switches",switcharoo)  
    #print(switcharoo[2])                

casecounter=0
case_count=0

##########========================
#get_number_of_nested_switches()
##########========================
###############################################################
################ testing call of these methods at once
###========== august 3rd test Tuesday nice air conditioning ====
def nested_switch_trapeze_tricks():
    #print("==== nested_switch_TRAPEZE_tricks() called=====")
    loop_thru_switch_locations()
    get_case_line_numbers(find_nested_switch_game)
    get_larger_number_less_than_case()
    get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
    copy_a_nested_switch(find_nested_switch_game)
    copy_coattails_bottom_of_big_switch_after_nested_switch_end() 
    fishfood()
    get_inner_switch_line() #not sure if I need this one
    switcharoo=[];switcharoo.append(0);linecounter=0
    #print("the nubmer of nested switches=")
    get_number_of_nested_switches()  # here it is 

#this calls it right here 
#nested_switch_trapeze_tricks()
#print("end of running nested_switch_trapeze_tricks() Gee what does it do")

####=============================== end of the line here==========



################################
## get line number of cases()
################################
def get_line_number_of_cases():
    #print("get_line_number_of_cases()")
    for line in find_nested_switch_game.splitlines():
    #get each case number 
    #check if switch in it
        if "case" in line:  #grabs first line
            case_count += 1
            #print("case_count=",case_count)
            #print(line)
        
            casecounter += 1
            linecounter += 1
            #print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
     
#answer 2nd case section    
#nested switch on line 10        
 #answer line 2 inside of case
 #case section 2 starts on line 8
''' OUTPUT
 get line number of each case section
		case 1 thru 3:
1
		case 4 to 7:
2
			case blable:
3
			case more:
4
		case 8 to 10:
5
case line numbers [0, 2, 8, 11, 14, 23]
Line 8 is case second section
We therefeore know that if switch is on line 10
then switch is on the 2nd line after the case section starts
====
get line number of each switch
each number after first switch is a nested switch
get the line number of each switch
	switch(exp) {  
			switch(exp){
line number of switches [0, 1, 10] <<<=== line 10 nested switch
'''
'''
 print('kangaroo hop hop!')
			switch(exp){
			case blable:
			   print("do something")
			   print("yep")
			case more:
			   print("nice")
			default:
			   print("we are done here")
			}'''  
    
    
    
#Monday june 28th, 2021 thinking
#get switch line number and case it's in and line number inside of case
#and what line the switch ends with }
#which I need to know to copy it. I can set the loop to start
#on a particular line and to concat a string and stop
#after coping a set number of lines. 
#Based on line count between switch and } which I can do first
#if line.startswith("switch") do until line startswith("}")




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========



#line_6.append(0)






     
case_guts='''
\tprint("aaaaaa in the main switch")
\tprint("bbbbbb below")
\tprint("ccccc#result of innerswitch running
\t#what ddddddd?? use a list to capture it
\tfallthr eeeeeeeu('word'
'''
    
    #method inner switch withnumber (input will likely be from a list later)
add_this="\tinner_switch_1('test4')\n"
nested_method_name=[]
nested_method_name.append(add_this)
crystal=[]
crystal.append(0)# [0]


#get input string of case section
#
# I need to get the line number where the switch is supposed to go
# based on the input C style location of the nested switch
# based on which case it is in (the sequence starts from 1)
# then detect the line number in order within that case where the switch starts
#
#
  
#exmaple, we need to add nested switchmethod to line 2
#so we copy line1

top=[]
middle=[]
bottom=[] 
put_in_here=[]
















###################################
## copy one line inside of case (x)
####################################
def copy_one_line_inside_case(x):
    #print("copy one line inside case()")
    astring=''
    soupstring=''
    line_counter =0
    #print(case_guts)    
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == x:
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    #print(' line',x,' string=',astring)
 ####################   
 #copy just the line entered within the case body







#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========








################################################
##  get_below_after_method_insertion()
################################################
def get_below_after_method_insertion(y):
    newstring=''
    coolstring=''
    line_counter =0
    #this copies 2nd string to string n (the rest)
    for line in case_guts.splitlines():
        if line_counter >= y:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
    #print('below after method insertion',y)   
    #print(newstring) #this copies all of the lines into newstring
    #this is the switchm


egg=[]



happydays='''
line =""
varholder=[]
varholder.append('0')
###############################============
	
# ===== inswitch ========
def inswitch(n):
	if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
		n = str(n)
	global case
	case = n.lower() 
#=====================
# for infallthru    
def infallthru(n):
	eval("inswitch('" + n + "')")
global x
x = "one" #it was "one"     
tahoe=[]
tahoe.append(0)
victory=[]
victory.append(0)
#######################
### inner switch_1(n):
#######################
def inner_switch_1(n): #test2 is the test
	print("=======inner_switch called==1==",n)
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break   
###================
inner_switch_1(zoo[1]) #this calls it with zoo[1]
'''

  
  
  
  
  
  
           
 
'''
to set adding tabs i realized there are two modes
regular switch and nested switch
and to subtract a tab i need to cancel nuke tabs in a line then add the desired number
to get what i want
'''  
import re
myString = "\t\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
#print(myString)
#print("now rip out the tabs")
myString = re.sub(r"[\t]*", "", myString) #was * where I have 2
#print(myString)   
#print("now add a tab")





#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






##### this makes the input for zoo[1] lowercase
###############################
## make_input_lower_case() ####
###############################
def make_input_lower_case():
    answer = zoo[1]
    answer = answer.lower()
    zoo[1] = answer    

# what i doing here is putting the dynamic built inners switch python code into a list.
# this is just beautiful and brilliant.

#modified on november 12th 2021 friday to get this sucker working 
##====================================
##  get_switch_number_in_comment()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
#this looks ofr the first switch at 3 tabs need to modify it to 1 tab depth. aha 
def get_switch_number_in_comment_in_output_python_code_string(stringname): #this might be for when
	#print("get_switch_number_in_comment_in_output_python_code_string(stringname)")
	#print("indian braves dancing for rain")
	# I create copies of the switch body strings
	#print("get_switch_number_in_comment_in_output_python_code_string() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	#print("this is what the string we are manipulating looks like")
	#for line in stringname.splitlines():
	#	print(line)
	#print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0 #this looks for inswitch at 1 tab depth length 
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "inswitch" in line and "end" not in line and tablength == 1:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			#print("switch number ",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			#print(stringname)
			break
		else:
			counter += 1
	return y;



flynow=[]
###============================================================================
##  put_output_python_nested_switch_code_into_def_inner_switch_numbered(string):
##==============================================================================
#try this november 12th struggling here 
#I want to see this


def put_output_python_nested_switch_code_into_def_inner_switch_numbered(stringname):
	#print('===== TESTING RED ALERT ======')
	#print("put outpout python nested switch code into def inner switch numbered")
	#this calls a method to get this switch number to use to number this nested switch
	thenumber= get_switch_number_in_comment_in_output_python_code_string(stringname) #use other code similar to this
	#print("the number it returned is",thenumber) #thenumber=22 #for testing
	string_to_add= "def inner_switch_" +thenumber.strip() +"_(n):\n"
	concatstring = string_to_add + stringname;
	#print("lets see if it actually worked or not and concatted it correctly")
	##################################
	#for line in concatstring.splitlines():
	#	print(line)
	flynow.append(concatstring) #so the resulting string modified exists.
	#########################

####===============
#testing moved here for safety
# CHECK FOR THE NUMBER OF SWITCHES WITHIN THE INPUT STRING
nested_switch=[]
nested_switch.append(0)
nested_switch[0]= False # by default
################################################################################
#determines if a string input is a nested switch with at least one inner switch
################################################################################

###################
##  jumanji(y)       tests if string input has at least one nested switch
###################  sets nested_switch[0] = True
def jumanji(y):  #instead of this I just do a count for endswitch which is just one line of code. 
	#print("--------------------------")
	#print(" --- J U M A N J I -------")
	#print("--------------------------")
	#print("this determines if it's a nested switch with a nested switch or more in it")
	#print("testing jumanji() counting switches and endswitches")
	#just some sample ifs to read what's the input look like 
	#print("this is looking into the string below")
	#print(swo)
	#print("--- end of string that we will analyze ---")
	#print("")
	#print("get count of lines startingwith switch in the string")
	#this counts switch number in the string
	switchcounter=0
	for line in y.splitlines(): #determine if switch is in line
	#this looks for switch in the line but endswitch can't be in this line
		if "switch" in line and "end" not in line:
			switchcounter += 1  ## SWITCH COUNTER
			#print("switchcounter=",switchcounter)
			#print("yea this starts with switch")
			continue
		else:
			continue
	#print("total switches =",switchcounter)
	
	##============================
	#this counts endswitch number in the string
	#print("get count of lines startingwith endswitch in the string")
	endswitchcounter=0		
	for line in y.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line: 
			endswitchcounter += 1  #END SWITCH COUNTER
			#print("endswitchcounter=",endswitchcounter)
			#print("yea this starts with endswitch")
			continue
		else:
			continue
	#print("TOTAL endswitches =",endswitchcounter) #endswitchcounter
	#print("end of this checker ===========")
	#print(" total switches",switchcounter, "and total endswitches",endswitchcounter)
	
	#this sets the flag in nested_switch[0] if at least one nested switch
	#===============================================
	#if one or more switch and one or more endswitches
	if switchcounter > 1 and endswitchcounter >=1: #actually if endswitchcounter 1 it's True
		nested_switch[0] = True
	else:
		nested_switch[0] = False
	
	#print("the result of this test for if this has nested switch(es)") 
	#print("this is the list with the critical nested_switch[0] value")
	#print("WHAT DOES THIS SAY --  it should be True")   
	#print("nested_switch[0] = ",nested_switch[0])
	#print("=================")
	#print("=================")
	#print("this  below this is dog breath that doesn't work")
	#print("====== end of this initial switch counter filter that will eventually")
	#print("=== trigger bypass205 to do multiple switches ====")
	
	
#end jumanji()  ===================||	








# ibm list is used for holding switch strings 
ibm=[]
ibm.append(0)

use_number=[]
use_number.append(0) #[0]



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





print("the one below this line should produce 2 switches and one with 10,20")
#this find the location one one pair of a nested switch and end switch

#this gets the start and end from samplestring
#empty_switch_and_endswitch_list_locations()



#loop
#pairlist is actually a list 
pairlist=[];theforce=[]
#this would just add the switch location
alpha='';beta ='';counter =0;jedi='';
#this reads in data from switch_location
#               and from endswitch_location
#======================================================
# fill_pairlist_with_switch_and_endswitch_pairs(yy):
#======================================================
def fill_pairlist_with_switch_and_endswitch_pairs(yy):
    #print("====fill pairlist with switch and endswitch pairs()=====")
    #print(" godzilla ruled over rodan ")
    get_switch_and_endswitch_locations(yy) #===== using sample stringh 
    #print("this is grabbing the switch locations which are dynamically added to a dictionary for pairlist")
    #print("the length of switch location =",len(switch_location))
    #print("the length of end switch locatoin =",len(endswitch_location))
    #print("==============...............============")
    # loop thru list switch_location ==============================
    counter =0;allpha='';beta='';           #so this is one small set switch and endswitch line numbers
    for item in switch_location: #this loops thru the list switch_location          
        alpha = switch_location[counter]
        beta  = endswitch_location[counter] #they should be the same length 
        #here the positions are appended to pairlist dictionary
        pairlist.append([alpha,beta])       #always in sets of 2 #adds alpha and beta as list into pairlist  list
       # print("pairlist=",pairlist)
        counter += 1
    #print("======================")
    newcounter=0
    #print("the length of the pairs =",len(pairlist));print('let me see what is in pairlist')
    #print("pairlist=",pairlist)
    for item in pairlist:  #this is the combined pairlist
        #print(item)
        sosmart = pairlist[newcounter] #here I access first and second numbers in pairlist
       #print(sosmart[0]);print(sosmart[1]) 
        #print("====== JEDI TEST ========")#not to be confused with jumanji above 
        #this takes in data from switch_location list and endswitch_location
        # and glues them together into a new pair list into 
        # list called theforce
        #this is constructing filling the data in the dictionary pair values
        jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
       # print('jedi=',jedi) #like this [12,16]
        
        #put pairs into list into jedi and append to theforce
        theforce.append(jedi) #the pair is added  to theforce list
        turbo  =theforce[newcounter]
        newcounter += 1
    # print("theforce=",theforce)
    #print("the length of theforce list =",len(theforce))
    #print("did we make it this far... in a galaxy")
    #adding loop here to test this
    #print("doing a newest test  christmas tree of the pairs in list theforce")
    acounter=0
    #print("====magic brew time=====")
    #print("== the filled list with pairs of switch endswitch is called theforce ===")
    for item in theforce:
        #print(item)
        #print("=======")
        cool =item
        #print("cool=",cool)
       
        #print("acounter=",acounter)
        x=''
        x = cool.split(",")  # see if this trick works
        #print(x[0], x[1]) # see if this trick works
        #print("end game")
        acounter += 1
        continue
   # print("end of printing each item in theforce")
###=====





thisdict ={}


def cleanse(x):
    x = eval(x)
    return x;
    
#modified this method on august 11th wednesday, 1:11pm
############################################
##     adding data list to dictionary
############################################
def adding_data_list_to_dictionary(dictname,key,newdata_list):
    #print("LOOK AT THOS at input params see if they are right first")
    #print(dictname)
    #print(key)
    #print(newdata_list)
    return #temporarily halts this from running
    
    #print("called adding data list to dictionary")
    #tryit =eval("" + dictname + "[" + key + "]" + "= " + newdata_list +"")
    #tryit =eval("" + 
    angel =dictname
    thekey= key
    newdata_list
    #print(angel)
    #print(thekey)
    #print(newdata_list)
    #print("====>>>====>>>end of games...")
    #print(tryit) #to see what it sees
    
    #thisdict["4"] = "[12,22]" #adding data list as string to dictionary
    
    #eventually I will add 1 to dictionary length
    
    ##########################################
    #dictname + key + [12,22] input format 
    ##########################################
    #dictionary name should be known
    # print(thisdict)
    #for item in thisdict.values():
    #    print(item)
    #print("testing getting value in dictionary by key")
    x = thisdict["4"]
    
    #x = thisdict.get("4") #this should work also
    #print(x) #together
    x = eval(x)#just dreamed this up and it worked
    # print("this represents getting the x and y for a nested switch locations")
    #print("first number",x[0])#seperate
    #print("second number",x[1]) #separate
    
    
        
#OUTPUT
'''
called adding data list to dictionary
{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, '4': '[12,22]'}
Ford
Mustang
1964
[12,22]
testing getting value in dictionary by key
[12,22]
first number 12
second number 22
'''
#print("fast wile e coyote test  adding data list to a dictionary")
#print("==========")
#print("==========")

# october 28th, 2021 thirstday
# I need to go thru combined pair list three + five + seven and feed it into a dictionary

## its really get index pair in struct
#### get_number_in_struct(x)   THIS WORKS!!!!!!!!!!! oct 26th



pair_returned=[]

##======================================
##  get_number_in_struct(x):
##==================================
def get_number_in_struct(x):
    #print("get_number_in_struct(x) called")
    #print("the input was x",x)
    #print("get_number_in_struct(x) called too cool")
    #print("get ",x)
    ##using eval() to do thisdict.get(x)===###################
    apple_pie=eval('thisdict.get(x)')
    #print("=====///get number in struck(x) called---------///")
    #print("get number ", str(x), " in struct with x called")
    #print("apple-pie=",apple_pie)
    super = apple_pie
    if apple_pie == None:
        pass #print("it is None")
    else:
        #print("why not",super[0],super[1])
        #print("now splitting it into the two numbers within the pair of switch endswitch")
        # print(super[0])
        #print(super[1])
        #doing this to have common lists for passing on to other functions later
        pair_returned.append(super[0])
        pair_returned.append(super[1])
        #print("pair_returned at this point has",pair_returned)
#=============================================


   

#=======================
#add data to struct
#======================

#print("no time for pumpkin carving")
#numb = number and aset = [start,stop]
aset=''
numb=''
# this method works on oct 26th 2021
##==============================================
## add_data_to_struct(thisdict,numb,aset)
##====================================================================
def add_data_to_struct(thisdict,numb,aset):
    return #abandoning this too confusing going with just a list of lists
    #print("add data to struct")
    #print("numb=",numb)
    #print("aset=",aset)
    #numb='12' #the number will keep a rolling total and added automaticaly
    thisdict[numb] = aset  #this just seems too simple.
    #print(thisdict) 
    
#add_data_to_struct(thisdict,numb,aset)
##============================

gooddata=[]
##==========================================
## get value in dict (name ofdict,x)
##==========================================
def get_value_in_dict(name_of_dict,x): # we will know the dict it won't change
    return #abandonning this for being too confusing and unworkable at this time
    #print("plumtree=",plumtree)
    #print(thisdict)
    #print("get value in dict",x)
    nn = plumtree.get(str(x))
    #print("================")
    #print("using key",x,"it retrieved from the plumtree dictionary",nn)
   # print("================")
    # I was assuming (wrongly) that all keys input would be in dictionary; unknown
    if x in thisdict: #it can't be this simple
        y=eval("plumtree[x]")
        #print(y)
        del gooddata[:] #clears it out 
        #print(y[0],y[1])
        gooddata.append(y[0])  #this returns with the index[0][1]
        gooddata.append(y[1])
    else:
        pass #print('x',x,'is not in dictionary plumtree')
    


plumtree={} #new dictionary
####=======================================================
#feed list of pairs into dictionary (such as blueberries)
#print("testing looping thru list")
#this represents a list of sublists of the switch,endswitch pairs
#I need to make testlist
#testlist=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]

returnlist=[]
returnlist.append(0)
#I can make my own custom methods to get from list
#the list is actually referenced starting from 1 where I start the counter
##==============================================
##  get_pair_from_testlist(x):
##==============================================
def get_pair_from_testlist(x):
    #print("=========get_pair_from_testlist=========")
    #print("testing get_pair_from_testlist",x)
    counter = 1
    #print("inside the loop we see for x this ",x)
    for item in testlist: #it doesn't really loop, it's a one pass loop
        #if number entered bigger then length of list warn then break    
        if x > len(testlist): #error detection bypass worked 
            #print("ERROR went beyond number length in list")
            #print("please enter a number less than ",len(testlist))
            break
        #if number entered less than 1 warn then break
        if x < 1: 
           # print("ERROR number must be 1 or higher")
            break
        if counter == x: #it matched with a doable number
            print(item)
            alpha = item[0]
            beta  = item[1]
            #print(alpha,beta)
            returnlist[0] = [alpha,beta]
            #print("returnlist[0] =",returnlist[0])
            break
        else:
            break
##==============================================================



#Okay. I need to fill the testlist from the threetabs, five tabs seven tabs nine tabs



#the list with the pairs is in testlist

#this dictionary is being abandoned for over complexity and confusion
# november 3ed 10:03 am morgan hill

#this reprents looping thru the testlist and filling data into the dictionary and populating it
##====================================================
##  fill_the_struct_dictionary_with_the_list()
##====================================================
def fill_the_struct_dictionary_with_the_list():
    return
    #print('fill the struct dictionary with the list')
    counter=1
    # loop
    for item in testlist:
        #print(item)
        aset=[item[0],item[1]]#this creats teh apirs 
        numb=str(counter) #making it a string here . clever
        thisdict=plumtree
        #add_data_to_struct()
        add_data_to_struct(thisdict,numb,aset) ###==============
        #print("=======")
        counter += 1

        #print("plumtree DICTIONARY now looks like this")    
        # print(plumtree)
        #print("here we go time to see it work===looping thru plumtree struct=====")
        for x in plumtree.values():
            print(x)
    
        #print("===========")    
        #for k, v in plumtree.items():
        #   print(k, v)




def testing_pair_list():
    return #not testing this right now
    # print("length of theforce=",len(theforce))
    #     print("together_pair=",together_pair)
    #     print("======testing pair list() == fireworks time in tahoe ====")
    #     print("theforce[0]=",together_pair[0]) #first pair coordinates start stop
    #     print("theforce[1]=",together_pair[1]) # second pair coordinates start stop
    #     print("===starting loop thru list theforce =======")
    #     newcounter=0
    #     print("dog breath test")
    #     for item in together_pair:
    #         print(item)
    #         #this only works for two numbers 2 number long currently
    #         dog = together_pair[newcounter] #here I access first and second numbers in pairlist
    #         x = dog.split(",")  # see if this trick works
    #         print(x[0])
    #         print("doing surgery cutting off first character")
    #         charlie=''
    #         charlie = x[0]
    #         super=x[1]
    #         print("super=",super)
    #         print("=====")
    #         charlie = charlie[1:]
    #         print("charlie =",charlie)
    #        
    #         super =super[:-1]
    #         print("super=",super)
    #         print("===...=.=.=.=.=.=.=.=.=.=.")
    #         print("===...=.=.=.=.=.=.=.=.=.=.")
    #         charlie=''
    #         charlie = x[0]
    #         charlie = charlie[4:]
    #         print("charlie =",charlie)
    #         #print(x[1])
    #         print("==========")
    #         newcounter += 1 #python doesn't have ++
    #         
    #     print("=== end of looping thru list =======")
    #     













######################################################
list_of_switch_range=[]
list_of_switch_range.append(0)
list_of_switch_range.append(0) #was 10 hard coded 
list_of_switch_range.append(0) #was 20 hard coded

#list_of_switch_range[1] = switch_location
#list_of_switch_range[2] = endswitch_location
##############################################################
## july 17th, 2021 11:12 am
#print("IS THIS WORKING OR NOT ==========")
#here we feed the input switch and endswitch into range lists
#THIS WORKS FOR JUST ONE INNER NESTED SWITCH 

anest_string='''
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''
print("wild wild west test...")

###########################################============
#experimenting on nov 4th thursday 
get_first_switch_test='''
			switch(exp){ #21         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''

get_first_switch_da='''
			switch(exp){ #  54         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					switch(exp) # 98
					break
				default:
					print("we are done here")
			endswitch 
'''

# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)




got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname):
##====================================================
def get_switch_number_at_top_of_string(stringname):
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		#print(line)
		#print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			#print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			#print(stringname)
			break
		else:
			counter += 1
	return y;


# here I would add the strings in quail after they have been separated
# and they are in the list mytestlist. I then apply a method to each
# string to get teh switch number at the top and append it 
# to the list got_the_number
 # I will need to loop thru the quail list of the seperated switch strings
 # and append the strings within to mytestlist
 #so actually I would loop thru quail list and call get switch number

mytestlist=[]
mytestlist.append(get_first_switch_test)
mytestlist.append(get_first_switch_da)
del got_the_number[:] #clear out this list at the beginning

#loop thru list with thes trings
#feed the strings into method get switch number at top first switch
##=====================================================
## get_first_switch_number_from_all_strings()  fly jets
##=====================================================
def get_first_switch_number_from_all_strings():
    #print("get_first_switch_number_from_all_strings()")
    for item in mytestlist: #this will be quail list before parser
        get_switch_number_at_top_of_string(item)


#get_first_switch_number_from_all_strings()
#print("really got_the_number=",got_the_number)



#
'''
 this transfers the line location of switch and endswitch
 to list of switch range 1 and 2 from 
 switch_location and endswitch_location
'''
#28,38 for second string
# I am skipping using this now NOT using this method 
##################################################
##  get_one_nested_switch_start_and_finish()
##################################################
def get_one_nested_switch_start_and_finish():  # this gets the input from switch_location[0]
    return
    #print("get_one_nested_switch_start_and_finish()")
# and from  endswitch_location[0]

## this takes in the two lists of list_of_switch_range[1] and list_of_switch_range[2]
    #print("=== ||=== get one nested switch start and finish line numbers")
    #force feeding it the second nested switch location input data 
    #these are hard coded for testing 

    list_of_switch_range[1] =switch_location[0] #force it in here
    list_of_switch_range[2] =endswitch_location[0]
    #list_of_switch_range[0]=0
    #list_of_switch_range[1]=10
    #print(list_of_switch_range[1])
    #print(list_of_switch_range[2])
    #list_of_switch_range[2]=20


the_nest_string= fridge[0] 



testing_string_list=[]

#this is what has the string_with_nested_switches in it
# THIS TAKES TABS OUT OF THE ENTIRE NESTED SWITCH 

###===================================================
#abvoe this line are the test input strings for switches






teststringgonow='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''
funky='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch 
'''

###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	#print("======starter engine called======")
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #had "not"
			tabdepth = line.count("\t")
			n= tabdepth;n = n-1  #need to have one tab in front
			break
	passthis[0]= n;
	#print("n =",n)











goldtime=[]
goldtime.append(0)
##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
##  methods: starter_engine()
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    #print("====modern tab shifter to left=======")
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
   




catching_first_change=[]






##########################################
##  take_out_x_tabs_from_front_of_line(n):
##########################################
def take_out_x_tabs_from_front_of_line(the_nest_string):
	starter_engine(the_nest_string);n=passthis[0]
	#print("take out ",n," tabs from front of line - of string")
	#print("take_out_x_tabs_from_front_of_line(n)") #make this is into a method 
	#print("n=",n)
	#get tab count in line with switch and counter =1
	#should be governed by the first line with switch 
	
				
	wildness=''
	#print('half way down n =',n)
	for line in the_nest_string.splitlines(): #nest_string
		
		newline = line[1:]
		#print(newline)
		
		if n == 4:
			wildness += line.replace("\t\t\t\t","\t") 
		if n == 3:
			wildness += line.replace("\t\t\t","\t") #strips one right
		if n == 2: #this leaves 1 tab in front of each line
			wildness += line.replace("\t\t","\t") #strips one right
		if n == 1: # we only one one tab in front of the switch word as the guidepost
			pass #do nothingwildness += line.replace("\t\t","\t") #strips one right
		wildness += "\n"
	#print("after minor surgery see if this works")
	#print(wildness)
	fridge[0] = wildness
	return wildness # this worked



#store in a dictionary each pair of switch and end switch params
# then I loop thru it with the numbers

####============ july 19th 2021  Monday ===================
# I already have the code to build a list of all switches and endswitches
# but I need to put them into a dictionary when I do that search to capture them as pairs

##================================



alist=[]
alist.append(0)
alist.append(10)
alist.append(20)
alist.append(30)
alist.append(40)

color_table={
    "brand":"mocha",
    "Red": [10,20],
    "3": [30,40]
}




friend1=[]
friend2=[]

thisdict =	{
  "1": [4,7],
  "2": [10,20],
  "3": [21,30]
}
for x in thisdict.values():
  print(x)
  cool = x
  print(cool[0])
  print(cool[1])
  friend1.append(cool[0])
  friend1.append(cool[1])
  print("good times")
  print(friend1)
  

mylist=[]

mylist.append(3)
mylist.append(4)
mylist.append(5)
mylist.append(6)

testlist =[]
testlist=[1,2,3,4,5,6,7,8,9,10]






#dictionary called pears
peartree = {}  


#given name peartree of dictionary
def get_value_of_key_original(x): #peartree hardcoded in
    car=eval("peartree.get('" + str(x) +"')")
    print(car)
    return car #so if it is a list it should return a list right?z









###################################################################||

#######################
peartree = {}   #this will always exist and needs to exist to work.
buton=[]   #this is the passing of the buton in track and field relays
buton.append(0) #two positions here in this inner list
buton.append(0)
########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists

def add_data_to_pears(x,apple):
    print("add_data_to_pears()",x,apple)
    peartree[x]=apple  #this is where the list is added
    print(peartree)

################################################
###### TESTING FILLING A DICTIONARY ############
###############################################@

# I will nede a loop
# july 21st, 2021
#this looks into peartree for a key to return a value
# the values it put into buton[0]and buton[1]
 
# this is accessing the peartree
##############################
##  ACCESS_SWITCH_1_N
##############################
def access_switch_1_n(t):
  return
  print("access_switch_1_n() called")
  print(peartree.get(t)) #was '1'
  one=peartree.get(t)
  print(one[0])
  print(one[1])
  #################
  # added July 21st
  buton[0]= one[0]
  buton[1]= one[1]
  print("this is looking into buton list")
  print("================//================")
  print("buton[0]=",buton[0])
  print("buton[1]=",buton[1])
  print("================//================")
  ##################
  print("I can now grab")
  print("the nest switch params")
  print("from the pear tree")
  print("to feed  copy nest method")
  print("first",one[0],"second",one[1])

#this is accessing the pears dictionary to get the data by the key
### this calls the method above   


###############################


#<href="https://discover.cs.ucsb.edu/commonerrors/pythonerrors.html"> python common errors UC Santa Barabara</a>

########
b=''


#==================================================================






#new pears

#creates this

# what this does is add ..  # 66  the line number after each switch(exp){

#print("TWIN LIST let's take a look and see what's in it")
#print("let's look inside of twinlist",twinlist)
#they have to be in the same order as the actual switch cases

'''
##================
======1:3==========                   switch1 > switch11 and switch49  =========
switch1
     switch11 method 3 tabs first number from pair 11,47
     switch49 method 3 tabs first number from pair 49.73
end73
#==============================       switch11 > switch15  =======
only switch at 5 tabs between 11 and 47
#minor 3 tab to 5 tabs  Copy 11 thru 47 TWO
switch 11  3 tabs
     switch 15#method  5 tabs   must be between 11 and 47
switchend47
#=============================         switch49 > switch53    ======
#minor 3 tab to 5 tab   THREE
only switch at 5 tabs between 49 and 73
switch 49
     switch 53 method must be between 
endswitch73
##====================  FOUR           switch15  > 23 =======
#minor  5 to 7 tabs   
only swith at 7 tabs between 15 and 38
switch 15
     switch 23 method
##====================  FIVE           switch23  none ======== by itself
#minor none 7 tabs not nested because no 9 tabs its an end tail
switch 23      
$$$$$$$===================================================$$$$$$$$
# I need to be able to generate the pattern
if tab depth == 3 then
first number of pair[0] is nested switch 11 and 49
     switch11 method  first number from pair 11,47
     switch49 method 
     
=======3:5
if tab depth == 5 then
first number of pair[0] 15 goes inside minor 
three tabs to five tabs
switch 11
     switch 15#method   must be between 11 and 47
switchend47
===== 3:5
[49,73],[3]=== [53,64],[5] if secondpair[0] > firstpair[0] and 
switch 49
     switch 53 method must be between 
endswitch73
#testing this
combinedtabs=[]
combined_tabs = threetabs + fivetabs + seventabs
#threetabs= [11, 47, 49, 73] done 
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]
'''
#print("testing merry christmas code")
#print("obviously this is a thinking and engineering problem")
threetabs = [[1, 2],[3, 4]] 
fivetabs  = [[5, 6],[7, 8]]
seventabs = [[9, 10]]
#testing this
fuel=[threetabs,fivetabs,seventabs]
combinedtabs_jazz=[]
combine=''
fulllist=["threetabs","fivetabs","seventabs","ninetabs","eleventabs","thirteentabs","fifteentabs"]

#def grab_these_tabs(x):
    


upto7 = "threetabs + fivetabs + seventabs"
combined_tabs_jazz = eval(upto7)
#print("combined_tabs_jazz=",combined_tabs_jazz)
#for item in combined_tabs_jazz:
#    print(item)
    

#laketahoe
combined_tabs=[]
##========================================================

table=[]
table.append(0)
#============================================================
## check_if_nested_switch_inside_this_switch(astring): 
## returns table[0] = False or True
# coded on dec 6th monday 12:== noon ish

#==========================================================
def check_if_nested_switch_inside_this_switch(astring):
    #print("check if nested switch inside this switch")
    counter=0
    table[0] = False
    for line in astring.splitlines():
        tabcount=line.count("\t")
        if tabcount == 3  and "switch" in line and "end" not in line:
            table[0] = True
            #print(line) #proof is in the pudding - how good is it
            break
            
            
            
            
            
##### this does absolutely nothing 
# I need to make a method to add main switch to string list
def add_main_switch_params_to_dictionary():
    return
    print("how it will work")
    #methods count end switches
    #Take answer add 1
    #loop thru input switch string get total number of lines
    #"3" : [1,44],  #is the result
    #call method to add it to dictionary


     




#######=========================================
#
##==============================================
def do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring):
	#print("do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up")
	#this 
	genius[0] = inputstring
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	
	




flag_test=[]  
toosmart=[]
toosmart.append(0)
baton=[]
baton.append(0)
 
flag_test.append(False) #set flag_test by default to False
#flag_test[0]
# x is the name of the string to be modified
switch_list=[]
endswitch_list=[]
thenewpairs=[]

##============================
##  buildpairlist()  created nov 21st, sunday to manage doing the main switch 
##============================  and cutting out switches at three tabs for main switch 
def build_pair_list(stringname):
	print("====== build_pair_list called ======")
	counter =0
	#flush lists
	switch_list=[]
	endswitch_list=[] #should reset them both 
	#thenewpairs=[]
	#del endswitch_list[:]
	#this fills up the switch_list line
	#===================================
	# LOOP FILLS UP SWITCH_LIST 
	#===================================
	#loop thru stringname and fill up switch list
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line:
			switch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	counter =0
	#loop thru stringname and fill up endswitch list
	#this fills up the switch_list line
	# =======================================
	# LOOP FILLS ENDSWITCH LIST 
	#========================================
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "endswitch" in line :
			endswitch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	del switch_list[0]     #delete first switch number which is on line 1
	del endswitch_list[-1] #delete last number endswitch which is end of entire string
	print("after deleting first and last switch we have..")
	print("switch_list=",switch_list);print("endswitch_list=",endswitch_list)
	counter=0 #build the pairs and put them into sweet; then append sweet to thenewpairs list
	#===================================================================================
	# LOOP FILLS THENEWPAIRS LIST WITH SWEET WHICH HAS SWITCH,ENDSWITCH LINE NUMBERS
	#===================================================================================
	for item in switch_list:
		sweet=[switch_list[counter],endswitch_list[counter]]
		thenewpairs.append(sweet)
		counter += 1
	print("this is what we want to see at starbucks")
	print("thenewpairs=",thenewpairs)
	#==================================
	# LOOP PRINTS OUT THE NEWPAIRS LIST
	#==================================
	for item in thenewpairs:
		print(item)
		print('stop here for now')
		#exit()
	#REVERSE THE NEWPAIRS LIST BECAUSE IT HAS TO BE DONE BOTTOM UP TO THE STRING 
	thenewpairs.reverse() #they have to be skipped bottom up to work properly
	print("thenewpairs=",thenewpairs)	
	print("resulting list of thenewpairs =",thenewpairs)



pinkpanther=''
##===========================================
##  skipping_some_lines() #this works
##===========================================
def skipping_some_lines(thestring,start,finish):#input string, switch number then endswitch line number  ....start line nest switch and finish  endswitch
	return
	print("METHOD  skipping_some_lines() called==========")
	print("======= skipping_some_lines() ================called",start,finish)
	# if I have a flag that it's been triggered then afterewards 
	# print("this is the input string used stating skipping_some_lines")
	# for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0]) =============================
	#if flag_test[0] == False: #meaning first pass  and what it's set to by DEFAULT
	smart=thestring;
	baton[0]=thestring #this is new
		#change it to True now
	flag_test[0] = True #this should now be tru e========================
	#else: #meaning TRUE this is run after first run of skipping_some_lines()======
		#what this does is use the new concatted changed string changed on the fly with each pass
		#for second and all subsequent passes it uses baton[0]
	thestring = baton[0]#====================
	#print('what is in baton[0]',baton[0])
	##==========================================================
	# the issue is that on the second pass it is using the original string
	# and it needs to be using the modified string
	# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
	# because the numbering system of the string starts from 1 too.
	### look that we have the counter here set to 1 by default 
	counter=1; concatthis =''; #finish = finish + 1 
	print("start=",start,"finish=",finish) #I took out x = 
	#smart=x;
	print("inside of skipping lines before going thru the loop this is the value of")
	print("the input string it will mess around with")
	#print(smart)
	print("=== ah now I get it these are the lines that it MUST SKIP and we want what is before and after this range to create the modified string =")
	print("it sees in start",start)   #this is a number
	print("it sees in finish",finish) #this is a number too
	##=================
	#so I would build pair list of inner switches at 3 tabs and then loop thru them to skip them
	#this is new on sunday november 21st 2021
	#what I want to skip on the fly without range data
	
	#------------------------------------------------
	#from switch at 3 tabs until endswitch at 3 tabs
	#skip the lines inbetween leaving switch word
	##----------------------------------------------
	
	
	##=============== this is a new addition to automate the grabbing of inner switches ====
	# this creates pairs of the switch, endswitch pairs 
	#if start == 1 and finish == 1: #meaning figure out pairs on the fly
	
		
	#exit()
	counter=0
	#for item in thenewpairs:
	#	start  = item[0]; print("start=",start)
	#	finish = item[1]; print("finish=",finish)
	#check thype
	print("checking tyhpe of thestring")
	print(type(thestring))
	print(thestring)  #it shows 0
	print("what is it?")
	print("starting baton[0] has teh initital input string in it")
	for line in thestring.splitlines(): #smart = x
			#this preserves the switch word and skips the rest of nested switch body including endswitch
			# if counter is between start and finish #just after start and less than = to finish
			#just added start +1 and finish + 1
			#tabdepth= line.count("\t")
			#if tabdepth == 3 and "switch" in line and "end" not in line:
			#		start = counter
			# use while loop of course
			#so it's upside down and backwards to create the same meaning.
			# probably need to do a prescan but maybe i can do it without doing prescan
			#get location of switch and endswitch at 3 tabs
			#while "endswitch" not in line:
			#####################==================
		if counter > start+1 and counter <= finish +1: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
		##=======================================
	baton[0]=concatthis;
	print("===output from skipping some lines====")
	#print('it created this string')
	#print(concatthis)
	print("how does it look===>>> by lettuce field")
	del ibm[:] #this should empty it
	print("this is the output result of skipping some lines")
	#print(concatthis)
	#what I am doing here is putting what has been concatted in the string into toosmart[0]
	#this has red_robin hardwired into the code 
	#just commented out line below november 10th, 2021 to see wehat happens 
	#toosmart[0]= red_robin #it did say toosmart[0] = red_robin
	#just commented these out thanksgiving
	#baton[0] = concatthis  #here the concatthis has been put into baton[0]=======
	#pinkpanther=concatthis==============
	##==========================================================
	### mocha test ### this is new November 10th, 2021  ########
	never_defeated[0]= baton[0]  #just added this line 
	###########################################################
	##==========================================================
	concatthis='' #this resets concatthis to empty-
	print('in baton here we have')
	#print(baton[0])
	print('==============')
	print("now the result is here....!!!!@@@@@$$$$$")
	print(never_defeated[0])
	#ibm[0] = concatthis	  #this has the switch string with the nested switch cut out
	#putting concatthis into ibm[0] here 
	ibm.append(toosmart[0])
	print("at the bottom of the skipping some lines to take out inner switch")
	print(" it sees this in ibm[0]")
	#exit()	
	#print(ibm[0])
		#just moved this over one tab	
#exit()
#end skipping_some_lines  ========================================================
print("Levels TEST on wonderful Monday winter wonderland ")
print("this will take out the inner switch between") 
never_defeated=[]
never_defeated.append(0)

#for line in skitahoe.splitlines():
#   print(line)




#it was previously this
def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
    return
    print('this one is sooo critical')
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    skipping_some_lines(stringname,start,finish)
    #this means that the output string should be placed into never_defeated[0]
    #for line in never_defeated[0].splitlines(): #prints it after takening out. 
    #    print(line)
        

##===========================================================================
##  modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#this was redesigned and modified on sunday november 21st at 8:30am to 
# work with skipping some lines with no known locations of inner switches at 3 tabs
# and it calls method build_pair_list to find them and reverse them for input for skipping_some_lines
# and I have to subtract 1 from start and finsh
#this one is used to get the main switch and take out switches at 3 tab depth

# and loops thru list feeding start and finish  params and calling skipping_some_lines()
# #  the input for start and finish will be 1 by default but they will be overwritten
# #  by the build pair list on-the-fly.
print('this one is sooo critical')
def modified2_cut_out_inner_switch_body_leaving_switch_word(stringname):
    #it is modified so it can change more than one inner switch into a switch, infinite
    #print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    ###======= this is ingenius=========
    #METHOD BUILD_PAIR_LIST(STRINGNAME) 
    if len(thenewpairs) > 0:
        #print("==TRUE thenewpairs >0 it is ===== ",len(thenewpairs))
        del thenewpairs[:] #delete contents of thenewpairs list if it's not empty yet
    #end if
    #if len(never_defeated[0]) > 0:
    never_defeated[0]='' #deletes it
    build_pair_list(stringname)           # goes thru thenewpairs list and
    for item in thenewpairs:              # fills start and finish into skipping_some_lines params
        start  = item[0];
        finish = item[1]; # print("start,finish=",start," ",finish)
        skipping_some_lines(stringname,start-1,finish-1)#so close now 
        #the result of the concatting goes into never_defeated[0]
    #this means that the output string should be placed into never_defeated[0]
    #print("let us see what we have jazz blues line 6166 ....")
    #so it's output is in  never_defeated[0]
    thisstring = never_defeated[0]
    return thisstring; #see if this works  it is important that we return the string
   #print("let's see what it has in it and if it converts the inner switch bodies to switch word...")
    #for line in thisstring.splitlines(): #prints it after takening out. 
    #    print(line)
    cat_scales[0]= never_defeated[0]
    #print("now loop thru pinkpanther")
  
        
#manipulate_string(item) #shifts it to the left

# this is the one that is new as of november 21st and it does the main switch with
# inner switches at 3 tabs that it takes out leaving just the switch word.
#============ original============ modified2
output_list=[]
output_list.append(0)
# testing spilled_coffee string 
stringname=spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#print("input string is spilled_coffee  =========")
#print("doing first attempt of converting inner switch bodies to just the switch word")
mybaby =''
mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)
#print("did this sucker work tuesday november 23?")
#print("now loop thru the output if it generated it")
#print("this is the resulting output processed by the modified2_cut_out... function")
#for line in mybaby.splitlines():
#    print(line)
    #print("======") 
#print("end of first string test for reducing switch bodies to switch word") 
#print("=== made it to this point after first attempt completed ===")  
#print("now a SECOND ATTEMPT AT CALLING THIS METHOD NOW. WEIRD AT LEAST FIRST PASS WORKS ==")
## testing skitahoe string
#stringname=skitahoe;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#print("just testing 2nd one with skitahoe string to see if it works ==input sstring is spilled_coffee")
mybaby =''
#worked by itself
#print("doing skithaoe string now=============")
#stringname=skitahoe
#mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)


    
#ram = never_defeated[0].replace("switch","rocks")
#never_defeated[0]= ram
#for line in never_defeated[0].splitlines():
#    print(line)
#exit()
#==================================
print("end of deifnitely working modifies2 cut out inner switch body.()")


#stringname=skitahoe; start=7; finish = 14; #this sucker was moving....    
#cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
print("let us see what we have.")








#this requires this function below to be called first though
#  smart_cut_out_inner_switch_bodies_at_three_tabs(samplestring)
pairset=[]
genius=[]
genius.append(0)

never_defeated=[]
never_defeated.append(0)
list_of_inner_switches_at_three_tabs=[]
list_of_inner_endswitches_at_three_tabs=[]




##========================================================
## loop_thru_pair_set_and_call_skiplines(samplestring)
##=========================================================
def loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring):
	print("len(never_defeated) =",len(never_defeated))
	#never_defeated[0] = thestring #this takes the initial string put into never_defeated[0]
	never_defeated.append(thestring) #maybe this is what I need to do to fix this bug
	print(never_defeated[0]) 
	counter =0
	#loop thru pairset of sets of switch,endswitch (already reversed to go bottom up)
	for item in pairset: #the pairset list was filled in smart_cut_out_inner_switch_bodies_at_three_tabs
		alpha = item[0];beta  = item[1];print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		#METHOD skipping_some_lines()============= uses never_defeated[0] stirng in list
		skipping_some_lines(thestring,start-1,finish-1) #added -1 on Mon Nov 22nd 2021 9:00 AM
		#doing this to see if it cut out the inner switch body 
		print("this is showing the changes reducing switches in never_defeated[0]")
		mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
		print("this is what the switch string looks like after taking out a switch body")
		counter += 1
	








##====================================================================
##  make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring)
##====================================================================
def make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):
	#print("METHOD make_Pair_set_of #### called  ... make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):")
	counter =0
	#print('let us look at this string to see what it sees')
	#print("========//////////==========///////==============")
	#for line in inputstring.splitlines():
	#	print(line)
	#print("========//////////==========///////==============")
	for line in inputstring.splitlines(): #smart = x
		#this preserves the switch word and skips the rest of nested switch body including endswitch
		#for this line get tab_depth
		#print("this is where I add the switch line number to list of inner switches at three tabs")
		tab_depth= line.count("\t") #but this presumes just one inner switch there could be more
		#if 3 tabs True AND switch in line and end not in line and counter > 1 
		if tab_depth == 3 and "switch" in line and "end" not in line and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_switches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	#print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)		
	#second new loop but looks for endswitch locations at 3 tabs 
	counter =0
	for line in inputstring.splitlines(): #smart = x
		#print(line)		
		tab_depth= line.count("\t")
		#print("this is where I add the endswitch line number to list of inner switches at three tabs")
		if tab_depth == 3 and "endswitch" in line  and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_endswitches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	#print("==================")
	#print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)	
	#print("list_of_inner_endswitches_at_three_tabs=",list_of_inner_endswitches_at_three_tabs)		
	#print("===================")
	#print("===== end of phase 1 =====")
	##======================================================================================
	#print('doing Friday debugging oh what fun it is to ride in a one horse open sleigh')
	if len(list_of_inner_switches_at_three_tabs) == 1:
		print("this means only ONE dam pair")
	else:
		#print("the length is =",len(list_of_inner_switches_at_three_tabs))
		cat = len(list_of_inner_switches_at_three_tabs)
		#print("the length of inner switches at three tabs is ",cat)
	###=================================================================	
	#print("now I need to make pairs")
	get_number = len(list_of_inner_endswitches_at_three_tabs)
	
	if get_number == 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	##=======================================================================		
	if get_number > 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	else:
		pass #print("there is only one switch endswitch so do regular mode just one inner switch at 3 tabs ")
	if get_number > 1:
		pairset.reverse()  # REVERSE PAIRSET SO THAT I CAN CHANGE THE INNER SWITCHES BOTTOM UP
	
	print(pairset)
	print("loop thru pairset") #to go thru input string and reduce inner switches to just switch word bottom up
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
	##======================================
	print("method to go thru pairset and call skipping_some_lines(start,finish)")
	do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring)
	#########====================================



fullhouse=[]
##============================================================================
##  take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word
##----------------------------------------------------------------------------
##  Methods: make_pair_set_of_inner_switches_at_three_tabs_depth(thestring) oh wow genius here
##  Methods: loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
##  Methods: skipping_some_lines(x,start,finish)
##  Methods: determine_if_inner_switch_inside_of_this_switch_string(weasel)
##  result of modified string put into  fullhouse.append(never_defeated[0])
##============================================================================
def take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring):
	return #not being used
	
	#print("THIS NEEDS TO WORK NOW==")
	#print(" take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring)")
	baton[0]=thestring
	#print("called ....take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestring)") 
	make_pair_set_of_inner_switches_at_three_tabs_depth(thestring)
	#print("this is scenario where if one inner switch it's not filling the pairset")
	#print("pairset=",pairset)
	loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
	#print("list_of_inner_switches_at_three_tabs=", list_of_inner_switches_at_three_tabs)
	#print("list_of_inner_endswitches_at_three_tabs=", list_of_inner_endswitches_at_three_tabs)
	#print("pairset=",pairset)
	#print("this should be the result of the switch with inner switches cut to just switch word, bodies gone")
	#for line in never_defeated[0].splitlines():
	#    print(line)
	##################################################
	## adding resultof output of methods of taking out inner switches into never_defeated[0]
	## which is put into list fullhouse using append
	### this is where the result of the change string put into never_defeated[0]
	### is appended to list fullhouse
	fullhouse.append(never_defeated[0]) #needs to be here obviously
	#-------------------------------------
	#if it is here then it's called ONLY after the first one has completed and thereafter
	#==================================================
	## this resets super important lists utilized 
	never_defeated[0]=''
	list_of_inner_switches_at_three_tabs.clear()
	list_of_inner_endswitches_at_three_tabs.clear()
	pairset.clear()
	baton[0]= ""
	



#print("====STARTING ATTEMPT 1====== charlie brown music is the best jazz ====")


#take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(spilled_coffee)




result_of_check_if_inner_switch=[]
result_of_check_if_inner_switch.append(0)

#coded on november 19th friday at 10:48 am morgan hill starbucks
##====================================================================
## determine_if_inner_switch_inside_of_this_switch_string(weasel):
##====================================================================
def determine_if_inner_switch_inside_of_this_switch_string(weasel):
    print("determine_if_inner_switch_inside_of_this_switch_string(weasel):")
    ## START INNER LOOP ======= devised on nov 19th friday 10L30 am ===========
    innerswitch= False #this must be set to False before each call below 
    result_of_check_if_inner_switch[0] = False
    for line in weasel.splitlines(): #this looks for an inner switch at 3 tabs depth
        tabdepth = line.count("\t")
        if tabdepth == 3 and "switch" in line:
            #print("where's the party THIS string has an inner switch ")
            innerswitch = True
            result_of_check_if_inner_switch[0] = True
            break
        else:
            continue
        #print("....")
    #print('this has to be called after the loop is done')
    print("result_of_check_if_inner_switch[0]=",result_of_check_if_inner_switch[0])
    #end loop ===================


funtestlist=[]

#print("big bird for prez")
#print("testing in my mind wed november 10th test ..going thru list and calling take out switch bodies.")
funtestlist=[samplestring,samplestringzoo1] #samplestringzoo1
#use the list I made earlier catching_first_change




#modified to get nested switch #so after the first switch in the string 
#so it gets the switch that is nested.
###============================
## get second switch number
##=============================
def get_second_switch_number(stringname): #this might be for when
# I create copies of the switch body strings
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		if "switch" in line and "end" not in line and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;
	
	


#peachtree=[]
#several_three_tab_switches_list=[]
## get second switch numbers check if many #returns list of inner switch id numbers

##==========================================================
# the issue is that on the second pass it is using the original string
# and it needs to be using the modified string
# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
# because the numbering system of the string starts from 1 too.
	
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1	
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
#stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)
#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##========================================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##========================================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	#print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		pass #print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		pass #print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	#print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	#print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)





##=====================================================
##  modern_take_out_endswitch(string):
##======================================================
def modern_take_out_endswitch(inputstring):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():





# instead what if I feel a list of switches at 3 tabs and endswitches at 3 tabs
# and make pairs and then use the skip robe which already works and that way 
# I will reuse working code and based on the length of the switch list I just
# look in both lists at the same location position 0 and then 1 etc.
#print("big test....starbucks morgan hill ========")

switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	
	
	
#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	#print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	#print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	#print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("switch_list=",switch_list)
	#print("endswitch_list=",endswitch_list)
	#print("end of line...")
	########################======
	
	########################==========
#print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function










#what this does is go thru a list that is in reverse order to cut out thru skipping
# a string to take out inner switches at 3 tab level.  it actually works.
# I need to have a modified one if only one list 

#we will have a loop ::; put this together on Friday, October 22nd, 2021 at 11 am
#string_after_cutting_out_inner_switch_body[0]= False 
#if len(inputlist) == 1:  good if only one list and reverse calls it does nothin
#what this does is loop thru a list of switch endswitch at 3 tabs and does more than one


###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    print(" ====convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):==== ")
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        #print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
    

	
#print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
inputlist =[]


#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================
def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]

	counter=0;
	for item in switch_list:
		pair=[switch_list[counter],endswitch_list[counter]]
		trialinputlist.append(pair)
		counter += 1
		
	
	for item in trialinputlist:
		inputlist.append(item)
	
	inputlist.reverse() #is this needed here or not 

	

outputstring=[]
outputstring.append(0)
snowboarding=[]


##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
		
			nestedswitch= True
			break
	
	print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
	
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	








##=========================================================
##  count_inner_switches_at_first_level(inputstring)
##=========================================================
def count_inner_switches_at_first_level(inputstring):
	print("=====count inner switches at first level=== so at 3 tabs ==")
	counter =0
	innerswitch = 0
	for line in inputstring.splitlines():
		tabdepth = line.count("\t") #added and "end" not in line to eliminate endswitch bug
		if "switch" in line and "end" not in line and tabdepth == 3:
			print("the line number is ",counter)
			linewithswitch =counter
			innerswitch += 1
			counter += 1
		else:
			counter += 1
			
	print("innerswitch count at 3 tabs in this string=",innerswitch)
	print("the line number of the sole inner switch is",linewithswitch)
	return innerswitch;




counter =0
switch_actual_tabs=[]
switch_actual_tabs.append(0)
import re
onetab="\t"  # here is onetab declared with one tab inside of it
fishbowl=[]
fishbowl.append(0)




#sunday confirmation number sundayoct 17th, 2021
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''
#this swaps endswitch with }
#what this does is replace endswitch with '}
###===================================
##  take_out_endswitch(stringname)
###===================================
def take_out_endswitch(stringname):
	print("take_out_endswitch()  called=====")
	answer=''
	galaxy = stringname
	print(galaxy)  #using replace endswitch with }
	#this replaces all endswitch(es) to }
	holdthis[0] = galaxy.replace("endswitch","}") #added here
	#bug what if there is already a curly brace but no endswitch
	print(holdthis[0])
	#move it to left
	answer = holdthis[0]
	newstring=''
	for line in holdthis[0].splitlines():
		if "}" in line and "\t" in line:
			line = line.lstrip()
			newstring += line
		else:
			newstring += line + "\n"
			
	holdthis[0] = newstring
	
	print(holdthis[0])
	#for line in holdthis[0].splitlines():
	#	print(line)
		

	
	
	

##==========================================
## shift_nest_string_to_left(stringname)   made on oct 15th, 2021 8:57 am
##==========================================
def shift_nest_string_to_left(stringname):   #cuts out tabs and adds new tabs automatically
    #print("========= shift_nest_string_to_left(stringname ===... =====")
    #for line in stringname.splitlines():
    #    print(line)
    #print("this is th einput string====")
    newline=''
    counter=0
    thismatters=''
    print("shift_nest_string_to_left() called")
    for line in stringname.splitlines():
        tabslength = line.count("\t") #this is set up for string3 initially. 
        print("tabslength=",tabslength)
        #counter +=1
        if counter == 1 and "switch" in line: #just added this oct 15th 
            #print(line)
            #print("we care about THIS ONE",tabslength)
            switch_actual_tabs[0] = tabslength
            #print("switch_actual_tabs[0]===",switch_actual_tabs[0])
        else:
            print("he well")
        print("=================>>>=======")
        #For teststring3  if 5 tabs in first line then tabslength-4  because it has 5
        ##==================================================================
        clever=0 #starting give it default value of 0 
        #this one works
        if switch_actual_tabs[0] == int(5): #5-4
            clever = 4
            #print("let's see if clever is an int here")
            #print(type(clever))  
            
        #for some reason this if below is not working right    
        if switch_actual_tabs[0] == int(3): #3 - 2 #reducing to 1 tab on first line
            clever = 1
           
        #I think what I need to do is determine indentation before first switch to gauge it    
        print(" switch_actual_tabs[0]=", switch_actual_tabs[0])
        #total_tabs_to_add=''
        ##########################################
        #if 5 tabs then -4
        #if 3 tabs then -2
        total_tabs_to_add=''   #this was 4 changed it to celver
        print("at this point what is the value of clever",clever)
        total_tabs_to_add =int(tabslength) - int(clever) # reducing it to 1 taking 4 tabs off  #right here 
        print("====")
        print("at this point what is the value of total tabs to add",total_tabs_to_add)
        
        print("tablength in first switch line =",tabslength)
        #====== if tablength = 5 -==========================
        if tabslength == 5:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 4 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
        #end if
        print("====")
        #number one rule code does exactly what you tell it to do. 
        #====== if tablength = 3 -==========================
        if tabslength == 3:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 2 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
            
        
       
        #print("so this line will have this many tabs in front",total_tabs_to_add)
        total_tabs_to_add = total_tabs_to_add * onetab #times 1 tab #0 x 1 = 0
        print("RESULT= total_tabs_to_add to each line",total_tabs_to_add)
        myString = line
        output   = re.sub(r"[\t]*", "", myString)    #takes all tabs out of this line
        newline += total_tabs_to_add + output + "\n" #this puts the tabs in front of the stripped string line
        counter +=1
        continue
    #print('the result is..')
    print("this prints out the output what the changed indentation shift to left looks like")
    #return newline
    fishbowl[0] = newline  #the output of shifting to left 
    #for line in newline.splitlines():
    #    print(line)
#print("drink coca-cola test")
#print("TESTING 3")    
#print("starbucks breakfast of friday testing..")
#print("testing indenting correclty teststring3")
#shift nest string to left
#shift_nest_string_to_left(teststring3) #good 5 TABS DOWN TO 1
print("red alert test 3 shift nest stirng to left side ... test 3 ")
print("look carefully at this and make sure that it's right with just one tab at top")
print("testing with string skitahoe")
#shift_nest_string_to_left(skitahoe) 
print('first we will do this simple test with no tabs see if it returns 0')
practicestring='''
switch(exp){
    case 1:
        print('hello')
'''
tabsinthisline =''
for line in practicestring.splitlines():
    if "switch" in line:
        tabsinthisline = line.count("\t")
        print("tabsinthisline=",tabsinthisline)
        break
        
#print("TESTING string 7 now indenting it to the left")
#shift_nest_string_to_left(teststring7) #good 5 TABS DOWN TO 1
#print("red alert testing shift string to left")





gold_list_results=[]
newstring=[]
newstring.append(0)
##=================================
##  manipulate_string(addstring) #this appends the changed switch strings to gold_list_results
##=================================
print('testing taking out 2 ')
def manipulate_string(addstring):
    #print("======manipulate_string() called line 8524=======")
     #the objective is to reduce tabs so only 1 tab in front of first switch in string
    cutout=''
   
    #print("=======pinpointing bug on november 30th =============================")
    print("getting tab count in front of first switch here")
    for line in addstring.splitlines():
        if "switch" in line and "end" not in line:
        #this determines the number of TABS in this line
            tabsinthisline = line.count("\t")
        
            # which then propogates down the length of the entire string
            if int(tabsinthisline) > 1:    #example
                cutout = tabsinthisline -1
                #print("tabsinthisline =",tabsinthisline);
               # print("cutout =",cutout)
                break
            if tabsinthisline == 1: #which means do nothing we want just 1 tab first
                cutout = -1; #this is using -1 as a flag
                break
            if tabsinthisline == 0:
                break
            # do nothing   193241613
     #take out just 2 tabs
    #print("now doing ===== SECOND PHASE ======of manipulate_string")
 
    super=''
    lastchar=''
    for line in addstring.splitlines():
        #if "switch" in line and "end" not in line:
        tabsinthisline = line.count("\t")
        #it does all lines of the string taking out the first 2 tabs which are chars
        if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
            sliced = line[cutout:] #this can be a variable
            #print("sliced sees",sliced)
            
            
        else: #this means its equal to 0
            #scenario zero tabs in front of first switch starting
            if tabsinthisline == 0:#this handles if there are zero tabs in front of switch line
                sliced = "\t" + line; # add one tab if zero tabs.
                #phase B ============================
                
                print("================================")
                #print("=====phase B sliced=",sliced)
            else:
                #phase C ===================
                sliced =  line; #maning this has at least 1 tab already
                
               
        super += sliced + "\n" # this does all lines in the string
        #=== super 1 ==================
        #print("SUPER 1 =",super)
        #scenario if it's already perfect at 1 tab length in front of switch
        if cutout == -1:  #this means tabs in this line determined to be 1
            super += line 
           
    return super #this should do it now this is what is returned a string called super
    
    
    newstring[0]= super #shift_nest_string_to_left(string)
    #this appends the super string to gold_list_results list 
    gold_list_results.append(super)
    

##  remove_garbage_on_right_margine(inputstring):    called after manipulate_string
##==============================
#removes garbage on right margine and takes out : in nested_switch if it exists
def remove_garbage_on_right_margine(inputstring): #this fixes garbage characters afterwords
	#print('----------cherry on top called----------------------')
	cutout=''
	#print("let us ORIGINAL INPUT STRING HERE look at the starting input string before modifying it")
	#for line in inputstring.splitlines():
	#	print(line)
	return  ##  this stops the method cold 
	counter=0
	print('starting to enter cherry on top really serious need to get it working')
	adder='';last_char=''; result = False
	for line in inputstring.splitlines():
		#print(line) #if "switch" in line and "end" not in line:
		#need test if last line is a number then don't chop it off
		
		#print("length of line=",len(line))
		#if length of this line is more than zero
		if len(line) > 0:
			last_char = line[-1]; #returns a character or number or space whatever it is 
		#ourstring = "switch(exp){ #22"
		last_char_in_line_is_number = last_char.isdigit()
		#  checks if last char in line is a number
		#############################
		if last_char_in_line_is_number == True:
			#print("last character is definitely a number")
			##########################################
			#print("last_char a number is",last_char)
			#if anumber == True:
			#print("SECOND SCENARIOthe last character is a NUMBER")
			adder += line + "\n"
			#print("last_char=",last_char)
			continue
		
    #need to ahve it check for "))"
		################if line ends with junk ==========================
		if last_char == ":" or last_char == ")" or last_char == "u" or  last_char == "#": #maybe any character
			#need to check if last 2 are )) only cut off one, otherwise
			# if it's only ) and then don't cut it off
			
			print("FIRST SCENARIO :, ),u, #")
			adder += line[:-1] + "\n" #this deletes the last character from the line
			print("last_char=",last_char)
			
			
		########### if line ends with a space 	
		if last_char == "": #meaning it is an empty space
			print("THIRD SCENARIOlast char is a SPACE")
			adder += line + "\n"
			print("last_char=",last_char)
			
			
			######## this handles if the line ends with a number
			#elif last_char.isdigit():   
			#	print("SECOND SCENARIOthe last character is a NUMBER")
			#	adder += line + "\n"
			#	print("last_char=",last_char)
		print("counter=",counter)
		counter += 1
	###########################################################
	############################################################	
	#decided to get rid of : inside of nested_switch here
	#this fixes this bug  >>  nested_switch_11:(exp) #11:
	#fprint("NOW remove dots inside of nested_switch line if they exist")
	
	verycool=''	
	
	
	for line in adder.splitlines():
		#check if nested switch in this switch string
		if "nested_switch" in adder:
			#print("TRUE nested_switch in line")
		
			if "nested_switch" in line and ":" in line:
				#print("nested switch is True")
				verycool += line.replace(":","") + "\n"
			else:
				verycool += line + "\n"
			
		else:
			verycool += line + "\n"
			#print("no nested_switch in this switch string")
			pass	
	#print("FINAL OUTPUT FOR THIS STRING======>>>>>")
	#for line in verycool.splitlines():
	#	print(line)    
	#print('afterwards not working yet just trying to get last char of each line')	
	#print('resulting fixed removed garbage looks like this.....')
	
	
		#it does all lines of the string taking out the first 2 tabs which are chars
		#if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
	newstring[0]=verycool #bug was right here.	
	inputstring=''
 ################################ 











def method1(inputstring):
     return;
     concat =''
     print("==method1==")
     concat += inputstring
     concat += " fish"
     print(concat)
     return concat

def method2(output1):
     return;
     concat =''
     print("==method2==")
     concat += output1
     concat += " mice "
     print(concat)
     return concat

def method3(output2):
     return;
     concat =''
     print('==method3==')
     concat += output2
     concat += " \nrain fall heavy"
     return concat

print("above the rocket launch")


####===========================================================
def try_these_chain_methods(inputstring):
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("looping through inputstring to see the starting state")
    #for line in inputstring.splitlines():
    #    print(line)
    ##==========    
    #print("==trying these three methods and see if it works or not==")
    output1 = manipulate_string(inputstring) #shift string to left
    #print("reached after first method called")
    #print("mOnday morning Blues testing of manipulate_string method")
    #print(newstring[0])
    
    #takes out extraneous :, ),#,u on right side AND removes : inside of nested_switch word
    remove_garbage_on_right_margine(output1) #this should work now Takes out garbage on far right
    output1 = newstring[0] #extranious #: ) empty lines have : u
    #for line in output1.splitlines():
    #    print(line)
        
    #return    #stoppinghere 
    ##=========
    start =1; finish=1;
    output2 = modified2_cut_out_inner_switch_body_leaving_switch_word(output1,start,finish,)
    #print("reached after second method called")
    ##=========
    output3 = take_out_endswitch(output2)
    #print("reached after third method called")
    #print("this is the final output string from the three chain methods",output3)
    ##=========







	


	
##=====================================
## swap_endswitch_with_curlybrace() this uses the method take_out_endswitch()
##======================================
##=presumes that quail list already filled up with seperated strings
devious_list=[]
peachtree=[]
#so this function loops thru quail list and checks if endswitch in a string in quail
def swap_endswitch_with_curlybrace(): #using testlist_of_strings
    print("=== swap_endswitch_with_curlybrace() ===========")
    print("this requires that quail list must already be filled with switch strings")
    counter=0
    #assert len(quail) > 0 #it did say quail list 
    if len(gold_list_results) > 0: #meaning there is something in quail list
        #looping thru quail list
        for item in gold_list_results:  #notice that this works by looping thru quail list and changing strings with endswitch
            if "endswitch" in item:
                print("yes endswitch is in this string")
                #it happens here TAKE OUT ENDSWITCH(ITEM)
                take_out_endswitch(item) #calling take_out_endswitch saved to holdon[0]
                #print(holdon[0])
                print("its appended to devious_list here via holdon[0]")
                devious_list.append(holdon[0])#this line just might not be working correctly need to look at it further
               # testlist_of_strings[counter] = holdon[0] #this puts it back into testlist slot
                holdon[0]=''
                counter += 1
                continue
            else:
                print("nope no endswitches")
                counter += 1
                continue
    else:
        print("testlist_of_strings list is empty so can't do swap endswitch with curylbrace")
    print("let's see if this works or not does this thing actually work")
    print('strawberrie fields are forever')
    # see if it takes endswitch out and puts } in its place
#end function



#three test in a row here of method calls 



print("===== hard code filling testlist_of_strings   ====")
testlist_of_strings=[]


print("===== testing this using a loop =====")
print("this left shifts and indents each switch string to prepare for going thru bypass205()")
counter=0  #this shifts (indents) the whole switch string to the left with 1 tab in front of switch
print("this prints out the switch strings after left Red Shift== to one tab")
cow_hide=[]
fuel=''
##==============================================
##  starting_what_switch_strings_look_like():
##==============================================
def starting_what_switch_strings_look_like():
    print("starting we have...")
    #for item in testlist_of_strings:
    #   print(item)

##==============================================
##  left_shift_all_switch_strings():
##==============================================    
def left_shift_all_switch_strings(): #this goes thru testlist_of_strings
    print("now we will shift the switch to the left margine")
    counter=0
    for item in testlist_of_strings:
        print("counter =",counter)
        manipulate_string(item) #this calls manipulate_string(item) to shift the switch string to the left
        #adds change to axis put into newloop appended 
        counter += 1

#starting_what_switch_strings_look_like()
#left_shift_all_switch_strings()





#for item in devious_list:
 #   print(item)
critical_list=[]
print('plum tree test') #hours spent getting this tow ork oct 17th, 2021 9;52pm
def goodtimes():
    return
    print("good times()")
    print("looping thru gold list results list")
    for item in gold_list_results:
        #print(item)
        del several_three_tab_switches_list[:] #delete it first to erase the chalkboard
        stringname=item
        get_second_switch_numbers_check_if_many(stringname) #output here
        print("several_three_tab_switches_list=",several_three_tab_switches_list)
        print(several_three_tab_switches_list)
        why= several_three_tab_switches_list
        #print("why=",why)
        print(type(why)) #gets the type of var why is.
        results=list(map(int,why)) #changing the string numbers into ints then it works
        #this adds to this list the inner switch numbers for each switch string
        print('results=',results)
        #some will have none, some will have 1, and some will have more than 1
        critical_list.append(results)
        print('critical_list=',critical_list)
        #print(peachtree)
#goodtimes()    
#print("end of show")    
#print("resulting three tab inner switches in each of the switch strings")


def cool():
    print('==========cool function==== is this working yet====')
    #for item in critical_list:
     #   print(item)

#cool()

   
    
    
    #holdthis[0] = galaxy.replace("endswitch","}")
#I need to replace the inner switches with methods now
####========== sunday october 17th, 2021 




 

#######================================================================#########==========
rose=[]
rose.append(0)
rose.append(0)

#######================================================================#########==========



##  copy_one_nested_switch_string(m82)   <<=======     this is the main trigger for the test july 18th 
##  I will need to add another paramter to determine which nestd switch is grabbed 
def extra(): # does nothing
	print("did it work??")
	
	
	
	
	
nest_string=[]	
######################################################
##  def copy_one_nested_switch_string(m82,zebra,cow)
######################################################
#this fills nest_string list with copies of the switch body strings
#and takes out front two tabs from string
def copy_one_nested_switch_string(m82,zebra,cow): #so I would add a param to determine which nest to grab july 18th 
	#print("==== copy_one_nested_switch_string() =====")
	#print("===========.................==============")
	
	
	#print("========COPY ONE NESTED SWITCH STRING()== called=====")
	#input_string[0]=samplestring
	counter=0		
	buildstring=''
	#print("printing samplestring first")
	#print(m82)This ONLY GRABS the first position which is 0 for switch and endswitch
	#when I loop thru this in the peartree dictionary I will put the current pair into 
	#switch_location[0] and endswitch_location[0]
	######################################################
	#print("WHAT ..... is in these two lists position 0 swith and endswitch")
	#print("it sees in y",y, "well how does it look")
	####################################
	#print("passing the params for switch and endswion and endswitchlcoation")
	del switch_location[:] #these were passed as params that govern grabbing the right string
	switch_location.append(zebra)
	print(switch_location[0])
	del endswitch_location[:] 
	endswitch_location.append(cow)
	#print(endswitch_location[0])
	#print("switch_location[0]",switch_location[0]) #10
	#print("endswitch_location[0]",endswitch_location[0]) #20
	#print("what it sees in switchlocation0 and endloaction0")
	#print("===========================================")
	# LOOP thru string
	###=================
	fridge[0]='' #empty this sucker just in case oct 5th 2021
	#print("list_of_switch_range[1]",list_of_switch_range[1]) #10
	#print("list_of_switch_range[2]",list_of_switch_range[2]) #20
	for line in m82.splitlines(): #determine if "endswitch" is in line
		#this by default starts copying the string once line greater than 2
		#this says if counter between 10 and 20 including start number and finish number		
		#############################################
		#if "switch" in line and "endswitch" not in line: #this shows just switch
		#	print("switch in this line",counter)
		#if "endswitch" in line:
		#	print("endswitch in this line",counter)
		##############################################	
		#right here if counter is between min line number and max line number
		alpha = int(switch_location[0])
		beta  = int(endswitch_location[0])   
		#this loops thru string and copies lines to buildstring
		if counter >= alpha and counter <= beta: #if counter between(within) alpha and beta:
			buildstring += line + "\n" #I need to start at the 10th line
			counter += 1	
			continue
		else:
			counter += 1 #wasn't adding to counter
			continue #really
	#print("the new creation concatted should be buildstring=")
	fridge[0]=buildstring  #here buildstring is stored in firdge[0]
	#print("what is in the fridge[0] the nested switch copied")

	newstring=take_out_x_tabs_from_front_of_line(m82) #this is running #takes off 2 leading tabs
	fridge[0] = newstring
	

	######################################################
	nest_string.append(fridge[0]) ##<<<===== right here the nested string is added to nest_string

	
	#need to delete teh first three tabs
	fridge[0] ='' #this empties fridge[0]
	
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [10,20], # I can make these now 
  "2": [28,38],
}
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========




smart_switch_numbers=[]
#the purpose of this is the switch ID number is it's initial line number
#NOTE: no spaces inbetween switch(exp){ otherwise replace doesn't work right 
#testing adding the comment and line number for switches

###=====================what I need to do =====================
# important sept 30th
# all I gotta do is make each nested switch like
# the main switch template and take out inner switch bodies
# then using the line number put in the generated method in it's place
# be sure that I add the line number as a comment I have that code
# and then make sure I get that switch line number to
# make the nested method to replace it
#####================================================================
#this one is all new and not tested september 30th musing
#testing adding the comment and line number for switches
#this is new not currently used or tested 

testcode='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''
#I am testing with this string the inner swithc is at 3 tabs, first switch at one tab.
#this was teststring6 also added 0 to end
teststring60='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


#so I will know what switch body I am dealing with so I can juggle them and manage them					
#when I get a string that I have copied I just need the switch at the top
##====================================
##  get_switch_number()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
def get_switch_number(stringname): #this might be for when
	#print("indian braves dancing for rain")
	# I create copies of the switch body strings
	#print("get_switch_number() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	#for line in stringname.splitlines():
	#	print(line)
	#print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#print("switch number is==>>>>>",y) 
			counter += 1
			#print(stringname)
			break
		else:
			counter += 1
	return y;





			
#keep line #15 del til = #38
################# creation of loopstring list to hold string that will hold the nested switch string

loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
#loopstring[0]=red_robin #   what it was previously ==samplestring #see if this works  #this is the mai nested string
#print('big test here ')
#print("loopstring[0]=",loopstring)
doves=[]






#https://www.youtube.com/watch?v=qtpxiNvGCp4
#########################################
##   copy_one_nested_switch_case_body()
#########################################
def copy_one_nested_switch_case_body(): #uses pears.values()
    print("======copy one nested switch case body () ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    counter = 1
    #using blueberries dictionary and not pears 
    #just changed this oct 6th wednesday 10am 2021 morgan hill starbucks
    
    # pears is a dictionary with values of start switch and end switch
    ## LOOP ######## this loops thru pears dictionary
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        #print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #great where does this copy of the string put into??
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
   
        

#########################################
#this is using the string red_robin for testing purposes. 
  # pears is a dictionary with values of start switch and end switch
    #this goes thru the blueberries dictionary set of switch end switch pairs ===========
    ##===================================================================================
    ## LOOP ######## this loops thru pears dictionary
    #del nest_string[:] #empty this list
    #this is the blueberry dictionary 
    #it loops thru blueberries to copy a string
    #looping thru blueberries dictionary here 
    


    
#loopstring[0]=red_robin #testing on oct 5th Tuesday
def copy_one_nested_switch_case_body_blueberries(): #uses pears.values()
    return
    print("======copy_one_nested_switch_case_body_blueberries() ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    print("I think that at this point nest_string whould be empty")
    print("len(nest_string=",len(nest_string))
    #nest_string=[] #this reinitializes it 
    counter = 1
  
    #right here nov 6 2021 saturday change this to the list of sublists (time to ditch the dictionary
    print("showing contents of blueberries dictionary values the strings here.")
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #this copied string is added to nest_string list
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
##=============oct 5th musing how to maket his puppy work 
#I need to have switch numbers by line number
# associated with it's pair start stop



#this is the resulting output of copying the string embedded in the main switch

holdthis=[]
holdthis.append(0) #creates the space to store it


teststring_brace='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''

#this swaps endswitch with }
# I need to count the "}" in the string, there should only be one, actually none
# if there is one it needs to be in the right place.
# I will have to loop thru the list to look if there is a brace in it already.
######################################
## take_out_endswitch(stringname)  #replaces endswitch with }
######################################
list_of_line_numbers_of_endswitches=[]
holdthis=[]
holdthis.append(0)
#the issue is that I need it to only do the bottom one 
def take_out_endswitch(stringname):
	#print("==========take_out_endswitch()and put brace in called=======")
	x='';x=stringname.count("endswitch") #should be 1
	print(x)
	counter = 0
	for line in stringname.splitlines():
		if "endswitch" in line:
			list_of_line_numbers_of_endswitches.append(counter)
			counter += 1
			continue
		else:
			counter +=1
		continue
	#print("list of line number of endswitches=",list_of_line_numbers_of_endswitches)
	coffee =list_of_line_numbers_of_endswitches[-1] #last one
	#print("the last endswitch =",coffee)
	#print(stringname) #this takes out endswitch and replaces it with }
	stringname=stringname.replace("endswitch","}")
	#for line in stringname.splitlines():
	#	print(line)
	holdthis[0] = stringname#now galaxy gets what is in holdthis[0]
	#print(holdthis[0])#return stringname #and this is returned
	
print("testing take out endswitch from string and replace it with a } ")
#take_out_endswitch(teststring_brace)
#outpout to holdthis[0]
#for line in holdthis[0].splitlines():#
#	print(line)
	



###===================================================
##   show_list_of_nested_strings_separated()
###===================================================
## july 21st 2021 349pm gilroy starbucks
#oct 5th this is a list of thes copied switch ends witch stings in nest_string
###=== this shows the nest_string list of nested switches
#this just loops thru nest_string which has the seperated nested strings
def show_list_of_nested_strings_separated():
    #print("======show list of nested strings separated=====")
    #print(" == StayPuff Marshmellow Man ==")
    counter=1
    #for item in nest_string: #this has the nest strings in it ALREADY nov 6, 2021
    #    print("counter=",counter)
    #    print(item)
    #    counter += 1
    #print('end of first simple test ')   
    #===========================    
    counter =0
    #print("loops thru nest_string that we filled up in copy_one_nested_switch_string(m82,zebra,cow)")
    #this requires nest_string which is looped thru
    #print("length of nest_string=",len(nest_string))
    # loop thru nest_string list     to take out endswitch
    #for item in nest_string: #nest_string must have refined main switch with nest methods numbered already
    #    if "endswitch" in item: #swap endswitch with '}'
    #        print("== endswitch detected ==") #should be 2 of them
    #        print(counter) #takes out endswitch from this current string here
    #        holdthis[0]=take_out_endswitch(nest_string[counter])#takes out endswitch from each string
    #        nest_string[counter] = holdthis[0] #voodoo magic
    #        counter += 1
    #    else:
    #        print("oh good") #absolutely nothing happens here
    #        counter += 1
                
   
    mycounter =1
    #nest_string_size= len(nest_string)
    #print("length of blueberries =",len(blueberries))
    ###############
    #this makes sure that the nest_string is equal in size to blueberries
    # to counter a bug of overflow junk that I will figure out later
    # oct 5, 2021
    #print("blueberries",blueberries)
    #print("")
    #this deletes excess data that is appended to nest_string inexplicably
    #this simple fix was solved on oct 5th tuesday at 11:30pm 2021=======
    #temporary getting excess from nest_string
    #so 
    while len(nest_string) > len(blueberries):
        del nest_string[-1] #last element in list is deleted
   
    #print("length of nest_string=", len(nest_string))
 
    #get length of blueberries
    #then reduce size of nest_string to that number (figure it out later) weird bug
    #print("nest_string size = ",len(nest_string))
    #for item in nest_string:  #nest_string
    #        da = blueberries.get(str(mycounter))#gets string at this position
    #        #print("getting data in blueberries",da)
    #       print("counter=",mycounter)
    #        #print(item)
    #        mycounter += 1
    #        
    #       print("==========-----------seperated nest strings -----------------")
    #print("==========")
    #now delete extra slots in nest_string
    
    


######################
##  more_testing()
######################
def more_testing():
    return
    print("=== more_testing() == charisma ===method testing ")
    #this is adding samplestring with main to nest_string[2] to see what it will look like when working
    print("let's see what is already in nest_string ===> SpaceX pretest ")
    print("to see what is in nest_string")
    #for item in nest_string:
    #    print(item)
    print("so slow 3 which is nest_string[2] has the main string in it")
    #let'see how it looks"
    print("==== after simple test of contents of nest_string")
    print("========")
    print("here we replace it with what will be after I modify it. this is dummy data testing")
    print("finished main string with nested methods added put into nest_string[2]")
    #nest_string[2] = samplestring_main # the third one - putting in a different string premade
    #this is what is different right here in the line above
    
    #testing what the stages need to look like
    #to test what it should look like but doesn't yet
    print(" now we will try it again and see how it looks ")
    print(" after changing main string boo boo ")
    #loop thru nest_string
    #for item in nest_string:
    #    print(item)
        #print("===========///======oct 5 tuesday 2021 testing  ========")
        
        
###==================================== oct 5 thinking how to do this. 
#for each switch number I need to know what ranges of it's inner switches are
#I need the range of the inner switch numbers start and stop
#so inner switch ranges for switches by switch line number

#more_testing()

####===========================================================###
####===========================================================###
####===========================================================###


### this works this takes the copied nested switch
### and sets the proper indentation for it
#so it takes out 2 really but we have to say 3
## july 17th 10:12am 2021 starbucks

#the eye opening= make a list of the methods sequence
#tuesday, August 10th, 2021 ====,,,,,,,,,,,==========




loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now

loopstring[0]=samplestring #see if this works  #this is the mai nested string
#print('big test here ')
#print("loopstring[0]=",loopstring)
doves=[]
copy_one_nested_switch_case_body() # this calls the loop

#print("pears dictionary",pears)
#print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
#print("pears now",pears)


#show_list_of_nested_strings_separated()
#more_testing()


###==========================================================








#unless I make a new string _so I want to remove teh first 2 tabs only
alpha_string=''
str1=''



 
skip_range=[]

#so I still need to get the start and finish lines  switch and endswitch for input 
del ibm[:] #empties it
#print(ibm[0])
#ibm.append(samplestring) #so in  ibm[0] this is putting samplestring into ibm[0]
#print(ibm[0])
#===================print testing on july 24th saturday  2021 at 9:36am =================
#print("at this point we have this in ibm[0] after taking out the first nested switch")

range_list=[]
skip_range.append(0) #slot [0]
skip_range.append(0) #slot[1]


#string,start,finish
#first it will just detect one nested switch , soon it will detect many

#this loops thru a string and makes a copy of the string
# but skips over a range example lines 10 thru 20
toosmart=[]
toosmart.append(0)
flag_test=[]
flag_test.append(False) #flag_test[0] set to False right here 
baton=[] #this is used to hold the concatted string that is changed on each pass 
baton.append(0)
baton[0]= "nada" #to start with to test this monstrocity


rose=[]
rose.append(9)  #testing purposes 
rose.append(19)
test_code_now='''
					switch(exp){ 
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){   #9 
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch  #19
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''








#this is testing with dummy data above in test_code_now
#taking out the inner switch body
#print("halloween is coming snoopy and woodstock test")

#print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1

#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
#print("===========rose test==== testing taking out inner switch body ===")
#the pair would go here 
input1 = rose[0]
input2 = rose[1]
#print(input1)
#print(input2)
#print("take out 10 thru 20")
#x = test_code_now
#start = rose[0]+1 #10 #TO PRESERVE INNER SWITCH TO REMAIN THERE
#finish= rose[1]+1 #20 #TO GO ONE BEYOND ENDSWITCH WORD
#skipping_some_lines(x,start,finish)
#print(toosmart[0])
#print("=====end end end of show end of this dumb test==testing rose flowers ===")
# october 1st this will have to be a prescan first pass to get the locations 
# this will look for an inner switch after first line and get it's line number
# and find it's 'endswitch' or '}'
# and put the switch line number and endswitch line number into a pair
# and then append it and keep going and that way it figures out the location on it's own
coffee_switches=[]
end_coffee_switches=[]

combinedlist=[]
switchtabs=[]
endswitchtabs=[]

#this is not working right 
### mr coffee smart skipping lines 
## mr_coffee_smart_find_innerswitches bodies and skip them except for inner switch word


##======================================================
##  mr_coffee_smart_skipping_lines(inputstring):
##======================================================
def mr_coffee_smart_skipping_lines(inputstring):
	return
	#print("======= mr coffee smart skipping lines ..this =======")
	#print(" makes pairs to find locations of switches and endswitches.")
	#print(inputstring)
	counter =0
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			tabdepth= line.count("\t")
			coffee_switches.append(counter)
			switchtabs.append(tabdepth)
			
			counter += 1
		else:
			
			counter += 1
	del coffee_switches[0] #deletes the first switch which is at the top 
	###=================================
	count =0
	#this looks for endswitch locations
	for line in inputstring.splitlines():
		if "endswitch" in line or "}"  in line:
			tabdepth= line.count("\t")
			end_coffee_switches.append(counter)
			endswitchtabs.append(tabdepth)
			counter += 1
		else:
			counter += 1
	#=====================================
	counter =0
	for item in coffee_switches:
		combinedlist.append("[" + str(coffee_switches[counter]) + "," + str(end_coffee_switches[counter]) + "]")
		counter += 1

	#print("zzzz the result list =",combinedlist)
	#print("switch tabs=",switchtabs)
	#print("endswitchtabs =",endswitchtabs)
	

#print("testing this using string red_robin to see if it works")
#print("this is only returning the range list of the switch endswitch pairs")	
#print("GO GO GO what that dog go")
#mr_coffee_smart_skipping_lines(red_robin2)
## it's chopping off this from the bottom
'''
fallthru
		
		default:
			print('the end')
}
'''


#now the string we have is missing the numbers above it 
#print(nest_string[2])
#start  = 10 #subtract number after first cutting out skipping
#finish = 19
#skipping_some_lines(nest_string[2],start,finish)

#print(toosmart[0])
#this changes the contents of nest_string[2] #see if this puppy works
#nest_string[2] = toosmart[0]
#print("what does this string look like right now this instant")
#print(nest_string[2])


#53 -65


#this would be done separately and is filling the range_list with the switch to endswitch params
#this will be a separate method for range input for the switch endswitches
#here the sublists of the param of each nested switch are added to range_list
#this is hard coded here filling the nested switch numbers 


#range_list=[[10,20],28,38]]  #that's right I do this backwards from bottom up!!!

'''
this goes thru the main switch string and makes a copy
of the main string in stages copying the whole thing
except for the range for each nested switch.
'''
## this means delete nested switches bodies except leave inner switch word only
##===================================================
#  REDUCE MAIN NESTED SWITCHES TO JUST SWITCH WORD
# debugged on august 5th 2021 gilroy starbucks
##===================================================
## this makes teh final main switch with the inner switch bodies stripped out
## just leaving the switch word where the nested switch was.
#range_list.append([10,20]) #these are added in order and then reversed
 # so that the nested switches are erased bottom up
addthis=[]
addthis.append([10,20])
addthis.append([28,38])
##========================
## add_to_range_list()
##========================
def add_to_range_list(): #uses addthis list 
    #print("add_to_range_list() this is necessary to work")
    for item in addthis:
        range_list.append(item) #adding to range list
        
    #print("length of range list =",len(range_list))
 
 
 
 #i will need to add data to range list still 
##======================
##  feed_range_list()
##======================
def feed_range_list():
    #print("=========feed_range_list() called=====>>>")
    #print("=========feed_range_list() called=====>>>")
    range_list.append([11,24]) 
    range_list.append([26,38])
    #print('range_list=',range_list)
    #the list has to be REVERSED to do the changes bottom up so the line numbers work correctly
    range_list.reverse()#reverses it NOTICE WE REVERS THE LIST TO CHANGE IT BOTTOM UP
    #this is so the bottom is done first 
    #print("length of range list =",len(range_list))



	


#The change that I need to make here is to cut out switches greater than 3 tabs  tabdepth > 3
##======================================================
##   reduce_main_nested_switches_to_just_switch_word():  #I think that this does all switches no matter their depth
##=======================================================
def reduce_main_nested_switches_to_just_switch_word(astring): #11 - 23 and 25-37
    #print("---- educe_main_nested_switches_to_just_switch_word(astring)====")
    #add_to_range_list() #this is new to put switch and endswitch lines into range_list
    feed_range_list() #added on wednesday, September 15th, 2021
    flag_test[0]== False #this flag is new this is the default setting for this flag
    #print("flag_test[0]=",flag_test[0])
    #when flag_test[0] = True that means it's doing 2nd and subsequent loops (changes) and use baton[0] for concatting string
    
    counter=0
    for item in range_list: ##range_list=[[10,20],28,38]] ==========================
        #print("**",item, item[0],item[1])
        #print("inside of loop thru range_list :: COUNTER HERE=",counter)
        skip_range[0]= item[0]; 
        skip_range[1]= item[1]
       
        toosmart[0]=astring #this might work
      
        skipping_some_lines(astring,skip_range[0],skip_range[1]) #this makes a new string skipping guts of inner switch
        counter += 1
        
   
##======================================================











smart_number=[]
smart_number.append('starter')
smart_number.append(0)
smart_number.append(0)
smart_number[1] = '1'
smart_number[2] = '2'
#switch is on line 10 need to change it this is looking for the switch

#this is changing ALL OCCURENCES of switch at the 
#same time just just the one I want it to change.
# I need to localize is it to one line number.

#have it change one and then break starting on the line above


#The problem I have is if I replace each switch with the nested numbers
#then the other code won't work so perhaps I need to add a comment
#the issue is making the main strings which should only have the first level inner switches
#which is governed by tab depth of 5 representing the second level
# since tab level 3 is the first main switch.
# I could do number 1 thru n for each level initally and then change them
# or I came up with the number top down 1 thru n but level list solves the problem 
#That was my genius

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#in terms of faster programming it's about communication and control
# the lollipop is the what level but above that are higher abstraction levels
# where yet more speed can be achieved and sustained
##$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========
#I think I will do the one nest level for now and add the other nest levels afterwords
#decision made august 22nd, 2021 9:08 am

# I have the main module which has nested methods
# I can use this for making nested switches with nested switch methods too
# but right now I want to get the nested feature working before implimenting it
#######3==================================
#Actually I can do the main and the nested that have inner switch words not changed yet
#And then apply the conversion to numbered switches
##=====================

danumber=''

##============================================
# swap_switch_for_nest_method_new(danumber)
#// inner switch(just the words) is swapped for nested method number")
#=============================================
#for this to work correctly I need to ahve already taken out the inner switch bodies that I copied
#print("about to do OPTIMUS PRIME === GO BABY GO ===")
def swap_switch_for_nest_method_new(stringname,danumber): # I will add more values later perhaps 3 or 4 for coordinates
	#print("#### ========= swap switch for nest method new  ========####")
	#print(" =======OPTIMUS Prime======")
	global abovenestedswitch
	#stringname=ibm[0]
	#stringname=ibm[0] #loading from ibm[0] good
	#print("called swap_switch_for_nest_method(n)")
	#print("it is using this number in use_number[0]",use_number[0])
	acounter=0
	for line in stringname.splitlines(): #determine if "endswitch" is in line
		tabdepth = line.count("\t")
		#print("the current tab depth in THIS line is",tabdepth)
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 check to make sure that switch and the comment line number in this line
		#this way it can ONLY make changes to switches at tab depth 3
		if tabdepth == 3: #this way it can ONLY access changing the string at 3 depth once
			#this way only if the tab depth is 3 can it manipulate the string
			if  "switch" in line and str(danumber) in line: #line with switch in it  
				#print(line)  #doing counter > 1 so it doesn't do the first line
				#this is where the string is changed
				stringname = stringname.replace("switch(exp){","nested_switch_" +str(danumber)  + "(n)")
				break
			else:
				acounter += 1
				continue
		else:
			acounter += 1
			continue
			
	#print("the final outcome of the chagne is here:")
	#for line in stringname.splitlines():
	#	print(line)
	

# this takes in what is in ibm[0] and the outputs it to ibm[0] also, quite clever.   
#print("let the judge state this is truth") 
#number_to_add=66 
#swap_switch_for_nest_method_new(teststring60,number_to_add) 
#ibm[0] = stringname
#print(ibm[0]) 



innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
#print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    #print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
    #print('this now takes out the { brace after switch if it is there')
    innerswitch=''
    #print("this is what it sees when it starts change_switch_to_method_solved()")
    #for line in inputstring.splitlines():
    #   print(line)
    #print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        pass 
        #print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    #print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        #print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            #print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
        #print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
       #check if } in this string an if so take it out
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
                #print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        #print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
           # print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            print("=====no { in string  ======")
            #end if
        #print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
        #check if } in this string an if so take it out #I have deactivated this since it's not needed
        
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
#print("where is my mocha brainfreeze test october 30th...")




#print("testing goldfish which is NOT indented yet")
#testing a second method in chain right now for expiermentinting==
#the input string MUST BE indented and look like this LOOK LIKE THIS 



###================== cold brew linus and snoopy ================== saturday morning software  november 20th, 2021 ====
#this is testing adding the nested switch 
linus_and_snoopy=[]
##==================================
##   add_nested_switch_methods():
##==================================
def add_nested_switch_methods():
    #print("add nested_switch_methods() in catching_first_change list")
    for item in catching_first_change: #<== list with strings after taking out inner switch bodies
        #print(item)
        #here calling method chaning_switch_to_method_solved swaps switch for nested_method_numbered
        fizz =change_switch_to_method_solved(item)#this is applying the method to add nested_switch method
        #print("===== oh yeah =====")
        linus_and_snoopy.append(fizz) #this is adding the changed string to linus_and_snoopy list
        
        #for line in fizz.splitlines():
        #    print(line)



##================================================
##print_out_result_of_adding_nested_switch() to each switch string:
##================================================
def print_out_result_of_adding_nested_switch():
    counter =1
    #print('we made it to the top of the Donnor Summit ')
    #for item in linus_and_snoopy:
        #print("counter=",counter)
        #for line in item.splitlines():
        #    print(line)
        #counter +=1






inputlist=[]
inputlist.append(0)
outputlist=[]
outputlist.append(0)
 

#put x in front so it's not used
#it must be indented properly to work daaaaa


#testing doing 2 methods back to back piping output from first to input to second
#first method   
###==================
##  do_the_pipe()
###==================    
def do_the_pipe():
    return
    #print("do the pipe() called pipe pipe PIPE PIPE PIPE")
    #print("outputlist[0]=",outputlist[0])
    #inputlist[0] = outputlist[0]
    #print("now put it into inputlist[0]")
    #print("inputlist[0]=",inputlist[0])
    
    






##============================================
## get_top_switch_number_from_this_string(x)
##============================================
twinlist=[]
#testing with string directly above this line
def get_top_switch_number_from_this_string(inputstring):
    #print("get_top_switch_number_from_this_string")
    #print("there is NO REASON to send humans to Mars")
    counter=0
    x= y =''
    for line in inputstring.splitlines(): #it will be the first switch 06
        if "switch" in line and "#" in line and "nested" not in line  and counter < 2: 
            #print("confirmed switchh in line ")
            #this is new getting the switch id number after # on-the-fly
            #get string to right of #, get right side,remove spaces
            x = line.split("#"); y = x[1];y = y.strip();
            #print("no drama this is what we have..")
            #print("y=",y)
            #print("now adding y to twinlist below")
            twinlist.append(y)
            break
        else:
            if counter > 3: #time to bail =too deep can't exist after first line actually
                break
            else:
                continue
                counter += 1
#grab first id number aftger switch 









#=====================================
# get inner switch number ()  only at the 3 tabs level depth though
#======================================
#so do this multiple times I would have to go thru a loop with the length of the count of switches at three tabs in a string
add_to_list=[]#and call this method get_inner_switch_number(stringname) #and change the counter number
thisline=[] #this also implies only getting one inner switch
def get_inner_switch_number(stringname): #implies at 3 tabs depth
	#print("======get inner switch number called=======")
	counter=0
	x=''
	#what this does is get the commented inner switch number after the # in switch
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tabdepth=line.count("\t")      #this is getting tabdepth for this line
		if "switch" in line and "end" not in line and tabdepth== 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			x = line.split("#")  #this manipulates the current line
			y = x[1];
			#print("switch number is...",y) 
			add_to_list.append(y)
			counter += 1
			print(stringname)
			#break  #after the if condition above it stops 
		else:
			counter += 1
	#print("List add_to_list=",add_to_list)
	#del add_to_list[0] #should delete first one
	#print('now we have ',add_to_list)
	#return y;


##===================================
##  funtime(stringname)
## this calls the method get_inner_switch_number()
##===================================
## this replaces the inners switch at 3 tabs with a netsed method name with the id comment number
#this right now only deals with one but I can modify it so that
#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
#print("I just don't believe I coded this back on oct 22nd")
#print("morgan hill starbucks frosty74")
#===========================================================================
#  convert_inner_switches_into_nested_methods_numbered(stringname): 
#============================================================================
# it will access a list using a loop and they will be put in in sequential order top down
def convert_inner_switches_into_nested_methods_numbered(stringname): #this is feeding in the number looking for
	#print("======convert_inner_switches_into_nested_methods_numbered=====")
	x='';concatthis='';counter =0
	# using method get_inner_switch_number(string)#which is grabbed from 3 tab depth only
	#for line in stringname.splitlines():
	#	print(line)
	#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if  tabdepth == 3  and "switch" in line:
		# I just moved what was in a method into the loop where the action happens
			x = line.split("#")  
			y = x[1];       #it was str(ournumber)
			y = y.replace(" ",'')
			filler ="nested_switch_" + str(y) +"(exp)" #has to be a string
			#### this is new december 5th #######
			#print("inside of function convert_inner_switches_into_nested_methods_numbered")
			#print("###====line 11729 ===========##")
			#print("filler=",filler)
			if ":" in filler:
			    filler=filler.replace(":","")
			#end if
			#print("after fix  -- filler=",filler)
			#print("###===============##")
			######################################
			line = line.replace("switch(exp){",filler) #notice replace using var 
			concatthis += line + "\n"
			counter += 1
			continue
		else:
			concatthis += line  + "\n"
			counter += 1
			continue
	################	
	#for line in concatthis.splitlines():
	#	print(line)	
		




# july 24th, 2021 
#the input for this MUST be the already reduced main switch which
# has just the switch word in place where each nested switch thru endswitch was.


###  Thursday, August 19th, 2021 time 9:07 am
# I think that I just need to not worry about the other nested switches
# and just do the first level of nested switch since the others will just be in the other switches
# so let' say I have two nested switches deep
# I only have to have (for the main switch) the first level nestedswitch
# so then the situation becomes the numbering because in this first level of nested switches
# they would be numbered in sequence 1, 2, 3 etc  
# if say there are two nested in teh first main swith then sub1
# but for the inner levels (the next tab level) I would have to do 4,5,6 I suppose
# so continuing sequence or 1.1 and so forth
# I need to come up with a simple numbering system maybe Alpha first level Alph
###
#what if I have pairs, simple numbering but 
##===========================================	
## number_nested_switches_in_sequence()
##===========================================
#put the input I just created into ibm[0]
#this would be the main string after the nested switches are taken out  leaving switch word
forcedinputstring='''
	switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 5')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     #  this would be 10  for line number      
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 18 but it said previously 28      
			fallthru
		
		default:
			print('the end')
}
'''
#this is input for add counter to switches
trouble=[]
trouble.append(forcedinputstring)


#this is using preset nested switch starting locations 11 and 29 for this test
# this is for making the nested switch numbered method 



#this swaps switch with nested_switch_" n
##########################################
## number_nested_switches_in_sequence():  #this is using hardcoded input for testing
##########################################
def number_nested_switches_in_sequence(): # list_of_nested_switches[11,29]
	#print("=R2D2= NUMBER_nested_switches_in_sequence()  ====== ajax =====")
	newcount=1  #number of nested switches starts from 1
	## wait do I loopthru it get the position of the inner switches now why not
	## modification on july 24th 
	#print("to see what it sees first")
	#this is string above called forcedinputstring
	#print(trouble[0])  #it was ibm[0] which I will change it back to later
	mystring=''
	mystring = trouble[0] #putting the string into trouble[0]
	newcounter=0
	foundone=[]
	# this gets the inner switch locations after the inner switch bodies have been stripped out (deleted)
	##===============================
	for line in mystring.splitlines():  #this fills list foundone with switch line numbers
		if "switch(exp)" in line:
			#print("true we found switch")
			foundone.append(newcounter) #this fills the foundone list of line numbers with switch in it
			newcounter += 1
			continue
		else:
			newcounter += 1
			continue
	#=== end loop ========================
	#print("we are done looking for the inner switch locations")
	#print("====================")
	#print("thefoundone llist has",foundone)
	#print("the length is", len(foundone))
	#print("========........======")
	#print(" ") #below we delete the first switch which is on line 1
	del foundone[0] #this should delete the first switch we don't need 
	#print("now we have for foundone list",foundone)
	## end getting inner switch lcoations
	##======================================
	
	#shiney= ibm[0] #so it will skip the first few lines skipping the first switch 
	thecounter = 0 #tracking lines in the string   oh it's using preset numbers
	#print('the list of nested switches starting line',foundone)
	switchcount=0
	magic_string=''
	seagull='' #WAS shiney.splitlines()
	for line in trouble[0].splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 #IT HAS TO BE AFTER THE FIRST 2 LINES TO SKIP THE FIRST SWITCH
		#if  switchcount > 0  and thecounter in foundone:
		# if thecounter in founderone
		if  thecounter in foundone:  #this must be line numbers of inner switches
		#this line of code is absolutely beautiful and elegant 
			#print("thecounter=",thecounter)
			#print("switchcount=",switchcount)
			########We know the line numbers do it on one pass perhaps
			# it should only go to the lines in the list of nested switches
			gettabcount=line.count("\t")
			line = line.replace("switch(exp){","nested_switch_"  + str(newcount) +  "  " +str(gettabcount) + " tabs " +"(n)")
			magic_string += line + "\n"
			#NEW line above
			newcount += 1  #break #because we are only doing it once to replace only ONE switch #start  = thecounter #this resets the range n to skip what it just did.
			thecounter += 1 #this adds to the neste switch counter
			continue    
		else:
			magic_string += line + "\n"
			# new ling e
			thecounter += 1
			continue
	#print("=====-----======-----======------=====----====----====---")
	#print("magic_string=")
	#print(magic_string)
	#print("========")
	#for line in magic_string.splitlines():
	#	print(line)
		
	#print("were the changes made - this is kind of important at this stage RED ALERT")
	trouble[0] = magic_string #here it's fed into trouble[0] so it's in a list now
	#print("did I rip out the nested switches or are they still intact???")
	#print("trouble[0]=",trouble[0])	
	#ibm[0] = shiney
			
####================================			












#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





			
###============== Sunday July 25th, 2021  10:19 am Cafe Borrone ===============
# the idea is to put the information for each nested switch case
# into the dictionary in terms of it's exact information
# so to fill the data into the nested switch dictionary I will need
# to loop thru the switch string and gather the data for each switch location
# and it's particulars and add it to the dictionary (this should be done first')
# the idea occurred to me since each nested switch has a specific location
# and juggling them can get quite confusing so this way I know which is which
# and where it is.
#=======================================================================
####################
## DICTIONARY HERE 
####################
#putting a named list inside of known dictionary
nest_data=[]
# I probably won't need this.
nested_switch_data =	{  #for pear tree in backyard (2 of them)
#key [level tab depth,number case,  line number, series number
"1": [3,2,23,1], # I can make these now 
"2": [3,3,43,2],
}

print(nested_switch_data)

result=[]
result.append(0)

###############################################################
## RAM LIST TO HOLD TEMPORARY DATA FROM LIST WITHIN DICTIONARY
###############################################################
ram_list=[]
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)

########################
## get_nest_data(key)
########################
def get_nest_data(x): #puts it temporarily into result[0]
	#print("get nest data called",x)
	#this grabs the value from the key and puts it into result[0]
	#these are teh parameters for tehe signature for this nested switch
	result[0]=nested_switch_data.get(x)
	#s- there would be a list within result[0]
	#why not instead populate a list
	#print("this is what is in result[0]")
	#print(result[0])
	for item in result[0]:
	    ram_list.append(item) #see if this fills it or not
	#print('ram_list=',ram_list)
#############################		

  #test data input
############################
##  add_to_nest_data(x,y)
############################
cool_list=[]

# what is missing is the meaning of the code and the beahvior that it creates
# when it's running and knowledge
# how it works and what it does at levels

x = cool_list
def add_to_nest_data(x,y):
	#print("====add to nest data() called with ", x  ,"and",y)
	nested_switch_data["my_list_" + str(x) ] = y

#print("my_list_1[0]",my_list_1[0])
#print("gosh")
######====================================
########
#print("working on access a dictionary in a precise positiion in a list")
#print("that is in the dictionary")
my_dict={}
#add a dictionary #this might be just what I need actually 
my_dict["my_list"] =[3,1,4,1]
#print('terrible')
#print('trying mydict[0] see if it works')
#print(my_dict["my_list"][0]) #the key
#print(my_dict["my_list"][1]) #the key
#print(my_dict["my_list"][2]) #the key
#print(my_dict["my_list"][3]) #the key
alpha = my_dict["my_list"][0]
#print("alpha sees =",alpha)
#check in the list


# 

my_list_1=[]
my_list_2=[]
my_list_3=[]
#####======================================
y = [1,2,3,4,5]
add_to_nest_data(1,y)

y = [23,26,34,42,52]
add_to_nest_data(2,y)

y = [63,66,64,72,72]
add_to_nest_data(3,y)
#print("=================")
#print(my_list_1)
#print(my_list_2)
#print(my_list_3)

#print(my_list_2)
#alpha = mylist_1[0] #should be 1
#print("is this even working....",alpha)

#print(" == looping through nested_switch_data to see the contents == ")
#print("TESTING ship wreck the contents of the dictionary now,,,")
#for key,value  in nested_switch_data.items():
#	print(key,value)
	













################################
##  NESTED_SWITCH_INFO
###############################	
def nested_switch_info(x):
	get_nest_data(x)
	#this will get the info from the dictionary		
			
			
			
switch_location=[]
endswitch_location=[]
#  WE ARE HERE THIS IS WHERE THE BIG TEST BEGINS TO REPLACE INNER SWITCHES WITH METHODS ON THE FLY
##=================
#if we already have the numbers it should work, later I will have it find the locations first






################
# the skipping is done by the main switch when I cam copying it and taking out the 
# nested switches below but keeping the switch word that I then convert to a method nested numbered
#################
### TESTING 
#NUMBERING OF NESTED SWITCH HAS TO BE DONE BOTTOM UP SINCE WE ARE RIPPING OUT THE NESTED SWITCH AFTER THE SWITCH WORD
#oh I will have to do this bottom up so the line numbers are correct.
#first show what is in ibm[0]





#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========


















def end_program():
    #print("ending program")
    return


#A method that calls a series of methods really utilizing output from previous method

#these might have been created above but I am doing them again here just in case.
input=[]
input.append(0)

output=[]
output.append(0)


##=====================
##   get_final_finished_string()
##=====================
def get_final_finished_string():
    return
    #print("===get_final_finished_string():===")
    #print("output[0]=",output[0])
    #print("=== result is in output[0] ===")
    
# passing the baton in the relay race 
##=====================
##   so_pipe()   #this feeds output[0] into input[0] to be used with next method
##=====================
def do_pipe():
    #print("==== do_pipe() ====")
    #put output[0] into input[0]
    input[0] = output[0] 


##=====================
##   initialize_lists()
##=====================
def initialize_lists():
    #print("====initialize_lists(): ====")
    input[0] =''
    output[0]=''
   


old_string_test='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 7')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
endswitch
'''

  
holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			#location = line.index("#")    #gets location from left where position of #
			#line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			#line[0] = first #this is new to slice off right of brace
			line = line[0]#first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():
	#    print(line)
	    
	##===========today sunday coding
	
	
	
	#print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
	


    
##======================================================================================
#the result of each of these methods will put their result in output[0]
#swap_feed_data then puts what is currently in output[0] into input[0] so it's a handoff of the baton
#each of these methods takes in input[0] as input with the result going into output[0]
#after each method we call do_pipe() which puts output[0] into input[0]
# string --> m1(input) => m2(input) => m3(input) => m4(input) => m5(input) 

##====================================================
##  first_method : manipulate_string  (left indent)
##====================================================
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    #print("manipulate_string left margin indent ===first message called..")
    #shifts string left to indent it properly
    astring=manipulate_string(astring) #I think that this does left shift indentation
    return astring

##==========================================
##  second method : take_out_switch_body  from inner switches
##=========================================    
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    #print("take_out_switch_body ...seconed method called...")
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #<== key this is new to see if it works=========
    #astring += " water"
    return astring


##=================================================
##  third method : change_switch_to_method_solved
##=================================================
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("change_switch_to_method_solved  swapto neested_switch method third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    return finalresult

##======================================
##  fourth method  : take_out_endswitch
##======================================
#take_out_endswitch(stringname)
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("take_out_endswitch  put in brace instead third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring)
    #astring += " bright"
    return finalresult
    
    
##=======================================================================================
#using descriptive names not true method names yet
# what this is doing is modifying a string in stages in a sequence 
# code name waterfall
output=[]
output.append(0) #so we can use output[0] below
##========================================
##  chain_methods()   this just does a sequence of methods piped  
##                    together so each method passes its output as input for next method
##=====================================
def chain_methods(item):
    #print("==NOT ANY MORE OFFICIAL== chain_methods called ====")
    firstresult  = first_method(item)         # manipulate_string(string)
    secondresult = second_method(firstresult) # take_out_switch_body(string)
    thirdresult  = third_method(secondresult) # change_switch_to_method_solved(string)
    fourthresult = fourth_method(thirdresult) # take_out_endswitch(string)
    output[0]    = fourthresult #this puts the result into output[0]
    #print("now we are looking in the frac output of fourth method")
    # for line in output[0].splitlines():
    #    print(line)
    #the resulting string is put into output[0]
    




##=================================
## change_slot_string(counter)    this changes content of each slot in nest_list
##=================================
def change_this_slot_string(counter): #requires output[0] finished string
    #print("==== change_this_slot_string(counter) ====")
    counter = int( counter)
    nest_list[counter] = output[0] #I really need to test this one and see if it works 
    #this means that needs to have finished chained_methods put into output[0]
    
##============================
## transform_string()    uses nest_list with strings in it of switch case bodies
##============================
def transform_string():  #this calls chain_method(item) # separate switch string input
    #print("==== transform_string() ====")
    counter =0  #loop
    for item in nest_list:  #loop thru nest_list and each loop does the chain_methods
        chain_methods(item) # takes in string and does sequence methods puts into output[0]
        change_this_slot_string(counter) #changes slot string from output[0]
        counter +=1


##==================================================
## loop_thru_finished_list_of_prepped_strings():
##==================================================
def loop_thru_finished_list_of_prepped_strings():
    #print("==== loop_thru_finished_list_of_prepped_strings() ====")
    counter =0  #loop
    #for item in nest_list:
    #   print(item)
    #   print("counter=",counter)
    #   print("===========")
        


# loop_thru_finished_list_of_prepped_strings() took this out
# this hasn't been tested yet. Today is Sunday, November 14th, 2021 10:58 am Pacific Standard Time
# this goes thru nest_list and modifies all of the switch strings
# and fixed the indentation, and adds nested methods and a comment after each switch 
# with the number after it and cuts out the switch bodies at three tabs depth
# and it uses chain methods in a sequence on each string so the loop only goes ONCE !!!!!
##====================================================
##  prep_nest_list_of_switch_strings_for_bypass205()   STAINED GLASS WINDOW SECTION
##====================================================
## ATTENTION: I have the code for this working but the names are new and I need to 
# put the first two methods lists below in these names. This is SOOO COOL NOW 
#dec 5th sunday I don't think that this is called yet.not tested yet then.

#def prep_nest_list_of_switch_strings_for_bypass205():
#    print("====prep_nest_list_of_switch_strings_for_bypass205() ==line 20359==")
#    go_thru_input_major_switch_string_and_make_list_of_pairs_switch_and_endswitches() # made above
#    using_pair_list_make_seperate_switch_strings_and_put_into_nest_list()             # made above
   # transform_string() #DOES CHAIN METHODS  loops thru  nest_list modifies each separated string
    #loop_thru_finished_list_of_prepped_strings() #thru FINISHED nest_list
    #the end result will be in nest_list with the strings ready to feed into bypass205
    
##===================================================================
###=============================stage 1==================
##===================================================================


holdingpattern=[]
holdingpattern.append(0)
##=========================================
## fixes_dots_in_nested_string(inputstring)
##=========================================
def fixes_dots_in_nested_string(inputstring):
    #print('testing very_clever')
    #    print(item)
    newline =''   
    for line in inputstring.splitlines():
        if "nested_switch" in line:
            newline += line.replace(":","") + "\n"
        else:
            newline += line + "\n"
    # print("this is the result of modifying and taking out : after nested_switch")        
    #for line in newline.splitlines():
    #    print(line)
    holdingpattern[0] =newline
     #I still need to change the slot in the string though 


##========================================================================
##========================================================================
##========================================================================



input=[]
output=[]
output.append(0)

mystring = "smile "

def get_one(astring):
    astring += " a"
    return astring
    
def get_two(astring):
    astring += " water"
    return astring

def get_three(astring):
    astring += " bright"
    return astring





#for testing purposes of transforming an input string this one is teststring3
#mystring = teststring3  #right here change it 
#for line in mystring.splitlines():
#    print(line)
   
   
   
##=============================================    
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    #print("=====first method started..")
    #shifts string left to indent it properly
    #LEAVE THIS DON"T MEDDLE THIS WORKS
    # MODERN TAB SHIFTER TO LEFT IS PURE GOLD
    modern_tab_shifter_to_left(astring) #I think that this does left shift indentation
    astring= goldtime[0] #output from modern_tab_shifter_to_left
    #removes garbage on right side of switch strings (still testing)
    ########################
    #print("check right here frosty")
    #print("newstring[0]=",newstring[0])
    
  

    
    #return astring
 ######################################   
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    print("=======seconed method started.take_out_switch_body..")
    #astring =newstring[0] #from first method above outoput
    #TAKE OUT SWITCH BODY METHOD
    #print("see what we are passing does it have something in it")
    #print(astring)
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #this is new to see if it works=========
    
    
    #print("==output from second method take out switch body==")
    #for line in astring.splitlines():
    #    print(line)
        
    #print("================")
    #astring += " water"
    return astring




 #converts inner switch into a nested_switch method numbered
############################################
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("=======third method started...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    #converts inner switch into a nested_switch method numbered
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    # print("===third method output==")
    #print("outoput from change switch to method solved")
    #for line in finalresult.splitlines():
    #    print(line)
    
    # print("what does it say right here")
    #for line in finalresult.splitlines():
    #    print(line)
        
    return finalresult    
    
    
    
############################################

#take_out_endswitch(stringname)  #this would do all of them regardless of number
def fourth_real_method(astring):  #this changes the inner switch to nested_switch numbered 
    #print("third method startedc...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring) #replaces it with }
    #astring += " bright"
    return finalresult
    
hollister_list=[]
#take_out_endswitch(stringname)
##=========================================
##  simulated_chain_methods():  this is called for each switch string
#this is doing one string at a time. 
##===================================
def simulated_chain_methods(mystring): #starting point 
    #print("SIMULATED CHAIN METHODS () Rudolph the red nosed reindeer")
    first_method(mystring)
    fizz=goldtime[0] #output from first_method()
    #print("stage1 fizz =",fizz)
    
    #print("FIZZ TESTING CRITICAL 1ST METHOD output of first_method() ")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fizz.splitlines():
    #    print(line)
    
    ##############################==================
    fizzy = second_real_method(fizz)  #missing 66
    #print("stage 2 fizzy=",fizz)
    
    #print("FIZZ  TESTING CRITICAL 2ND METHOD to see what's in frac")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fizz.splitlines():
    #    print(line)
    
    #return   
    ##############################
    fuzzy = third_method(fizzy)
    #print("stage 3 fruzzy=",fuzzy)
    
    #print("FUZZY  TESTING CRITICAL 3RD METHOD to see what's in ")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in fuzzy.splitlines():
    #    print(line)
        
        
    ############################
    frac  = fourth_method(fuzzy)
    # print("strage 4 frac=",frac)
    #############################
    #print("now we are looking in the frac output of fourth method")
    #for line in frac.splitlines():
     #   print(line)
    #print('above this line is the Rudolph the red nosed reindeer final first test')    
    #print("line number 12502")
    #frac is the result
    #look at frac to see when  switch 31 and 66 are missing
    #print("FRAC  TESTING CRITICAL 4TH METHOD n frac")
    #print("==looking for missing switch 31 and missing switch 66=======")
    #for line in frac.splitlines():
    #    print(line)
        
    hollister_list.append(frac) #new on november 30th Tuesday 
    
    
    
    
###==============
##   plan B 
##================  testing converting nest string testlist_of_strings
def planB():  #november 30th, tuesday 9:45 am morgan hill starbucks 
    #print("never give up")
    #print("PLAN B called using simulated_chain_methods on each switch string")
    #print('===== welcome to planB ==== november 30th tuesday===')
    #print("doing planB testing each nest_list doing chain_methods")
    counter=1
    for item in testlist_of_strings: #test string names numbered
        #print("========================")
        simulated_chain_methods(item) #testing chain methods
        #print("====== counter= ",counter)
        counter += 1
    return    
    #print("the HOLLISTER LIST of modified switch strings that started out seperated")
    #for item in hollister_list:
    #    print(item)
    #   print("==== middle ground between methods ===")


#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########



#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop
#these are the REAL CHAIN METHODS AS OF DEC 11 SATURDAY 2021 8:10 AM ====

#this should reset them but perhaps not because it's only loaded once.
result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]



print("this is after the input stings have already been seperated")
##======================
##  move_string_to_left_side()        first method modern tab shifter to left 
##======================
#output: result_of_first_method all switch strings modified
def move_string_to_left_side():
    #print("=====APPLE== modern_tab_shifter_to_left()=====")
    #print("line 20254 testlist of strings")
    #for item in testlist_of_strings:
    #    print(item)
    #print("====================")
    counter = 1
    for item in testlist_of_strings:
        #print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
    return #=========================
 
    




##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
# output result_of_second_method
# method used: take_out_switch_body(string)
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    #print("=====PLUM == take_out_switch_body(item)====")
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
        #print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
        #print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    counter =1
    return #=================================
    #print("result of taking out inner switch bodies")
    #for item in result_of_second_method:
    #   print(item)
    #   print("=========")
    #   print("counter=",counter)
    #  counter += 1
    





##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
## output: result_of_third_method
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    #print("=====PEACH===change_switch_to_method_solved===")
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        #print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    #########################################
    counter =1
    #print('result of 3rd method on string')
    return #=============================
    #for item in result_of_third_method:
    #    print(item)
    #    print("=========")
    #    print("counter=",counter)
    #    counter += 1
    
    
    
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
## output: result_of_fourth_method
##=================================================================
def replace_endswitch_with_close_brace():
    #print("=======ORANGE=====take_out_myendswitch===")
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
        #print("=======")
        fizz =  holdthis[0]
        #print('orange fizz =',fizz)
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        #print("===== counter =",counter)
        counter += 1
   #########################################
    #print('result of 4th method on string')
    counter=1
    return #=================
    #for item in result_of_fourth_method:
    #    print(item)
    #    print("=========")
    #    print("counter=",counter)
    #    counter += 1


#######################################################

    
    
    
    
    
    
    
    
#this gets the numbers and fills up the list switch_numbers_to_transfer  
switch_numbers_to_transfer=[]
cell=[]
cell.append(0)
##==================================== created dec 6th monday 2021
##  get_switch_number_now(lestring): from quail list before bypass205 is called
##====================================
def get_switch_number_now(lestring): #fills list switch_numbers_to_transfer
    #return
    #print("====get_switch_number_now()===line number 20450==") #gets it from quail list
    #print("lestring input param=")
    check_if_words_red_white_blue_in_string(lestring)
    #for line in lestring.splitlines():
    #    print(line)
    #print("=========")
    counter =0
    for line in lestring.splitlines():
        if  counter == 1 and "switch" in line and "#" in line and "end" not in line:
             x =line.index("#");
             x=x+1;
             answer=line[x:];
             cell[0]=answer;
             switch_numbers_to_transfer.append(answer) #fills up this list
             break;
        else:
             counter +=1
    
    
            
#this fills up the switch_numbers_to_tranfer list used in bypass205 to
#use in the numbering of the switches with a # after each
##====================================================
##  fill_switch_numbers_list_to_transfer():
##  method: get_switch_number_now()
##==================================================  
def fill_switch_numbers_list_to_transfer():
    #print("=======fill switch nubmers list to transfer()==line20339==")
    #this is where each switch number in the comment #11 example is put
    #into the list switch_numbers_to_transfer the baton to python output string put in number
    #print("===========new test jan 21st ===line number 20337================")
    vprint('this is in result_of_fourth_method')
    #for item in result_of_fourth_method:
    #    print(item)
    #print("===========new test jan 21st ===================")
    for item in result_of_fourth_method:
         get_switch_number_now(item) #fills list switch_numbers_to_transfer
    #there will be no changes to this switch string   
 
    
    
    #exit()
    #this gets the switch number from each first switch in a string
    # and put is tinot switch_numbers_to_transfer 


#print("=========== get switch numbmer in quail list") 
##=============================================
## get the switch_numbers_to_transfer():
#this is trapeze to get the switch number for first switch in each string
#which will be used for make the def nested_switch and main_switch in python mode
##=============================================
def get_the_switch_numbers_to_transfer():
    counter=1
    #print('what is in chain_output_list line 20375')
    #print("chain_output_list=",chain_output_list)
    ################################################
    for item in chain_output_list:
        get_switch_number_now(item) 
        #print("number =",counter)
        #print(cell[0]) 
        counter += 1          
    #print("switch_numbers_to_transfer",switch_numbers_to_transfer)
  
  
  
  
  
chain_output_list=[]
##===================================================
## fill_chain_output_list():
##==-================================================
def fill_chain_output_list():
    del chain_output_list[:] #empty it to be sure
    #print("====fill chain output list()====")
    for item in result_of_fourth_method:
        #print(item)
        chain_output_list.append(item) #ah this is where that is. 

##======================================================
## loop_thru_chain_output_list_and_fill_quail_list()
##======================================================          
def loop_thru_chain_output_list_and_fill_quail_list():
    #print("here we are filling the QUAIL list officially -it's about time")
    del quail[:] #empties quail list
    for item in chain_output_list:
        quail.append(item)
    #print("====Quail List Output===at the bottom of chain_methods ======= ")
    #print("quail output now is this which will be fed into bypass205() parser")
    #for item in quail:
    #    print(item)        
    #print(" ")
    
   # print("==switch_numbers_to_transfer list==")
    #print(switch_numbers_to_transfer)
##=============================================
## show_list_switch_numbers_to_transfer()
##=============================================
def show_list_switch_numbers_to_transfer():
    return
    #print("===switch numbers to transfer== stage2 Linus==")
    #print(switch_numbers_to_transfer)
    #print("")
    #for item in switch_numbers_to_transfer:
    #    print(item)     

##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##====================================
##  do_the_blender_chain_methods()
##====================================
def ydo_the_blender_chain_methods(): #not called
    return
    # print("==the blender chain methods()=jan 26th =1.0 as of Jan 17th, 2022 at 2:30pm")
#     move_string_to_left_side()                         #indents to left
#     take_out_the_inner_switch_bodies_leaving_switch()  #cut out switch bodies leaving switch
#     change_switch_to_nested_switch_method()            #switch becomes nested_switchX
#     replace_endswitch_with_close_brace()               #endswitch becomes }
#     fill_switch_numbers_list_to_transfer()             #list generated used for codegen
#     fill_chain_output_list()  
    #print("=== end of blender chain methods() ==")    

##  waterfall_chain_methods_gold_master()  formally called do_it()  #this is the one actually being used.
## uses testlist_of_strings for input
##==================================================
#the way this works is each method does all of the switch strings as a set
#each of these methods does all of the switch strings in the list at once 
#and the results are passed downward cascading for the next method to modify.
#========WATERFALL CHAIN METHODS GOLD MASTER THE REAL DEAL=======
##===================================================================================    
## ====  WATERFALL CHAIN METHODS GOLD MASTER OFFICIAL OFFICIAL OFFICAL OFFICIAL  =====       
##==========dead code not called ===========================================================================
def ywaterfall_chain_methods_gold_master():  #THIS WILL TAKE IN THE QUAIL LIST FOR INPUT
    return #print("=line 20579==WATERFALL CHAIN METHODS Gold Master 1.3()==jan 24th ==THE REAL DEAL  REAL WORLD = ")
    #do_the_blender_chain_methods()
    #show_list_switch_numbers_to_transfer()
  
##===================================================================
## prepare_input_switch_strings_with_chain_methods_for_bypass205()
##==================================================================
def prepare_input_switch_strings_with_chain_methods_for_bypass205():
    #print(" -------prepare_input_switch_strings_with_chain_methods_for_bypass205()------")
    waterfall_chain_methods_gold_master()  #<<=== this calls the chain_methods to run
    #this would prepare the separated switch string bodies for parsing



##=================================
#prepare_input_switch_strings_with_chain_methods_for_bypass205()
 
##=======================================================================
##=======================================================================
##=======================================================================
##==========this will be stage 2   chain methods =============================================================
##=======================================================================



    






  

# -*- coding: utf-8 -*-
tahoetest=[] #initalized here
tahoetest.append('starter') #position 0 holds just starter

# empty_tahoetest()
switch_count=[]
del switch_count[:] #empties list in case residue from previous runs

#############################
##    empty_tahoetest()
#############################
def empty_tahoetest():
    del tahoetest[:] #this erases the list completely if called 

########################################
## show_the_nested_strings_in_memory()
########################################
def show_the_nested_strings_in_memory():
    return
    #for item in tahoetest:
    #    print("=======")
    #   print(item)
    #    print("=======")
           
           
disney_tron_trace_list=['starter']

######## show tron trace path ===========
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	#for item in disney_tron_trace_list: #loops thru it
	#	print(item) #gives us the line number




#### mytrace ===============
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)
	
#import sw_module_extra
digitalcandy=[]
line_numbers_of_first_cases=[]

#########==============================
### added June 3rd, 2021 
## initialization 
show_code=[]
show_code.append(False)
#show_code[0]= False
#print('starting out what the flag for show code shows')
#print("default setting for show_code[0]",show_code[0])
#show_code.append(False) # by default
#############################################
#to show or hide the docstring switch input in C style
### show input switch string
show_input_string=[]
show_input_string.append(False)
#show_input_string[0]= False

def show_input_switch_string():
    del show_input_string[:] #empty it first
    show_input_string.append(True) #then add True to position [0]
################################
### hide input switch string
def hide_input_switch_string():
    del show_input_string[:] #empty it first
    show_input_string.append(False)

### show_generated_code
def show_generated_code():
    show_code[0]= True
    
### hide_generated_code
def hide_generated_code():  #test this if it really works
    show_code[0]= False
    
#the dilimma is resetting it to default of False
#actually they would probably want them all on or all off honestly
#and they -the settings - show stay in that state  (makes sense)    



    
########## woodstock here may 29th ===============


disney_tron_trace_list=['starter']
######## show tron trace path
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number

#### mytrace
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


############################=============
varholder=[]
#def flush_lists():
#	varholder=[]
varholder.append("zilch") #if nothing changes it's default



def is_number(inputString):
	return any(char.isdigit() for char in inputString)
valve=[]
###############################===========


#####################		
newlist =[];count =''  # these are used
######################
####################################################
##      swap_thru_lines_with_expanded_cases()     ##  this is for number cases
####################################################
def swap_thru_lines_with_expanded_cases():
	mytrace('swap_thru_lines_with_expanded_cases()')
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			# this is where it gets number that is now a string
			cat =is_number(smart[1])  #calling method to check if  #the case name is a number
									 
			#print(cat)
			cool = smart[1][:-1]  #chops off : from end last char
			holder = "'" + cool + "'"  #this puts the number in quotes
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	#after the numbers have been converted into strings


############################
list_with_thru_macros=[]
list_with_thru_macros.append(0) #position 0 nothing
backwards_thru_list =[]  #initializing the list




#############################
################ case 1 to 10: becomes case 1 thru 10:######################
################################
#### change to into thru ()       created friday feb 5th, 2021 morning
################################
def change_to_into_thru():  #this is a simple way of doing it
	mytrace('change_to_into_thru()')
	#print("change macro to into thru")
	global switchcasetester
	mycounter = 0; banana=''
	for line in switchcasetester.splitlines():
		simple = mycounter-1
		if "case" and "to" in line:  #this means the macro to
			banana=switchcasetester.replace(" to "," thru ")  #just addded spaces
			switchcasetester=''; switchcasetester = banana
			#print(switchcasetester)
		else:
			pass


###########################################		
## make_list_of_lines_using_thru_macro():		
###########################################
def make_list_of_lines_using_thru_macro():
	mytrace('make_list_of_lines_using_thru_macro()')
	#print("=====WARNING WILL ROBINSON LOST IN SPACE====")
	#print("* * * * WORKING ON FUNCTION make_list_of_lines_using_thru_macro()")
	#print("===----------=== make list of lines using thru macros() ====--------=")
	#go thru list and if thru in line add that line to list
	global switchcasetester #just added this 
	#how comes this works without global switchcasetester?

	#global switchcasetester #it should work now
	thru_counter = 0
	for line in switchcasetester.splitlines():
		#just added the word to that means the same thing as thru
		if  "case" and "thru" in line:  #on
			list_with_thru_macros.append(thru_counter)
			thru_counter += 1
		else:
			thru_counter += 1
			continue
	#print(list_with_thru_macros)		
	#then I need to reverse the list
	backwards_thru_list=list_with_thru_macros
	backwards_thru_list.reverse()
	#print("backwards we have",backwards_thru_list)
	bottom_up_change_of_thru_line_test() #this just shows the result but really does nothing



##### testing january 10th to go to each case thru from bottom up and change line
##### to prove it's working
####################################################################
## what this does is change the thru macro line starting at the bottom
## by accessing the backwards list made above 
##  backwards_thru_list  that took in the line number of each thru line and reversed it
##########
def bottom_up_change_of_thru_line_test():
	mytrace('bottom_up_change_of_thru_line_test()')
	#global mouse
	global opal; opal = ''; mycounter = 0
	#print("value of mycounter should be zero",mycounter)
	#for item in backwards_thru_list: 
	#set mycounter to a number for line in mouse.splitlines() : #this goes thru the mouse string
	#	print(line)
		

###############==============
smart =''
beta =''
opal=''
import re
newline=''
#################==============


##############################################################################
#################### case_numbers_to_strings() ###############################
##############################################################################
######  converts numbers to strings case 1: to case '1': #####################
##############################################################################
def case_numbers_to_strings():
	mytrace('case_numbers_to_strings()')
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#print("========  CASE NUMBERS TO STRINGS  ====")#go thru the entire string
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global switchcasetester ## just addded this may 27th
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			#print(cat)
			cool    = smart[1][:-1]  #chops off : from end
			holder  = "'" + cool + "'" #this puts the ' on both flanks of the number
			cool    = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	#after the numbers have been converted into strings


#############################================


exp =''; case =''
exp = ""

mycounter=0


line =""
varholder=[]
varholder.append('0')
###############################============

#perhaps this is the clever() being called afterall june 9th 2021
#apparently this needs to exist in this file
def clever(i): #so it already exists we are changing its value
	print("clever() on line 276")
	varholder[0]='' #this should reset it to nothing
	mytrace('clever()')
	varholder[0]= i
	#===this works and it fills a list with input from an argument
	#print('varholder[0]=',varholder[0])
	#print(varholder[0]) #to actually see proof
	return varholder[0]
	angel = varholder[0]

###############################================


z =''
import re  #for regular expressions
acounter=0
x = 0;y =0
smart=''
res =[]
newlist=[]
switch_python_gen=''
###########################================




###==============================================================
###================  expand_thru_macro()  =======================
###==============================================================

inputnum = 1
def expand_thru_macro():
	mytrace('expand_thru_macro()')
	global switchcasetester
	change_to_into_thru()   #<======  "to macro" swapped with "thru" in switch case input
	newlist=[] #resets newlist
	global mouse; global ajax; global snowy; snowy=''
	mycounter = 0 ### mouse 
	for line in switchcasetester.splitlines():  #doing mouse not doing switchcasetester yet
		#beta = mycounter-1
										#reinitialize what I'm using with each loop iteration
		smart=[]; ajax=''; newlist  =[]
		#this is the bug fix so I say if "thru" in line but NOT "fallthru" in line.
		if "thru" in line and "case" in line and "fallthru" not in line:  #only used with numbers
			#print(line)
			if ":" in line and line.endswith(":"): #referring to one : in line
				line = chomp(line) #moved taking off colon here  line=line[:-1] 
				#print(line)
				## added on new years eve to hopefully fix bug of : in line with number
				#ValueError: invalid literal for int() with base 10: '3:'
				if ":" in line:
					#print("true : in line where only numbers allowed")
					line=line.replace(":",'')
					#print("now it looks like this on new years eve insane bug ")
					#print(line)
			else:  #so now if the line doesn't end with a colon it doesn't chomp it
				pass
			
			smart=line.split() #separates case from casename

			counter = smart[1]
			#this is filling up the newlist
			
			#### THIS FILLS newlist with the case info
			# ======LOOP  ==================
			#print("sniffing for bug here ===")
			if ":" in smart[3]:
				#print("smart[3]=",smart[3])
				smart[3]=smart[3].replace(":",'')
				#print("now we have",smart[3])
			##============ bug is down her ein smart[3] apparently =============
			for counter in range(int(smart[1]),int(smart[3]) + 1):
				newlist.append(counter)
				counter += 1
			
			ajax =''
			
			##==============================================================
			# LOOP ====================
			 
			for item in newlist:  #this list has the number in it
				ajax += "\t\tcase " +   str(item)   + ":" + "\n"
				#now delete last \n on end 
			#print("==== big test of replacing it ====")
			ajax = ajax.rstrip() #see if this works takes off last "\n" whcih was extra
			ajax = ajax[:-1] #chops off last char on end which is the :
			
			snowy=switchcasetester.replace(line, ajax)
			switchcasetester='';switchcasetester = snowy
			
			



######################################
##  convert_case_numbers_to_strings()
#######################################  #if no macros it just adds strings around numbers


def convert_case_numbers_to_strings():
	#print("we are here in convert case numbers to strings did this reach this far")
	#print("convert_case_numbers_to_strings() called ")
	mytrace('convert_case_numbers_to_strings()')
	global switchcasetester
	make_list_of_lines_using_thru_macro()
	expand_thru_macro()
	case_numbers_to_strings() #stringifies the numbers like this 3 becomes '3'



#this calls convert_case_numbers_to_strings
#this is reading numbers in cases NOT STRINGS and converting them into strings
##############================
cray=[] # this is used to hold the switchcasetester briefly when rewriting it
cray.append('starter')
##############=================

###########################################################
# if a multiple nested switch (at least one nested switch)
#added Mon June 28th, 2021 doing the engineering to make the impossible possible fuzzy logic
multi_switch_with_nested_switches=[]
multi_switch_with_nested_switches.append(0)
multi_switch_with_nested_switches[0] = False #by default
############################################################



##############################
##     macro_expansion()       
############################## # may 26th testing this 

def macro_expansion(y): #expands macros to and thru (if they exist)
	mytrace('macro_expansion()')
	#print("-----==macro_expansion ==-------")
	#print("macro_expansion called")
	if valve[0] == True:    #meaning numbers in cases detected
		#mytrace('starter_sequence_mode_2()')
		global switchcasetester; switchcasetester=y;
		#print("what is in switchcasetester before expanding macros if they exist")
		#print(switchcasetester)
		#################################
		convert_case_numbers_to_strings()  ## <<=== expands macros here 
		#################################
		#print(switchcasetester)
		cray[0] =switchcasetester  #this assigns the output string to cray[0]
	
############==============
# these are used 
coffee=[]  
valve=[]
valve.append("nada")# 0
valve.append("sway")# 1
#############==============


# this gets the line number of the first case in the switch case string
#################################################
##  grab_first_case_of_switch_string(y)
#################################################
def grab_first_case_of_switch_string(y): 
	mytrace("grab_first_case_of_switch_string()") 
	#global switchcasetester
	mycounter = 0
	#this takes in sw to test for finding out if numbers like case 2: or words case "apple"
	for line in y.splitlines():
		if "case" in line:
			#print("the counter for spotting word case is ")
			#print(mycounter)
			#print("coffee has in it at this point ",coffee)
			coffee.append(mycounter)
			#print(coffee[0]) #just added this 
			break  #here after getting the first instance of a case we leave the loop
		else:
			mycounter += 1
			continue




#####################################################
##  remove_tabs_from_string(y)
##################################################### 
def remove_tabs_from_string(y):
	mytrace("remove_tabs_from_string()") 
	y=y.replace("\t","")
	return y





#####################################################
##  grab_first_case_line_in_switch_case_string(y)
##################################################### 


def grab_first_case_line_in_switch_case_string(y):
	#global sw
	mytrace("grab_first_case_line_in_switch_case_string()") 
	#print(coffee[0])  #testing what's in this
	getline= eval("y.splitlines()[" + str(coffee[0]) + "]")
	#print(getline)
	return getline


##################################
##  check_if_number_in_string(x)
################################## 


def check_if_number_in_string(x):
	mytrace("check_if_number_in_string()") 
	theresult = any(char.isdigit() for char in x)  #this line from stackoverflow
	return theresult







################################
########    CHOMP(x)  ########## cuts off last char of a string
################################
## this bites off the last character in a string ##
def chomp(x):
	mytrace('chomp()')
	#print("====== chomp called",x)
	x = x[:-1] 
	#print("x=",x)
	return x




##### end of woodstock code =========================




###=====================
##      adder(x)
##======================

targetlist=[] #just added this 
targetlist.append(0) #initializes it

#math demonstration adding numbers between cases using fallthru
############ adder() ############## added may 27th 2021
def adder(x): #this can be modified to do more
	#print("targetlist[0]=",targetlist[0])
	print("adder called with ",x)
	#first time thru
	if targetlist[0] == 0:    
		x = str(x)
		targetlist[0] = x
		#print(targetlist[0])
	else:   #already something in here
		x = str(x)
		targetlist[0] = int(targetlist[0]) + int(x) #currently just adds
	print(targetlist[0])   #this can be modified to change the + using 
	#          plus()  minus() divide()  multiply() sqroot() etc...
	#return(x)

##====================================================================
	
buildstringlist=[]
buildstringlist.append(0)
# this can be used to create a math formula on the fly too
# from my experience 
################################################
##### concatting a string in fallthrus in switch case
############ buildstring() ############## added may 27th

###=========================
##      buildstring(x)
##==========================
def buildstring(x): #this should be 3
	#print("buildstring called with ",x)
	if buildstringlist[0] == 0: #first time thru
		#x =x + 1
		x = str(x)
		buildstringlist[0] = x # example 'Cola'
	else:   #already something in here
		#targetlist[0] = targetlist[0] + x
		#x =x + 1
		x = str(x)
		buildstringlist[0] = str(buildstringlist[0]) + str(x)
	print(buildstringlist[0])
	#return(x)
		




###================================================================	
#bugsbunny.py
#march 18th, 2021
global sw
varholder=[]
baseline=[]
baseline.append('a') #holder for switch code
#def flush_lists():
#	varholder=[]
varholder.append("zilch")

case_main_body_list_with_tail=[]

#experimental

valve=[]
var2=[]
var2.append("zilch")
starbuckslist=[]

# I have cases lists up to 1000
# you can add more but they must be in order and spelled correctly.
# python won't correctly dynamically generate them unfortunately.

def sw_reset():
	return
	#print("sw_reset() was called!!!!!========")
	#importlib.reload(switchmodtrial7)
	
#empty_list method
def empty_list(name): #might need to have it take in with string
	del name[:] #this empties the list
		


############## june 8th attempt ###########========= works==============================
###################################################################
##  TOP OF CASE CONSTANT UPPERCASE AND CONVERSION TO STRINGS
###################################################################
if_strings_found=[]
if_strings_found.append(False) #to initialize it with something

#print(sw)

#endswitch(sw)
def hasNumbers(inputString):
	return any(char.isdigit() for char in inputString)

#june 5th 2021 coding test
uppercase_test=[]
uppercase_test.append(False) # by default
#uppercase_test[0]

found_number_in_case=[]
found_number_in_case.append(False)

#might have to change sw to switchcasetester



#####################################
##  detect_if_number_in_cases()
#####################################
def detect_if_number_in_cases():
	global sw
	#print(sw)
	mycounter = 0
	contains_digit= False
	#global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:  #all it does is test the first case and then bails
			contains_digit = any(map(str.isdigit, line))
			if contains_digit == True:
				#print("number found")
				found_number_in_case[0]= True
				break
			else:
				pass
	#this will be commented out later
	#print("===========================")
	#print("did we find numbers in cases?",found_number_in_case[0])
	#print("===========================")	    
 






###########################################
##     detect_if_no_quotes_around_word()
###########################################
def detect_if_no_quotes_around_word():
	#print("detect if no quotes aorund word called")
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	#global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:  #all it does is test the first case and then bails
			if "'" not in line and '"' not in line:
				#print("no strings in line that we can see")
				#if_strings_found[0] == False:
				continue
					
			else:
				if "'"  in line or '"'  in line:
					if_strings_found[0]= True
					#if_strings_found[0] == True:
					break
					
	#this will be commented out later
	#print("===========================")
	#print("if_strings_found[0] =",if_strings_found[0])
	#print("===========================")
	
	
	
	
	
	
	
	
##########################################   
##    check if case word is uppercase()
##########################################
def check_if_case_word_is_uppercase():  #returns uppercase_test[0]
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			#cat =is_number(smart[1])  #calling method to check if the case name is a number
			##############################
			#print('smart[1]=',smart[1])
			#print("========================")
			#print("verify that it\'s all caps for the word ignoring _")
			cat = smart[1]
			#print("cat=",cat)
			#print(line)
			
			#print("verify that it's all uppercase constant")
			if cat.isupper() ==  True:
				#print("=====yes all UPPERCASE=====")
				uppercase_test[0] = True  #sets flag to True
				#print("===============")
				#print("uppercase_test[0]=",uppercase_test[0])
				#print("==============")
			else:
				pass #print("not all uppercase")
	###########################################				
	
	
	


###############################################
##  case_constant_uppercase_word_to_strings()
###############################################
def case_constant_uppercase_word_to_strings(): # case WORDINCAPS: becomes case 'WORDSHERE':
	#print("case constant uppercase word to strings() called")
	mytrace('case_numbers_to_strings()')
	#print("called case constant uppercase word to strings()")
	#print('starting this function we have this test view of uppercase',uppercase_test[0])
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			#cat =is_number(smart[1])  #calling method to check if the case name is a number
			##############################
			#print('smart[1]=',smart[1])
			#print("========================")
			#print("verify that it\'s all caps for the word ignoring _")
			cat = smart[1]
			#print("cat=",cat)
			#print(line)
			
			#print("verify that it's all uppercase constant")
			if cat.isupper()==  True:
				#print("=====yes all UPPERCASE=====")
				uppercase_test[0] = True
				#print("===============")
				#print("uppercase_test[0]=",uppercase_test[0])
				#print("==============")
			else:
				pass #print("not all uppercase")
				
			#print("=================")
			da = cat.isupper()
			
			dog = "'" + cat + "'"
			dog = cat[1:] 
			dog = cat[-1:]
			#print(cat) #to see what it sees now
			#print("=================")
			sa = cat.islower()

			fuel =cat[0].isdigit()
		
			
			if cat[0] == "'": 
				cat.replace("'",'' )
			if cat[-1] == "'":
				cat.replace("'",'' )
			#print(cat)	
			#####========
			if cat[0] == '"':
				cat.replace('"','' )
			if cat[-1] == '"':
				cat.replace('"','' )
			#print(cat)	
			###### new idea on Wednesday June 2nd
			#print("=====verify not single or double quotes in case line")
			if "'" not in line and '"' not in line:
				pass
			else:
				pass#print("true no quotes in line")
			######################################		
			#print('====this adds the strings to be sure that they are in the correct format')
			cool    = smart[1][:-1]  #chops off : from end
			holder  = "'" + cool + "'" #this puts the ' on both flanks of the number
			cool    = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			opal=sw.replace(line,"\t\t" +newline)
			sw=''
			sw = opal
			mycounter += 1
		else:
			mycounter += 1
			continue
						
	baseline[0] = sw  #this means uppercase constant words
	



 

###############################################
##    check_if_uppercase_constant_cases()
###############################################
def check_if_uppercase_constant_cases(y):
    global sw
    sw = y
    detect_if_number_in_cases()
    detect_if_no_quotes_around_word()
    check_if_case_word_is_uppercase()
    
    if uppercase_test[0] == True:  #this does nothing now 
        pass #print("it is UPPERCASE")
    else:
        pass #print("it is lowercase")
    # this is if numbers in case and if strings found and if uppercase (3 booleans))
    ##===========================================
   # 

   ### BOOLEAN test to determine if case UPPERCASE: no numbers, no strings and uppercase True
    if found_number_in_case[0]  == False \
        and if_strings_found[0] == False \
        and uppercase_test[0]   == True:
    ### BOOLEAN test to determine if meets criteria of uppercase word for a case
    ##============================================
        ## this is where the case words are converted to strings
        ########################################
        case_constant_uppercase_word_to_strings()
        ########################################
        #print("MEETS criteria to convert inputs string uppercase constants to strings")
    else:
        baseline[0] = "nada"  # doesn't meet criteria of case UPPERCASE
        pass                  # do nothing if critiera not met for converting to strings
                              # later will add ability to handle lowercase and numbers 
                              # print("doesn't meet criterial to do uppercase to strings")
                              #	adds strings





	
caselist1=[]
caselist2=[]
caselist3=[]
caselist4=[]
caselist5=[]
caselist6=[]
caselist7=[]
caselist8=[]
caselist9=[]
caselist10=[]
caselist11=[]
caselist12=[]
caselist13=[]
caselist14=[]
caselist15=[]
caselist16=[]
caselist17=[]
caselist18=[]
caselist19=[]
caselist20=[]
caselist21=[]
caselist22=[]
caselist23=[]
caselist24=[]
caselist25=[]
caselist26=[]
caselist27=[]
caselist28=[]
caselist29=[]
caselist30=[]
caselist31=[]
caselist32=[]
caselist33=[]
caselist34=[]
caselist35=[]
caselist36=[]
caselist37=[]
caselist38=[]
caselist39=[]
caselist40=[]
caselist41=[]
caselist42=[]
caselist43=[]
caselist44=[]
caselist45=[]
caselist46=[]
caselist47=[]
caselist48=[]
caselist49=[]
caselist50=[]
caselist51=[]
caselist52=[]
caselist53=[]
caselist54=[]
caselist55=[]
caselist56=[]
caselist57=[]
caselist58=[]
caselist59=[]
caselist60=[]
caselist61=[]
caselist62=[]
caselist63=[]
caselist64=[]
caselist65=[]
caselist66=[]
caselist67=[]
caselist68=[]
caselist69=[]
caselist70=[]
caselist71=[]
caselist72=[]
caselist73=[]
caselist74=[]
caselist75=[]
caselist76=[]
caselist77=[]
caselist78=[]
caselist79=[]
caselist80=[]
caselist81=[]
caselist82=[]
caselist83=[]
caselist84=[]
caselist85=[]
caselist86=[]
caselist87=[]
caselist88=[]
caselist89=[]
caselist90=[]
caselist91=[]
caselist92=[]
caselist93=[]
caselist94=[]
caselist95=[]
caselist96=[]
caselist97=[]
caselist98=[]
caselist99=[]
caselist100=[]
caselist101=[]
caselist102=[]
caselist103=[]
caselist104=[]
caselist105=[]
caselist106=[]
caselist107=[]
caselist108=[]
caselist109=[]
caselist110=[]
caselist111=[]
caselist112=[]
caselist113=[]
caselist114=[]
caselist115=[]
caselist116=[]
caselist117=[]
caselist118=[]
caselist119=[]
caselist120=[]
caselist121=[]
caselist122=[]
caselist123=[]
caselist124=[]
caselist125=[]
caselist126=[]
caselist127=[]
caselist128=[]
caselist129=[]
caselist130=[]
caselist131=[]
caselist132=[]
caselist133=[]
caselist134=[]
caselist135=[]
caselist136=[]
caselist137=[]
caselist138=[]
caselist139=[]
caselist140=[]
caselist141=[]
caselist142=[]
caselist143=[]
caselist144=[]
caselist145=[]
caselist146=[]
caselist147=[]
caselist148=[]
caselist149=[]
caselist150=[]
caselist151=[]
caselist152=[]
caselist153=[]
caselist154=[]
caselist155=[]
caselist156=[]
caselist157=[]
caselist158=[]
caselist159=[]
caselist160=[]
caselist161=[]
caselist162=[]
caselist163=[]
caselist164=[]
caselist165=[]
caselist166=[]
caselist167=[]
caselist168=[]
caselist169=[]
caselist170=[]
caselist171=[]
caselist172=[]
caselist173=[]
caselist174=[]
caselist175=[]
caselist176=[]
caselist177=[]
caselist178=[]
caselist179=[]
caselist180=[]
caselist181=[]
caselist182=[]
caselist183=[]
caselist184=[]
caselist185=[]
caselist186=[]
caselist187=[]
caselist188=[]
caselist189=[]
caselist190=[]
caselist191=[]
caselist192=[]
caselist193=[]
caselist194=[]
caselist195=[]
caselist196=[]
caselist197=[]
caselist198=[]
caselist199=[]
caselist200=[]
caselist201=[]
caselist202=[]
caselist203=[]
caselist204=[]
caselist205=[]
caselist206=[]
caselist207=[]
caselist208=[]
caselist209=[]
caselist210=[]
caselist211=[]
caselist212=[]
caselist213=[]
caselist214=[]
caselist215=[]
caselist216=[]
caselist217=[]
caselist218=[]
caselist219=[]
caselist220=[]
caselist221=[]
caselist222=[]
caselist223=[]
caselist224=[]
caselist225=[]
caselist226=[]
caselist227=[]
caselist228=[]
caselist229=[]
caselist230=[]
caselist231=[]
caselist232=[]
caselist233=[]
caselist234=[]
caselist235=[]
caselist236=[]
caselist237=[]
caselist238=[]
caselist239=[]
caselist240=[]
caselist241=[]
caselist242=[]
caselist243=[]
caselist244=[]
caselist245=[]
caselist246=[]
caselist247=[]
caselist248=[]
caselist249=[]
caselist250=[]
caselist251=[]
caselist252=[]
caselist253=[]
caselist254=[]
caselist255=[]
caselist256=[]
caselist257=[]
caselist258=[]
caselist259=[]
caselist260=[]
caselist261=[]
caselist262=[]
caselist263=[]
caselist264=[]
caselist265=[]
caselist266=[]
caselist267=[]
caselist268=[]
caselist269=[]
caselist270=[]
caselist271=[]
caselist272=[]
caselist273=[]
caselist274=[]
caselist275=[]
caselist276=[]
caselist277=[]
caselist278=[]
caselist279=[]
caselist280=[]
caselist281=[]
caselist282=[]
caselist283=[]
caselist284=[]
caselist285=[]
caselist286=[]
caselist287=[]
caselist288=[]
caselist289=[]
caselist290=[]
caselist291=[]
caselist292=[]
caselist293=[]
caselist294=[]
caselist295=[]
caselist296=[]
caselist297=[]
caselist298=[]
caselist299=[]
caselist300=[]
caselist301=[]
caselist302=[]
caselist303=[]
caselist304=[]
caselist305=[]
caselist306=[]
caselist307=[]
caselist308=[]
caselist309=[]
caselist310=[]
caselist311=[]
caselist312=[]
caselist313=[]
caselist314=[]
caselist315=[]
caselist316=[]
caselist317=[]
caselist318=[]
caselist319=[]
caselist320=[]
caselist321=[]
caselist322=[]
caselist323=[]
caselist324=[]
caselist325=[]
caselist326=[]
caselist327=[]
caselist328=[]
caselist329=[]
caselist330=[]
caselist331=[]
caselist332=[]
caselist333=[]
caselist334=[]
caselist335=[]
caselist336=[]
caselist337=[]
caselist338=[]
caselist339=[]
caselist340=[]
caselist341=[]
caselist342=[]
caselist343=[]
caselist344=[]
caselist345=[]
caselist346=[]
caselist347=[]
caselist348=[]
caselist349=[]
caselist350=[]
caselist351=[]
caselist352=[]
caselist353=[]
caselist354=[]
caselist355=[]
caselist356=[]
caselist357=[]
caselist358=[]
caselist359=[]
caselist360=[]
caselist361=[]
caselist362=[]
caselist363=[]
caselist364=[]
caselist365=[]
caselist366=[]
caselist367=[]
caselist368=[]
caselist369=[]
caselist370=[]
caselist371=[]
caselist372=[]
caselist373=[]
caselist374=[]
caselist375=[]
caselist376=[]
caselist377=[]
caselist378=[]
caselist379=[]
caselist380=[]
caselist381=[]
caselist382=[]
caselist383=[]
caselist384=[]
caselist385=[]
caselist386=[]
caselist387=[]
caselist388=[]
caselist389=[]
caselist390=[]
caselist391=[]
caselist392=[]
caselist393=[]
caselist394=[]
caselist395=[]
caselist396=[]
caselist397=[]
caselist398=[]
caselist399=[]
caselist400=[]
caselist401=[]
caselist402=[]
caselist403=[]
caselist404=[]
caselist405=[]
caselist406=[]
caselist407=[]
caselist408=[]
caselist409=[]
caselist410=[]
caselist411=[]
caselist412=[]
caselist413=[]
caselist414=[]
caselist415=[]
caselist416=[]
caselist417=[]
caselist418=[]
caselist419=[]
caselist420=[]
caselist421=[]
caselist422=[]
caselist423=[]
caselist424=[]
caselist425=[]
caselist426=[]
caselist427=[]
caselist428=[]
caselist429=[]
caselist430=[]
caselist431=[]
caselist432=[]
caselist433=[]
caselist434=[]
caselist435=[]
caselist436=[]
caselist437=[]
caselist438=[]
caselist439=[]
caselist440=[]
caselist441=[]
caselist442=[]
caselist443=[]
caselist444=[]
caselist445=[]
caselist446=[]
caselist447=[]
caselist448=[]
caselist449=[]
caselist450=[]
caselist451=[]
caselist452=[]
caselist453=[]
caselist454=[]
caselist455=[]
caselist456=[]
caselist457=[]
caselist458=[]
caselist459=[]
caselist460=[]
caselist461=[]
caselist462=[]
caselist463=[]
caselist464=[]
caselist465=[]
caselist466=[]
caselist467=[]
caselist468=[]
caselist469=[]
caselist470=[]
caselist471=[]
caselist472=[]
caselist473=[]
caselist474=[]
caselist475=[]
caselist476=[]
caselist477=[]
caselist478=[]
caselist479=[]
caselist480=[]
caselist481=[]
caselist482=[]
caselist483=[]
caselist484=[]
caselist485=[]
caselist486=[]
caselist487=[]
caselist488=[]
caselist489=[]
caselist490=[]
caselist491=[]
caselist492=[]
caselist493=[]
caselist494=[]
caselist495=[]
caselist496=[]
caselist497=[]
caselist498=[]
caselist499=[]
caselist500=[]
caselist501=[]
caselist502=[]
caselist503=[]
caselist504=[]
caselist505=[]
caselist506=[]
caselist507=[]
caselist508=[]
caselist509=[]
caselist510=[]
caselist511=[]
caselist512=[]
caselist513=[]
caselist514=[]
caselist515=[]
caselist516=[]
caselist517=[]
caselist518=[]
caselist519=[]
caselist520=[]
caselist521=[]
caselist522=[]
caselist523=[]
caselist524=[]
caselist525=[]
caselist526=[]
caselist527=[]
caselist528=[]
caselist529=[]
caselist530=[]
caselist531=[]
caselist532=[]
caselist533=[]
caselist534=[]
caselist535=[]
caselist536=[]
caselist537=[]
caselist538=[]
caselist539=[]
caselist540=[]
caselist541=[]
caselist542=[]
caselist543=[]
caselist544=[]
caselist545=[]
caselist546=[]
caselist547=[]
caselist548=[]
caselist549=[]
caselist550=[]
caselist551=[]
caselist552=[]
caselist553=[]
caselist554=[]
caselist555=[]
caselist556=[]
caselist557=[]
caselist558=[]
caselist559=[]
caselist560=[]
caselist561=[]
caselist562=[]
caselist563=[]
caselist564=[]
caselist565=[]
caselist566=[]
caselist567=[]
caselist568=[]
caselist569=[]
caselist570=[]
caselist571=[]
caselist572=[]
caselist573=[]
caselist574=[]
caselist575=[]
caselist576=[]
caselist577=[]
caselist578=[]
caselist579=[]
caselist580=[]
caselist581=[]
caselist582=[]
caselist583=[]
caselist584=[]
caselist585=[]
caselist586=[]
caselist587=[]
caselist588=[]
caselist589=[]
caselist590=[]
caselist591=[]
caselist592=[]
caselist593=[]
caselist594=[]
caselist595=[]
caselist596=[]
caselist597=[]
caselist598=[]
caselist599=[]
caselist600=[]
caselist601=[]
caselist602=[]
caselist603=[]
caselist604=[]
caselist605=[]
caselist606=[]
caselist607=[]
caselist608=[]
caselist609=[]
caselist610=[]
caselist611=[]
caselist612=[]
caselist613=[]
caselist614=[]
caselist615=[]
caselist616=[]
caselist617=[]
caselist618=[]
caselist619=[]
caselist620=[]
caselist621=[]
caselist622=[]
caselist623=[]
caselist624=[]
caselist625=[]
caselist626=[]
caselist627=[]
caselist628=[]
caselist629=[]
caselist630=[]
caselist631=[]
caselist632=[]
caselist633=[]
caselist634=[]
caselist635=[]
caselist636=[]
caselist637=[]
caselist638=[]
caselist639=[]
caselist640=[]
caselist641=[]
caselist642=[]
caselist643=[]
caselist644=[]
caselist645=[]
caselist646=[]
caselist647=[]
caselist648=[]
caselist649=[]
caselist650=[]
caselist651=[]
caselist652=[]
caselist653=[]
caselist654=[]
caselist655=[]
caselist656=[]
caselist657=[]
caselist658=[]
caselist659=[]
caselist660=[]
caselist661=[]
caselist662=[]
caselist663=[]
caselist664=[]
caselist665=[]
caselist666=[]
caselist667=[]
caselist668=[]
caselist669=[]
caselist670=[]
caselist671=[]
caselist672=[]
caselist673=[]
caselist674=[]
caselist675=[]
caselist676=[]
caselist677=[]
caselist678=[]
caselist679=[]
caselist680=[]
caselist681=[]
caselist682=[]
caselist683=[]
caselist684=[]
caselist685=[]
caselist686=[]
caselist687=[]
caselist688=[]
caselist689=[]
caselist690=[]
caselist691=[]
caselist692=[]
caselist693=[]
caselist694=[]
caselist695=[]
caselist696=[]
caselist697=[]
caselist698=[]
caselist699=[]
caselist700=[]
caselist701=[]
caselist702=[]
caselist703=[]
caselist704=[]
caselist705=[]
caselist706=[]
caselist707=[]
caselist708=[]
caselist709=[]
caselist710=[]
caselist711=[]
caselist712=[]
caselist713=[]
caselist714=[]
caselist715=[]
caselist716=[]
caselist717=[]
caselist718=[]
caselist719=[]
caselist720=[]
caselist721=[]
caselist722=[]
caselist723=[]
caselist724=[]
caselist725=[]
caselist726=[]
caselist727=[]
caselist728=[]
caselist729=[]
caselist730=[]
caselist731=[]
caselist732=[]
caselist733=[]
caselist734=[]
caselist735=[]
caselist736=[]
caselist737=[]
caselist738=[]
caselist739=[]
caselist740=[]
caselist741=[]
caselist742=[]
caselist743=[]
caselist744=[]
caselist745=[]
caselist746=[]
caselist747=[]
caselist748=[]
caselist749=[]
caselist750=[]
caselist751=[]
caselist752=[]
caselist753=[]
caselist754=[]
caselist755=[]
caselist756=[]
caselist757=[]
caselist758=[]
caselist759=[]
caselist760=[]
caselist761=[]
caselist762=[]
caselist763=[]
caselist764=[]
caselist765=[]
caselist766=[]
caselist767=[]
caselist768=[]
caselist769=[]
caselist770=[]
caselist771=[]
caselist772=[]
caselist773=[]
caselist774=[]
caselist775=[]
caselist776=[]
caselist777=[]
caselist778=[]
caselist779=[]
caselist780=[]
caselist781=[]
caselist782=[]
caselist783=[]
caselist784=[]
caselist785=[]
caselist786=[]
caselist787=[]
caselist788=[]
caselist789=[]
caselist790=[]
caselist791=[]
caselist792=[]
caselist793=[]
caselist794=[]
caselist795=[]
caselist796=[]
caselist797=[]
caselist798=[]
caselist799=[]
caselist800=[]
caselist801=[]
caselist802=[]
caselist803=[]
caselist804=[]
caselist805=[]
caselist806=[]
caselist807=[]
caselist808=[]
caselist809=[]
caselist810=[]
caselist811=[]
caselist812=[]
caselist813=[]
caselist814=[]
caselist815=[]
caselist816=[]
caselist817=[]
caselist818=[]
caselist819=[]
caselist820=[]
caselist821=[]
caselist822=[]
caselist823=[]
caselist824=[]
caselist825=[]
caselist826=[]
caselist827=[]
caselist828=[]
caselist829=[]
caselist830=[]
caselist831=[]
caselist832=[]
caselist833=[]
caselist834=[]
caselist835=[]
caselist836=[]
caselist837=[]
caselist838=[]
caselist839=[]
caselist840=[]
caselist841=[]
caselist842=[]
caselist843=[]
caselist844=[]
caselist845=[]
caselist846=[]
caselist847=[]
caselist848=[]
caselist849=[]
caselist850=[]
caselist851=[]
caselist852=[]
caselist853=[]
caselist854=[]
caselist855=[]
caselist856=[]
caselist857=[]
caselist858=[]
caselist859=[]
caselist860=[]
caselist861=[]
caselist862=[]
caselist863=[]
caselist864=[]
caselist865=[]
caselist866=[]
caselist867=[]
caselist868=[]
caselist869=[]
caselist870=[]
caselist871=[]
caselist872=[]
caselist873=[]
caselist874=[]
caselist875=[]
caselist876=[]
caselist877=[]
caselist878=[]
caselist879=[]
caselist880=[]
caselist881=[]
caselist882=[]
caselist883=[]
caselist884=[]
caselist885=[]
caselist886=[]
caselist887=[]
caselist888=[]
caselist889=[]
caselist890=[]
caselist891=[]
caselist892=[]
caselist893=[]
caselist894=[]
caselist895=[]
caselist896=[]
caselist897=[]
caselist898=[]
caselist899=[]
caselist900=[]
caselist901=[]
caselist902=[]
caselist903=[]
caselist904=[]
caselist905=[]
caselist906=[]
caselist907=[]
caselist908=[]
caselist909=[]
caselist910=[]
caselist911=[]
caselist912=[]
caselist913=[]
caselist914=[]
caselist915=[]
caselist916=[]
caselist917=[]
caselist918=[]
caselist919=[]
caselist920=[]
caselist921=[]
caselist922=[]
caselist923=[]
caselist924=[]
caselist925=[]
caselist926=[]
caselist927=[]
caselist928=[]
caselist929=[]
caselist930=[]
caselist931=[]
caselist932=[]
caselist933=[]
caselist934=[]
caselist935=[]
caselist936=[]
caselist937=[]
caselist938=[]
caselist939=[]
caselist940=[]
caselist941=[]
caselist942=[]
caselist943=[]
caselist944=[]
caselist945=[]
caselist946=[]
caselist947=[]
caselist948=[]
caselist949=[]
caselist950=[]
caselist951=[]
caselist952=[]
caselist953=[]
caselist954=[]
caselist955=[]
caselist956=[]
caselist957=[]
caselist958=[]
caselist959=[]
caselist960=[]
caselist961=[]
caselist962=[]
caselist963=[]
caselist964=[]
caselist965=[]
caselist966=[]
caselist967=[]
caselist968=[]
caselist969=[]
caselist970=[]
caselist971=[]
caselist972=[]
caselist973=[]
caselist974=[]
caselist975=[]
caselist976=[]
caselist977=[]
caselist978=[]
caselist979=[]
caselist980=[]
caselist981=[]
caselist982=[]
caselist983=[]
caselist984=[]
caselist985=[]
caselist986=[]
caselist987=[]
caselist988=[]
caselist989=[]
caselist990=[]
caselist991=[]
caselist992=[]
caselist993=[]
caselist994=[]
caselist995=[]
caselist996=[]
caselist997=[]
caselist998=[]
caselist999=[]
caselist1000=[]

'''
def runthisnow():
	print("====caselists generated===")
	i = 128; j = 1000;
	while i  < j:
		print("caselist" + str(i) + "=[]")
		i += 1
		continue;
'''	
		

#runthisnow()


def clear_out_all_case_lists():
	#get last case list number like 14
	caselist1=[]
	caselist2=[]
	caselist3=[]
	caselist4=[]
	caselist5=[]
	caselist6=[]
	caselist7=[]
	caselist8=[]
	caselist9=[]
	caselist10=[]
	caselist11=[]
	caselist12=[]
	caselist13=[]
	caselist14=[]
	caselist15=[]
	caselist16=[]
	


#this resets all of the lists
##### flush_lists() ##############
def flush_lists():
	#print("===== flush lists() called =====")
	mytrace('flush_lists  =====')
	#switchcasetester = ''
	#sw=''
	#newest additions here april 7, 2021
	birdsong=[0]
	music=[0]
	colorful=[0]

	caseset=[]
	wilsonball=[]
	palmtrees=[]
	candy=[]
	digitalcandy=[]
	caselist =[]
	breaklist =[]
	einstein=[]
	smartcasemanager=[]
	british=[]
	cranberries=[]
	defaultlist =[]
	blanklines  =[]
	mixedlist   =[]
	batterondeck =[] #I can have item to comapore with in here
	seriestogether =[]
	res =[]
	getfirstword =[]
	casephrase =[]
	alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
	casesections =[]
	casesectioncounter =[]
	breakposition =[]
	trontime =[]
	tronlinenumbers =[]
	fallthrulist = []
	smartlist =[]
	smartlistlocations=[]
	fallthrulocations=[]
	#theinputlist =[]
	digitalcandy=[]
	line_numbers_of_first_cases=[]
	

#################  from woodstock_alpha which is the numbers code 
#################======== beginning of woodstock code added here at top =====
#################
show_py_switch=[]
show_py_switch.append(False)  #this is show_py_switch[0]

#to debug generated code you can see the generatedcode 
def view_code_turn_on():
    show_py_switch[0] = True
    
    
def view_code_turn_off():
    show_py_switch[0] = False

#what this does is show the output python code that is genereated from code gen
#and then executed

view_code_turn_on()  #if it says view_code_turn_off() it won't show the generated python
    
  



'''
reset_list_to_just_starter(listname)
this makes sure that a list is reset if already used recently to
the initial state with starter in the first list element with nothing else
so that it will have a lengthh of 1. It can be 0 or 'starter' in the first slot.
This was devised to clear out lists so that after the first switch is called
all subsequent switch calls have cleared lists so it's as if each call of a 
switch is the first switch call rather than calling reload module. 
'''
#april 27th, 2021  2:46pm
############################################
#   reset_list_to_just_starter(listname)
############################################
def reset_list_to_just_starter(listname):
	#print("reset_list_to_just_starter() called")
	if len(listname) > 1:         # checks if list length greater than 1
		for item in listname:     # loop through entire list
			if len(listname) > 1: # if length of list > 1
				listname.pop()	  # delete last item of list
		#end loop
		if len(listname) == 2:    # if length of list equals 2
			listname.pop()		  # delete last item in list

		if len(listname) == 1:    # if list length = 1  all okay
			pass #print('proceed',listname, ' length 1 is correct')
		else:
			pass #print("this list", listname, "is wrong supposed to be length 1", len(listname))
	else:
		# length of list is 0 or 1 do nothing
		pass

#####################################
# reset_list_to_empty
#####################################
def reset_list_to_empty(listname):
	del listname[:]  #just changed this wednesday may 19th 










######################################
default_location=''
def get_default_location_2(): #line number location of the word default
	print("=============get default location called =================")
	mytrace('get_default_location_2')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
			break
		else:
			counter += 1
			continue
	return default_location







	
########################################
##      get last break in string
########################################
listofbreaks=[]
def get_last_break_in_string_2():
	#print("==============find last break in string============")
	mytrace('get_last_break_in_string_2()')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string
	
	
	
	
#############################


#I need to add a break if there isn't one saturday, December 5th
#it expects a break at bottom of default.
#and I just realized it requires a default but doesn't look for one
newton=''
orange=''
#this scans through input switch and changes default to case default
#switchcasetester=''
last_break=''
#this assumes that there is a default. I will just make it mandatory to have a default
################################################################################
### this does convert_default_case AND add break after default if it needs one
################################################################################
def convert_default_case_2(): #I got this working November 26th, 2020
	#print("IS THIS BEING CALLED convert_default_case_2()")
	mytrace('convert_default_case_2')
	#print("===========convert default case called ===========")
	############################################################
	get_default= get_default_location_2()
	last_break =get_last_break_in_string_2()
	
	
	############################################################
	global switchcasetester
	# IF default(LINE NUMBER) < last break(LINE NUMBER)  There is a break
	#########################################################################
	#this says: if default (line number) LESS than last break (line number)
	#in other words this says if "break" after "default" is True 
	if int(get_default) < int(last_break):  #### if default  < last break  
	
	#########################################################################
		
		#print("there is a break after default")
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
		
		# at this ELSE This is triggered if NO BREAK IS AFTER DEFAULT and therefore add a break
		#the else  is triggered if int(a)> int(b) meaning break number LESS THAN default line num
	else:
		#down below here it adds break after default and makes case deafult
		#print(switchcasetester)
		########################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		orange=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = orange
		#print(switchcasetester)
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
	
	






def testing_number_of_lines_in_string_2():
	mytrace('testing_number_of_lines_in_string_2()')
	count =0
	for line in switchcasetester.splitlines():
		count +=1
		#print(count)
	#print("there were ",count, "lines in string")
	return count




    #apple = "one"
###=================== nov 19th new code ============
###================ get_closing_brace (line number) ==============
closing_brace=''
def get_closing_brace_2():
	#print("get_closing_brace called")
	mytrace('get_closing_brace_2')
	counter =0
	closing_brace =testing_number_of_lines_in_string_2()
	return closing_brace

###=============================================
default_location=''
def get_default_location_2():
	mytrace('get_default_location_2')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
		else:
			counter += 1
			continue
	return default_location



list1 =[]
list1.append("four")


#varholder[0] ="four"









list1=[]
exp =''; case =''
exp = ""

#exec(betterworknow)




####======== starts here ===============
#this is the function triggered to start the parser and codegen
def start_trigger_2():  #this converts the default case immediately
	#global switchcasetester  #just added this to hopefully fix bug
	trigger = True
	print("trigger =", trigger)
	if trigger == True:
		print("trigger =", True)
	else:
		print('trigger=',False)

	mytrace('start_trigger_2')
	convert_default_case_2()





caselist    =[]
breaklist   =[]
defaultlist =[]
blanklines =[]
mixedlist   =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]
getfirstword =[]
casephrase =[]
alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
casesections =[]
casesectioncounter =[]
breakposition =[]
trontime =[]
tronlinenumbers =[]
fallthrulist = []
smartlist =[]
smartlistlocations=[]
fallthrulocations=[]
#theinputlist =[]





###### how do I pass a list
#this might work
def get_first_list():
	mytrace('get_first_list()')





#this finds teh first case in each case section and works
#should be: starter,apple, bananas,chocolate, fish,default
#digitalcandy=[[3,7],[7,19],[19,26],[26,33],[33,43],[43,46]]
















mycounter=0
turtle_tab1=[]
turtle_tab2=[]
turtle_tab1.append('starter')
turtle_tab2.append('starter')
#print('looking for tabs in lines================')
#this is just testing in one case for now
#what I am trying to do is 2 loops one for each case section
#so for the second pass it should start at the next case occurrence
#so first I need to prescan it and get the line number of each case
#apparently the solution is using the digitalcandy list with
#the range of case line numbers which I already have calcualted
#this way I can reuse that and focus on just one case section at a time
#and loop through the digital candy list
#I should fill a two dimensional loop
#I can make each new loop and apppend it to the big loop

biglist=[]
testlist=[1,1,1,1,] #tabs for each line in a case
testlist2=[2,2,2,2,2,2]
biglist.append(testlist)
biglist.append(testlist2)

listofifs =[]

def big_gears_filling_list_with_case_bodies_2():
	mytrace('big_gears_filling_list_with_case_bodies_2')
	#mytrace('snowtime') #it calls snowtime() below
	#print("================  big gears filling list with case bodies called  ==========")
	counter=0
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]
		counter += 1
		snowtime(item[0],item[1])  #snowtime is called here





z =''
#this loopsthru the string of jsswitch between
#case numbers in line
mytablist=[]
sublist=[]
case_main_body_list=[]  #just added this oct 8th
#this copies the case body for each case section and addds it to case_main_body_list

def snowtime_2(x,y):  #this grabs the body from one case section at a time
	mytrace('snowtime()')
	global practicestring1
	practicestring1 = ""
	
	mycounter=0
	dog=''
	mytablist=[]
	for line in switchcasetester.splitlines():


		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line:

			if len(line) == 0: #this means that the line is empty

				mycounter += 1 #see if this is necessary here or not
				continue
			else:


				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				sublist.append(dog)
				#print('the tabs are invisible and embeddd in the code string.')


		mycounter += 1
		#print(sublist)
	mytablist.append(sublist)
	#print("mytablist =",mytablist)

	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 ='' #clears it out

#=========================================================================






#===================================================
#global variable initialization here
#november 10th, 2020
theresult = ''
#testing_this_out function calls function input_string() which returns
#the docstring as a variable and is assigned to the global variable theresult



#=====================================================






















#line_numbers_of_first_cases
#look at this force feeding it input i need to find the generation of the inputlist


	#print("=======")

	#str = "'apple'"
	#print(str)
	#print(str.replace('"', ''))





#sunrise();

#what this does is take the input of teh [concatstring list] with line numbers
#which has the first case line number for each section
#I need the case number list name to feed it













#this_needs_to_work_badly();[2, 7, 17, 24, 34]
#theinputlist =[2,7,17,24,34]  #5 which is case_sections + 1 (default)
case_sections = 0
total = 5
#==========================
#I will have to dynamically initialize these


mainlist=[]
#diamonds=[[2,7],[7,19],[19,26],[26,36]]  what I am aiming to make
#these are lines of the first case line numbers and then the default line number


#theinputlist= [2, 7, 17, 24, 34]  #last one is default which is really a case


length_of_input_list = len(line_numbers_of_first_cases)   #question does this work because it's an even number
#output
mainlist= [] # [[2, 7], [7, 19], [19, 26], [26, 36]]



find_default=''
lastbrace=''

list_trex=[]
listcandy=[]
defaultlist=[]  #here defaultlist is declared as empty



	#digitalcandy.append(defaultlist)
###=============================================




## what this does is delete the existing last sublist from digitalcandy
## and then it replaces it with a new list appended that has the default line number and
## curly brace line number (can alternatively be the last line of string) both equal length





#==============
# this looks like good logic to check between default and closing brace/last line
# determined last line number also eventually
# december 7th, this is dependent on default word existing
# the point of this code section is to VERIFY that there IS a BREAK after default
# and if there isn't a break add one
#=========
#
#===============
#defaultlist=[]
'''

'''
###====================
####======== find_last_break_in_string  ========= in switchcasetester input switch
listofbreaks=[]
def find_last_break_in_string_2():
	mytrace('find_last_break')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string

#=========================
####### special addition to digital_candy 2
#############################################


#working on this December 17th new functions
'''

   
'''

######################
##  stage_four_2
#######################
def stage_four_2():
	mytrace('stage_four_2()')
	#print('stage four')
	#magictimenow_2()
	#convert_to_twin_list_2()
	#special_addition_to_digital_candy_2() #======added nov 25th, 2020
	#rule_the_earth_2()






#================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.
firstline =""
#additions on Sunday August 23rd, 2020
royallist=[]  #mythical list of tail for case section codegen
royallist.append('starter'); #which fills position0


#this is a super important function I think I wrote it at the beach a few days ago
def testing_this_to_get_word_2():
    return
   



#testing_this_to_get_word()  #==================this should call it now
######################
##  stage_five_2
#######################
def stage_five_2():
    return#print('stage five')
    #testing_this_to_get_word_2()




    ###########################################################
    #these are the line number positions of first case for each section [2, 7, 19,26]
    #this looks in one section at a time for a break and fallthru
#diamonds =[]
    #this is all just raw code not even in a function
def does_this_run():
    mytrace("does_this_run")
    c = 1    #current case numbr section
    d = c + 1

    x = clever[0]
    y = clever[1]
             #this loops by default through the entire string
             #for line in splitline().switch:

     #=======================================================
     #this is looking between x and y which are in diamonds
     #========================================================

    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]
    #print("testing getting the dam range to work")
    #print("looking for BREAK in this case section")
    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;


        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=========================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##===========================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:  #what about fallthrough also to test for
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');

    if "true" in case1findfallthru:
        #print('fallthru found')
        royallist.append('fallthru')

    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        royallist.append('fallthru')

    #print("royallist=",royallist)
###########






#//=========== iron curtain============================

 ##===============================================================
  ####=================== American River Methods ==================
  ##===============================================================


  #================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.







######################
##  grab_body_of_code_inside_case_sections_2
#######################
buildlist=[]
def grab_body_of_code_inside_case_sections_2():
    mytrace("grab_body_of_code_inside_case_sections")
    #print("grab body of code called== @@@@")
    smartcounter=0  #reset at zero

    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)

        if smartcounter > x and smartcounter < y:  #so get what's inbeteen
       #this should only print the body of this one case section
            if "case" not in line and "break" not in line and "fallthru" not in line:
                #print(line)
                buildlist.append(line,smartcounter);
                smartcounter += 1;
                #do I need continue?





#august 27 thurday coding test       this will be the sets of cases for each case section
caseset=[]
###############################
## create_case_name_lists_2
###############################

def create_case_name_lists_2(x,y):
    #print("==$$$$$$$$$$$$$$$$$$$$$$$$$$$$$==")
    #print("================this is line 1615===CREATE CASE NAME LISTS=====================")
   # print("def create_case_name_lists:")
    #print("working on fix to solve bug if user uses more than one word for a case")
    #print("such as alpine meadows whereas right now its geared for one word cases")
    
    mytrace('create_case_name_lists')
    #print("=================create case name lists called == @@@@")

    smartcounter=0 #reset at zero
    genius = ''
     #need list of first cases that will work for input
    
    ##===================================================================
    ## LOOP LOOKING  CASE SECTION APPEND LINES FROM BODY AFTER CASES UNTIL NEXT FIRST CASE
    ##=======================================================================
    #print("here we get the words in each case section=====------")
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter < y:  #so get what's inbeteen
        #this should just look
            if "case"  in line:
                #print("did it take off front of line?")
                #print(line.split(' ',1)[1])
                #print(line,smartcounter)
               # print("=================================")
                genius =line.split()
                #print("genius =",genius)
                #print("======= len(genius) ==============")
                #print("WE ARE HERE==>>>>")
                #print('number of words in the line case = len(genius) ',len(genius))
                
                #print("number of words in this line =",len(genius))
                #print("it's current state is only grab the second word which is position [1] by default")
                ap=''
                #testing with more than one word the defualt was the first one
               #================  jan 3, 2021 code fix experimentiong case alpine meadows
                if len(genius) == 2:
                    #print('teh default was 1 word case and one word')
                    caseset.append(genius[1])
                    #print(caseset)
                    
                if len(genius) == 3:
                    #print('teh default was 3 words case and two words')
                    ap =genius[1] + genius[2]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) == 4:
                   # print('teh default was 4 word case and 3 words')
                    ap =genius[1] + genius[2] + genius[3]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) > 4:
                    #print("more than four words in this line detected")
                    #print("just do the default for now will fix later")
                    caseset.append(genius[1])
                    #print(caseset)
                
                #print("it looks like I'm just grabbing the first word of a case which I initially tested it with")
                #print('line 1632')
                #print(caseset)
                #buildlist.append(line);
                smartcounter += 1;

    #print("caseset list for one case section=",caseset);
    wilsonball=[]
    wilsonball.append('starter')
    wilsonball.append(caseset)
    #print("******** === wilsonball=",wilsonball)





#do bypass before even doing switch case

'''
if number quick check if number in list
get highest_number in list of numbers
if entered number > highest_number 
   goto default case
   print("msg your number is not in list")
'''








#this actually looks for breaks, missing beaks, and fallthrus
####=====================
##case_tail_list_maker_2() finds breaks, missing break detection, fallthrus
##========================
def case_tail_list_maker_2(x,y):
    #empty_list(royallist)
    mytrace('case_trail_list_maker_2')
    #print("=######	C A S E    T A I L   M A K E R called  ")
    smartcounter=0
    #this looks for "case" in the switch case string
   
    for line in switchcasetester.splitlines(): #switch case in JS
        if "case" in line: #see if this puppy works
            firstline = line.split()
         
            smartcounter += 1;
        else:
            smartcounter +=1;

    #here we get the location of the "default"
    smartcounter=0
    for line in switchcasetester.splitlines(): #switch case in JS
        if "default" in line: #see if this puppy works
            firstline = line.split()
            location_of_default = smartcounter
            break
            #smartcounter += 1;
        else:
            smartcounter +=1;



   #not sure if I am using c and d or not or if I switched to x, y instead
    c = 1    #current case number section
    d = c + 1



    #print("x",x,"y",y);
    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]

    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;

     #we ARE STARTING A SECOND LOOP HERE -------------------
        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=====================================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##======================================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #I think that this is the end of the for loop here



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');



    if "true" in case1findfallthru:
        #print('fallthru found')
        smart = len(royallist)  #new code
        smart += 1
        #before I add this one         so I am putting a number here which is used
        fall = "fallthru" + str(smart)  #to call the correct word in starbuckslist
        #print("we have",starbuckslist[smart]," added to fallthru")
        #I will need to do this
        #  fall = "fallthru('" + starbuckslist[smart] + "'")
        royallist.append(fall)
    wolf =''
    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        sosmart = len(royallist)
        sosmart += 1   #number below so it makes fallthru4 in example
        fall = "fallthru" + str(sosmart) #+ ")"  #just added this  thursday night
        #print("we have",starbuckslist[sosmart], "added to fallthru")
        #print("smart is length of royal list before adding fallthru",sosmart)
        wolf = "fallthru(" + "'" +  str(sosmart) + "'" + ")"  #this makes fallthru(4) which I need
        #because I can convert the number to a word in new list
        #print("wolf=",wolf)  #so this works
        royallist.append(fall)
   
    
    #print("royallist=",royallist)
    #this changes the first position which is [0] fallthru1 to starter
    royallist[0] = "starter"
    #print("now royallist has this in it")
    #print(royallist)











tail_list=[]
cranberries=[]
cranberries.append('starter')
##===========================
##==== def p51_mustang_2() ===  adds the number to  fallthru(3) like that
##===========================
  #this makes the cranberries list which is the tail list used on codegen page
#diamonds=[[2,7],[7,17],[17,24],[24,34]]
#this makes the cranberries list
def p51_mustang_2(): #makes critical cranberries list which is the taillist for switch cases
	return


###############################
## stage_six_2
###############################
def stage_six_2():
    return#print('stage six')
    #p51_mustang_2()







#The purpose of this method == flyingcloud == is to
#fill small lists with
#the respective case names
#get case names in each set and add to list





#=====================================
#========== flyingcloud ==============  Thursday morning coding
#=====================================
#case1list=[]
#case2list=[]
#wilderness=''
#wild=''
#diamonds=[[2,7],[7,17],[17,24],[24,34]]

#this is used for the caselists that are generated for
#the python output for each case section there is a list
#and if the programmers writes more case sections and there
#isn't enough lists then the switch will fail
#so I started with ten case section lists and just expanded
#it to a thousands. You can always add more.


#forcing it to see what happens november 21st
#caselist7=['default']


#we will know before hand how many caselists will be filled 4

#this makes the first case list called starbucks which is used throughout the program
##==========================
##   flying fish 2            this loops through the dimaonds list of first cases
##==========================
def flyingfish_2():
	return




##==========================
##   flying cloud_2            this builds a list of the case names for each section
##==========================

#smartcasemanager.append("['starter']")

def flyingcloud_2(x,y,z):
	return
	
	


einstein=[] #resets einstein to empty
	#========================================
#this fills up smartcasemanager list
###############################
## nightowl_2
###############################
def nightowl_2():
	return
	


#this prints out the smartcasemanager list to verify that it worked and has the sublists

#=================================
def goodseason():
	mytrace('goodseason')



###############################
## stage_seven_2
###############################
def stage_seven_2():
    return#print('stage seven')
    #flyingfish_2()


#wilson=''
#mystring =''

#============================
#      wildgame
#============================
#or am I using the current case number or next case number for fallthru
#so does it represent the current location and then we add 1 to it or does fallthru(#) have
#the next number position embedded in it already
#this will go through the list and convert the fallthru(#) into names making the gold tail list
#which is used to build the case sections









goldtaillist =[]
#I need to loop through this list and create the new list for final gold tail list
def autumn_2():  #this builds the break fallthru(nextcasename) list
	mytrace('autumn_2')
	#print("autumn leaves falling")
	#print("autumn called to make new list of breaks and fallthrus final")
	#print("please work I need this to work")
	counter =0
	#print('starbucks =',starbuckslist)
	#print("mintlist =", mintlist)
	for item in starbuckslist:
		print(item)
		#goes through list


		if item == "break":
			#print('break found')
			goldtaillist.append("break") #how come it doesn't append this
			counter += 1


		if  "fall" in item:
			#print('fallthru found!')
			#print('counter=',counter)
			result =wildgame(counter)  #it wants a number use the counter
			#print("wildgame() result=",result)
			goldtaillist.append(result)
			counter += 1
		else:
			counter += 1

		if item == "starter":
			goldtaillist.append("starter")
			counter += 1
			continue

		if item == "default":
			goldtaillist.append("default")
			counter += 1
			continue

	#print("goldtaillist =",goldtaillist)




#autumn()



crushit =[]









#thurday, september 10, 2020 truck stop insight
#=============== stars() =============================
#=========== this goes thru dummy list with just starter fallthru and break and default
#==========/=== and adds the numbers of teh fallthru locations into cru0list
#=======================================================

miraclelist=[]
###############################
## stars_2
###############################
def stars_2():
	mytrace('stars')
    #print('STARS test of loking for words in list')
	#print('look for break default starter fallthru')
	#print("listnow =",listnow)
	counter =0
	#print("starting looking in loop")

	for item in listnow:
		if "break" == item:
			#print('break')
			crushit.append("break")
			counter += 1

		if  item.startswith("f") == True:
			#print('fallthru found')
			crushit.append("fallthru('" + str(counter) + "')")
			counter += 1

		if item.startswith('d') == True:
			#print("default found")
			crushit.append("default")
			counter += 1

		if item.startswith('s') == True:
			#print("starter found")
			crushit.append("starter")
			counter += 1



	#====
	#starter is 0 but not a case
	#first case is position 1 (if fallthru(1)) it becomes fallthru(2) for conversion
	#so it is based on current position for the current case and then the NEXT case is +1
	#==========================================
	#input must be 1 or higher but less than the length-1 can't be starter (0) or default(length-1)
	wilson=''
	newnumber=''
	counter =0
	for item in cru0:
		if item.startswith("f") == True:  #fallthru or fallthrough
			#print("fallthru found")
			mystring=item
			#print('mystring=',mystring)
			wilson=int(''.join(filter(str.isdigit, mystring)))   #this extracts the number from a string
			newnumber = wilson + 1
			newnumber = int(newnumber)
			answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
			ohbaby = "fallthru('"  + answer  + "')"
			ohbaby =ohbaby.strip()
			miraclelist.append(ohbaby)
			counter += 1

		if item.startswith('d') == True:  #default is last case needs to have break
				#print("default fuound")
				miraclelist.append("break")
				counter += 1

		if item.startswith('s') == True:
				#print("starter found")
				miraclelist.append("starter")
				counter += 1

		if item.startswith('b') == True:
				#print('break')
				miraclelist.append("break")
				counter += 1








#======== adderrsmill==============================
case_main_body_list=[]
case_main_body_list.append('starter')  #this is to fill up position 0

z =''


# big gears filling list with case bodies of python code


###############################
## big_gears_filling_list_with_case_bodies_2()
###############################

def big_gears_filling_list_with_case_bodies_2():
	return

import re  #for regular expressions
#this one
handy_list_of_tabs=[]
dual_slots=[]
crummy =[]
fiasco =[]
n_count_per_section=''
case_section_lines_of_code=[]

#new idea have line count based on first line of code in THIS section after if case
#and the first line is 1 and not 0 so it's human math thinking

###############################
## smarty_2
###############################
def smarty_2(x,y):  #this grabs the body from one case section at a time
	mytrace('smarty_2')
	#print("=====/////======= smarty called ====2340=====//////=====")
	#print("line 818 snowtime(",x,y,")  S  N  O  W  T  I  M  E  ")
	#print("=====================  snowtime called", x, y," ===================")
	#print("smarty x y testing blank lines existence to delete them")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	for line in switchcasetester.splitlines():
		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line  and "}" not in line \
		and "{" not in line:
		#this takes out the empty line by skipping it

			#added this sept 17 2020 to eliminate empty lines that do and mean nothing
			if len(line) == '\n': #this means that the line is empty
				#print("yes an empty line")
				#print(line.count("\n")) #just added this
				#del line #does this work
				mycounter += 1 #see if this is necessary here or not
				continue
			else:
				

					#else:
					#by default each line will require 2 tabs in front of it
				line=line[1:] #takes off first tab off from front of line

				#We know the length so if last line no \n on end

					# ============== Glory =======================
				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
					#=============== Glory =======================
					#line 2386 where the fun is

					#Right here  flag whether to add  + "\n"





			####################
		mycounter += 1

	#this would be the string and nuke last line trailing \n which I know will be there
	practicestring1 = practicestring1.rstrip("\n")
	### and here the practice string is added (appended) to case_main_body_list
	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 =''  #here we nuke practicestring1 so I can reuse for each case section
	#print("=========")
	

def loop_thru_case_sections_2():
	#print("======== loop thru case sections =============")
	mytrace('loop_thru_case_sections_2')
	#print("loop thru cases sections which is a list")


#loop_thru_case_sections()  #=================

###############################
## stage_eight_2()
###############################
def stage_eight_2():
	mytrace('stage_eight()')
	#print('stage eight')
	#loop_thru_case_sections_2()


icecream=''
###############################
## herewego_2()
###############################
def herewego_2(): #loops and prints all main bodies
	return 
	
	

print("")

acounter=0
#for item in case_main_body_list:
#	print(len(item))
#	acounter += 1










#print("digitalcandy=",digitalcandy)
#big_gears_filling_list_with_case_bodies()
#herewego()  #==================================
###############################
## stage_nine_2()
###############################
def stage_nine_2():
	mytrace('stage_nine()')
	#print('stage nine')
	#big_gears_filling_list_with_case_bodies_2()
	#herewego_2()


#print("tail_list cranberries =",cranberries)
###=============================================================================
x = 0;y =0
smart=''
#cranberries=[]
list_of_rows_of_case_names=[]


#making case section sublists here
#this is for making the variable lists to fill the case sections of cases
# and to refer to each of these caselists with ifs and elifs




###############################
## make_case_sets_2()
###############################

def make_case_sets_2():
	mytrace('make_case_sets_2')
	#print("===== make_case_sets called ====")
	acounter = 0
	firstcasesectionlist=[]
	firstcasesectionlist.append("starter")
	 #this will be the case name
	#print("we have length of ", len(digitalcandy))
	#print(digitalcandy) #so we can see our input values of digitalcandy list
	for item in digitalcandy:
		x = None  #zap them out perhaps
		y = None
		#what = digitalcandy[acounter]
		x = item[0]; y = item[1]

		z = acounter
		partynation_2(x,y) #partynation called here------ PARTYNATION -----------
		acounter += 1
	#adding default to see if it works
	#firstcasesectionlist.append("default")
	#this happens after the loop has finished
	#print("what 9999 is this =",firstcasesectionlist)
	#print("----------")
	counter=0
	list_of_rows_of_case_names.append(firstcasesectionlist) #since this will be the last one
	castle_time_2()

smartcasemanager=[]  #creating the initializing smartcasemanager







###############################
## castle_time_2()
###############################

#this just prints it out the sets of the cases for each case section
def castle_time_2(): #fills up smartcasemanager
	mytrace('castle_time_2')

	#list_of_rows_of_case_names.append("[['default']") #trying this
	#print("============CASTLE_TIME called ===========")
	count=0
	while count < len(list_of_rows_of_case_names):
		if count == 0:
			count +=1
			continue
		#print(list_of_rows_of_case_names[count][1:])
		count += 1

	#print("more testing to get this right")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	##################################################
	### SMARTCASEMANAGER LIST FILLED HERE ############
	##################################################

	#this fills up list smartcasemanager from list_of_rows_of_case_names
	#this is doing a brute force copy of a list
	for item in list_of_rows_of_case_names:
		smartcasemanager.append(item)


	#print(smartcasemanager)
	smartcasemanager.pop()
	#print('after deleting last item in list')
	#print(smartcasemanager)

	finallist = ['default'] #see if this works
	list_of_rows_of_case_names.append(finallist)
	#print("this should be default below======+++")
	#list_of_rows_of_case_names[-1]
	#smartcasemanager.append("['default']") #using a default case so it can be fallthrud from above
	#print(smartcasemanager) #now we add default to the end or do we need to or not
#==========================================================
#======================== partynation =====================


###############################
## partynation_2()
###############################
list_of_rows_of_case_names=['starter']
firstcasesectionlist=['starter']
def partynation_2(x,y):  #this grabs the body
	mytrace('partynation_2')
	#print("====partynation======")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	firstcasesectionlist=[]
	firstcasesectionlist.append('starter')
	#start loop
	#this specifically is looking for the word case
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if mycounter >= x and mycounter < y \
		and "case" in line:     #just added default
			genius = line.split()
			wild=genius[1].strip()
			wild = wild[:-1]
			wild = wild[1:-1]

			firstcasesectionlist.append(wild)  #adding this case name to firstcasesectionlist

		mycounter += 1
	#end loop
	#This is forcing default into firstcasesectionlist
	#wild = 'default'   #major test here
	#firstcasesectionlist.append(wild)
	for item in firstcasesectionlist:
		item.replace('"',' ' )


	firstcasesectionlist[1:-1]
	for item in firstcasesectionlist:
		item.replace('"',' ' )
	#here the currently newly minted case list is added to the big list
	#which is called list_of_rows_of_case_names
	list_of_rows_of_case_names.append(firstcasesectionlist)



	firstcasesectionlist= []
	#firstcasesectionlist.append('starter')



###############################
## testingthis_2()
###############################
def testingthis_2():
	mytrace('testingthis()')
	#print(" this prints out the contents of the important lists")

	

###############################
## stage_ten_2()
###############################
def stage_ten_2():
	mytrace('stage_ten_2()')
	#print('stage ten')
	#make_case_sets_2()
	#testingthis()



#I just need the lists to build my code generation now to generation
#the logic right

#codegen is using the output lists from the parser

#this is the taillist

#this is bringing it altogether simulating it creating the
#switch case in three parts
#with a counter and a loop

#trace()
#lists for starbuvks_drive_thru_code.py
caselist     =[]
breaklist    =[]
fallthrulist =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]


alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]

#this will be the first
#print("this will run at the top of the page and call the functions in sequence\n")
#cranberries=[]
my_godzilla_list=[]
newlist=[]
smartylist=[]
tryagain=[]
coollist=[]
#test data here it will be one file and just flow down with no imports
#rodan=[2,7,17,24,34]

tabs =['starter',"\t","\t\t","\t\t\t","\t\t\t\t","\t\t\t\t\t","\t\t\t\t\t\t"]






firstcaselist=[]

#digital_candy=[[2, 7], [7, 17], [17, 24], [24, 34]]

switch_python_gen=''










###=================================================================
###  below I get the location of default and closing curly brace for end of switch
###  this is to be used for determining the default case which is utilized for
###  the situation of a fallthru down into default
###  this also adds one more case tothe regular cases and I need these parameters

#print("============ surgery here S=================================")
#print("")
###############################
## make_default_case_2()
###############################
def make_default_case_2():
	mytrace('make_default_case()')
	find_default = get_default_location_2()
	#print("NEW location of default =",find_default)

	lastbrace = get_closing_brace_2()
	#print("NEW location of closing brace =", lastbrace)


	#digitalcandy.append
#november 21st coding
#make_default_case()

## what I still need to put together to have the body of the default case
## and that will be used for the default case and the body of the else:


 ##so if line is > default and line is < lastbrace
 ##and "break" not in line
 ##and fill practice string and append the pracietce sting to case_main_body_list
##use snow(x,y) and a loop to grab the lines of code inside of default
##make sure "


#print(" this prints out the contents of the important lists")

#print("==============================================")
#print("digitalcandy list ========")
#for item in digitalcandy:
#	print(item)



#print("they all need to start with 'starter' in position 0")
#print("the big 3 need to have the same number of elements for the length to be the same")

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus
# digitalcandy

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#what smartcasemanager output looks like in ufos file
#this was tyhe failed attempt at managing the indentation over to the left
#for the switch case output in python and I have a simpler solution I will end up using.




		#counter += 1














###############################
## parktime_2()
###############################

def parktime_2():

	mytrace('parktime')
	import re
	myString = "\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
	#print(myString)
	output   = re.sub(r"[\n\t]*", "", myString)



###############################
## stage_eleven_2()
###############################
def stage_eleven_2():
	mytrace('stage_eleven()')
	#print('stage eleven')
	#parktime_2()


#input for the switch case happens (above) the docstring JavaScript switch case interface




######===================================================================
###======== switch_code_gen here ============
# add error mistake if no input for exp it will do nothing
# this is good for me to think of adding
# also add break if no break in default for input from js switch
# monday dec 14th thinking
# need to add input stuff here that is in the top running betterworks

sw=''
sweet =''
switch_gen=''
#testing input here
  #this has to be above the generated code

testlist=[]
exp =''

############################################################
########  SWITCH CODE GENERATOR INTO PYTHON ################
############################################################

#======================================
#  ====== project mr coffee ========
#this takes in lists calculated above and generates a string of python switch case code
def switch_code_gen_2():
	return
	
	


	#this is called in switch as a method from angel_falls
	#to put string into varholder[1]
def dothis(x):
	varholder.append(x)
	#print(varholder[1]) 
	
	
def lovely_output():
	print(varholder[1])
	#print("lovely_output called")
	#print("")
	







###############################
## stage_twelve_2()
###############################
#this executes the generated python switch code
def stage_twelve_2():
	mytrace('stage_twelve()')
	#pass

		
	for x in caselist1[:]:
		caselist1.remove(x)
	
	for x in caselist2[:]:
		caselist2.remove(x)
		
	for x in caselist3[:]:
		caselist3.remove(x)
		
	for x in caselist4[:]:
		caselist4.remove(x)
		
	for x in caselist5[:]:
		caselist5.remove(x)
		
	for x in einstein[:]:
		einstein.remove(x)
	
	smartcasemanager=[]
	print(smartcasemanager)
		
	for x in testlist[:]:
		testlist.remove(x)
		
	#print("after emptying einstein list we have")
	print("einstein=",einstein)	
	
	
	#global switchcasetester #new
	#switchcasetester =''  #new
	#print(switchcasetester)
	#case_main_body_list=[] #nukes it
	resetting_up_case_body() #clears out case_main_body_list then appends('starter') to it
	#print("caselist",caselist)
	#print("smartcasemanager",smartcasemanager)
	#print('printing out lists contents to see what is actually in them')
	#print("this is to determine what is in the lists after a switch case has")
	#print("been generated and it no long needs the data from the parser")
	empty_list(smartcasemanager)
	empty_list(einstein)
	empty_list(defaultlist)
	empty_list(candy)
	empty_list(digitalcandy)
	empty_list(palmtrees)
	empty_list(gti)
	empty_list(drive_thru)
	empty_list(mochalist)
	empty_list(case1findbreak)
	empty_list(case1findfallthru)
	empty_list(line_numbers_of_first_cases)  #missed s after number
	empty_list(case_main_body_list)
	#empty_list(case_main_body_list_with_tail)
	empty_list(starbuckslist)
	empty_list(wilecoyote)
	empty_list(birdsong)
	empty_list(cranberries)
	empty_list(royallist)
	empty_list(roadrunner)
	empty_list(penguin)
	empty_list(caselist1)
	empty_list(caselist2)
	empty_list(caselist3)
	empty_list(caselist4)
	empty_list(caselist5)
	empty_list(caselist6)
	empty_list(caselist7)
	empty_list(caselist8)
	empty_list(caselist9)
	empty_list(caselist10)
	empty_list(caselist11)
	empty_list(caselist12)
	empty_list(caselist13)
	empty_list(caselist14)
	empty_list(caselist15)
	empty_list(caselist16)
	empty_list(caselist17)
	empty_list(caselist18)
	empty_list(caselist19)
	empty_list(caselist20)
	

	
	'''
	print("defaultlist=",defaultlist)
	print("candy=",candy)
	print('digitalcandy=',digitalcandy)
	print("palmtrees=",palmtrees)
	print("how many of these have data in them after the first switch?")
	print("gti",gti)
	print("mochalist",mochalist)
	print("drive_thru",drive_thru)
	print("einstein",einstein)
	print("smartcasemanager",smartcasemanager)
	print("testlist",testlist)
	
	#funny
	print("case1findbreak",case1findbreak)
	print("case1findfallthru",case1findfallthru)
	print("seal",seal)
	print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	print("case_main_body_list=",case_main_body_list)
	#print("case_main_body_list_with_tail",case_main_body_list_with_tail)
	'''
	
		
	smartcasemanager=[]
	#print("candy=",candy)


	#this seems to work whereas nothing above actually worked
	## only guaranteed way to empty lists completely 
	for item in range(0,len(palmtrees)):
		palmtrees.pop()

	for item in range(0,len(digitalcandy)):
		digitalcandy.pop()

	for item in range(0,len(einstein)):
		einstein.pop()

	for item in range(0,len(wilecoyote)):
		wilecoyote.pop()
		
	for item in range(0,len(candy)):
		candy.pop()
		
		
	for item in range(0,len(case_main_body_list)):
		case_main_body_list.pop()
		
	

	for item in range(0,len(birdsong)):
		birdsong.pop()
##3====================
	for item in range(0,len(caselist1)):
		caselist1.pop()

	for item in range(0,len(caselist2)):
		caselist2.pop()

	for item in range(0,len(caselist3)):
		caselist3.pop()

	for item in range(0,len(caselist4)):
		caselist4.pop()

	for item in range(0,len(caselist5)):
		caselist5.pop()

	for item in range(0,len(caselist6)):
		caselist6.pop()

	for item in range(0,len(caselist7)):
		caselist7.pop()

	for item in range(0,len(caselist8)):
		caselist8.pop()

	for item in range(0,len(caselist9)):
		caselist9.pop()

	for item in range(0,len(caselist10)):
		caselist10.pop()
##3==========
	for item in range(0,len(royallist)):
		royallist.pop()

	for item in range(0,len(cranberries)):
		cranberries.pop()
		
	for item in range(0,len(roadrunner)):
		roadrunner.pop()
		
	for item in range(0,len(penguin)):
		penguin.pop()
		
	for item in range(0,len(british)):
		british.pop()
		
		
	###############
	#print("gti",gti)
	for item in range(0,len(gti)):
		gti.pop()
		
	#print("mochalist",mochalist)
	for item in range(0,len(mochalist)):
		mochalist.pop()
		
	#print("drive_thru",drive_thru)
	for item in range(0,len(drive_thru)):
		drive_thru.pop()
	#funny
	#print("case1findbreak",case1findbreak)
	for item in range(0,len(case1findbreak)):
		case1findbreak.pop()
		
	#print("case1findfallthru",case1findfallthru)
	for item in range(0,len(case1findfallthru)):
		case1findfallthru.pop()
		
	#print("defaultlist",defaultlist)
	for item in range(0,len(defaultlist)):
		defaultlist.pop()
			
	#print("seal",seal)
	for item in range(0,len(seal)):
		seal.pop()
	#print("this one is the HOLY GRAIL one")
	#print("line_number_of_first_cases",line_numbers_of_first_cases)
	for item in range(0,len(line_numbers_of_first_cases)):
		line_numbers_of_first_cases.pop()	

	#print('==== after clearing them we have ======')
	
	if len(palmtrees) > 0:
		palmtrees.pop()
	#print('after checking the length of the list this deletes more if greater than 0')
	#print("palmtrees=",palmtrees)
	#print("starbucklist=",starbuckslist)
	for item in digitalcandy:
		digitalcandy.pop()

	#print("digitalcandy=",digitalcandy)
	
	if len(einstein) > 0:
		einstein.pop()
		
	
	#print("=========")
	for x in smartcasemanager[:]:
		smartcasemanager.remove(x)
	#print("contents of smartcasemanager=",smartcasemanager)
	
	#print("see if this helps empty it smartcasemanager")
	for item in smartcasemanager:
		smartcasemanager.pop()
		
	
	








#this is reading numbers in cases NOT STRINGS and converting them into strings

#this is new but I haven't tried it yet december 5th
def starter_sequence_mode_2():
	return
	#mytrace('starter_sequence_mode_2()')
	#this ensures that these are ONLY called if valve[0] is True
	#if valve[0
		








	
daisy=''
def parser_mode_2(a):  #in snoopy1.py
	mytrace('parser_mode_2 in snoopy1()') #was greatpumpkin
	print('=======INSIDE OF PARSER in snoopy1  =========')
	return
	


##############  added April 2nd, 2021  ###############################################
# this is a pre scan of the switch case input string to determine if


# this gets the line number of the first case in the switch case string








	
#this will need to be called for each specific thru line
###==============================================================
###================  expand_thru_macro()  ===================
###==============================================================

#inputnum = 1
#def expand_thru_macro1():
#nt(switchcasetester) #was mouse here 
#return ajax
			
			








#this should only go through the first case and then leave the loop
#this grabs the first case line from the switch case looking for a number
#this looks in the string switchcasetester string using a loop
#and in first line with case to see if there is a number or are numbers

#######################  this is used by faucet_valve to detect numbers
##       finbar()    ##  tests first case in switch for numbers
#######################  and returns True if numbers are used else False
def finbar():
	mytrace('finbar()')
	toowild='';global switchcasetester;counter =0;
	numberflag = False # by default until otherwise determined 
	for line in switchcasetester.splitlines():
		if "case" in line and "'" not in line and '"' not in line:  
			#print("so I can see what it sees I am printing the line")
			#print(line)
			toowild = line
			break #get out of the dam loop 
		else:
			counter += 1
			continue
	#end loop
	money= hasNumbers(toowild)  #returns True or False
	if money == True: #means has number(s) in it
		print("yes number in the line")
	else:
		print("no number in line")
	return money 



icetea=''
valve=[]
##########################################
#             faucet_valve()  this fills valve[0] with True or False for numbers
##########################################
def faucet_valve():
	mytrace('faucet_valve()')
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#here it calls finbar() which looks for number in the first case line
	icetea =finbar()  #method finbar() determines if case has a number like case 4:
	print("icetea =",icetea) #True if numbers
	#decided to just return True or False for now
	valve.append(icetea) #valve[0] = icetea
	firstcase = valve[0]  #True if number otherwise a string so False
	#print("contents of valve[0]",valve[0])
	



############################################
##             is_number()
############################################
def is_number(inputString):
	mytrace('is_number')
	return any(char.isdigit() for char in inputString)







#what if I go thru switchcasetester
#and each line with case is just converted to lowercase
#it should work because it's still a string
#make the whole thing lower case



newlist =[];count =''




####################################################
##      swap_thru_lines_with_expanded_cases()     ##
####################################################
def swap_thru_lines_with_expanded_cases():
	mytrace('swap_thru_lines_with_expanded_cases()')
	print("swap thru lines with exanded cases() called...")
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			#print(" ")
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			# this is where it gets number that is now a string
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			print(cat)
			cool = smart[1][:-1]  #chops off : from end last char
			holder = "'" + cool + "'"  #this puts the number in quotes
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	##=====
	#after the numbers have been converted into strings



### LISTS ####
list_with_thru_macros=[]
list_with_thru_macros.append(0) #position 0 nothing
backwards_thru_list =[]  #initializing the list






############################################
##        change_to_into_thru():
############################################
def change_to_into_thru():
	mytrace('change_to_into_thru()')
	#print("change to into thru() called...")
	global switchcasetester
	#print("=========looping thru looking for to===feb 5th 2020====")
	#print(switchcasetester)
	mycounter = 0
	for line in switchcasetester.splitlines():
		simple = mycounter-1
		
		if "case" and "to" in line:  #this means the macro to
			#print(line)
		
			banana=''
			banana=switchcasetester.replace(" to "," thru ")  #just addded spaces
			switchcasetester='' #this nukes it resets it
			switchcasetester = banana
			#print("the result of changing macro to to thru is this:")
			#print(switchcasetester)
		else:
			pass






############################################
##	bottom_up_change_of_thru_line_test():	
############################################
def bottom_up_change_of_thru_line_test1():
	#print("bottom up change of thru line test() called")
	mytrace('bottom_up_change_of_thru_line_test()')
	global mouse
	global opal
	opal = ''

	#go thru the entire string")
	#and change each case number  into a string for preparing for python handling
	## this uses backwards_thru_list
	mycounter = 0
	
	
	#for item in backwards_thru_list: 
	#set mycouter to a number for line in mouse.splitlines() : #this goes thru the mouse string
		#print(line)






###############################################
##   make_list_of_lines_using_thru_macro()
###############################################
def make_list_of_lines_using_thru_macro1():
	#print("we are in make_list_of_lines_using_thru_macro1")
	#print("make lis tof lines using thru macro() called")
	mytrace('make_list_of_lines_using_thru_macro()')
	# make list of lines using thru macros()
	#go thru list and if thru in line add that line to list
	global switchcasetester
	thru_counter = 0
	for line in switchcasetester.splitlines():
		#just added the word to that means the same thing as thru
		if  "case" and "thru" in line:  #on
			list_with_thru_macros.append(thru_counter)
			thru_counter += 1
		else:
			thru_counter += 1
			continue
	#THIS IS the list with thru macros line numbers====")
		
	#then I need to reverse the list
	backwards_thru_list = list_with_thru_macros
	backwards_thru_list = backwards_thru_list.reverse()  #list reversed right here
	bottom_up_change_of_thru_line_test1()






smart =''
beta =''
opal=''
import re
foolish =''
newline=''
#case_numbers_to_strings changes number cases to strings with the number inside
# I still need to sniff and detect if the cases are numbers before calling this 
##############################################################################
#this converts the numbers to strings such as case 1:  to case '1': ####






#######################################
##    case_numbers_to_strings()    ##
#######################################
def case_numbers_to_strings_1(str):
	#print("THIS one was called line 4194....")
	#print("case numbers to strings () called")
	mytrace('case_numbers_to_strings1()')
	global switchcasetester

	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			#print(" ")
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			#print(cat)
			#print("HOW DOES IT LOOK HERE???-----====")
			cool = smart[1][:-1]  #chops off : from end
			holder = "'" + cool + "'"
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#this is to see the switch case input string after the modification
	#after the numbers have been converted into strings



#above and before stage_one()

#===================================



			
			
	




###########################################################
# I can't assume that there is a to or thru macro in use
# this checks if at least one to or one thru in the entire switch case since it will
# be scanned entirely.
############################################################





## march 15th, 2021 Monday
##################################
valve=[]

##################################
## checks if first case is number
##################################
def check_if_first_case_is_number():
	# I think I can test if there is a number in the line that determines it
	#print("check_if_first_case_is_number called")
	mytrace('check_if_first_case_is_number()')
	# loop through switchcasetester
	# this only looks for the first case that it encounters
	counter =0
	numberflag = False # by default until otherwise determined 
	for line in switchcasetester.splitlines():
		if "case" in line:  #error this doesn't account for using thru or to
			grabchunk = line
		# I will need it to specifically look for if "case" in line and not "thru" or not "to"
		# another situation is if case and line and 'thru' in line or 'to' in line
		# however, no matter what I can just look if number in line meaning it's a number
		# and then just grab what is after the word case before : or thru or to
		# I think I can check if two numbers are in line
		#this apparently tests if 2 numbers in the line
			#print("== TESTING HOW MANY NUMBERS IN CASE LINE == if 1 or 2 numbers")
			if sum(map(str.isdigit, line)) == 2 and "thru" or "to" in line:
				#this checks if thru in line 
				####### RIGHT HERE THE FLAG NUMBERS IS FLIPPED TO TRUE AFTER THIS TEST
				#######  NUMBERS
				numbers = True  #this is used for knowing there is likley to and thru in use in case
				numberflag = True  #2 numbers in line 
				if  "thru" in line:
					print("'thru' detected and there are 2 numbers in the line")
				else:
					pass
				#this checks if to in line
				if  "to" in line:
					print("'to' detected and there are 2 numbers in the line")
				else:
					pass

			else:
				print("there are not 2 numbers in the line")
				#this checks if only one number in line and no thru or to in line
				if sum(map(str.isdigit, line)) == 1 and "thru" not in line and "to" not in line:
					#print("there is only one number in the case line")
					#print("here we have discovered there is indeed a NUMBER in case line")
					numbers = False  #meaning ONLY one number in case not two numbers 
					numberflag = True
				else:
					numberflag = False
					pass

			#this scenario is for just  case 2:
			#if  " thru " and " to " not in line:
			
			#print('== TESTING GRABCHUNK == to have it grab a number in case')
			#print("grabchunk",grabchunk)
			if grabchunk.startswith('\t\tcase'):
				grabchunk = grabchunk[7:-1]
				print("now grabchunk=",grabchunk)

			#test here if empty space at end of string
			if grabchunk.endswith(':'):
				grabchunk.replace(":","") #so rediculously stupid
				#grabchunk = grabchunk[:-1]
				print("now grabchunk=",grabchunk)
				grabchunk = grabchunk.rstrip() #to remove leading and trailer spaces
			#print("we now have (will it work) for grabchunk",grabchunk[:-1])
			#print("what happens after this is strange")


			#grabchunk = line[5:] #this cuts off 'case ' and ':' at end
			#print("first test of grabchunk=",grabchunk)
			
			#print("numberflag either True number or False not number",numberflag) #was super
			if numberflag == True:  #it was super == True
				#print("the first case True is a number",numberflag) #was super
				valve.append(numberflag) #was super
			else:
				#print("the first case False is NOT a number",numberflag) #was super
				valve.append(numberflag) #was super
			break
		else:
			#print("no case in line", counter)
			counter += 1
			continue
		# end if
	# end loop
	
###############====





disney_tron_trace_list=['starter']


##################################
##  show tron trace path        ##
##################################
def show_tron_trace_path():
	print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number





#######################
##     mytrace     ##
#######################
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


###====================================
# march 18th, 2021 testing 9:45 am

###############################
##  hasNumbers(string)
###############################
#def hasNumbers(inputString):
# 	return any(char.isdigit() for char in inputString)


disney_tron_trace_list=['starter']
######## show tron trace path
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number

#### mytrace
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


#also do this for reset below

#this alters a string so the case doesn't matter, (think it's all lowercase)
#for laster # make it suitable for caseless comparison 
#str = str.casefold() 
numbers = False #by default and is flipped to True in 
digitalcandy=[]
######################### reset()  the module ##########
####### this makes it possible to call multiple switch cases that start out empty
######################################

# march 15th, 2021 at the beach =============================
# this has the names of vars I need to empty when flush
# the names of the vars are constant and I should hard code them in
list_of_vars=[]

# this holds the names of the lists I used in parser and codegen
# that will be flushed after generating a switch case
# the names of the lists will be hardcoded since they are unchanging
# and this listoflists is now actually emptied - it's a guide rail
list_of_lists=[]



# this resets the sw and switchcasetester variables
def reset():  #this now does nothing.
	#print("reset() called but does nothing now ....")
	global sw
	global switchcasetester
	sw='' #this empties it
	switchcasetester='' #this empties it
	return sw;

#zap var method
def zap_var(y):
	eval("y=''")  #this empties the var
	return y    




def change_list(zoo):
    #print("change_list() calleed")
    switch_config.init()
    switch_subfile.stuff(zoo)
    print(switch_config.mylist[0])
    


###############===================================




###////////////////////////////////////////////===========
###   American Standard  Flush all vars and lists clean
##///////////////////////////////////////////////////////////

#print("========= together =========")
#print(" did I just quote our principal? ")

#print("purely testing this now ")

#list_of_lists=["applepie","peachpie","lemonpie"]

applepie =["one","two","three"]
peachpie =["fun","silly","iceplant"]
lemonpie =["lemon tree","plum tree", "pear tree"]

##===========================
#this was for testing   
list_of_lists=[['applepie'],['peachpie'],['lemonpie']]



###==============
#new "thursday march 18th, 2021 today "
#this is the format that works for names of lists stored in a list
#this means that the vars also use a list of lists  of length 1 with string inside
list_of_vars = [['chilis'],['mystarbucks'],['jungle']]

#solution put the string in a list
chilis = ["one flew over the cuckoos nest"]
mystarbucks = ["is the drive thru open or not"]
jungle = ["better get walking"]

#target = list_of_lists[0]  this represents a list in a list position 0
#print_out_a_list(target) 

def print_out_a_list(target):
	nicejob= " ".join(str(x) for x in target)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	for item in eval(nicejob):
		print(item)
	
#target = list_of_lists[0] #get name of list in list by position
#empty_a_list(target)
#target = list_of_lists[1] #get name of list in list by position
#empty_a_list(target)
def empty_a_list(target):
	nicejob= " ".join(str(x) for x in target)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	sweet = eval(nicejob) #applepie
	del sweet[:] # will this work
	print(sweet) #should be []


def clear_out_list(i): # clear_out_list('fox')
	#print("clear_out_list() called")
	#print('startingit has apps jacks popcorn mtv')
	print(i)
	nicejob = i
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	sweet = eval(i) #fox
	print(sweet) #['apps','balls','craps']
	del sweet[:] # will this work
	print(sweet) #should be []

fox = ['apps','jacks','popcorn','mtv'] #so an outside free floating list not in a list




###### empty_this_list_now(x) list name
def empty_this_list_now(x): #param is listname
	print("x=",x)
	x=[]
	print("x=",x)

# this means view_all_list_contents()
################################
##  see_each_list_contents()
###############################
def see_each_list_contents():
	mytrace('see_each_list_contents()')
	#print("see_each_list_of_contents() testing this now")
	counter=0
	#print("====== list_of_lists ====")
	#print("=== testing so I have utter and complete control ====")
	#print(list_of_lists[0])
	cards = list_of_lists[0]
	#print("this is what we are starting with ")
	#print(cards)
	#print("what I am testing here is getting the name of a list")
	#print("so that I can manipulate it")
	L = list_of_lists[0]       
	nicejob= " ".join(str(x) for x in L)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	print(nicejob) #should be the name of the list applepie
	#print("testing looping thru the list of applepie useing eval")
	for item in eval(nicejob):
		print(item)
	#print("====end of looping ===")





#empty_lists_in_list_of_lists()




 # flush all vars and all lists which will be done after codegen completed
 # this flushes the lists to empty and vars set to ''
 #################################
 ##      american_standard()  couldn't not working
 #################################
def american_standard():
	#flush lists
	mytrace('american_standard()')
	print("american_standard() called")
	#empty lists used in parser and codegen
	#note the list_of_lists does not get emptied, these are necessary for the data structure
	for item in list_of_lists:
		weasel=item[counter]
		print("list name=",weasel)
		#this loops through the list item from list above
		for item in eval(weasel):
			print(item)
			empty_list(item) #calls method empty_list()
			print(item)
		print("------------")
		#empty_list(item) #this empties this list to []
	#flush vars 
    #empty vars used  in parser and codegen
    #the list_of_vars[] does not itself get cleared it is for the loops reference
	for item in list_of_vars:   #which have their names in a list for convenience
		vartime=item[counter]
		print("list name=",vartime)
		for item in eval(vartime):
			print(item)
			zap_var(item) #calls zap_var() erases contents of var
			print(item)
		 #this empties this var to ''




#print("testing view contents of lists")
see_each_list_contents()
#print("flush lists clean")
#american_standard()










###################################################################
## this determines if numbers are used in switch case
## such as case 3 thru 30:  and case 1: etc and case 35 to 50:
## however odd case if a person uses case "4": that is a string though a number
## oh just thought what if someone enters numbers as strings!!!?? 
## dam another filter to add.
## THIS DETERMINES IF CASES USE NUMBERS NOT WORDS
## IT LOOKS IN FIRST CASE LINE IF NUMBER(S) ARE USED LIKE case 5:
#######################  this is used by faucet_valve to detect numbers
##       finbar()    ##  tests first case in switch for numbers
#######################  and returns True if numbers are used else False
def finbar():
	mytrace('finbar()')
	toowild=''
	#print("FINBAR ====$$$$ ===== called to test if detecting a number in string")

	#print("FINBAR ====$$$$ ===== called ")
	#print("FINBAR ====$$$$ ===== called ")
	global switchcasetester
	counter =0
	#this should only go through the first case and then leave the loop
	#this grabs the first case line from the switch case looking for a number
	#this looks in the string switchcasetester string using a loop
	#and in first line with case to see if there is a number or are numbers
	numberflag = False # by default until otherwise determined 
	print("ABOUT TO LOOK IN SWITCH STRING FIRST CASE FOR WORD")
	for line in switchcasetester.splitlines():
		#this will be the first case it test
		#just added "'" not in line and '"' not in line:
		################################################################
		if "case" in line and "'" not in line and '"' not in line:  
			#print("so I can see what it sees I am printing the line")
			#print(line)
			toowild = line
			#print("this has to be the first case line the FIRST LINE")
			#print(line)
			#print("###################################")
			break #get out of the dam loop 
		else:
			counter += 1
			continue
	#end loop
	#uses method hasNumbers to determine if a string has number in it.
	money= hasNumbers(toowild)  #returns True or False
	#print("is there a number in the string",money)
	if money == True:
		pass #print("yes number in the line")
	else:
		pass # print("no number in line")
	return money 
	#######
	









#this will need to be called for each specific thru line
###==============================================================
###================  expand_thru_macro()  ===================
###==============================================================















	


valve=[]
#def is_number(inputString):
#	return any(char.isdigit() for char in inputString)

# this has mode 1 to do words by default but if numbers calls methods to
# convert the numbers into strings and expand the macros to and thru and 
# create lists of cases if macros used
# # ex case 1:    #if firstcase is a number its True


##########################################
#             faucet_valve()
##########################################
def faucet_valve():
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	mytrace('faucet_valve()')
	icetea =finbar()  #method finbar() determines if case has a number like case 4:
	print("icetea =",icetea) #True if numbers
	#decided to just return True or False for now
	valve.append(icetea) #valve[0] = icetea
	firstcase = valve[0]  #True if number otherwise a string so False
	
	if firstcase == True: 
		#print("here means firstcase == True meaning a NUMBER:")
		convert_case_numbers_to_strings()
	else:
		pass
		#print('firstcase == False  meaning strings words')
		#meaning to the strings words as normal

	
	


#################################


#change_list("The Simpson's cartoon")
#print(switch_config.mylist)


#change_list("funny times")
#print(switch_config.mylist)

    ############################
    ### get_case_name()
    ############################
def get_case_name(y):  #y will be the line
    #print("get_case_name called")
    #y = y.split()
    y = y.replace(":","")
    y = y.replace("case","") #remove case
    y = y.replace("\t","")    # remove :
    #print(y)
    return y
    
    
    
    ############################
    ### get_location_of_case()
    ############################
    #debugging june 16th, 2021
def get_location_of_case(listname,word):
    #print("called get_location_of_case(listname,word) line 5220")
    #print("listname,word=",listname,word)
    #print("get location of case () called ")
    #print("this is searching for ",word)  #below took out  + "'" + both sides of word
    ## june16th2021
    
    ##### the bug is here ValueError: None is not in list
    answer =eval("" + listname + ".index("  + word + ")")
    #print('====after running get_location_of_case we get this== should be a number==')
    #print("location of case",word," in listname=",answer)
    return answer




def replace_in_list(x,y,z):  
	z[x]= y   #listname[5] = 'word'
	#this doesn't do print of the list afterwards




sneaky = ['british'] # I  can change the list it uses on-the-fly
#z = 'british' as global variable
###############################
##  do_replace(x,y)
###############################
def do_replace(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=british  #list name for breaks and fallthrus final
	replace_in_list(x,y,z) 
		
		
def smart_replace(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=penguin  #list name for breaks and fallthrus final
	replace_in_list(x,y,z) 
			
		
		
		
		
###################################
## do_replace_item_in_list
###################################

	# LISTNAME z   [x  NUMBER]=  y  WITH WORD using 3 inputs 
	###########################################
def do_replace_item_in_list(z,x,y): #listname[5] = 'word'
	replace_in_the_list(x,y,z)






#dec 31st
### for combo words like "alpine meadow" allow them in javascript interface
#of switch case and then concat them together with _ underscore
#for processing and then in output remove _ underscore


#from goldfish import ball #the string will that work
#dec 24, 2020 4pm pacific standard time progress putting code in module
#talking to goldfish right now which will be input file

#from triple_lindy import *
#imports the switch case

#defining varholder

strawberry_log=[]
#tbhis will be based on tron trace idea 

  ## WRITE STRING TO FILE
def write_string_to_file(xx):
	#print("=====write string to file called ====")
	#print("===PUT STRING INTO FILE =====")
	import os
	os.remove("sw_test.txt")  #this deletes the file
	f = open("sw_test.txt", "a")
	print("===about to add string switchcasetester to file===")
	f.write(xx)  #make sure it reads from goldfish
	f.close()

###############
##  check if default and check if beak in switch case#####
def add_break_to_default():  #and check if default too
    #print("add break to default() current does nothing ")
    return
    # look in stirng for break
    #if "break" in switchcasetester:
        #do nothing
    #actually also test here if default in switchcasetester stirng
      #and if not default then add default
    #else:
        #then add the break to default
        #brilliant;
        #first test if default case
        #if no default add default and break







   #READ STRING FROM FILE
def read_string_from_file():
	#print("====== read string from file called ======")
	#print("=== READ_FILE_PUT_INTO_STRING====")
	f = open("sw_test.txt", "r")
	boomerang = f.read()
	#print("=====output of string here=======")
	#print(boomerang)
	return boomerang


case_main_body_list=[]
def resetting_up_case_body():
	case_main_body_list=[]
	case_main_body_list.append('starter') 
	z =''
	
	
####################################################################
##  get_length_of_string()  the length of the switch case string
## this 
####################################################################
## get length of string()
mrdefault = 0
#this gets the line number of default (there must be a default)
#this also gets the length of the switchasetester string
def get_length_of_string():  #this only works if there is a default
	mytrace('get_length_of_string()')
	#print("######## get_length_of_string() called")
	#print("get length of string() called ====== ")
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
		#this is where the default is located on this line number
			mrdefault = counter;  #right here it assigns the counter number to mrdfault var
			#print("mrdefault=",counter) #this won't work without default word
		else:
			pass
		counter += 1
		
	#count backwards thru loop to get first break
		
	#print("length of the string =",counter)
	the_counter=mrdefault
	#print("we are starting to count from ",the_counter)
	solution ="false"
	for line in switchcasetester.splitlines():
		if "break" in line:
			#print('yes break after default')
			solution="true"
			break
	
		else:
			the_counter += 1
	
	
	#if solution == "true":
	#	print("break after default")
	#else:
	#	print("add the break at end")
	

	#the_last_line = counter
	#the length of the string of switchcasetester is returned here 
	return counter;  #it returns the length of the string in counter.


thebreak = False  #by default setting


############################################
##  wise_owl()  adds break to default case
############################################
def wise_owl(t):
	#mytrace('wise_owl()')
	#print("##### wise_owl() called with",t)
	#print("WISE OWL CALLED with ",t)
	#print("wise owl() called to add break to default case if it is missing ====== door number 3")
	#print("wise_owl input t =",t)
	if t == True:
		pass #print('already a break in default case')
	else:
		#print("it's obviously FALSE so add break to switchcasetesterstring")
		#print('no break detected so adding break at bottom of default')
		global switchcasetester
		#print("switchcasetester=",switchcasetester)
		################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		strawberry=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = strawberry
		#print("=====after adding break to bottom of default we have====== ")
		#print(switchcasetester)
	#print("t=",t,"already break beneath default") #this outputs the input paramter to see what wise_owl saw
		
#######


#we know from above the range of lines that the default is 
#we also know the last line number
#we start counting from the position of the default word
#################################################
##  testing_if_break_in_default_tail()
#################################################
### if there is default fine, but it requires a break (to be parsed)
## the reason is that at Yale is says that in C a break in default is optional
## but they also say at Yale that a default is REQUIRED
## so this tests that in default(is there a break and if not simply add a break

def testing_if_break_in_default_tail(): #assumes that there is a default!!!!!
	mytrace('testing_if_break_in_default_tail()')
	#print("######## testing_if_break_in_default_tail() called############")
	#print("testing if break in default tail() called=====DOOR NUMBER 2 ===")
	global mrdefault #I was missing this
	#print("mrdefault =",mrdefault)
	#get_last_break_in_string()
	#look at this carefully it starts the smartcounter with the line of default 
	smartcounter = int(mrdefault) #the starting point   #the default line number retrieved before this
	#print("for smartcounter starting we have ",smartcounter)
	thebreak = False #default setting boolean
	global switchcasetester
	for line in switchcasetester.splitlines():
		if "break" in line:
			thebreak = True
			break  #out of loop
		else:
			pass
			smartcounter += 1
	#print("thebreak=",thebreak) #this returns True in thebreak if there is a break in default
	#print("new roller coaster testing if break missing after default and ")
	#print("now add the break at bottom of default ")
	if thebreak == False:
		#print("add break to bottom of default case now right here")
		#global switchcasetester
		#print("switchcasetester=",switchcasetester)
		################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		staypuff=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = staypuff
		#print("=====after adding break to bottom of default we have====== ")
		#print(switchcasetester)
	
	#wise_owl(thebreak) #would be wise_owl(True) #adds break to default case if it is missing break
	#return thebreak  #would return True  or   False
    

#switchcasetester=''

#saw this on the web, doubt it works
def doesitwork():
    return
    #print(getattr(goldfish, seagull))



def felix(): #felix the cat for testing
	#print("====felix called testing writing string to file =======")
	newyears=read_string_from_file()
	#print('     ')

	#print(newyears)
	#print('     ')







'''
The difference is one is just in a wordname
and the other format is typed out
maybe I need to make it the triple string
previou idea was
'''









#def victory():
#	print("read the dam file")
#	#open and read the file after the appending:
#	f = open("sw_test.txt", "r")
#	print(f.read())

# I should have case names in a list
# merely check if word "not in" list then default
# I can go through the switch case input and build a list of each case name
# dec 27th thinking to detect if no matches using not in list so that
# I can return the entered value confidently
# I found them they are in the caselist taht is generated, where I can grab them
# and merely dump them into one big list using append
switch_return_value=['starter']

varholder=[]
varholder.append("") #if nothing changes it's default

var2=[]
var2.append("")


def is_number(inputString):
	return any(char.isdigit() for char in inputString)

valve=[]
valve.append("nada")
angel =''
input = ''

#it would already be tested if a number in the first case already 

#this is the clever() that is actually being called line 4847
# this calls faucet_valve to determine if cases are numbers or words
#apparently this needs to exist in this file
# I need to number them because I have several functions called clever()
def clever(i): #so it already exists we are changing its value
	#print("clever() line 4851")
	#sw_reset()
	#print("this is the clever() that is being called line 4850")

	 #this reloads the module
	varholder[0]='' #this should reset it to nothing
	reset()  #reset() is hidden inside of clever for input to the switch
	mytrace('clever()')
	print("clever() called in switch_mgrcat")
	#faucet_valve()
	#print("valve[0]",valve[0])
	#print("if true then number in first case in switch so using numbers")
	#print("if false then string word in first case in switch using words or char")
	#print("clever called for input to switch case exp")
	varholder[0]= i
	#===this works and it fills a list with input from an argument
	#print('varholder[0]=',varholder[0])
	#print(varholder[0]) #to actually see proof
	return varholder[0]
	angel = varholder[0]
	## ===check if input is a number or a word with letters
	#====x = angel.isdigit() commented out march 17, 2021
	#print('about to call FINBAR() to look in first case line')





#apparently this needs to exist in this file
def moreclever(i): #so it already exists we are changing its value
	#print("moreclever input called")
	varholder[0] ='' #clears it out
	#print("clever called for input to switch case exp")
	varholder[0]= i










#testing accessing switchcase from file goldfish
def mountain2(c):
	#print("==mountain2==",c)
	var2[0]= c
	global weasel
	weasel = var2[0]
	global switchcasetester
	switchcasetester =''
	switchcasetester = weasel
	#print("switchcasetester=",switchcasetester)






jazz=''
#thinking of putting the switch case in here
def galaxy(moon):
	return
	print("galaxy called")
	jazz = moon
	c = len(jazz)
	switchcasetester=moon
	return switchcasetester



##########################
##  romanwall()(
##########################
def romanwall(j):
	mytrace('romanwall')
	#print("=======romanwall called=====")
	#I might have to concat it and make it into
	#virgin reutrn switchcasetester = '''
	#it might have to be generated and then eval(string) or exec(string)
	supertramp= j
	switchcasetester= j  #seeing what happens
	#print(supertramp)
	#see if it can read what is in the string
	#just testing what I can do here with the string
	answer =supertramp.count("case")
	#print("the number of cases in this string =",answer)
	#print(switchcasetester)




def adjust_input(x):
	#print("adjust input called with", x, "inside of yosemite")
	newstring =varholder.append(' + x + ')

	
	
	
	 #should print 4

# Remember that the output code gen is invisible and won't be seen by
# he programmer
case = ''
valve_setting=''
# =======  switch  =================================
def switch(x):
#####################  filter to determine if input is number or word/letter/alpha
	#print("we are inside of switch now",x)
	global input
	
	global case
	#strings
	#print("switch method called",x)
	#if string
	if type(x) == str:
		x = str(x)
		case = x.lower()
		#print("case =",case)
	
	



# =======   fallthru       =========================
# the magic is here fallthru actually calls switch
def fallthru(y):
    eval("switch('" + y + "')")


#varholder=[]
#varholder.append("walmart")  #position 0  varholder[0]
#varholder.append("0")      #position 1
# =======   testfunction    ========================
exp=''



def first_test():
	#print(" ==  testing def first_test with switch case translate test====")
	#varholder=[]
	varholder[0] ="candy" #input value test

#### this is used to do a trace log of functions called #################
### this is called at the bottom show_tron_trace_path()
### and at the beginning of each function/method  mytrace(x) name inserted of the function




print("======")
print("practicing with list funnybusiness here for practice and fun")
print("======")
funnybusiness=['starter','wildone','wildtwo']
reset_list_to_just_starter(funnybusiness)
#print(funnybusiness)

coyote_list=[]  #initialize it
#trontime= ['empty', 'switch', 'case', 'case', 'code;', 'code;', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'break', 'empty', 'case', 'case', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'default', 'code;', 'code;', 'break', 'code;']


# I can simply fill it manually with a loop and append
#print(trontime)

birdsong=['starter'] #assigned
music=[0]
colorful=[0]
#down here it was unassigned
#empty_this_list_now(birdsong) #clearing it before entering the function this time
#######################################
def make_list_of_first_cases():
#######################################
	return #print("initially list length of birdsong is",len(birdsong))
	if len(birdsong) > 1:
		for item in birdsong:
			if len(birdsong) > 1: 
				birdsong.pop()
		#end loop
		if len(birdsong) == 2:
			birdsong.pop()

		if len(birdsong) == 1:
			print('length of this list is 1 is correct')
		else:
			print("this list is wrong should be length 1", len(birdsong))
	else:
		if len(birdsong) == 1:
			print('the length of',birdsong, 'is 1')
		else:
			print("this one slipped though and has a length greater than 1 ",birdsong)


####################
	mytrace('make_list_of_first_cases')
	#print("========== called make list of first cases() ===========")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			smart=line.split()        # separates case from casename
			birdsong.append(smart[1]) # this adds casenameto list birdson
			music.append(mycounter)   # list of number for case line
			mycounter += 1
		else:
			mycounter +=1
		#print("after the if this is the content of birdsong",birdsong)
	#print("I think that the list of line numbers of cases is called music",music)
	#print("list of first case names",birdsong)


	if len(music) % 2 !=0:
		music.append("0")  #this is a balancer if it's an odd number adds one more to it


#what I can do is have a simple true or false switch
#and leave the function calls where they are and if triggered true
#then they will be called otherwise they won't be called.


#start_trigger()

######################################
default_location=''
def get_default_location(): #line number location of the word default
	#print("=============get default location called =================")
	mytrace('get_default_location')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
			break
		else:
			counter += 1
			continue
	#print("the default location line number =",default_location)
	return default_location
	
	
##############################################
##	add_break_to_bottom_of_default():
##################################################
lovely=''
def add_break_to_bottom_of_default():
	mytrace('add_break_to_bottom_of_default()')
	global switchcasetester
	#print("=========just called ADD_BREAK_TO_BOTTOM_OF_DEFAULT()=========")
	lovely = switchcasetester #the whole switch case string
	x = lovely.count('break')
	#print("there are ",x ,"breaks in the switch case")
	#test if break after default line
	#print('start phase 1 ....')
	
	counter =get_default_location() #the line number
	#print("counter starting value of default is",counter)
	findbreak = False #by default unknown at this point if a break after default
	#print("findbreak=",findbreak)
	#print('start phase 2 ....')
	
	for line in switchcasetester.splitlines():
		#print('counter=',counter)
		if "break" in line:
			break_location = counter
			findbreak = True
			#print('findbreak =',findbreak)
			break
		else:
			counter += 1
			continue
	#print('start phase 3 ....')		
	#print("the value of findbreak =",findbreak)
	#print("this is after the loop has gone through looking for break after default line")		
	if findbreak == True:
		pass
		#print("findbreak = True so do nothing break exists after default")
		#print("do nothing break exists after default")
		#print("it will be interesting if this is true, but I can test it")
		#print("the number of breaks found in the switchcasetester was",x)
		#print("let's look in switchasetester and see for ourselves.")
		#print(switchcasetester)
	else:
		#print("if at this point then break after default is False")
		#print("break is false and need to add it")
		#print("switchcasetester starting =")
		#print(switchcasetester)#have to add break with tabs before it
		peach=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = peach
		#print("after adding beak beneath default we have ")
		#print(switchcasetester)
		#print("end of BIG TEST for break in default addition")	
	#return break_location   (maybe we don't need this)
	
    
		








#########=============== get last break in string ==================
listofbreaks=[]
genius=''
nobreaks = "false"
def get_last_break_in_string(): #but what if no break??? march 1st bad assumption here
	#print("======BLINK182========get last break in string in the whole switch case string ============")
	mytrace('get_last_break_in_string()')
	counter=0
	global switchcasetester
	#test this right here and now
	#print("### @@@@@ simple test looking for any break in switch case string switchcasetester")
	#if "break" in switchcasetester:
	#	print("yes there is a break")
	#	
	#lse: #this means there are no breaks in the switchcase string
	#	listofbreaks.append("0")  ## this is new 
	#	print("no break in switch case")
	
	#print("starting loop looking for breaks in switch case")
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			nobreaks = "false"	
			counter +=1
		else:
			counter += 1
			continue
		###=============
	#print(switchcasetester)
	#print("testing length of listofbreaks list")
	#print("if no breaks in switch case then add a break after default now")
	if len(listofbreaks) == 0:
		#print("list of breaks is empty")
		#print("therefore there is no break in entire string ")
		#print("this means no break in default")
		#print("adding break at bottom of default case now")
		#global switchcasetester
		#this immediatley adds break after default
		courage=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = courage
		#print("we now have ((look for the new break in default")
		#print(switchcasetester)
		#################### looks for location of break in default
		newcounter =0
		#print("starting loop looking for breaks in switch case")
		for line in switchcasetester.splitlines():
			if "break" in line:
				listofbreaks.append(counter)
				nobreaks = "false"	
				newcounter +=1
			else:
				newcounter += 1
				continue
			
	else:
		#print("the list of breaks has",len(listofbreaks), " elements")
	#idea if no breaks add one
		genius = listofbreaks[-1]  #last break number
	#print("genius is the last break line number =",genius)
	
	if counter == 0: #means no breaks in string of switchcasetester
		#print("there aren't any breaks in the switch case")
		nobreaks = "true"
		#print("nobreaks = true")
	else: #counter greater than 0
		nobreaks = "false"
		#print("nobreaks = false")
		pass

	#print("lets see the list of breaks full list",listofbreaks)
	#print("the length of hits of lines with break so the length is ",len(listofbreaks))
	#print("the number of breaks = ",counter," if none then nobreaks = ",nobreaks)
	if len(listofbreaks) >= 1:
		baby = listofbreaks[-1] #the last one
		#print("the last break line number is ", baby)
	else:
		pass #print("the number of breaks in the string is None",0)
		
	return baby #which is a string
	
	
	
	
#############################


#I need to add a break if there isn't one saturday, December 5th
#it expects a break at bottom of default.
#and I just realized it requires a default but doesn't look for one
newton=''
orange=''
#this scans through input switch and changes default to case default
#switchcasetester=''
last_break=''
#this assumes that there is a default. I will just make it mandatory to have a default
################################################################################
### this does convert_default_case AND add break after default if it needs one
################################################################################
last_line_of_string=0 #initializes it 
#####################################
## this assumes that there is a default which should exist.
## I will deal with a missing default and insert one later


# so before convertind default to case default I need to count breaks from default down
# and if there isn't one in default add a break

#idea first pass makes switch with place holder innerswitch functionname with input
#but on second pass I make the second internal switch BRILLIANt

##################################
###  convert  default  case '':
mrlastbreak=''
lastbreak=''
###################################
def convert_default_case(): #I got this working November 26th, 2020
######################################
	#print("convert_default_case()  ===&&&&&-- CALLED Motel 6 test night")
	#add_break_to_bottom_of_default()  ##march 3rd, 2021
	mytrace('convert_default_case')
	#print("===========convert default case called ===========")
	############################################################
	get_default= get_default_location()
	
	#print("the last break would be ",listofbreaks[-1])
	if len(listofbreaks) == 0:  #maybe it will be None
		pass  #print("no breaks in the whole switch case string")
	else:
		pass
	
	last_break=get_last_break_in_string() #what if it returns None???
	#this is new march 1st 2021 starbucks coding in earlying
	last_line_of_string = get_length_of_string()
	#print("the last line of string =",last_line_of_string)
	
	if int(last_break) < int(get_default):
		#print("there is definitely no break in default case")
		#print("and a break needs to be added immediately")
		######################################################
		#print("adding break at bottom of default case now")
		global switchcasetester
		tang=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = tang
		#print("we now have ((look for the new break in default")
		#print(switchcasetester)
	else:
		pass #print("there is a break inside of default")
	
	#print("====================")
	#last_line =get_closing_curly_brace() #its just the length of the string switchcasetester
	################# just commented out line above march 1st, 2021
	
	############################################################
	
	# IF default(LINE NUMBER) < last break(LINE NUMBER)  There is a break
	#########################################################################
	#oh my god this assumes that there is a break
	#so no matter what I should put a break after default
	# this says if default is after break meaning no break after it
	#this is dependent on the last break existing or any break for that matter; it assumes a break
	#however, if there is no break in the string I am hosed and need to realize that.
	#I can't assume that there will be a break above the default or after the default either.
	#print("this if test for get_default < last_break fails if no break in string")
	#print("it's based on the bad assumption that there is a break in the switch case")
	#print("so I need to modify it to check if there is a break in the whole string")
	#print("and if count('break') == 0 then the answer is None")
	#if line number of default is LOWER then last break line number
	
	#then there is a break AFTER the default
	
	if int(get_default) < int(last_break):  #### if default  < last break  
	#this means that last break in string is above the default. b
	#########################################################################
		
		#print("there is a break after default")
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		
		###==== tuesday coding project =====##
		## test right here if a break or not
		#need to test if break is after default or not
		# and add a break here if no break so the switch case gets read.
		
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		##I need to add the break to default here if it doesn't exist. 
		# I need to look if a break is between default and last line of switchcase
		# march 1st, 2021 I need to add a break to default if no dfeault
		#look between default word and {
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
		
		#the else  is triggered if int(a)> int(b) meaning break number LESS THAN default line num
	else:
		#down below here it adds break after default and makes case deafult
		#print(switchcasetester)
		
		########################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		## I can do a count for break  starting from the default line number
		## and discover if there is a break in default the only safe place I can put it .
		#this is now unecessary since it's alrady done.
		#######################################################################
		
		
		#orange=switchcasetester.replace("}","			break \
		#	\n}")
		#switchcasetester=''
		#switchcasetester = orange
		
		
		#print(switchcasetester)
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
	
	






def say(x):
    print(x)

def testing_number_of_lines_in_string():
	mytrace('testing_number_of_lines_in_string')
	count =0
	for line in switchcasetester.splitlines():
		count +=1
		#print(count)
	#print("there were ",count, "lines in string")
	return count



def testingatheory():
    mytrace('testingtheory()')

    #apple = "one"
    
    
    
    
###=================== nov 19th new code ============
###================ get_closing_brace (line number) ==============
closing_brace=''
def get_closing_brace():
	#print("get_closing_brace called")
	mytrace('get_closing_brace')
	counter =0
	closing_brace =testing_number_of_lines_in_string()
	return closing_brace




###=============================================
default_location=''
def get_default_location():
	mytrace('get_default_location')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
		else:
			counter += 1
			continue
	return default_location



list1 =[]
list1.append("four")


#varholder[0] ="four"







#print("this is actual generated code I am trying to run now....")
#print("this is betterworknow in python generated previously")



list1=[]
exp =''; case =''
exp = ""

#exec(betterworknow)
#print("=== executin betterwork now test bit")




####======== starts here ===============
##################################
##          start_trigger()
##################################
#this is the function triggered to start the parser and codegen


# this is to circumvent a bug if no break in switchasetester it crashes
# this is to circumbent a bug if the user doesn't include a default case
# which is necessary since it has a break mandatory even if all above
# cases have no break which they can
# this way I'm not adding a break to a case that wasn't intended to ahve one

    #global switchcasetester
    #if "default" not in switchcasetester
    ## add dfeeault case with break
  
    #if "break" not in switchcaseter
        #add break to default which is the only one required to have break
        #since it's the last case 
    
      
###  right here I need to add
###  verifiy default and a break in switchcase strubg  to begin with
######################################
##    starter_trigger()  
######################################
	#global switchcasetester  #just added this to hopefully fix bug
def start_trigger():
	trigger = True  #default setting
	#print("trigger =", trigger)
	#if trigger == True:
	#	print("trigger =", True)
	#else:
	#	print('trigger=',False)
	mytrace('start_trigger')
	convert_default_case() #this changes default: to case 'default': but default needs to exist!
	output = testing_if_break_in_default_tail()
	wise_owl(output) #this should feed in the parameter of if break between default and last line of string
	#print("this will go first")
	### convert default case and then test if break in default and add break if necessary
	#this is done because in C and javascript it's just:   default: so it needs to be converted to a case
	#I will have it add break inside of convert_default_case()
	#convert default case called here 







## from web stackoverflow
def islist(obj):
    if ("list" in str(type(obj)) ): 
        return True
    else : 
        return False
################################
        
#line numbers with line_numbers_of_first_cases
#################################
foo =[]
def bar():  #call this when clever(input) called
    print("bar() called") # to clear out list to make sure it's empty 
    global foo
    #print('in here now')
    foo =[1]
    print(foo)

#bar()

def goldmedal():
    global foo
    #print(foo)
    foo.append("xmas time")
    #print(foo)
    
#goldmedal()

def silvermedal():
    global foo
    foo.pop(0)
    #print(foo)
    foo.append("nighttime")
    #print(foo)
    
    
#silvermedal()

def coolness():
    global foo
    foo=[]
    #print(len(foo))
    
#coolness()

def solid():
    global foo
    foo.append("water")
    foo.append("tennis")
    foo.append("gold")
    print(foo)
    print(len(foo))
    
#solid()    

def badass():
    return  #don't need this now
    print("badass callsed")
    global foo
    foo=[]
    print(foo)
    foo.append("starter")
    foo.append("charlie brown")
    foo.append("wilson")
    foo.append("frisbee")
    foo.append("target")
    foo.append("snoopy")
    foo.append("red barron")
    foo.append("coffee")
    foo.append("starbucks")
    #print(foo)
    print("==============")
    


def clearit():
    return
    print("clearit()")
    global foo
    foo =["starter"]
    if type(foo) is list:
        print('a list')
    else:
        print("not a list")
    #print(foo)

#badass()

def showit():
    global foo
    #print(foo)
####################
##    STAGE ONE
####################
def stage_one():  #this calls start_trigger()
    mytrace('stage_one')
    #print('stage one')
    #emptying the lists in question here that might be the problem
    #print("in stage_one() resetting lists palmtrees, carnberries, royalllist, british")
    #print("penguin, roadrunner, starbuckslist")
    palmtrees=[]
    cranberries=[]
    royallist=[]
    british=[]
    penguin=[]
    roadrunner=[]
    starbuckslist=[]
    digitalcandy=[]
    start_trigger()



# thursday january 21st testing early in morning
# .bug I see is line number of first case lists is wrong
#rule_the_earth()
# File "/Users/blakesouthwood/Desktop/python code /gold Switch case code/backups GOOD working gold master switch case/
#firefall_yosemite_falls.py", line 1322, in rule_the_earth
#   second_word = line.split()[1]
# also digitalcandy has the duplciate first 2,10 issue bug

#=====line numbers of first cases list====
#[2, 10, 16, 23, 29, 35, 41, 47, 52, 52, 2, 10, 16, 25, 26, 32, 38, 42]    

'''
##  so per MIT I need to use assertion checks
#  if (condition == true) 
    do this
    else
    assertion error put messsage and then
    call return
''' 

   





caselist     =[]
breaklist    =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]
getfirstword =[]
casephrase =[]
alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
casesections =[]
casesectioncounter =[]
breakposition =[]
trontime =[]
tronlinenumbers =[]
fallthrulist = []
smartlist =[]
smartlistlocations=[]
fallthrulocations=[]
#theinputlist =[]
digitalcandy=[]
line_numbers_of_first_cases=[]

global woodstock #is this what it wanted to solve the bug
#global candy
#####this is where i'm testing now
line_numbers_first_cases =[]        

woodstock =[]  #testing this out   
candy =[]  #for digital candy    ###3 oh my god I had candy a global and candy a list  [] jeeze. 
#==================================     
def simple_test():  #call this when clever(input) called
    # print("================")
    # print("simple test of filling global list") # to clear out list to make sure it's empty 
    global line_numbers_first_cases
    # print('in here now')
    #print(line_numbers_first_cases)
    line_numbers_first_cases =['snoopy','linus','lucy','woodstock']
   # print(line_numbers_first_cases)
    #print("=============")

simple_test()   


def add_to_test_list():
    #print("==================")
    #print("add to test list attempt")
    global line_numbers_first_cases
   # print("in here now")
   # print(line_numbers_first_cases)
   # print("now adding three more words to it")
    line_numbers_first_cases.append("rediculous")
    line_numbers_first_cases.append("silly")
    line_numbers_first_cases.append("tired")
    #print(line_numbers_first_cases)
    #print("====================")
            
def empty_test():  #call this when clever(input) called
   # print("===============")
   # print("empty list") # to clear out list to make sure it's empty 
    global line_numbers_first_cases
   # print('in here now')
    line_numbers_first_cases =['starter']
    #print(line_numbers_first_cases)        
    #print("==================")
        
        
        
linenumber=[]        
dunkindonuts=['starter']
list_with_code=[]
jazz=['starter']
##################################################
def magictimenow():   ### this builds the list for line_numbers_of_first_cases using strings
##################################################
	mytrace('magictimenow')
	#breakpoint()
	#print("THIS IS MAGICTIMENOW TESTING WHERE THE BUG IS APPARENTLY")
	#print("down to 11% charge better hurry")
	#this should make it real
	global woodstock
	#print("========== what is in trontime? =======")
	#print("what the fuck is in trontime",trontime)
	#print("length of trontime=", len(trontime))
	
	if len(trontime) > 0:
		del trontime[:] #this empties the list trontime
	
	#print("trontime length is now",len(trontime))
	#print("now trontime should be empty by default - to cover all of the bases")
	#print("trontime=",trontime)
	
	
	#print("woodstock contains=",woodstock)
	#global candy
	#print("candy contains=",candy)
	#print("switchcasetester=",switchcasetester)
	mytrace('magictimenow()')
	#This makes a list of true if case in line and false if no case in this line
	#print("first fillup a list with true and false")
	#print("true if case in this line and false if not")
	#print("=== simple test if case in a line if so then True")
	#print("let us see what is in switchcasetester")
	#print(switchcasetester)
	#print("=== and if no case in this line then put False")
	#print("these true and false go into list called ifcaseinline")
	ifcaseinline=['starter']   #theresult
	#this loop puts true into ifcaseinline if case in this line otherwise it puts false
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if "case" in line:
			#print(line)
			ifcaseinline.append("true") #adds "true" to list ifcaseinline
			continue
		else: #no case in this line
			ifcaseinline.append("false") #adds 'false' to list ifcaseinline
			continue

	#print("this should show list of each line and if case in this line")
	#print("ifcaseinline",ifcaseinline)

	#now just find pattern this line true and line above it false
	firsttestforfirstcase=['starter']
	coolcounter=0
	#print("about to test loop looking for first case")
	for item in ifcaseinline:
		if item == "true" and ifcaseinline[coolcounter-1] == "false":

			#print("the line number of teh first case is",coolcounter)
			firsttestforfirstcase.append(coolcounter)
			coolcounter +=1
			continue
		else:
			coolcounter +=1
			continue
	#print("finished",firsttestforfirstcase)#this is list of trues and falses
	#pertaining to if the word 'case' is in this line number of code

	counternew=0
	for item in ifcaseinline:
		#print(item,counternew)
		counternew += 1
	#print("=============================")
	#return #this kills the function and it stops


	counter = 1  #starting counting with 1
	a_string = switchcasetester
	first_word = a_string.split()[0]
	#print('big assed test here to get a first word in a string')
	#print(first_word)
	#get line numbers and see if sequential cases on neighboring lines
	word = 0
	mycounter=0  #switchcasetester
 	#this is where trontime list is filled with 'true' if line number has 'case' in it
 	#and 'false' is put if this line doesn't have the word 'case' in it

	#print("this is the beginning of the regular for loop through the string")
	num = 1  #for organizing case numbers in order of appearance
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		genius = line.split() #new  [0] was at end of it  ((this does the line split for each line))
		mycounter += 1
		#these are two different conditions see if it finds them
		######### these are new to filter it more strictly July 23, 2020
		

		if "case" in line:
			#getfirstword.append("case")
			trontime.append("case")
			#print('case found')
			continue

		if "switch" in line:  #force feed it
			getfirstword.append("switch")
			trontime.append("switch")
			#print("switch found")
			continue

		if "fallthru" in line or "fallthrough" in line:  #force feed it
			getfirstword.append("fallthru")
			trontime.append("fallthru")
			#print("linenumber of fallthru =",mycounter)
			smartlistlocations.append(mycounter)
			fallthrulocations.append(mycounter)
			continue

		if "break" in line:  #force feed it
			#getfirstword.append("break")
			trontime.append("break")
			breakposition.append(mycounter)
			continue
			##################


		if "default" in line:  #force feed it
			getfirstword.append("default")
			trontime.append("default")
			continue

		if len(line.strip()) == 0: 
			getfirstword.append("empty")
			trontime.append("empty")
			continue
        #I remember this line clearly I wrote it at cafe borrone in Menlo park
        #and I finally was able to get the detection of cases in the correct lines in the list
		if "case" and "break" and "default" and "switch" not in line and len(line.strip()) > 0 :

			getfirstword.append("code;")
			trontime.append("code;")
			continue

	#print("==========  CAFE BORRONE  ============")


	#print('this is looking in trontime')
	thecounter=0
	for item in trontime:
		#print(item,thecounter)  #commented out long list
		thecounter += 1

	#print("now this is new virgin code to detect a case that is the first case")
	#print("and this is done by also checking if the line above tested False for having a case")
	firstcaselist=[]
	#print("========here we do some more HALLOWEEN testing============")
	#print("-----this is getting the first case in each section to use in fallthrus-----")
	#this is designed to detect the first case in a case section by detecting a case
	#that does not have a case above it making it by definition the first case
	#now this means no blank spaces between lists of cases for this detection to work.


############## this is where line_numbers_of_first_cases is constructed ##################
##############  I should make this a separate function ###################################
	
	################### may 13th, 2021 coding #########################
	#this is where the line_numbers_of_first_cases list is filled with the line number of first cases
	 #nuked 'starter' from it
	
	#breakpoint()
	#print('what it sees in the input switch case line 6675')
	#print(switchcasetester) 
	#print("this is a simple pretest of cases")
	jumbocounter=0
	for line in switchcasetester.splitlines():
		#how we designate it being the first if no case above it on previous line.
		if "case" in line:
			#print("case found in this line")
			#print(line)
			
			jumbocounter += 1
			dunkindonuts.append(jumbocounter)
			#print("line number =",jumbocounter)
			continue
		else:
			jumbocounter += 1
			continue
	#end loop
	#print("dunkindonuts=",dunkindonuts)
	
#####################################################################

	#end loop
	#print("after finding default it should be below this line ..")
	#print("after sensing if default in switch case are",dunkindonuts)
	#print("so I can see what the computer sees and analyzes where the cases are and if default there")
	
	################### may 13th, 2021 coding #########################
	
		

	#print("now in JAZZ LIST list we have hopefully just the first cases")
	#print("and here is the list",jazz)
	#don't recall if I need to add default as a case think so
	
	#what this does is look in the current line for the word "case"
	#and looks in the trontime list for the line above the current line to make
	#sure that "case" is not in the previous line determined by the word 'false'
	#print("the counter in trontime might be wrong or missing or something")
	#print("trontime=",trontime)
	#print("WAIT WHERE'S MY PHONE??? What is in trontime",trontime)
	###### this printed trontime #########
	#for item in trontime:
	#	print(item)
		
	acounter=0
	#THE BUG IS EITHER HERE SOMEHOW OR IN TRONTIME
	#the trontime list only has trues and falses so true if case in line otherwise false
	for line in switchcasetester.splitlines():
		#this checks if case in this line but no case in line before it
		#the tricky part of this solution is that it is looking above the current line
		#trontime list holds true and false depending on if 'case' in that line number
		if "case" in line and "case" not in trontime[acounter-1]:  #tests if no case above this line with case
			#print('the line number is',acounter)
			line_numbers_of_first_cases.append(acounter)
			#global woodstock
			woodstock.append(acounter)
			#global tintoy
			#tintoy = genius
			genius = line.split()
			#print(genius[1])
			strng= genius[1]
			angel= strng[:-1]
			#print(angel)
			angel = angel.strip()
			firstcaselist.append(angel) #this should grab the case name
			#print('case found')
			acounter +=1
			continue
		else:
			acounter +=1
			continue

	acounter=0
	for line in switchcasetester.splitlines():
		#this checks if case in this line but no case in line before it
		if "default" in line:  #tests if no case above this line with case
			#print('the line number is',acounter)
			line_numbers_of_first_cases.append(acounter) #adds the default line number to list
			
			woodstock.append(acounter)
			genius = line.split()

			firstcaselist.append('default') #this should grab the case name
			#print('default found')
			acounter +=1
			continue
		else:
			acounter +=1
			continue
	######################################################
	#print("there I empty dunkindonuts, list_with_code, jazz")
	#empty these lists
	del dunkindonuts[:]
	del list_with_code[:]
	del jazz[:]

	#print("after empting the new lists we have ")
	#print("dunkindonuts=",dunkindonuts)
	#print("list_with_code",list_with_code)
	#print("jazz",jazz)
	######################################################
	smartnewlist=[]

	for item in firstcaselist:
		if item != "default" :
			item = item[1:-1]
			smartnewlist.append(item)

		if item == "default":
			smartnewlist.append(item)




###################################################################################


###### how do I pass a list
#this might work
def get_first_list():
	mytrace('get_first_list()')





#this finds teh first case in each case section and works
#should be: starter,apple, bananas,chocolate, fish,default
#digitalcandy=[[3,7],[7,19],[19,26],[26,33],[33,43],[43,46]]








#2, 3, 7, 8, 9, 10, 19, 20, 26, 27, 36
def go_thru_casenumbers():
	mytrace('go_thru_casenumbers')

	dacounter=0
	for item in music:

		dacounter += 1












mycounter=0
turtle_tab1=[]
turtle_tab2=[]
turtle_tab1.append('starter')
turtle_tab2.append('starter')
#print('looking for tabs in lines================')
#this is just testing in one case for now
#what I am trying to do is 2 loops one for each case section
#so for the second pass it should start at the next case occurrence
#so first I need to prescan it and get the line number of each case
#apparently the solution is using the digitalcandy list with
#the range of case line numbers which I already have calcualted
#this way I can reuse that and focus on just one case section at a time
#and loop through the digital candy list
#I should fill a two dimensional loop
#I can make each new loop and apppend it to the big loop

biglist=[]
testlist=[1,1,1,1,] #tabs for each line in a case
testlist2=[2,2,2,2,2,2]
biglist.append(testlist)
biglist.append(testlist2)

listofifs =[]

##### this calls snowtime inside of big_gears_filling_list_with_case_bodies()
def big_gears_filling_list_with_case_bodies():
	mytrace('big_gears_filling_list_with_case_bodies')
	#mytrace('snowtime') #it calls snowtime() below
	#print("================  big gears filling list with case bodies called  ==========")
	counter=0
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]

		counter += 1

		snowtime(item[0],item[1])  #snowtime is called here with parameters two index numbers
		#from digitalcandy for the first case and next case line number
		





z =''
#this loopsthru the string of jsswitch between
#case numbers in line
mytablist=[]
sublist=[]
case_main_body_list=[]  #just added this oct 8th
#############################################################################
#this copies the case body for each case section and addds it to case_main_body_list
#### def snowtime fills up case_main_body_list with the body of code in each case section
#############################################################################
def snowtime(x,y):  #this grabs the body from one case section at a time
	mytrace('snowtime')
	global practicestring1
	practicestring1 = ""
	
	mycounter=0
	dog=''
	mytablist=[]
	for line in switchcasetester.splitlines():


		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line:

			if len(line) == 0: #this means that the line is empty

				mycounter += 1 #see if this is necessary here or not
				continue
			else: #if here then the line length must be greater than 0 so something is in it


				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				sublist.append(dog)
				#print('the tabs are invisible and embeddd in the code string.')


		mycounter += 1
		#print(sublist)
	mytablist.append(sublist)
	#print("mytablist =",mytablist)

	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 ='' #clears it out

#=========================================================================




def cotton_candy():
	mytrace('cotton_candy')
	#print("===========cotton candy debugging jan 15th 2021==========")
	
	answer=''
	for item in range(1,len(case_main_body_list)):
		#print("item in cotton candy is",item)
		if isinstance(item,int): #if int is True
			pass
		else:  #if it's not int strip it
			item = item.strip() #not int  THIS STRIPS OFF SPACES
		
		if isinstance(item,int): #if int is True
			pass
		else: #if not int do this
			answer =item.count('\\t')  #COUNTS TABS BUT I DON'T THINK I DO ANYTHING WITH THEM
			answer = ''
#I think I was using this previously to calculate tabs to add 


def stage_two():
	mytrace("stage_two")
	#print('stage two')
	#cotton_candy()

#cotton_candy()





#===================================================
#global variable initialization here
#november 10th, 2020
theresult = ''
#testing_this_out function calls function input_string() which returns
#the docstring as a variable and is assigned to the global variable theresult



#=====================================================






#counts tabs

#### =================== truckeeriver() ==================
def truckeeriver():
	mytrace('truckeeriver')
	casecounter=0
	mycounter = 1
	#print('truckee river called')
	for line in switchcasetester.splitlines():   #this was just going thru my prototype string of switch cases
		if "case" in line:				#and oh, I need to make sure I have tabs in my real js switch
			casecounter += 1
			if "case" not in line:
				if "\t" in line and not "break" in line and not "switch" in line and not "fallthru" in line and not 'case' in line:
					#print(line)
					dog=line.count('\t') #this counts the tabs in front of a line
					turtle_tab1.append(mycounter)
					turtle_tab1.append(dog) #dog this counts total number of tabs in this line


					mycounter += 1


		else:
			pass

	#print("turtle_tab1 list=",turtle_tab1) #should be just one slot


#truckeeriver()

def stage_three():
    #print('=====stage three====')
    mytrace("stage three")
    truckeeriver()







my_list=[1, 3, 4, 5, 6]
global coyote_length
new_c_list = []
####################################
def shrink_coyote_list():
	#print("======== shrink_coyote_list called ===========")
	mytrace("shrink_coyote_list")

    #get length of coyote_list
	global coyote_length;
	coyote_length = len(coyote_list)
    #print("the list length =", coyote_length)


	default_loc = coyote_list.index('default')


	for item in coyote_list:
		if item != "default":
			new_c_list.append(item)
			continue;
		else:
			break;



    #print("the length of the new shortened list =", len(new_c_list))
    #this is my solution for list out of range bull bug

	if (len(new_c_list))% 2 == 0:  #this would only be done once and modify the list
    #to manipulate.
		pass
	else:

		new_c_list.append('nada')






#============== get starting position in coyote




x = 0
destination =0
playwith =0
def get_starting_position_in_coyote(x):
    mytrace('get_starting_position_in_coyote')
    #print("getting starting position")
    answer =new_c_list[x]  #this is what I'm looking inside of the list
   






def get_current_position_in_coyote(x):
    mytrace("get_current_position_in_coyote")
    #print("getting starting position")
    answer =new_c_list[x]  #this is what I'm looking inside of the list







hopper_list =[]
def add_one_to_position_in_coyote(x):
    mytraace("add_one_to_position_in_coyote")
    #print("fall to position called")
    x= x + 1
    answer =new_c_list[x]

    destination = answer;




#print("okay the fun starts here =======>>>>>>>>")

# this figure out the number of case sections (number of case ifs really)
#it goes through the coyote list and checks if a line contains case and the next doesn't
#this works  july 30 2020
counter =0
casecounter = 0
list_of_cases =[]
while counter < len(new_c_list):
    #print(get_starting_position_in_coyote(counter)) #position 0

    if new_c_list[counter] == "case" and new_c_list[counter +1] != "case": #this represents the bottom of case set group
        counter += 1
        casecounter += 1;
        continue;
    else:
        counter += 1
        continue;


########################################
##  new_add_to_front() actually appending it to end of list
########################################
## it's adding it to the tail NOT THE FRONT

def new_add_to_front(x,listname):
	mytrace('new_add_to_front')
	#print(" ============ function new_add_to_front() called =======")
	#listname.insert(0, x) #cool it worked  this would add it to the front
	listname.append(x)

    #go through copy of that list and del items
    #I see this represents building the list











#what I already solved was how many sections of case groups there are
#now I need to get the remaining case locations
#if case not in line meaning after first case section so this would start after the last case in the first section
#July 30th, 2020 fun
# i should know how many cases in each section
####THIS GETS THE FIRST CASE IN EACH CASE SECTION THE LINE NUMBER
#starbuckslist=[]
#starbuckslist.append('starter')
genius =''
#diamonds=[[2,7],[7,19],[19,26],[26,36]] #this is input
#I have that list 2,7,19,26,36


#so quite simply I just need to cascade it down like a waterfall from above
#which shouldn't be too hard



#line_numbers_of_first_cases
#look at this force feeding it input i need to find the generation of the inputlist
#theinputlist =[2,7,17,24,34]  # case case case case default   I took off 36 default
total = len(line_numbers_of_first_cases)
palmtrees=[]  #defined here so it's global 
mochalist=[]
greenmilelist=[]
###################################
def rule_the_earth():
###################################

	mytrace("rule_the_earth")
	global woodstock
	#this is to get the first case of each section
	#print('======= ***** ====rule the earth ==== creates starbucks list === *******  =====')
	mycounter =0
	second_word=''
	theline=''
	#print("the input to figure out the first case in each list inputlist list =",line_numbers_of_first_cases)
	## go thru digital list of the case locations
	## it will be the x position that's easy enough
	bestbuy1 =''
	bestbuy2 = ''
	
	
	test1 =''
	test2 =''
	plumtree=''
	total_word_count=''
	#print("inside of function rule_the_earth()")
	#print("palmtrees at this point has in it line 6693 ",palmtrees)
	#palmtrees.append('starter')
	#####################################
	## new addition to reset palmtrees list april 27th 2021 6:30 pm
	reset_list_to_just_starter(palmtrees) #clears out list if previously used resets it
	#print("palmtrees should only have starter in it at this location")
	palmtrees.append('starter') #which would be in slot 0
	#print("palmtrees=",palmtrees)
	#breakpoint()
	##for case sets I just go thru till case not in line and fill a new list
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		#go thru case list here as the feeder
		if mycounter in line_numbers_of_first_cases:
			#breakpoint()#print(line)
			#felix is the line split into a string
			felix= line.split()
			#print("NUMBER OF WORDS IN THIS CASE LINE")
			#print("number of words in this line is ",len(felix))
			
			#print("inside rule_the_earth line with case")
			#print("felix=",felix)

			if "default" in line:
				#print(line)
				second_word = line.split()[0]
				#########experimentaionl april 29th 
				#print("this is new on april 29th, 2021")
				#whatcount = len(second_word)
				#if 'case' in second_word:
				#	print("true case in this line")
				#	print("the number of words -1` for case",whatcount -1)
				#	whatcount = whatcount -1
				#else:
				#	print("false no case in this line")

				#print("the number of words -1` for case",whatcount)
				#this line will be no default
			else:
				#this ELSE MEANS DEFAULT NOT IN THIS LINE !!!!!!!
			################# code to get the 
				#print("I think that case must be in this line")
				#print("look at this next line carefully")
				#print('line =',line)
				second_word = line.split()[1] #right here it grabs just one word
				#that is the flaw
				##### addition here 
				#### first check if only one word
				#print("felix=",felix)
				#print("DEBUGGING ==6730==")
				#print("the line with default=",line)
				#print("felix[0]=",felix[0])
				del felix[0] #should delete first word case
				total_word_count = len(felix) #already deleted first word
				if total_word_count > 0:
					#print("assertion :: there is at least one word in the case")
					pass
					
				#secenario if only one word case like Tahoe
				#############################################
				## SCENARIO 1  IF ONLY ONE WORD FOR THE CASE
				# THIS DETERMINES IF THE CASE IS JUST ONE WORD
				#############################################
				if total_word_count == 1:
					#print("there is only one word in this case",felix)
					the_words = felix
					plumtree=' '.join(felix)
					#plumtree = felix  #it might be in a list actually 
					#print(plumtree)
					plumtree=plumtree[:-1] #this takes off the : on the end of the string
					#print("plumtree=", plumtree)
					#print("yeah plumtree is a stirng at this stage")
					#print("===== experimenntal plum tree to add to palmtrees === ")
					coolness = plumtree.replace("'","")
					plumtree = coolness
					#print(plumtree)
					
					#palmtrees=palmtrees[1:-1]
					palmtrees.append(plumtree)
					#print('AT THIS JUNCTURE LINE 6745 palmtrees=',palmtrees)
					#starbuckslist.append(plumtree)
				else:
					pass
				##############################
				#this senario if 2 or more words for the case like "alpine meadows
				## SCENARIO 2 IF 2 OR MORE WORDS IN THE CASE
				#THIS DETERMINES IF THE CASE IS AT LEAST 2 OR MORE WORDS
				###############################
				if total_word_count > 1:
					#print(total_word_count, " words in this  case")
					#print("felix =",felix)
				#========here is the JOIN to convert the line as a list with case into a string ======
					plumtree=' '.join(felix)
					#print("== output of plum tree ==")
					#print(plumtree)
					if plumtree.endswith(":"):
						plumtree=plumtree[:-1]  #this should delete the colon of end
						alltheway = plumtree.replace("'","") #this elminates double quotes
						plumtree = alltheway
						#starbuckslist.append(plumtree)
						palmtrees.append(plumtree)
						#print("here at line 6767 palmtrees=",palmtrees)
					else:
						pass
					
				#print("plumtree=", plumtree)
				
				#print("the words for this case are",the_words)
				#print("the number of words for this case in the line are ",total_word_count)
				##===========
				#print(" ====== entering new section of coding here at Volvo ==== ")
				
				#print("=====")
				#print("=== coding at walmart saturday night ===")
				
				
				

#january 26yh, 2021 my initial design was
#this is where we will have the case words 
#my flaw was having it designed to only handle the second word, the word after case
#and that was limiting it but it will be modified correctly soon.

# case word:  but this breaks if more than one word like "alpine meadows"
# I need to add my code adjustment here 
			#======================  thursday surgery cleaning up the words 'words'
			#wild= second_word[1:-1]
			
			#wild = "'" + wild       #adding a ' to left side of word
			#darn = wild[1:-1]
			#wild = darn
			#second_word = wild
			#=======================
			#if second_word != "default": #this is new
			#	starbuckslist.append(second_word)

			if mycounter == total:
				break
			else:
				mycounter += 1
		else:
			mycounter += 1
	#starbuckslist.pop()
	#starbuckslist.append('default')
	#print("starbuckslist=",starbuckslist)
	palmtrees.append('default')
	#print("palmtrees=",palmtrees)
	starbuckslist=[] #resets it
	reset_list_to_just_starter(starbuckslist)
	#print("what's in starbuckslist here",starbuckslist)
	#filling starbuckslist
	#####################################
	
	#print("===========================")
	for item in palmtrees:
		starbuckslist.append(item)
	#print("at line 6820 strarbuckslist =",starbuckslist)	
	#print("we now have... starbuckslist")
	#print(starbuckslist)
	#print("===========================")
	
	
	




	#print("testing this::::")
	#RIGHT here is where I need to remove " and : from each item in list
	counter = 0
	#print("new test here")
	mochalist.insert(0, "'starter'")
	for item in starbuckslist:
		#print(item)
		#if item != "starter":
		if item != "starter":
			item = item[:-1] #take out the :
			#===================================== experimental surgery here to have list

			#=====================================['apple','fish',etc]
			#print(item)
			mochalist.append(item)
		else:
			mochalist.append(item)
	mochalist.append("'default'")

	#print("the mochalist after adding starter and default to it ")
	#for item in mochalist:
	#	print(item)


	acounter=0
	#greenmilelist.append('starter')
	for item in mochalist:
		if item != "starter" and item != "default":
			item[1:-1]
			greenmilelist.append(item)



	#print("=======")

	str = "'apple'"
	#print(str)
	#print(str.replace('"', ''))





#sunrise();

#what this does is take the input of teh [concatstring list] with line numbers
#which has the first case line number for each section
#I need the case number list name to feed it
















#starbuckslist=[]
#starbuckslist.append("starter");
################################################################
def this_needs_to_work_badly():   
#this fills the starbuckslist which is used in p51 for fallthru(casenmae)

#################################################################
	#print("=========this_needs_to_work_badly() =============")
	#print("=========this_needs_to_work_badly() =============")
	#print("=========this_needs_to_work_badly() =============")
	mytrace('this_needs_to_work_badly')
	#print('===============this needs to work badly called =======to get first case name ==')
	#print("============= THIS NEEDS TO WORK BADLY() called =============== ")
	#print('this gets the first case name (designed as one word initially')
	#print("but I need to modify it to take more than one word so I will need to count")
	#print("how many words are in the *first case* so it's flexible and smart")
	#new_add_to_front(x,listname)
	mycounter = 0
	#print("starting out we have in starbuckslist",starbuckslist)
	#print('case section line number list =',concatstring)
	#print("what is in concatstring?") #I think it's the first case line number in each section
	#print(concatstring)
	
	
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		#go thru case list here as the feeder
		#print(line)
		if mycounter in concatstring: #so it's looping thru switchase and line number in concatstring list
			#print("!!!!!!!======!!!!!!!!!!line=")
			#print("dam line?",line)
			#print("underneath line=====================")
			firstline = line.split() #we refer to the line as firstline a variable
			#print(firstline)
			
			
			#baby = genius[1] # it's only grabbing one word after case (by design here)
			#print("baby= genius[1]",baby)
			# if "case" in line: #see if this puppy works
			#remove the colon from the end
			#use a replace
			#firstline = line.split()
			#this makes a list called firstline
			#this gets the number of words in the line
			length_list = len(firstline)
			#now subtract first word 'case' 
			del firstline[0] #deletes the first word which is case
			length_list = len(firstline) #we thn print the number of words in this case
			#print("the number of words in this case is",length_list)
			#['case', "'alpine", "meadows':"]
			#print("line 1538")
			#print(firstline)
			#print("the length of this case name in words =",length_list)
			#while True:
			#remember that we have wiped away(erased) the case word it's gone
			if length_list == 1:
				answer = firstline[0]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                 
			if length_list == 2:
				answer= firstline[0] + " " + firstline[1]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 3:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 4:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3]
				answer = answer[:-1]
				print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 5:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 6:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4] + " " + firstline[5]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 7:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 8:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 9:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]  + " " + firstline[8]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 10:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7] + " " + firstline[8] + " " + firstline[9]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			
			
			
			####==============
			new_add_to_front(baby,starbuckslist)  ## actually adds to tail of starbuckslist
			#test
			#print("new add to front (baby,stabuckslist)")
			#print("baby=",baby)
			#print("starbuckslist=",starbuckslist)
			mycounter += 1 #n
		else:
			mycounter += 1
			
	#print("resulting starbuckslist=",starbuckslist)


######=============================================================















#this_needs_to_work_badly();[2, 7, 17, 24, 34]
#theinputlist =[2,7,17,24,34]  #5 which is case_sections + 1 (default)
case_sections = 0
total = 5
#==========================
#I will have to dynamically initialize these


mainlist=[]
#diamonds=[[2,7],[7,19],[19,26],[26,36]]  what I am aiming to make
#these are lines of the first case line numbers and then the default line number


#theinputlist= [2, 7, 17, 24, 34]  #last one is default which is really a case


length_of_input_list = len(line_numbers_of_first_cases)   #question does this work because it's an even number
#output
mainlist= [] # [[2, 7], [7, 19], [19, 26], [26, 36]]



find_default=''
lastbrace=''

list_trex=[]
listcandy=[]
defaultlist=[]  #here defaultlist is declared as empty

#uses input_list[2,7,19,26,36]
# THIS IS NEW FOR SUNDAY AUGUST 23, 2020 modified november 16th
# CONVERT TO TWIN LIST
number_of_case_sections=0
###################################
def convert_to_twin_list():  #uses list called line_numbers_of_first_cases
###################################
    mytrace("convert_to_twin_list")
    #print("=====line numbers of first cases list====")
    #print(line_numbers_of_first_cases)
    #so the length of line_numbers_of_first_cases tells us how many case sections
    #print("=9009=0=09=0=0=00=000099999=9=9=9=9=99=9=9=9=")
    #print("the number of case sections =", len(line_numbers_of_first_cases))

    #####
    ## create case lists
    #print("called create case lists")
    #create_case_lists()
    #print("them out to see them now")
    #show_case_lists()
    ##3===================
    global woodstock
    #print("woodstock in twin list=",woodstock)
    # added april 27th,2021 at 6:35 pm ===================
    
    #sniffer to see what is in digitalcandy here 
    #print("digitalcandy=",digitalcandy)
    #print('testing what is in digitalcandy line 7128')
    if len(digitalcandy) == 0:
    	print('')#'digitalcandy is empty')
    else:
    	print('')#"digitalcandy length =",len(digitalcandy))


    #this clears out digitalcandy (hopefully)
    # if digitalcandy has something in it then clear it
    if len(digitalcandy) > 0:
    	reset_list_to_just_starter(digitalcandy) #this makes it read ['starter']
    else:
    	pass
    #================
    #breakpoint()
    #print("starting out this is what is inside of list digitalcandy")
    #print("this is a moment before converting it into a twin list")
    #print("before appending to digitalcandy I wasnt verifying if it was empty")
   # print('the length of digitalcandy =',len(digitalcandy))
    #print(digitalcandy)
    ###############
    #digitalcandy.pop() #takes off first item of starterj this makes it empty
    #========================
    #global candy
    #candy=''
    #candy=[]
    #breakpoint()
    #input_list -= 1 #true cases last number is default
    ##################
    #print("inside of convert_to_twin_list")
    #print("line_numbers_of_first_cases",line_numbers_of_first_cases)
    list_trex=[] #this should reset it
    #print("list_trex=",list_trex)
    alpha = 0; beta = 1; counter = 0  #down below it was: length_of_input_list
    while counter < len(line_numbers_of_first_cases) -1:
        eval("list_trex.append(line_numbers_of_first_cases[alpha])")
        eval("list_trex.append(line_numbers_of_first_cases[beta])")
        eval("digitalcandy.append(list_trex)")
        eval("candy.append(list_trex)")
        alpha += 1; beta += 1; counter += 1
        list_trex=[] #resets list to reuse next loop
    #print('digitalcandy =',digitalcandy)
	#digitalcandy.append(defaultlist)
###=============================================




## what this does is delete the existing last sublist from digitalcandy
## and then it replaces it with a new list appended that has the default line number and
## curly brace line number (can alternatively be the last line of string) both equal length





#==============
# this looks like good logic to check between default and closing brace/last line
# determined last line number also eventually
# december 7th, this is dependent on default word existing
# the point of this code section is to VERIFY that there IS a BREAK after default
# and if there isn't a break add one
#=========
#
#===============
#defaultlist=[]

###====================
####======== find_last_break_in_string  ========= 
##in switchcasetester input switch
listofbreaks=[]
def find_last_break_in_string():
	mytrace('find_last_break')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string

##############################
##  change_to_string()   -- fancy replace to switchcasetester
##############################
def change_to_string(x,y):
	mytrace('change_to_string()')
	#print('change_to_string()',x,y)
	global switchcasetester
	peach='';peach=switchcasetester.replace(x, y)
	switchcasetester=''; switchcasetester = peach



##### friday, march 26th, 2021
##### convert case line to lowercase that's what matters for matching
def convert_case_line_to_lowercase():
	mytrace('convert_case_line_to_lowercase()')
	#print('convert case line to lowercase')
	counter=0
	global switchcasetester
	for line in switchcasetester.splitlines():
		if 'case' in line:
			#this should make whole line lowercase
			change_to_string(line,line.lower())
			counter +=1
		else:
			counter += 1
			continue
	#print("after lowering words in case line we have")
	#print(switchcasetester)




#=========================
##########################################
def special_addition_to_digital_candy():
##########################################
	mytrace("special_addition_to_digital_candy")
	#global candy
	candy.pop() #treated as a list
	digitalcandy.pop() #delete last item sublist
	#print("digital candy after pop =",digitalcandy)

	#this gets the line number of the word default
	find_default = get_default_location()  #gets line number of default

	#this gets the line number of the closing brace (identical to last line of docstring)
	last_brace   = get_closing_brace()        #gets the line number of closing curly brace
	thelastbreak = find_last_break_in_string()#put it here
	mystring = str(get_closing_brace())       #puts closing brace line number in mystring
	defaultlist.append(find_default)          #defaultlist[0] #default line number
	defaultlist.append(int(mystring))         #defaultlist[2]
	
	#print("defaultlist=",defaultlist)
	#print("digitalcandy at this point",digitalcandy)
	#so this means that digital candy should already exist and be populated
	#don't want to corruptthis it is only expecting two values not three
	digitalcandy.append(defaultlist) #these two are the parameters to look between
	#print("defaultlist=",defaultlist)
	#print("line 7317")
	#print("candy",candy)
	candy.append(defaultlist)
	#print("now candy shows",candy)
	#print("at this point digital candy shows",digitalcandy)
	
	#look_for_break_after_default(defaultlist)
	#this is new code to determine if missing break in default input section
	three_in_row=[]
	three_in_row.append(find_default)  #defaultlist[0] #default line number
	three_in_row.append(thelastbreak)  #defaultlist[1] #break line number (if here)
	three_in_row.append(int(mystring))
	a = find_default
	b = thelastbreak
	c = int(mystring)
	#print("testing here before doing comparison")
	#print("a,b,c",a,b,c)
	#I might need to call this first since it's a strange bug if a missing break
	#remember if there is no break then add it with replace
	####################
	if b > a:
		#print("==== testing if break AFTER default")
		#print("there is a break in default") #in the default case
	#else:
		#print("there is a MISSING break in default case") #beneath default
		#print('there is NOT a break in default need to add one')
		#again this is adding a break in default to javascript switch case
		#because of an obscure bug caused by missing break in default
		#print("this is before adding break to default")
		#print(switchcasetester)
		#global switchcasetester
		orange=''
		global switchcasetester  #just added this may 31st, 2021 
		orange=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester='' #this nukes it resets it
		switchcasetester = orange
		#print("after adding break to default")
		#print(switchcasetester)
		return switchcasetester

#working on this December 17th new functions

##### stage_four has faucet_value() in it which checks if switch is case numbers
##### and if so then converts the numbers to strings





#############################################################################
def stage_four():
	#print(switchcasetester) 
	#print("===== testingwhat it sees in stage four() ======")
	mytrace('stage_four()')
	#print('stage four')
	####<<====== added March 15th,2021 converts numbers to strings if numbers
	magictimenow()
	convert_to_twin_list()
	special_addition_to_digital_candy() #=======added nov 25th, 2020
	rule_the_earth()


'''
starbuckslist is just the first case name of each case section
in drive_thru list I put EACH case which is wrong.
'''




#================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.
firstline =""
#additions on Sunday August 23rd, 2020
royallist=[]  #mythical list of tail for case section codegen
royallist.append('starter'); #which fills position0

drive_thru=[]
drive_thru.append("starter")
#this is a super important function I think I wrote it at the beach a few days ago

### modfiied tuesday january 26th, 2021 to put a multi word like "alpine meadows" into fallthru('alpine meadows') currently only takes in one word
###
def testing_this_to_get_word():
	mytrace('testing_this_to_get_word')
	#print("======def ======testing this to get word() ==================")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")

	smartcounter=0
	#this looks for "case" in the switch case string
	for line in switchcasetester.splitlines(): #switch case in JS
		if "case" in line: #see if this puppy works
			#remove the colon from the end
			#use a replace
			firstline = line.split()
			#this makes a list called firstline
			length_list = len(firstline)
			#now subtract first word 'case' 
			del firstline[0]
			length_list = len(firstline)
			#print("the number of words in this case is",length_list)
			#['case', "'alpine", "meadows':"]
			#print("line 1441")
			#print(firstline)
			#print("the length of this case name in words =",length_list)
			#while True:
			
			if length_list == 1:
				answer = firstline[0]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
			 
			if length_list == 2:
				answer= firstline[0] + " " + firstline[1]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 3:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 4:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 5:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 6:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4] + " " + firstline[5]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 7:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 8:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 9:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]  + " " + firstline[8]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 10:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7] + " " + firstline[8] + " " + firstline[9]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			#print(firstline[0])
			#print("now try this",firstline[length_list])
			smartcounter += 1;
		else:
			smartcounter +=1;
    
	#print("================== drive thru list of case names ")
	#print("the list of case names no matter how many words is here in list drive_thru")
	#print("drive_thru list contents now are ",drive_thru)
	#print("")
	#print("now we will loop thru the drive_thru list")
	#LIST OF CASE NAMES
	#print("==========================")
	#print("drive_thru=",drive_thru)
	#print("===========================")
	count=0
	for item in drive_thru:
		#print(item,count)
		count += 1
        
	#here we get the location of the "default"
	smartcounter=0
	for line in switchcasetester.splitlines(): #switch case in JS
		if "default" in line:
			firstline = line.split()
			location_of_default = smartcounter
			break
			#smartcounter += 1;
		else:
			smartcounter +=1;

########   end of this never ending function ##########

#testing_this_to_get_word()  #==================this should call it now

def stage_five():
    #print('stage five')
    testing_this_to_get_word()




    ###########################################################
    #these are the line number positions of first case for each section [2, 7, 19,26]
    #this looks in one section at a time for a break and fallthru
#diamonds =[]
    #this is all just raw code not even in a function
case1findbreak=[]
case1findfallthru=[]



def does_this_run():
    mytrace("does_this_run")
    c = 1    #current case numbr section
    d = c + 1

    x = clever[0]
    y = clever[1]
             #this loops by default through the entire string
             #for line in splitline().switch:

     #=======================================================
     #this is looking between x and y which are in diamonds
     #========================================================

    counter =0
    case1 =[] #case number list to add fallthru
   
    #print("testing getting the dam range to work")
    #print("looking for BREAK in this case section")
    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to 
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;


        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=========================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##===========================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:  #what about fallthrough also to test for
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');

    if "true" in case1findfallthru:
        #print('fallthru found')
        royallist.append('fallthru')

    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        royallist.append('fallthru')

    #print("royallist=",royallist)







#//=========== iron curtain============================

 ##===============================================================
  ####=================== American River Methods ==================
  ##===============================================================









buildlist=[]
def grab_body_of_code_inside_case_sections():
    mytrace("grab_body_of_code_inside_case_sections")
    #print("grab body of code called== @@@@")
    smartcounter=0  #reset at zero

    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)

        if smartcounter > x and smartcounter < y:  #so get what's inbeteen
       #this should only print the body of this one case section
            if "case" not in line and "break" not in line and "fallthru" not in line:
                #print(line)
                buildlist.append(line,smartcounter);
                smartcounter += 1;
                #do I need continue?








#august 27 thurday coding test       this will be the sets of cases for each case section
caseset=[]
def create_case_name_lists(x,y):
    #print("==$$$$$$$$$$$$$$$$$$$$$$$$$$$$$==")
    #print("================this is line 1615===CREATE CASE NAME LISTS=====================")
    #print("def create_case_name_lists:")
    #print("working on fix to solve bug if user uses more than one word for a case")
    #print("such as alpine meadows whereas right now its geared for one word cases")
    
    mytrace('create_case_name_lists')
    #print("=================create case name lists called == @@@@")

    smartcounter=0 #reset at zero
    genius = ''
     #need list of first cases that will work for input
    #Thursday coding to save this day from a disaster of nothing working
    ##===================================================================
    ## LOOP LOOKING  CASE SECTION APPEND LINES FROM BODY AFTER CASES UNTIL NEXT FIRST CASE
    ##=======================================================================
    #print("here we get the words in each case section=====------")
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter < y:  #so get what's inbeteen
        #this should just look
            if "case"  in line:
                #print("did it take off front of line?")
                #print(line.split(' ',1)[1])
                #print(line,smartcounter)
                #print("=================================")
                genius =line.split()
                #print("genius =",genius)
                #print("======= len(genius) ==============")
               # print("WE ARE HERE==>>>>")
               # print('number of words in the line case = len(genius) ',len(genius))
                
                #print("number of words in this line =",len(genius))
                #print("it's current state is only grab the second word which is position [1] by default")
                ap=''
                #testing with more than one word the defualt was the first one
               #================  jan 3, 2021 code fix experimentiong case alpine meadows
                if len(genius) == 2:
                    #print('teh default was 1 word case and one word')
                    caseset.append(genius[1])
                    #print(caseset)
                    
                if len(genius) == 3:
                    #print('teh default was 3 words case and two words')
                    ap =genius[1] + genius[2]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) == 4:
                    #print('teh default was 4 word case and 3 words')
                    ap =genius[1] + genius[2] + genius[3]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) > 4:
                    #print("more than four words in this line detected")
                    #print("just do the default for now will fix later")
                    caseset.append(genius[1])
                    #print(caseset)
                
                #print("it looks like I'm just grabbing the first word of a case which I initially tested it with")
                #print('line 1632')
                #print(caseset)
                #buildlist.append(line);
                smartcounter += 1;

    #print("caseset list for one case section=",caseset);
    wilsonball=[]
    wilsonball.append('starter')
    wilsonball.append(caseset)
    #print("******** === wilsonball=",wilsonball)










#this actually looks for breaks, missing beaks, and fallthrus
####=====================
##case_tail_list_maker() finds breaks, missing break detection, fallthrus
##========================
snowman=[]
homer=[]
gti=[]
gti.append("starter")
funny=''
seal=[]
homer.append('starter')
solution=''
snowman.append('starter')
wilecoyote=[]  #I was clearing it out here good thing I noticed it
casecaptured=''

reset_list_to_just_starter(wilecoyote)
#print("wilecoyote list",wilecoyote)
#wilecoyote.pop()

mrcase=''
def case_tail_list_maker(x,y):  #two vars x and y are case locations from digitalcandy
    mytrace('case_trail_list_maker')
    #print("=######	C A S E    T A I L   M A K E R  searches for breaks and fallthrus  ")
    #print("digitalcandy=",digitalcandy)
    #print("length of digitcandy=",len(digitalcandy))
   
    smartcounter=0
    #this looks for "case" in the switch case string
    for line in switchcasetester.splitlines(): #switch case in JS
        if "case" in line: #see if this puppy works
            firstline = line.split()
           
            smartcounter += 1;
        else:
            smartcounter +=1;

    #here we get the location of the "default"
    smartcounter=0
    for line in switchcasetester.splitlines(): #switch case in JS
        if "default" in line: #see if this puppy works
            firstline = line.split()
            location_of_default = smartcounter
            break
            #smartcounter += 1;
        else:
            smartcounter +=1;



   #not sure if I am using c and d or not or if I switched to x, y instead
    c = 1    #current case numbr section
    d = c + 1
    #print("x",x,"y",y);
    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]

    smartcounter=0
    ram=''
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    #homer=[] #this is to keep track of whether break or fallthru as backup checker
   ##############################################
   
    ##############################################
    ##############################################
   # print("HUGE TEST to make it work Tuesday feb 22nd")
    #this goes through the whole switch case 
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        #print("======= TESTING THIS  ========")
        #print("x =",x,"and y=",y)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            ####################################
            if smartcounter == x: #case line
                #print("GET CASE NAME")
                mrcase =get_case_name(line);  #calling method here 
               # print("just here got the_section",mrcase)
               # print(mrcase)
                
                mrcase =mrcase.lstrip() 
                mrcase =mrcase.rstrip()
                #print(mrcase)
            #end if
            
            
            #firstline = line.split()
            #print("I need to make sure it searches through the lines")
            #print(line)
            global funny
            funny += line
            #### I have simpified it to if break then break, otherwise fallthru
            if "break" in line:
                #print("===== gold ======")
                #print("we found a break line number =",x,y,smartcounter)
                
                wilecoyote.append(mrcase) # first case number in digitalcandy
                #I will put the case name instead of x
                
                homer.append(smartcounter)
                seal.append(smartcounter)
                #if i detect a break on a line in a case section that's true
                
                #smartass.append("break")
                #homer.append('break')
                case1findbreak.append("true")
            else:  # I just modified this one and using homer
                case1findbreak.append("false")  #meaning add invisible fallthru
                #print("no break found in this section") #and no fallthru
                #print("no break found =",x,y,0) #using 0 for no break found
                #homer.append('fallthru')
                #break not in line it's fallthru
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #########################
  
        
        
     #we ARE STARTING A SECOND LOOP HERE -------------------
        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
        #print("this was the old design the newone will be different")
        if "break" in funny:
            gti.append("break")
        else:
            gti.append("fallthru")
        
        
    smartcounter=0 #reset at zero
    ##=====================================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##======================================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" or "fallthrough" in line: #just added fallthrough here
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
              
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #I think that this is the end of the for loop here
    #print("=================================")
    #print("gti  list has",gti)
    #print("=================================")
    #print("========WILECOYOTE LIST=========")
    #print(wilecoyote)

   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found in this case section ')
        royallist.append('break'); #this adds break to royallist
     


# here it's appending the fallthru('casename')
    if "true" in case1findfallthru:
        #print('** = fallthru found in case section')
        smart = len(royallist)  #new code  a number
        smart += 1
        #before I add this one         so I am putting a number here which is used
        fall = "fallthru" + str(smart)  #to call the correct word in starbuckslist
     
        royallist.append(fall)
        #homer.append(fall)
        
  # here it test if "break" not in case section and "fallthru" not in case section
    wolf =''
    if "true" not in case1findbreak and "true" not in case1findfallthru:
       # print("** = need to add a fallthru in this section with no break and no fallthru")
        sosmart = len(royallist)
        sosmart += 1   #number below so it makes fallthru4 in example
        fall = "fallthru" + str(sosmart) #+ ")"  #just added this  thursday night
       
        wolf = "fallthru(" +   str(sosmart)  + ")"  #this makes fallthru(4) which I need
        #because I can convert the number to a word in new list
        #print("wolf=",wolf)  #so this works
        royallist.append(fall)
       # homer.append(fall)
   
    #print("let us see what the size and end of royallist is",royallist)
    #print("royallist lenght=",len(royallist))
    royallist.append('break'); #this is for the default case which must be a break
    #print("royallist final =",royallist)
    #print("lenght of royallist final =",len(royallist))
    snowman.append("break")
    #print("gti coming thru",gti)
    #print("this is our winner=================")
    #print("seal=",seal)
    #print("the list of first case number in digitalcandy with a break in it")
    #print("wilecoyote=",wilecoyote)



##########################################################################
##           dividide and conquor    thrusday, feb 25th, 2021 nearly 1pm
##########################################################################






#####################################
### crashing waves at beach ()   ####
#####################################
penguin=[]  #defining a new list here 
def crashing_waves_at_beach():
	mytrace('crashing_waves_at_beach()')
	#print("Crashing Waves At Beach function called")
	######## there is a lot going on here
	'''
	loop thru wilecoyote of cases with breaks and
	   get index location of those cases in palmtrees list
	   put the index number into roadrunner list
	   
	 
	loop thru digitalcandy to make list of same size and fill british list with all 'fallthru'
	
	loop thru roadrunner list with index number
	and replace index number in british with "break"
	
	'''
	#print("this is what is in wilecoyote",wilecoyote)
	#print("I got this working the other day at motel 6 on Tuesday night")
	################################################
	#print('in crashing waves at beach we have wilecoyote line 7975',wilecoyote)
	#print("palmtrees at line 7977 we have ",palmtrees)
	###=================#######@@@@@@@@@@@@@@@@@@@@@@@
	#print("debugging on june 16th, 2021")
	#print("palmtrees to see whats in this list")
	##########################

	## this gets the location of the case in wilecoyote inside of palmtrees list
	for item in wilecoyote: #goes through list of case sections with breaks
		
		####@@@++++++++++__+++========================
		toad = get_location_of_case("palmtrees",str(item))
		roadrunner.append(toad) #this returns a number the index position
	#print("ROADRUNNER list contains numbers of index locations of cases in palmtrees",roadrunner)
#################################################
	# make a new list based on digitalcandy
	#print("in digitalcandy at line 7988 we have",digitalcandy)
	thecounter=0
	for item in range(0,len(digitalcandy)): #using this for length of case sections sequence
		#filling list with fallthrus
		#print("what I am doing here is adding the Next case number so it's correct")
		  #I had to move the counter before it to get it working correctly
		british.append("fallthru" + str(thecounter + 1)) # current case number + 1 for next case
		thecounter += 1
	#this adds break after the loop finishes	
	british.append("break") #adds one more to list since default is extra case
	
	

	############ this is where BREAK  is inserted into the list with replace method 
	mycounter=0
	
	for item in range(0,len(digitalcandy)):  #adding a case to it default
		if mycounter in roadrunner: #if it finds first case line number in roadrunner
			#print("this is where it is inserting break into the list british")
			do_replace(int(item),"break")## do_replace(1, 'break')  list[index number]
			mycounter += 1
		else:
			mycounter += 1
			
	#print("============================")
	#print("british is ",british) #break and fallthru list
	#this changes the first position slot to starter

	#this assigns values to specific elements in the british list
	#british[0] = "starter"
	#this ensures that the last one is a break no matter what it's force fed in. 
	#british[-1] = "break" #makes sure last one is break which is absolutely must be. 
	#print("here is the finished british list before adding teh fallthru with case")
	#print("british now =",british)
	##############
	#print("british list at line 8024=",british)
	#############
	#do this first  assuming of course default (worry about adding defaeult laster
	#check if "break" in switchcasetester
	#if False then add it to bottom of default
	#if no break in switch case it won't parse - sooo funny 
	
	####==================================================
	#print("=== OFFICIAL BRITISH LIST ==== USING SMART BREAKS AND FALLTHRUS NUMBERED == ")
	#print(british)
	########################################################
	british[0]  = "starter"
	british[-1] = "break" #just to be sure 
	#print("####################E#######################")
	#print("February 25th, 2021 Beach Coding with seagulls flying just above the waves ")
	#print('totally NEW OCEAN BEACH CODE TO MAKE NEW FALLTHRU INTO LIST OCEANWAVES')
	#print("which will be put into cranberries replacing what's in cranberries ")
	#print("=================-------- waves at abeach -------+++++++++=================")
	#print("======================= waves at beach and seagulls flying over ice plants =====")

	
	for item in british:
		penguin.append(item)
	
	
	newcounter=0



	for item in range(0,len(british)):  #should only look inside of items starting with f
		if british[item].startswith("fallthru"):
			
			getnumber= british[newcounter] #gets the fallthruX
			
			getnumber = getnumber[8:] #gets the number from cutting off front fallthru
			getnumber = getnumber.rstrip()
			getnumber = getnumber.lstrip()
			
			newnumber = int(getnumber)
			
			casename =palmtrees[newnumber] #has cases in sequence
		
			mrfallthru = "fallthru("  + "'" + casename + "'" +  ")"#
		
			smart_replace(newnumber-1,mrfallthru)## just added minus 1
			
			newcounter += 1
		else:
			newcounter += 1
	newcounter = 0		
			
	
	penguin[-1] = "break"
	
	#### I can change the contents of british or makea  new list so as to not mess it up.
	oceanwaves =[]

###########################################################################









tail_list=[]
cranberries=[]
cranberries.append('starter')
british =[]  # list for faltlhru and breaks for each section to be managed
roadrunner=[]
######################################
##  f22_fighter_jet()
######################################
#this is called if numbers is true:
#this is not called because I found a way
# to send the numbers thru the string parser
# I don't think that this is called 

def f22_fighter_jet(): #makes critical cranberries list which is the taillist for switch cases
	return #this kills it
	

###################################################
 
  #this makes the cranberries list which is the tail list used on codegen page
#diamonds=[[2,7],[7,17],[17,24],[24,34]]
#this makes the cranberries list

##===========================
##      def p51_mustange()  ==  adds the number to  fallthru(3) like that
##===========================
def p51_mustang(): 
	mytrace('p51_mustang')
	counter = 0
	c = 1		#current case number section
	d = c + 1
	#print("** inside of p51 mustange [[ digitalcandy ]] =",digitalcandy)
	royallist =[] #resetting this Friday april 9th
	#maybe in digitalcandy
	#print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	#print("digitalcandy in p51mustange=",digitalcandy)
	for item in digitalcandy:	#this is going through the diamonds list
		holder = digitalcandy[counter]
		x = holder[0]
		y = holder[1]
		##print("x",x,"y",y);
		case_tail_list_maker(x,y)   #here it is calling case_tail_list_maker
		counter += 1

	royallist.append('break');  #in default
	counter = 0
	


	#this goes thru the royallist with breaks and fallthrus(numbers)
	
	#loops thru to royalist[item] then accesses the starbucklist[item to append
	# I can make fallthru('fish') and fallthru('default')  and have the formula working
	#I use numbering in royalist starter1(0) (position1 fallthru2)   (position2 fallthru3) etc
	#if they use big numbers I will put them inside of (number) and grab teh number startswith("(")
	
	#for item in range(1,len(royallist)):
	for item in royallist:  #so royallist has starter break fallthru3 default in it 
		if "break" in item:
			cranberries.append("break")
		
		#print("this is where fallthru gears work line 2182")
		if "fallthru" in item:
			#### this grabs the number on the end of fallthru that is already there. 
			item=item.strip()
			#print("item=",item)
			item =item[-1]
			
			item = int(item)   #is this returning a number?
			## yea this is retrieving the number from the end of the word fallthru
			
			
			doggy =palmtrees[item] #just added -1   this is like fallthru('cherry')  #was starbucks
			#print("doggy",doggy)
			doggy[1:]  #deletes first item
			doggy[:-1] #deletes last item
			
			#this builds the fallthru(nextcase)
			ohbaby = "fallthru("  + "'" + doggy + "'" +  ")"#this is the number
			
			cranberries.append(ohbaby) # just added this Thrusday, sept 10th Target
	
	oceanwaves=[] #this sets it at empty
	
	crashing_waves_at_beach()
	
	for item in british:
		oceanwaves.append(item)
	

			
			
	
	


# I will need to change this here and just have p51mustang
def stage_six():
    p51_mustang() #so it only calls p51_mustang now
   




#The purpose of this method == flyingcloud == is to
#fill small lists with
#the respective case names
#get case names in each set and add to list


#=====================================
#========== flyingcloud ==============  Thursday morning coding
#=====================================
case1list=[]
case2list=[]
wilderness=''
wild=''
#diamonds=[[2,7],[7,17],[17,24],[24,34]]



#forcing it to see what happens november 21st
#caselist7=['default']


#we will know before hand how many caselists will be filled 4

#this makes the first case list called starbucks which is used throughout the program
##==========================
##   flying fish             this loops through the digitial candy list of first cases
##========================== which are the line numbers of each case
def flyingfish():
	
	ax = len(digitalcandy)
	#print("length of digitalcandy =",ax)
	mytrace('flyingfish')
	mytrace('flyingcloud')
	x =''
	y =''
	z ='' #just reset z to nothing
	thecounter=0
	thecounter=0
	# loops through diamonds list of case position to build the first case list
	# which is called starbucks
	z = thecounter #which is 0 by default above
	z += 1  #then it starts at 1
	#print('digitalcandy=',digitalcandy)
	global candy
	#print('candy=',candy)
	#print("digitalcandy at line 8418=",digitalcandy)
	for item in digitalcandy:
		x = item[0]
		y = item[1]
		#print("** look at x,y,z here **")
		#print("x",x,"y",y,"z",z)
		flyingcloud(x,y,z) #z starts at 1 and adds 1 to z with each loop
		z += 1
		thecounter += 1
	z = 0
	thecounter=0
	nightowl()   #fills smartcasemanager





##==========================
##      flying cloud            
##==========================
#  this builds a list of the case names for each section
smartcasemanager=[]
smartcasemanager.append("['starter']")
def flyingcloud(x,y,z):
	#print("smartcasemanager=",smartcasemanager)
	words=''
	
	#print("flyingcloud called; this builds a list of the case names for each section")
	mytrace('flyingcloud')

	smartcounter=0
	#print("x,y",x,y)
	for line in switchcasetester.splitlines(): #switch case in JS
		#print("inside of loop values of x,y at top of for loop ",x,y)

		if smartcounter < x:
			smartcounter += 1
			continue

		#to stop going through string of code
		if smartcounter == y:
			break

		if "case" not in line:
				break

		if (smartcounter >= x and smartcounter < y) and ("case" in line):
			firstline = line.split()
			#print("length of firstline words =",len(firstline))
			words = len(firstline)  #this is the length of the first line
			
			#print("=========== line 2000 ===firstline====")
			#print("firstline=",firstline)
			if words == 2:
				wilderness = firstline[1] #this grabs the case name
				
			if words == 3:  #if 2 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]   
				
			if words == 4:  #if 3 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3] 
			
			if words == 5:  #if 4 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] 
				
			if words == 6:  #if 5 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5]
				
			if words == 7:  #if 6 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6]
				
			if words == 8:  #if 7 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7]
				
			if words == 9:  #if 8 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8]
				
			if words == 10:  #if 9 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8] + ' ' + firstline[9]
				
			if words == 11:  #if 10 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8] + ' ' + firstline[9] + ' ' + firstline[10]
			
			wild= wilderness[1:-1]
			#print("wild=",wild)
			wild = "'" + wild  #adding a ' to left side of word
			darn = wild[1:-1]
			wild = darn
			
			############# feb 6, 2021
			
			# will need to use the case or counter number and
			# use eval to just do this with one if
			eval("caselist" + str(z) + ".append(wild)")

		else:
			if "case" not in line:
				break

#############################################
einstein=[] #resets einstein to empty
	#========================================
#this fills up smartcasemanager list




#============================
#      nightowl()
#============================
def nightowl():
	#print("===== nightowl() called ======")
	mytrace('nightowl()')


	i = 1
	#this filles the list smartcasmanager skipping 0 position
	#while i <= len(digitalcandy):  #use range here
	for item in range(1,len(digitalcandy)):
		eval("smartcasemanager.append(" + "caselist" + str(i)+ ")")
		i += 1

	i+=1
	eval("smartcasemanager.append(" + "caselist" + str(i)+ ")")

	#this copies smartcasemanager and puts it into list einstein
	for item in smartcasemanager:
		einstein.append(item)



#this prints out the smartcasemanager list to verify that it worked and has the sublists

#=================================
def goodseason():
	mytrace('goodseason')




def stage_seven():
    #print('stage seven')
    flyingfish()


wilson=''
mystring =''


#or am I using the current case number or next case number for fallthru
#so does it represent the current location and then we add 1 to it or does fallthru(#) have
#the next number position embedded in it already
#this will go through the list and convert the fallthru(#) into names making the gold tail list
#which is used to build the case sections
bronzelist =[]
#I think it will already have it in it calculated currecent case section number + 1

#============================
#      wildgame
#============================
def wildgame(y):   #this gets the number out of fallthru(5) and converts it to the casename
	mytrace("wildgame")

	mystring='fallthru(' + str(y) + ')'  #this gets the number from fallthru to use in starbuckslist to get case name
	#print('mystring=',mystring)

	wilson=int(''.join(filter(str.isdigit, mystring)))  

	#this extracts the number from fallthru(5) and gets the 5

	#print("the input number it sees in fallthru as input",wilson)
	newnumber = wilson + 1
	#print("newnumber=",newnumber)
	newnumber = int(newnumber)
	#print("the output fallthru number for next case name after adding 1 = ",newnumber)
	answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
	#answer should be a string which is the case name
	ohbaby = "fallthru('"  + answer  + "')"  #this is the number
	#print("we now have ",ohbaby)   #this should be "fallthru('casename') which is put at bottom of a case section
	ohbaby =ohbaby.strip() #this is beautiful
	#it looks like this:   fallthru('fish')
	return ohbaby   #first time I recall using return in python for anything










goldtaillist =[]
#I need to loop through this list and create the new list for final gold tail list
def autumn():  #this builds the break fallthru(nextcasename) list
	mytrace('autumn')
	counter =0

	for item in starbuckslist:
		print(item)
		#goes through list


		if item == "break":
			#print('break found')
			goldtaillist.append("break") #how come it doesn't append this
			counter += 1


		if  "fall" in item:
			result =wildgame(counter)  #it wants a number use the counter
			#print("wildgame() result=",result)
			goldtaillist.append(result)
			counter += 1
		else:
			counter += 1

		if item == "starter":
			goldtaillist.append("starter")
			counter += 1
			continue

		if item == "default":
			goldtaillist.append("default")
			counter += 1
			continue

	#print("goldtaillist =",goldtaillist)




#autumn()



crushit =[]


#thurday, september 10, 2020 truck stop insight
#=============== stars() =============================
#=========== this goes thru dummy list with just starter fallthru and break and default
#==========/=== and adds the numbers of teh fallthru locations into cru0list
#=======================================================

miraclelist=[]

####################
##    stars()
####################
def stars():
	mytrace('stars')
    #print('STARS test of loking for words in list')
	#print('look for break default starter fallthru')
	#print("listnow =",listnow)
	counter =0
	#print("starting looking in loop")

	for item in listnow:
		if "break" == item:
			#print('break')
			crushit.append("break")
			counter += 1

		if  item.startswith("f") == True:
			#print('fallthru found')
			crushit.append("fallthru('" + str(counter) + "')")
			counter += 1

		if item.startswith('d') == True:
			#print("default found")
			crushit.append("default")
			counter += 1

		if item.startswith('s') == True:
			#print("starter found")
			crushit.append("starter")
			counter += 1



	#====
	#starter is 0 but not a case
	#first case is position 1 (if fallthru(1)) it becomes fallthru(2) for conversion
	#so it is based on current position for the current case and then the NEXT case is +1
	#==========================================
	#input must be 1 or higher but less than the length-1 can't be starter (0) or default(length-1)
	wilson=''
	newnumber=''
	counter =0
	for item in cru0:
		if item.startswith("f") == True:  #fallthru or fallthrough
			#print("fallthru found")
			mystring=item
			#print('mystring=',mystring)
			wilson=int(''.join(filter(str.isdigit, mystring)))   #this extracts the number from a string
			newnumber = wilson + 1
			newnumber = int(newnumber)
			answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
			ohbaby = "fallthru('"  + answer  + "')"
			ohbaby =ohbaby.strip()
			miraclelist.append(ohbaby)
			counter += 1

		if item.startswith('d') == True:  #default is last case needs to have break
				#print("default fuound")
				miraclelist.append("break")
				counter += 1

		if item.startswith('s') == True:
				#print("starter found")
				miraclelist.append("starter")
				counter += 1

		if item.startswith('b') == True:
				#print('break')
				miraclelist.append("break")
				counter += 1








#======== adderrsmill==============================
case_main_body_list=[]
 #this is to fill up position 0

z =''


# big gears filling list with case bodies of python code



#################### this is where the case section bodies are added to a list
#################### case_main_body_list



################################################
##  big_gears_filling_list_with_case_bodies()
################################################
def big_gears_filling_list_with_case_bodies():
	case_main_body_list.append('starter')  #moved this here 
	mytrace('big_gears_filling_list_with_case_bodies')
	#print("================big gears filling list with case bodies called==========")
	#breakpoint()

	counter=0
	#print("=====DIGITAL CANDY ======")
	#print("digitalcandy=",digitalcandy)
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]
		#print(item[0],item[1])
		
		counter += 1
		#print("counter=",counter)
		smarty(item[0],item[1])  #snowtime is called here
	#case_main_body_list.append('default')

import re  #for regular expressions
#this one
handy_list_of_tabs=[]
dual_slots=[]
crummy =[]
fiasco =[]
n_count_per_section=''
case_section_lines_of_code=[]

#new idea have line count based on first line of code in THIS section after if case
#and the first line is 1 and not 0 so it's human math thinking

def smarty(x,y):  #this grabs the body from one case section at a time
	mytrace('smarty')
	#print("in smarty what is in case_main_body_list",case_main_body_list)
	
	#print("smarty x y testing blank lines existence to delete them")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	for line in switchcasetester.splitlines():
		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line  and "}" not in line \
		and "{" not in line:
		#this takes out the empty line by skipping it
			#print("line=",line)
			#added this sept 17 2020 to eliminate empty lines that do and mean nothing
			if len(line) == '\n': #this means that the line is empty
				
				mycounter += 1 #see if this is necessary here or not
				continue
			else:
				

					#by default each line will require 2 tabs in front of it
				line=line[1:] #takes off first tab off from front of line

				# ============== Glory =======================
				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				#=============== Glory =======================

		mycounter += 1

	#this would be the string and nuke last line trailing \n which I know will be there
	practicestring1 = practicestring1.rstrip("\n")
	### and here the practice string is added (appended) to case_main_body_list
	#print("this is WHERE a line inside of a case section is added to case_main_body_list")
	case_main_body_list.append(practicestring1)  #the body case code is added here
	#print("case_main_body_list=",case_main_body_list)
	del practicestring1  #this nukes it
	practicestring1 =''  #here we nuke practicestring1 so I can reuse for each case section
	#print("=========")
	#print("list of tabs=",handy_list_of_tabs)
	#print("number of lines with code =",len(handy_list_of_tabs))
	#print("pairs tabs and line number ",fiasco)
	#print("number of lines in each section =", n_count_per_section)
	#case_section_lines_of_code.append(n_count_per_section)
	#print("=========")
	#print("==== attempting to print out cases section code from case_main_body_list")
	acounter=0
	for item in case_main_body_list:
		#print("==========")
		#print(item)
		acounter += 1
		#print("case=",acounter)
		#print(item)
	

def loop_thru_case_sections():
	#print("======== loop thru case sections =============")
	mytrace('loop_thru_case_sections')
	#print("loop thru cases sections which is a list")

###############################################################################
###############################################################################
#TUESDAY CODING February 7th outside Panara Bread

##  THIS IS TO REPLACE A WORD IN A LIST
#################################
##  replace_in_list(number,word)    replace_in_list(2, 'fallthru')
##################################
# replace word in list by index position
def replace_in_list(x,y,z):  
	z[x]= y   #listname[5] = 'word'
	#print(z)  #print(listname)

#  new_replace_index(x,y)  uses two variables and 
#  hard code list name and call replace_in_list(x,y,z)
def new_replace_index(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=fruits  #list name
	replace_in_list(x,y,z)   ##<<==== it calls the method above brilliant
	#print(fruits)
	


fruits = ['apple', 'banana', 'fallthru']

fruits.insert(1, "orange")

#print(fruits)

fruits[0] = 'starbucks'
#print("")
#print(" changing replacing value")
#print(fruits)
end = len(fruits)-1 # last index position

#this should put tophat into front of list
new_replace_index(0,"tophat")   #<<==== look here oinly using 2 vars
replace_in_list(1, 'break',fruits)
replace_in_list(2, 'fallthru',fruits)
replace_in_list(end, 'break',fruits)
#replace_in_list(0, "starter",fruits)
fruits=[]
fruits.append("starter")
ii = 0
while ii < 10:
	fruits.append("fallthru")
	ii += 1  #always add the dam counter
	
	
#need to have a list with the NUMBER in sequence of case sections with break
# like this  listofbreaks=[1,2,5,6,7,9]

#print(fruits)
replace_in_list(end, 'break',fruits)
#print(fruits)
replace_in_list(2, 'break',fruits)
replace_in_list(3, 'break',fruits)
replace_in_list(4, 'break',fruits)
replace_in_list(8, 'break',fruits)
replace_in_list(9, 'break',fruits)
end = len(fruits)-1 # last index position
replace_in_list(end, 'break',fruits)
#print(fruits)
#print("=====")
new_replace_index(end,"panera bread") 
new_replace_index(6,"break") 

#print("=== the end here of replace for now ===")


#==================
#Output

#['apple', 'orange', 'banana', 'fallthru']

#changing replacing value
#['starbucks', 'orange', 'banana', 'fallthru']
#['starbucks', 'break', 'banana', 'fallthru']
#['starbucks', 'break', 'fallthru', 'fallthru']
#['starbucks', 'break', 'fallthru', 'break']


######################################








#loop_thru_case_sections()  #=================


#######################
##  stage_eight()
#######################
def stage_eight():
	mytrace('stage_eight()')
	#print('stage eight')
	loop_thru_case_sections()


icecream=''
def herewego(): #loops and prints all main bodies
	mytrace('herewego')
	

	counter=0
	#this loops thru the case_main_body_list
	for item in case_main_body_list:
		if counter == 0: #skips the first slot "starter"
			counter += 1 #I forgot the bloody counter
			continue

		#print("=========================================")
		#print(case_main_body_list[counter])

		icecream= case_main_body_list[counter].count("\n")

			#myString = practicestring1
			#	print(myString)  #below zapping out pesky tabs at front
			#	# uses regular expression to nuke tabs
			#	output   = re.sub(r"[\t]*", "", myString)

		#print("==== ICE CREAM number of lines of code in section =====")
		#print("the number of lines of code in this  section=",icecream, "section",counter)

		#print("================================",counter)
		counter += 1




	#print("experimenting here in here we go")
	#get length (number of lines) of each
	#body_size = len(case_main_body_list[3])
	#print("the number of lines =",body_size)

#print("")

acounter=0
#for item in case_main_body_list:
#	print(len(item))
#	acounter += 1



#print("digitalcandy=",digitalcandy)
#big_gears_filling_list_with_case_bodies()
#herewego()  #==================================




##########################
##  stage_nine()
##########################
def stage_nine():
	mytrace('stage_nine()')
	#print('stage nine')
	big_gears_filling_list_with_case_bodies()
	herewego()


#print("tail_list cranberries =",cranberries)
###=============================================================================
x = 0;y =0
smart=''
#cranberries=[]
#print("at this juncture line 9166 what exactly is in list of rows of case names list")
#print(list_of_rows_of_case_names)

list_of_rows_of_case_names=[]
for item in list_of_rows_of_case_names:
	del item
#print("length of list_of_rows_of_case_names=", len(list_of_rows_of_case_names))


#making case section sublists here
#this is for making the variable lists to fill the case sections of cases
# and to refer to each of these caselists with ifs and elifs


#########################
##   make_case_sets()
#########################
def make_case_sets():
	mytrace('make_case_sets')
	#print("===== make_case_sets called ====")
	acounter = 0
	firstcasesectionlist=[]
	firstcasesectionlist.append("starter")
	 #this will be the case name
	#print("we have length of ", len(digitalcandy))
	#print(digitalcandy) #so we can see our input values of digitalcandy list
	for item in digitalcandy:
		x = None  #zap them out perhaps
		y = None
		#what = digitalcandy[acounter]
		x = item[0]; y = item[1]

		z = acounter
		partynation(x,y) #partynation called here------ PARTYNATION -----------
		acounter += 1
	#adding default to see if it works
	#firstcasesectionlist.append("default")
	#this happens after the loop has finished
	#print("what 9999 is this =",firstcasesectionlist)
	#print("----------")
	counter=0
	list_of_rows_of_case_names.append(firstcasesectionlist) #since this will be the last one
	castle_time()

smartcasemanager=[]  #creating the initializing smartcasemanager



#this just prints it out the sets of the cases for each case section
def castle_time(): #fills up smartcasemanager
	mytrace('castle_time')

	#list_of_rows_of_case_names.append("[['default']") #trying this
	#print("============CASTLE_TIME called ===========")
	count=0
	while count < len(list_of_rows_of_case_names):
		if count == 0:
			count +=1
			continue
		#print(list_of_rows_of_case_names[count][1:])
		count += 1

	#print("more testing to get this right")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	##################################################
	### SMARTCASEMANAGER LIST FILLED HERE ############
	##################################################

	#this fills up list smartcasemanager from list_of_rows_of_case_names
	#this is doing a brute force copy of a list

	#print("list_of_rows_of_case_names",list_of_rows_of_case_names)
	#print("this is what is in list_of_rows_of_case_names")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	del smartcasemanager[:] #this doesn't seem to work 
	while len(smartcasemanager) > 0:
		for item in smartcasemanager:
			del item
	#print("what is in smartcasemanager now???",smartcasemanager)

	#print("smartcasemanager should be empty now",smartcasemanager)

	#print(smartcasemanager)

	#print('after deleting last item in list')
	#print("this is what is in smartcasemanager",smartcasemanager)
	#print("the length of smartcasemanager is", len(smartcasemanager))

	finallist = ['default'] #see if this works
	list_of_rows_of_case_names.append(finallist)
	#print("this should be default below======+++")
	#list_of_rows_of_case_names[-1]
	#smartcasemanager.append("['default']") #using a default case so it can be fallthrud from above
	#print(smartcasemanager) #now we add default to the end or do we need to or not


############################
#        partynation 
############################
list_of_rows_of_case_names=['starter']
firstcasesectionlist=['starter']
def partynation(x,y):  #this grabs the body
	#print("==29734== partynation()=====")
	mytrace('partynation')
	#print("====partynation======")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	firstcasesectionlist=[]
	firstcasesectionlist.append('starter')
	#start loop
	#this specifically is looking for the word case
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if mycounter >= x and mycounter < y \
		and "case" in line:     #just added default
			genius = line.split()
			wild=genius[1].strip()
			wild = wild[:-1]
			wild = wild[1:-1]

			firstcasesectionlist.append(wild)  #adding this case name to firstcasesectionlist

		mycounter += 1
	#end loop
	#This is forcing default into firstcasesectionlist
	#wild = 'default'   #major test here
	#firstcasesectionlist.append(wild)
	for item in firstcasesectionlist:
		item.replace('"',' ' )


	firstcasesectionlist[1:-1]
	for item in firstcasesectionlist:
		item.replace('"',' ' )
	#here the currently newly minted case list is added to the big list
	#which is called list_of_rows_of_case_names
	list_of_rows_of_case_names.append(firstcasesectionlist)



	firstcasesectionlist= []
	#firstcasesectionlist.append('starter')




def testingthis():
	mytrace('testingthis()')
	#print(" this prints out the contents of the important lists")

	#print("==============================================")
	#print("digitalcandy list ========")
	for item in digitalcandy:
		pass #print(item)
		
	global candy
	for item in candy:
		pass #print(item)
		
	

####################
##    stage_ten()
####################
def stage_ten():
	mytrace('stage_ten()')
	#print('stage ten')
	make_case_sets()
	#testingthis()



#I just need the lists to build my code generation now to generation
#the logic right

#codegen is using the output lists from the parser

#this is the taillist

#this is bringing it altogether simulating it creating the
#switch case in three parts
#with a counter and a loop

#trace()
#lists for starbuvks_drive_thru_code.py
caselist     =[]
breaklist    =[]
fallthrulist =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]


alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]

#this will be the first
#print("this will run at the top of the page and call the functions in sequence\n")
#cranberries=[]
my_godzilla_list=[]
newlist=[]
smartylist=[]
tryagain=[]
coollist=[]
#test data here it will be one file and just flow down with no imports
#rodan=[2,7,17,24,34]

tabs =['starter',"\t","\t\t","\t\t\t","\t\t\t\t","\t\t\t\t\t","\t\t\t\t\t\t"]



#I just turned these off at the bottom

'''
sunrise=[]
fishfood()
fortunate()
test1()
testhere()
'''
###################
#       get() 
###################
#this is a return value in varholder[1]
def get(x):
	switch_return_value.append(x)
	#print("inside of switch_return_value[1]")
	#print(switch_return_value[1])


firstcaselist=[]

#digital_candy=[[2, 7], [7, 17], [17, 24], [24, 34]]

switch_python_gen=''










###=================================================================
###  below I get the location of default and closing curly brace for end of switch
###  this is to be used for determining the default case which is utilized for
###  the situation of a fallthru down into default
###  this also adds one more case tothe regular cases and I need these parameters

#print("============ surgery here S=================================")
#print("")



##########################
##  make_default_case()
###########################
def make_default_case():
	mytrace('make_default_case()')
	find_default = get_default_location()
	#print("NEW location of default =",find_default)

	lastbrace = get_closing_brace()
	#print("NEW location of closing brace =", lastbrace)


	#digitalcandy.append
#november 21st coding
#make_default_case()

## what I still need to put together to have the body of the default case
## and that will be used for the default case and the body of the else:


 ##so if line is > default and line is < lastbrace
 ##and "break" not in line
 ##and fill practice string and append the pracietce sting to case_main_body_list
##use snow(x,y) and a loop to grab the lines of code inside of default
##make sure "


#print(" this prints out the contents of the important lists")

#print("==============================================")
#print("digitalcandy list ========")
#for item in digitalcandy:
#	print(item)



#print("they all need to start with 'starter' in position 0")
#print("the big 3 need to have the same number of elements for the length to be the same")

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus
# digitalcandy

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#what smartcasemanager output looks like in ufos file
#this was tyhe failed attempt at managing the indentation over to the left
#for the switch case output in python and I have a simpler solution I will end up using.




		#counter += 1














##########################
##  parktime()
###########################
def parktime():
	mytrace('parktime')
	import re
	myString = "\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
	#print(myString)
	output   = re.sub(r"[\n\t]*", "", myString)

 #seeing teh contents of stanford
def what_is_in_stanford():
    return# print("what is in stanford")
    #print("len of stanford =",len(stanford))
    #for item in stanford:
    #   print(item)
    #    print("---------------")
        
##########################
##      stage_eleven()
###########################
def stage_eleven():
	mytrace('stage_eleven()')
	#print('stage eleven')
	parktime()


#input for the switch case happens (above) the docstring JavaScript switch case interface

#made June 29th, 2021 
#this changes switch to inswitch and fallthru into infallthru
#this is required for doing nested switches 
#nested_switch[0] must be = True
#paloalto[0]




######===================================================================
###======== switch_code_gen here ============
# add error mistake if no input for exp it will do nothing
# this is good for me to think of adding
# also add break if no break in default for input from js switch
# monday dec 14th thinking
# need to add input stuff here that is in the top running betterworks

sw=''
sweet =''
switch_gen=''
#testing input here
  #this has to be above the generated code

testlist=[]
exp =''
##############################
tahoetest=[]
tahoetest.append(0)
nested_switch=[]
nested_switch.append(False) #default testing 

main_switch=[]
main_switch.append(0)
main_switch[0]=0

#added this on June 28th, 2021 7:08 pm
gti=[] #this saves the output for the main switch by default no matter what (CATCHES IT)
execute_main_switch=[]
execute_main_switch.append(0) #this just creates position 0
###############################	
funny=[]
funny.append(0)  #used for testing nested switch
	
	

# this replaces switch to inswitch and fallthru to infallthru
# after the python has been generated

#def modify_for_nested_switch_method(x):




###########################
# june 30th 2021  wednesday testing gathering the output of the code gen into stanford list
stanford=[]  #I am not emptying this so it should just fill up
################################
##      switch_code_gen()                                                                 ###
################################
#this takes in lists calculated above and generates a string of python switch case code
def switch_code_gen():
	
	#breakpoint()
	mytrace('switch_code_gen()')
	#####
	
	
	#Here I am putting the contents of penguin into cranberries
	#print("this is where I empty cranberries list and fill it with penguin")
	del cranberries[:]  #emptying cranberries here 
	
	#print("length of penguin is ",len(penguin))
	
	for item in penguin:  #this works - how wonderful
		#print(item)
		cranberries.append(item)
		
	
	
	###########  march 7, 2021  #######################################
	# I think that I just need to loop through casemainbodylist
	# and append cranberries based on teh counter and then eliminate the third tier below
	# what I am doing is adding teh cranberris(one liner break or fallthru to the case_main_body_list
	####################################################################

	
	
	case_main_body_list_with_tail=['starter']
	
	######## acounter is HERE on next line
	acounter=1
	
	for item in range(1,len(case_main_body_list)):
		felix = case_main_body_list[item]
		#print("inside of the parser ========")
		#print("====I am looking inside the case_main_body_list here===")
		#print(felix) # I would get what case I am in here 
		#print("====acounter=", acounter ,"============")
		
		# removes newlines after lines of code
		victory = felix.rstrip()
		
		victory +="\n\t\t"+ cranberries[acounter] #tacks on break/fallthru
		
		case_main_body_list_with_tail.append(victory)  #appends the melding together to 
		
		victory=None
		victory=''
		                                 #case_main_body_list_with_tail
		#print("--------------")
		
	
		acounter += 1
	
	
	#==== end loop ======
	
	anewcounter=0
	
	
	


	##############
	topvars2 = "\n\n" #"\nexp = varholder[0]\n\n"


	#this builds the case lists for each case section
	#which are used when it says: if case in caselist2:

	numb = 1
	counter = 1
	#thedefault = "['default']"
	# for i in range(len(list_fruits)):
	numberofcaselists = len(einstein)-1 #was using smartcasemanager but polluted
	###################################################
	#   this is printing out the caselists at the top
	###################################################
	
	#print("einstein=",einstein)
	
	#--- testing dec 24th for varholder[0] input word ----
	#------------------------------------
	top_input_of_exp = "exp = varholder[0]" 
	
	# "varholder.append(exp)\n" +
	#print("varholder[0] =",varholder[0])  
	#new line to see the input expression exp from clever

	
	#print(varholder) #added this to see what the input in clever is
		#-------------------------
	# this prints the case lists of the words in each case section
	


	einstein.append("default")  #adding default to the end of einstein copy list
	
	#print("einstein list",einstein)
	
	
	
	 
	for item in range(1,len(einstein)):     #first loop was smartcasemanager
		trains =  str(counter)
		merge = "caselist" + trains    #caselist1
		toosmart = eval(merge)
		caselist = merge + " = " + str(toosmart)    #this is the caselist name we eval to display it
		#print(caselist)
		testlist.append(caselist) #trying a hunch here
		######################
		#inside1 = caselist  #this is only apparently capturing the last one
		#####################

		counter += 1
		numb += 1
		
	#after loop finished we have the caselists generated captured inside of testlist
	
	##############################################
	switchy= "switch(exp)\n" +"while True:\n\n" #=====
	##############################################

	#print("")

	mycounter =1 #it was 0
	#size=  #notice -1

	front="case in caselist"

	#this makes each case section
	#=======   LOOP  =================
	# I will need to use the first part, second part, third part
	# I will use three seperate lists that work in tandem to hold the variable strings
	# which will then be accessed to concat the strings in the proper order
	#=================================
	firstpart =[]
	secondpart=[]
	thirdpart =[]
	extremelysmart=[]
	
	

	#just changed this to range(0,len(case  it was range(1,len(case 
	for item in range(1,len(case_main_body_list_with_tail)):       #second loop
		if mycounter == 1:
		#============  first section case=============

			first_if= tabs[1] + "if " + front+str(mycounter)   + ": #"
			toosmart = eval("caselist" + str(mycounter))

			newlist = [first_if, toosmart]
			##############################################################
			sofrustrated =str(newlist[0]) + " " + str(newlist[1]) #=== only catching last one==
			extremelysmart.append(sofrustrated)
			###### firstpart adding if line ###########
			firstpart.append(sofrustrated) #this feeds the if line into first part list
			### these are the case sections AFTER the FIRST CASE SECTION  	
			# this is different because it starts with an elif instead of the first if
		else:    #rest of cases after first case ======
			restofifs= tabs[1] + "elif " + front+str(mycounter)+ ": #"
			toosmart = eval("caselist" + str(mycounter))
			newlist = [restofifs, toosmart] #comments put case names to right of caselistnumber
			caselistline = str(newlist[0]) + " " + str(newlist[1]) #=====
			extremelysmart.append(caselistline)
			firstpart.append(caselistline) #this feeds elif line into first part list
		
		######################
		#=== second part of each case section
		weasel= case_main_body_list_with_tail[mycounter]   ### RIGHT HERE 
		secondpart.append(weasel) #this feeds the string body into secondpart

		######################
		#=== third part of each case section
		#this is the tail either break or fallthru(name)
		
		
		mycounter += 1     #loop counter
	
	#=== END LOOP  =============================================

	################
	theelse = tabs[1] + "else:"  #this is just once
	firstpart.append(theelse) #this feeds the else clause into first part
	#this is the last real case after the regular cases

	##################3
	 #last case body for default

	lastishcase =case_main_body_list_with_tail[-1]

	secondpart.append(lastishcase)  #this feeds the body into secondpar

	##########################
	
	#this works this creates the strings of the caselist at the top above switch correctly
###============================================
# caselists concatted to string cool
	cool=''

	#== LOOP === these are stored in list called testlist
	for item in testlist: #to see if the caselist names are in here  in this list
		cool += item + "\n"
		#print(item)
	#== end loop 
	
	cool += "\n\n"

	#== END LOOP

################################################################################################
##### march 7th, 2021  I think I just add thirdpart to end of second part (it's just one line)
################################################################################################
#===case sections three parts at once ==")
	rocks=''
 #=====================
 #== LOOP
	counter=0  #each section will have the same number of items
	for item in firstpart:
		rocks += str(firstpart[counter]) + "\n" + str(secondpart[counter]) + "\n\n"
		counter += 1
		#printing out the three part case sections")
 #=== END LOOP

	#adding strings together here
	#=========================================
	sweet = topvars2 + cool + switchy + rocks
	#=========================================
	###============== stanford. append(sweet) =============
	# putting sweet into list stanford june 30th, 2021
	# PUT GENERATED PYTHON SWITCH STRING INTO STANFORD LIST
	#=======================
	stanford.append(sweet) #Right here the output string is appended to stanford
	#=======================
	#here I am filling the list stanford with the sweet string before it's executed
	###=====================================================
	
	#here I will put exec(sweet) but testing multiple right onw
	
	
	funny[0]='' #clears it out first
	funny[0] = sweet
	#print("june 29th progress Santa Cruz Avenue coding ")
	
	#so whenever I need to grab the main 
	#list gti will hold the main switch in position 0 always and is current
	gti.append(sweet)  #default this is saved 
	#when multiple switch is carried out I need to grab the main switch string
	#to add to the multi layer cake
	
	
	#what if we just capture this string so we can use it and save it if we need
	# it and so that solves the problem actually.
	
	
	#june 28th 2021=================
	#########----------------------------------------------
	#if doing_main_switch_with_nested_switches == True:
	#   #add main switch string which will have nested_switch_methods
	#   if len(multiple_switches) == 0: #not filled yet
	#       #add main switch to list 
	#        multiple_switches.append(sweet)
	#        
	#    if len(multiple_switches >= 1 and nested_switch[0] == True:
	#     
	    
	#print("to execute it or not, yes if only one switch stanford len == 1 =")
	#print("I will need to know based on before it is even run so I need to")
	#print("count how many switches are in the switch string")
	#print("based on that number we will KNOW before start inside of endswitch() ")
	#print("if it is a solitary switch or a switch with nested switches inside of it")
	#listname switchcount
	
	## the list name will be called switch_count
	################# june 30th, 2021  10:02 am Santa Cruz Avenue Starbucks #############
	#this determines if we execute a switch string based on if there is ONLY one switch() in it)
	# because if there are more than 1 switches in it then it MUST HAVE nested switches
	'''
	print("this is INSIDE THE CODE GENERATOR in teh Silver Module")
	print("number of switches in this switch string is ",len(switch_count))
	print("we have a switch_count = ",len(switch_count))
	#switch_count is a list
	print("this is where the fuzzy logic determines if")
	print("the switch code in python is executed or NOT executed immediately")
	print("but is added to the stanford list which is automatic and then")
	print("it is put into a triple string to work in tandem with the nested switches")
	print("methods")
	print("LEN(SWITCH_COUNT=",len(switch_count)) #this will be for each switch string
	print("we have for len(switch_count",len(switch_count))
	'''
	
	'''
	if len(switch_count) == 1:
		exec(sweet)
	else:
		pass  #it is automatically already indenpendently added as a string to stanford list
	'''	
		
	#############################################
	'''if show_code[0] == True:
		pass #print(sweet)
	else:
		#print(sweet)  #otherewise don't print it
		pass     
	 '''   
	    
	    
	# here I will have the flag to show or hide the output 
	# to see what the generated code is.
	#############===================
	#################################
	#################################
	#print("show_code =",show_code[0])
	'''
	if show_code[0] == True:
		pass # print(sweet)
		#pass
	else:
		#print(sweet)  #otherewise don't print it
		pass # do nothing
	'''
	#############===================
	#################################
	#################################

	#print('===== executing generated  code=====')
	# right now the nested output switch is a nested single switch
	# for doing what I want to do I need to create the main switch also
	# as a string and not execute it immediately.
	# today is June 28th, 2021
	
	########################################
	#print("the input exp in clever was:: ",varholder[0]) #varholder[0]
	
	
	#print("")
	#this is where the generated python code (shown above) is executed
	
	#print("$$$ ===>> nested_switch[0]=",nested_switch[0])
	#print("what is in tahoe test at this point",tahoetest)
	#print("what is in tahoetest[0]",tahoetest[0])
	######################################
	
	
	
	
	
	##### this is to check to make sure that it puts sweet string into
	##### tahoetest[0] which is the first slot for now
	##### eventaully it will be several.
	#It is set before the switch string input in file test_inputs_beta
	#by default nested_switch[0] will be set at False
	## June 17th, 2021 testing Starbucks Santa Cruz Avenue
	#if nestedswitch True add sweet string to tahoetest[0]
	
	'''
	if nested_switch[0] == True:
		print("====nested_switch[0] = True ===",nested_switch[0])
		print("====don't execute generated python===")
		print("==== put it into tahoetest[0]===")
		## this says: put sweet into tahoetest[0]
		#############################################
		tahoetest.append(sweet) #this adds it in sequence
		# this captures the generated string and puts it into tahoetest list
		
	
		#this will needto append it rather then targeting tahoetest[0]
		#print insdeof this if let's see what it's lengthis
		print("length of tahoetest[0] =",len(tahoetest))
		print("let's immediatley see it's contents")
		print("===...===...===...==this prints out the generated python")
		print("tahoetest[0]=",tahoetest)
		#halloween=''
	'''
		#halloween = ''.join(tahoetest) #string from list to loop thru it
		######################################
		#decided I concat and build a string just use it - sweet
		#for line in sweet.splitlines():
			#if "break" or "fallthru" in line:
				#how_many_tabs=line.count("\t")
				#print("number of tabs =",how_many_tabs)
	'''
		#################################################
		print("==== /// \\\\ =====bottom of the output python hopefully")
	else:  # if nested_switch[0]= False
		#this means exec(sweet) which means it's not a nested switch 
		print("$$$ ==should be False=>> nested_switch[0]=",nested_switch[0])
		print("we are executing the generated code")
		
		main_switch[0]=gti[0] #this is a flow thru transfer by default
		
		#this will need to be set in bypass205
		
		if multi_switch_with_nested_switches[0] == True:
			print("don't execute it - don't run the output python")
			print("this is the main switch which we will add to the rest of the nested switches")
			print(gti[0])
			print(main_switch[0])
			#we can access gti[0] with the main switch python where we need it
		else: #means  multi_switch_with_nested_switches[0] == False
		
			#regular single switch with no nested switches within it
			exec(sweet)  #this is the building of the string of python code strings
	'''
	#####################################
	## testing ##### experimenting June 29th, 2021 Starbucks testing =======
	# remember that I wanted it to save each main switch by default
	# and only execute it if it is only switch in list so list length of 1  is True
	
	#paloalto=[]
	
	
	## what this does is use a flag to govern whether the main switch is executed
	## right off the bat. if execute_main_switch(first switch) is set to True execute
	## it means that there are no nested switches in it (except a method)
	## this is based on how many switches there are inside of the string
	
	
	
	# this runs the python switch code as ifs with the input
	# hard coded into it
	sweet=None
	sweet=''
	
	topvars2=None
	topvars2=''
	
	cool=None
	cool=''
	
	switchy=None
	switchy=''
	
	rocks=None
	rocks=''
	
	#print("")
	#print(" =====done executing output from switch ======")
	#print("")
	#print("testing this deletion of list with tail")
	case_main_body_list_with_tail=[]#''
	#print("we have",case_main_body_list_with_tail)	
		
	#print("now deleting this list case_main_body_list_with_tail")
	#case_main_body_list_with_tail=[] #hardcoded it to ensure it works
	firstpart=[]
	secondpart=[]
	thirdpart=[]
	extremelysmart=[]

#loop thru stanford list  dedc 15th wednesday morning 7"23 am
#print("==loop thru stanford list in snoopy_doghouse==")
#for item in stanford:
#    print(item)	
#this is called after switch_code_gen
#####managing_nested_switch_scenario():

## MANAGING NESTED SWITCH SCENARIO

def managing_nested_switch_scenario():
	#return
	#print("=====managing_nested_switch_scenario() called=====")
	#print("=====managing_nested_switch_scenario() called=====")
	if len(stanford) > 0: #meaning something is in Stanford
		#print('nested_switch[0] = True')
		#print("stanford list length=",len(stanford))
		pass
		#print("so do the building cake methods")
		#print("lengstanfordth of stnaford is ",len(stanford))

	else:
		pass #print('nested_switch[0] = False')
		#print("nested switch is False do nothing more")

##3===================================================        













#this executes the generated python switch code
def stage_twelve():
	#print("after here?")
	gti=[] #clears out gti list 
	mytrace('stage_twelve()')
	#changing to run second switch case january 15, 2021
	switchcasetester =''
	sw =''
	
	#print("hopefully this will empty smartcasemanager")
	#print("it current has this in it ", smartcasemanager)
	#print("it's current length =",len(smartcasemanager))
	
	
	#print("list_of_rows_of_case_names ", list_of_rows_of_case_names )
	del list_of_rows_of_case_names[:] #empties this list
	#print("list_of_rows_of_case_names ", list_of_rows_of_case_names )
		
	for x in caselist1[:]:
		caselist1.remove(x)
	
	for x in caselist2[:]:
		caselist2.remove(x)
		
	for x in caselist3[:]:
		caselist3.remove(x)
		
	for x in caselist4[:]:
		caselist4.remove(x)
		
	for x in caselist5[:]:
		caselist5.remove(x)
		
	for x in einstein[:]:
		einstein.remove(x)
	
	smartcasemanager=[]
	#print(smartcasemanager)
		
	for x in testlist[:]:
		testlist.remove(x)
		
	
	resetting_up_case_body() #clears out case_main_body_list then appends('starter') to it
	 
	
	smartcasemanager=[]
	

# right now the limit is 10 case sections I need to add to that


	
	#this seems to work whereas nothing above actually worked
	## only guaranteed way to empty lists completely 
	for item in range(0,len(palmtrees)):
		palmtrees.pop()

	for item in range(0,len(digitalcandy)):
		digitalcandy.pop()

	for item in range(0,len(einstein)):
		einstein.pop()

	for item in range(0,len(wilecoyote)):
		wilecoyote.pop()
		
	for item in range(0,len(candy)):
		candy.pop()
		
		
	for item in range(0,len(case_main_body_list)):
		case_main_body_list.pop()
		
	

	for item in range(0,len(birdsong)):
		birdsong.pop()
##3====================
	for item in range(0,len(caselist1)):
		caselist1.pop()

	for item in range(0,len(caselist2)):
		caselist2.pop()

	for item in range(0,len(caselist3)):
		caselist3.pop()

	for item in range(0,len(caselist4)):
		caselist4.pop()

	for item in range(0,len(caselist5)):
		caselist5.pop()

	for item in range(0,len(caselist6)):
		caselist6.pop()

	for item in range(0,len(caselist7)):
		caselist7.pop()

	for item in range(0,len(caselist8)):
		caselist8.pop()

	for item in range(0,len(caselist9)):
		caselist9.pop()

	for item in range(0,len(caselist10)):
		caselist10.pop()
##3==========
	for item in range(0,len(royallist)):
		royallist.pop()

	for item in range(0,len(cranberries)):
		cranberries.pop()
		
	for item in range(0,len(roadrunner)):
		roadrunner.pop()
		
	for item in range(0,len(penguin)):
		penguin.pop()
		
	for item in range(0,len(british)):
		british.pop()
		
		
	###############
	#print("gti",gti)
	
	for item in range(0,len(gti)):
		british.pop() #was british.gti()
		
	#print("mochalist",mochalist)
	for item in range(0,len(mochalist)):
		mochalist.pop()
		
	#print("drive_thru",drive_thru)
	for item in range(0,len(drive_thru)):
		drive_thru.pop()
	#funny
	#print("case1findbreak",case1findbreak)
	for item in range(0,len(case1findbreak)):
		case1findbreak.pop()
		
	#print("case1findfallthru",case1findfallthru)
	for item in range(0,len(case1findfallthru)):
		case1findfallthru.pop()
		
	#print("defaultlist",defaultlist)
	for item in range(0,len(defaultlist)):
		defaultlist.pop()
			
	#print("seal",seal)
	for item in range(0,len(seal)):
		seal.pop()
	#print("this one is the HOLY GRAIL one")
	#print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	for item in range(0,len(line_numbers_of_first_cases)):
		line_numbers_of_first_cases.pop()	

	#print('==== after clearing them we have ======')
	
	if len(palmtrees) > 0:
		palmtrees.pop()
	#print('after checking the length of the list this deletes more if greater than 0')
	#print("palmtrees=",palmtrees)
	#print("starbucklist=",starbuckslist)
	for item in digitalcandy:
		digitalcandy.pop()

	#print("digitalcandy=",digitalcandy)
	
	if len(einstein) > 0:
		einstein.pop()
		
	
	#print("=========")
	for x in smartcasemanager[:]:
		smartcasemanager.remove(x)
	#print("contents of smartcasemanager=",smartcasemanager)
	
	#print("see if this helps empty it smartcasemanager")
	for item in smartcasemanager:
		smartcasemanager.pop()
		
		
	
	del trontime[:]  #empties trontime list
	#print("now trontime =",trontime)
	



#==========================================================================================
#===== this is test what will be generated below after the python switch is generated above



####======= this is the input to the python switch
#input_list = ["fortune"]  #global var that will be fed into switch(x)








list1=[]
list1.append("five")

























def marine_one():
	mytrace('marineone()')
    #print("====== marine one called =====")
	#print(switchcasetester)
    #print("the number of tabs in this baby")
	tabnumbers =switchcasetester.count("\t")






# put this into a function
#switch_code_gen() ##=== this calls and generates the python switch case
				  ##=== this has the code generation of the python code
				  # and adds the generated python switch string to stanford list
#print(switch_python_gen)
#exec(switch_python_gen)




def pilgrim(): #testing import in another file
	return
	#print('pilgrim')


##############################
###      flush lists()
##############################
def flush_lists_previous():
	mytrace('flush_lists()')
	#print("flush_lists() called hallijua")
	gti=[]
	royallist=[]
	palmtrees =[]
	woodstock=[]
	oceanwaves=[]
	candy=[]
	digitalcandy=[]
	einstein=[]
	smartcasemanager=[]
	varholder=[]
	british=[]
	cranberries=[]
	

#case_main_body_list=[]
#this is new but I haven't tried 
# this has a sequence that must be followed for it to work 
##################################
## starter sequence mode 1
##################################
#this is for parsing and codegen of cases with words only
def starter_sequence_mode_1():
	add_to_the_main_sequence("starter_sequence_mode_1()")
	#print("it SEES in valve[0]",valve[0])
	#print("the if vavle[0] = False is the setting in here ")
	# valve[0] is False if words, it is True if numbers
	#this if means this can only run if valve[0] is False not numbers
	# I just made this change since both are now strings
	#########################################
	if valve[0] == True or valve[0] == False: #case numbers if True WAS False #means cases are words like "apple pie"
		mytrace('starter_sequence_mode_1()')
		
		convert_case_line_to_lowercase()  #right here for conformity all words lowercase
		badass()
		stage_one() 				## and if numbergs
		add_to_test_list()  #testing here
		#case_main_body_list.append("starter")
		stage_two()
		stage_three()
		stage_four()
		stage_five()
		stage_six()
		stage_seven()
		stage_eight()
		stage_nine()
		stage_ten()
		stage_eleven()
		#print('stopping just before switch_code_gen()')
		#quit() #see if this works
		switch_code_gen() #  <<<==============it's called right here the code generator
		#this creates the generated python string and puts it into (adds it to) the stanford list
		
		######### testing this to do next stages 
		######### if nested switch with several strings
		######### so that I don't just tack it onto switch code gen
		######### and this way it's done after stanford is filled with output 
		######### python stings
		managing_nested_switch_scenario()
		
		stage_twelve()  # <== this resets the lists for next use of switch
		########=== added june 16th, 2021 #####
		#uppercase reset to default 
		#set these after exec
		#this resets defaults to turn off uppercase yes 
		
		#uppercase_test[0] = False:
		#baseline[0]="nada"
		#############################
		clearit()
		
		global woodstock
		#print("what we have in woodstock=",woodstock)
		#print("now we clear out woodstock list")
		woodstock=[]
		#print("woodstock=",woodstock)
		global candy
		#print('what we have in candy=',candy)
		#print("now we delete its contents")
		
		candy=[]
		#print("candy=",candy)
		#flush_lists()
		global sw 
		sw = ''
		global switchcasetester
		switchcasetester =''
		smartcasemanager=[]
		#print("smartcasemanager=",smartcasemanager)
		british=[]
		#print("british=",british)
		penguin=[]
		
		#print("penguin=",penguin)
		clear_out_all_case_lists() #doing 16 for now
		#show_tron_trace_path()
		
		
	else:
		pass
		
	#print("needle in haystack")
	showit() #it must be in here......
	#print("what about here")
	empty_test() #test of global list

	#flush_lists() #this is new january 16th, saturday debugging trying second switch case
	
daisy=''
m1=[]
m1.append(0)

sample_fish='''
 switch(x)    
    while True:                 
        if   case  == "one":
            print("this is the first case in the main ")
          
            ######################
            print("out of from  below")
            print("tahoe[0]=",tahoe[0]) #result of  running
          
            fallthru('word')   
                     
        elif case == "two":
            print("this is the first case in the main ")
            prelow")
            print("tahoe[0]=",tahoe[0]) #result of  running
            fallthru('word') 
            
        elif case == "three":
            print("this is the first case in the ")
            print("out of from  below")
'''
### just had idea if a nested method switch has yet another nested switch
#in it it needs to be changed to a method so it wouldn't happen.

listforfun=[]
listforfun.append(0)
inputstringswitches=[]
inputstringswitches.append(0)
inputstringswitches.append(0)

#after doing the silver module call this
#modify nested switch 
def modify_nested_switch():
    #print("called modify switch for nested method switch")
    galaxy=''
    galaxy = sample_fish  #this is modifying string above for being a nested switch
    #listforfun[0]= galaxy
    inputstringswitches[1] = galaxy.replace("switch","inswitch")
    galaxy = galaxy.replace("fallthru","infallthru")
    inputstringswitches[1] = galaxy
    #print("how does this look.... june 29th.")
    #print(inputstringswitches[1])
    



####### TESTING 
#print("testing doing a simple test of switch and fallthru changing it")
#modify_nested_switch(sample1)
#print(m1[0])


import re
def hasNumbers(inputString):
		return bool(re.search(r'\d',inputString))



	############################
	
			

##############  added April 2nd, 2021  ###############################################
# this is a pre scan of the switch case input string to determine if
# the cases are numbers like case 1 thru 5: or case 10 OR words like case "apple":
coffee=[]  #holds line number of first case in switch case
valve=[]
valve.append("nada")# 0
valve.append("sway")# 1 #so we have valve['nada','sway']
#these are just fillers they mean absolutely nothing

# this gets the line number of the first case in the switch case string
#####################################################
##  grab_first_case_of_switch_string(y)
##################################################### 
def grab_first_case_of_switch_string(y): 
	mytrace("grab_first_case_of_switch_string()") 
	#global switchcasetester
	mycounter = 0
	#this takes in sw to test for finding out if numbers like case 2: or words case "apple"
	for line in y.splitlines():
		if "case" in line:
			coffee.append(mycounter) 
			break  #here after getting the first instance of a case we leave the loop
		else:
			mycounter += 1
			continue

#####################################################
##  remove_tabs_from_string(y)
##################################################### 
def remove_tabs_from_string(y):
	mytrace("remove_tabs_from_string()") 
	y=y.replace("\t","")
	return y

#####################################################
##  grab_first_case_line_in_switch_case_string(y)
##################################################### 
def grab_first_case_line_in_switch_case_string(y):
	#global sw
	mytrace("grab_first_case_line_in_switch_case_string()") 
	#print(coffee[0])  #testing what's in this
	getline= eval("y.splitlines()[" + str(coffee[0]) + "]")
	#print(getline)
	return getline


##################################
##  check_if_number_in_string(x)
################################## 
def check_if_number_in_string(x):
	add_to_the_main_sequence("check_if_number_in_string()")
	mytrace("check_if_number_in_string()") 
	theresult = any(char.isdigit() for char in x)  #this line from stackoverflow
	return theresult

###########################
##     parser_mode_1()
###########################
## testing April 3rd 2021 seeing if this works or not. 
def parser_mode_1(a):
	#print("a= ",a)
	mytrace('parser_mode_1 in switch_cat()') #was greatpumpkin
	#print('=======INSIDE OF PARSER in switch_cat for strings  =========')
	mountain2(a)    # this changes sw to switchcasetester #I can't beleive that this reverse number was being called 
	starter_sequence_mode_1()
# flow_fork_input()  #this fills valve[0] with True or False
# if valve[0] is True  it means numbers = True  (thus numbers      )
# if valve[0] is False it means numbers = False (thus words strings)
## the new code will go in here Friday morning.. April 2, 2021
#this fills valve[0] with True or False for numbers in cases
#################################
##     flow_valve_input(y)
##################################
def flow_valve_input1(y):  #this determines if switch case string is numbers or words
    add_to_the_main_sequence("flow_valve_input1(y)")
    mytrace("flow_valve_input()")                            #get first case in switch case string
    ######## this gets the necessary data to test if case is a number
    getline  = grab_first_case_of_switch_string(y)           #get first case line
    toocool  = grab_first_case_line_in_switch_case_string(y) #remove tabs from the case line
    toocool  = remove_tabs_from_string(toocool)              #test if number in first case line yes = True no = False
    ######## here the data is now analyzed to see if a number  and returns True if number False if not number
    valve[0] = check_if_number_in_string(toocool)            #looks in case line
    valve[1] = toocool                                       #put case name/number into valve[1]
    #print("output from FLOW VALVE=",valve[0],"and",valve[1])
    
    #print("valve[0]=",valve[0]," and valve[1]=",valve[1])
   # print("========")
################################################



def blue2():
    mytrace("blue2()")
    #print("blue2()")
    #print("do NUMBERs parser")
    
def pink1():
    mytrace("pink1()")
    #print("pink1()")
    #print("do words parser")
    
#this fills valve[0] with True or False
#based on analyzing the switch case string first case if number or not
############################
#this controls calling numbers parser if True
#this controls calling words   parser if False
#this is in great_pumpkincat2.py


#this part hasn't been tested yet.
# I have to make sure that the normal endswitch() continues to work 
switch_count=[]
switch_count.append(0) #to create position 0
number_of_switches_in_string='' #initializing it July 1st 2021

########################
##     endswitch(y)      this calls flow_valve_input which checks if cases are numbers or words
########################  and if numbers = True then call parser_mode_2(y); If numbers = False parser_mode_1(y)
def endswitch(y): #pulls in sw 
	print("------ endswitch(y)----------")
	add_to_the_main_sequence('endswitch(y)')
	#print("====TESTing in beginning of endswitch() =====>>>")
	#print("====TESTing in beginning of endswitch() =====>>>")
	#print("====TESTing in beginning of endswitch() =====>>>")
	switchcasetester='';switchcasetester=None;
	del switchcasetester;switchcasetester='';
	mytrace("endswitch() in switch_cat called")
	show_input_switch_string() #flag for testing this shows the input string
	#hide_input_switch_string()# flag for showing input string
	###################################
	###################################
	#june 30, 2021 10:10am santa cruz avenue Menlo Park
	#count switch inside of input string for switchcase
	#print("====This is inside of silver switch module ")
	#print("====This is inside of endswitch function before doing anything to the string")
	#print("====meaning BEFORE the switch string is parsed")
	# I might hav eto redo this one as line.startswith("switch")
	########### I might have to do it different hen count and loop thru it
	########### and get teh accurate count that way 
	# so I wouuld loop thru string
	#and check if line.startswith('switch') to know for sure.
	#I can verify by also counting line.startswith("endswitch")
	'''
	###################################################
	#print("what is in switch_count list starting", switch_count) #should be nothing
	#number_of_switches_in_string =y.count("switch")
	#print("extra counts this many switch(s) in the string",number_of_switches_in_string)
	#
	#print("try counting endswitch for nested and then add 1 for first switch")
	#this idea occurred to me if the switch search isn't accurate
	'''
	############
	############ testing experimental (right now it doesn't matter
	############ july 1st, 2021  commented this out today don't want to think about this part 
	
	realnumber = y.count("endswitch") #it's possible there are no nested switches
	realnumber = realnumber + 1 #this account for the first switch which isn't counted
	if realnumber == None or realnumber == 0:
		realnumber = 1 #this is in case there are no endswitches meaning no nested switches
	#end if
	print("see if this number is different")
	print("counting the endswitch + 1 we get ",realnumber)
	if realnumber >= 2:
	    print("voila we have nested switches ")
	else:
	    print("nope, just one single switch ")
	    
	    
	#put jumanji here but it does two different things
	
	#this just counts the number of "switch" in the string but not their locations
	#with my loop concept idea I would get the line number of each switch
	#but the moret that I thought about it the more it occurred to me that
	#the only way to know for sure is to count "endswitch"
	##===================================
	#right now for now this doesn't matter nor concern me one bit
	######### what this section does is determine how many switches are in a string
	#########################
	#print("extra count of switches in this input switch is",number_of_switches_in_string)
	#switch_count[0]=number_of_switches_in_string
	#print("the number of switch_count in THIS input switch string =",switch_count)
	#if switch_count[0] == 1:
	#	print("it is ONE")
	#else:
	#	print("it is ",switch_count)
	#print("===========#####################=====================")
	###################################
	
	###===================
	check_if_uppercase_constant_cases(y)  #if UPPCASE this senses it and converts to string
	
	if baseline[0] != "nada": #means it converted to uppercase
		y = baseline[0]
	#else:   #added this else  and pass on June 16th
	#	 pass #this puts the input string from baseline[0] into y
	#####################
	#this checks if first case is a number like case 2: returning True if numbers 
	flow_valve_input1(y)   #puts True or False into valve[0] added April 2nd, 2021
	#####################
	print("if number in first case",valve[0])
	# the key is macro expansion is only called if numbers are True
	if valve[0] == True:    #meaning numbers like case 12:
		macro_expansion(y); #checks if macros and expands them and converts numbs to strings
		y=None; del y; y = cray[0];
	#end if
	#####################################
	flush_lists() 
	parser_mode_1(y) 
	################## normal endswitch ends here  don't mess it up.
	
	
	
	
	####################################################################
#parser guts is the same sequence of code in the endswitch above
# I am just trying to reduce code  that's all.
####============================
####      parser_guts()           #dreamed up on July 10th, 2021 to see if it would work
####============================
def parser_guts(y):# this is used for the nested switches
	#print("--------------parser_guts called -------------------")
	#breakpoint()
	check_if_uppercase_constant_cases(y)  #if UPPCASE this senses it and converts to string
	
	if baseline[0] != "nada": #means it converted to uppercase
		y = baseline[0]
			#else:   #added this else  and pass on June 16th
			#	 pass #this puts the input string from baseline[0] into y
		#####################
		#this checks if first case is a number like case 2: returning True if numbers 
	flow_valve_input1(y)   #puts True or False into valve[0] added April 2nd, 2021
	#####################
	#print("if number in first case",valve[0])
		# the key is macro expansion is only called if numbers are True
	if valve[0] == True:    #meaning numbers like case 12:
		macro_expansion(y); #checks if macros and expands them and converts numbs to strings
		y=None; del y; y = cray[0];
		#end if
		#####################################
	flush_lists() 
	parser_mode_1(y) 	
		
		
#end of parser_guts()	
	
	######## this is the bottom of the normal scenario of a switch string with only one switch case in it
	
	####### this is where I will be testing using 2 and 3 switches in one string
	#######  july 1st, 2021  testing
	#####===============================================================================
	#####      BYPASS205  HANDLES AND MANAGES DOING NESTED SWITCHES , SO SWITCHES WITH 1 OR MORE NESTED SWITCHES
	####==================================================================================================
	##### this is bypass205 and it will manage and handle doing a multiline string
	##### which does multiple calls of the parser and code gen and fills a list called stanford
	####  with the generated python string 
	####  and then adds methods to the nested switches and then 
	#### builds a multi layer cake by concattting (in file fourth of july ) and executes it).

### this is testing and not in the real code ######




###==== dec 21st testing =========
#this is prefilling quail list for bypass205() 
#with test input javascript switch strings in chain_output_list
#THIS IS WHERE I WOULD HAVE THE CHAIN METHODS THAT PRODUCES THE SWITCH STRINGS
# PREPPED FOR BYPASS205 FINALLY .
#HERE THEY ARE HARD CODED AND NOT GENERATED (YET) STILL TESTING IT.

#here the gold strings are put into chain_output_list

chain_output_list=[]  #was gold1 thru 7


##===========================================
## testing_using_chain_finished_output():
##===========================================
# this is filling the quail list with test data switch strings 
def testing_using_chain_finished_output():
    print('for testing putting chain_output_list into quail')
    del quail[:]
    #right here this is filling the quail list from the chain_output_list
    for item in chain_output_list:
        quail.append(item)
    ##====================================
    print("output of quail which should have been generated using starship module")
    #print("new years eve test ")
    #for item in quail:
    #    print(item)
           
#this fills the quail list from chain_output_list
#testing_using_chain_finished_output()
# I am filling the quail list here with the chain_output_list of teh gold1 thru gold7 strings


zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'


#print("from the web trying this out")

#quail=[]
# I am adding the quail list to practice filling it

#endswitch_location=[]
#switch_location=[]

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter

	empty_switch_and_endswitch_list_locations()

	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		
		if "switch" in line and "end" not in line:
			#print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		elif "endswitch" in line:
			#print("endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1
			
			
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch

	answer = len(switch_location)
	answer = answer -1

	if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
		pass #print("endswitch locations =",endswitch_location)
		#print("out of curiosity print the number of endswitches", len(endswitch_location))
	else:
		pass
		
	
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	
	
	
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location
smart_rat=[]
string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
#print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
#print(string)

#print("end of test from the web")
#print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 


#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 



sweetlist=[]
holdinglist=[]; holdinglist.append(0) #to create slot 0
boomerang=[];   boomerang.append(0)
#def get_switch_parents()

# I need to do a second pass and modify this just modified 
# texas string to show it's inner switch line numbers

##============================================
##  modify_string_before_splitting_it_up():
##============================================
def modify_string_before_splitting_it_up(inputstring):
    print("texas string first")
    #for line in inputstring.splitlines():
    #    print(line)
    #print("=========================") 
    counter =0    
    print("modify_string_before_splitting_it_up():")
    craftline =''
    for line in inputstring.splitlines():
        if holdinglist[0] == 0: #this compendates for the first one
            holdinglist[0] = '1' #ASSIGN JUST ONE EQUAL
        else:
            boomerang[0]= holdinglist[0]
    
        if "switch" in line and "end" not in line: #this eliminates endswitch confusion
            tabcount=line.count("\t")#                                   line number          tab count 
            if tabcount == 3: #this compensates for 2nd nested switch at 3 tabs
                boomerang[0]='1' #representing parent switch 
            else:
                pass
            if tabcount == 3:
                boomerang[0]= '1'; #assignment only use one = 
            craftline += line.replace("switch(exp){","switch(exp){ # "+str(counter)+":" + str(tabcount) + " "+"parent switch=" + str(boomerang[0]) + "\n")
            holdinglist[0]=  str(counter)
            #I need to add this to the special dictionary now
            #put it into a list first
            sweetlist.append([counter,tabcount,boomerang[0]])
            counter += 1
        else:
            craftline += line + "\n"
            counter += 1
    #print("this is the output test revisiting this on November 2nd, Tuesday")
    #print(craftline)    
    #print('end of test......... monday morning blues ')  

#modify_string_before_splitting_it_up()

listinput=[]
#exit()




#
# we have 1,11 and 1,49  so two inner switches
#
# so it would be in main switch 1 and then 11,49
#

#print("I'm making this so only one tab difference")     
#print("sweetlist=",sweetlist)    




#print("and then the switches with no nests") 
#print("if number in second slot and not ever in first slot it's a single")

#need to figure out how to add these automatically
  

switchnumbers=[]
tabslist=[]
switchlinenumbers=[]
peach_data=[]




isnt_this_pretty='nada'
pattern_input=[]
pattern_input.append('0')
pattern_input.append('0') #[1] patterninput[1]
pattern_input.append('0') #[2] patterninput[2]

##============================
##  input_tab_combo(x,y):
##=============================
def input_tab_combo(x,y):
    #print("====== input_tab_combo(===", x, y)
    pattern_input[1]=x #5
    pattern_input[2]=y #7

porsche_carerra=[]
capture_switch_lines_nested=[]


plums=[]
plums_data=[]
endswitchlinenumbers=[]
endtabslist=[]


             



#this builds the pairs of switch endswitches by tabs since they ahve to be lined up
#from the switch down to the endswitch in the same tab depth 


 ##=====================this might be teh top of the methods ==========================================================
 ##===============================================================================
 
 
        
## loops thru tabsubs and appends item to tabcount
#=========================
#  little_method(tabcount)            
#=========================
def little_method(tabcount): #threetabs example is the param here in tabcount
    for item in tabsubs:
        tabcount.append(item)
    del tabsubs[:]
        
        
        
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

  
##=================================
##  list_tabs_lists_by_depth():
##================================== 
def list_tabs_lists_by_depth():
    pass



#this takes in the tab depth with x and goes thru the string
#and fills the appropiate tab list if 3 then threetabs, if 5 then fivetabs
##====================================================
## internal_machinery()   designed wed sep 29th, 2021
##====================================================
## key engine inside of function this_makes_switch_and_endswitch_pairs_by_tab_levels()
def internal_machinery(x,inputstring): #this doesn't change anything in the string whatsoever
    #print("===internal_machinery() called=== METHOD 4.5  inside of METHOD 4  ===")
    counter=0
    for line in inputstring.splitlines():
        tab_length = line.count("\t")
        if tab_length != x or "switch" not in line:
            counter += 1; continue
        if tab_length == x: 
            if "switch" in line and "end" not in line:
                tabsubs.append(counter);counter += 1;continue
            if "endswitch" in line:
                tabsubs.append(counter);counter += 1;continue 
    #print("tabsubs = ",tabsubs) #this can be increased to manage n number of tabs depth
    if   x == 3: little_method(threetabs)
    elif x == 5: little_method(fivetabs)
    elif x == 7: little_method(seventabs)
    elif x == 9: little_method(ninetabs)
    elif x == 11:little_method(eleventabs)
    elif x == 13:little_method(thirteentabs)
    else:
        pass
          







##==================================================
## make_switch_and_endswitch_pairs_by_tab_levels() 
##=================================================== 
#def make_switch_and_endswitch_pairs_by_tab_levels(): 
#    #print(":=============== METHOD 4 ======") 
#   for item in super_listinput: # listinput is dynamically made above
#        x = item;
#        internal_machinery(x,inputstring)
     

###=============================== 
 
        #del tabsubs[:] #should clear it
###=================
rattabs=[]



##==============================
##  experimental_machinery
##===============================
def experimental_machinery(x,inputstring): 
    counter =0
    #newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    internal_machinery(x,inputstring)
 
    ###============

combined_tabs=[]
christmastree=[]




##============================================
## combine the lists together  #waterfall ifs
##=============================================
#not called 
def combine_the_lists_together(x):
    print("--- combine the lists together --31623-") 
    get_length_of_threetabs    = len(threetabs)
    get_length_of_fivetabs     = len(fivetabs)
    get_length_of_seventabs    = len(seventabs)
    get_length_of_ninetabs     = len(ninetabs)
    get_length_of_eleventabs   = len(eleventabs)
    get_length_of_thirteentabs = len(thirteentabs)
    #test if threetabs list is empty
    if get_length_of_threetabs > 0: #then proceed there is at least one
        #this is a waterfall extending numbers to add to christmastree list
        if x >=  3:christmastree.extend(threetabs);
        if x >=  5:christmastree.extend(fivetabs);  
        if x >=  7:christmastree.extend(seventabs);
        if x >=  9:christmastree.extend(ninetabs); 
        if x >= 11:christmastree.extend(eleventabs);
        if x >= 13:christmastree.extend(thirteentabs);
    
    else:
        pass
        #print('all of the tab lists are empty')
        #print("don't bother trying to extend empty tab lists")
      
      
      
       

##========================================================
##  build_tab_list_added_together(largest_tab_number):   Thursday, Nov 4th, 2021 
#   this does this combined_tabs = threetabs + fivetabs + seventabs etc
##========================================================
def build_tab_list_added_together(largest_tab_number):
    del christmastree[:] #clears out the combined_tabs list to erase it
    combine_the_lists_together(largest_tab_number) #<<==input is the largest tab number
    
    
    
    
    
    
 
#==========================================================
# combine_tabs_by_length_into_christmastree_list(input)
#==========================================================
def combine_tabs_by_length_into_christmastree_list():
    #print("======METHOD 6 ===  combine tabs by length into christmastree_list====>>>>")
    themax = holding_themax[0] #this gets the highest tab level (deeply nested)
    build_tab_list_added_together(holding_themax[0])   #METHOD  7
    
 
 
 
 
   
#================================= 
#  build_pairs_with_jazz()
#=================================  
#this goes thru christmas list of pairs and and makes snowtime list of pairs jazz added to snowtime 
def build_pairs_with_jazz(): 
    #print("=== METHOD 7== build pairs with jazz =======>>>>")
    counter =0
    empty_this_list(snowtime)
    for x in christmastree: #loops thru at 2 at a time
        jazz = [christmastree[counter],christmastree[counter+1]]
        snowtime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2 
        #prevents overflow error for out of range error
        if counter >= len(christmastree):
            break
            
            
         
         
         
         
         
         
#=======================================
#  build_tab_depth(inputstring)
#========================================            
def build_tab_depth(inputstring):
    #print("build tab depth ==== METHOD 1 ==  build_tab_depth(=======>>")
    empty_this_list(add_tab_depth)
    for line in inputstring.splitlines():
        if "switch" in line and "end" not in line: #this is looking for a switch in a line
            get_tab_depth=line.count("\t")         #this is a var that gets the count of tabs
            add_tab_depth.append(get_tab_depth)    #this is for filling the list of each tab depth
        else:
            continue
    #print("add_tab_depth=",add_tab_depth)
    #print("max tab depth=",add_tab_depth[0])
            
      
      
            
      
      
      
      
            
def loop_thru_pairs_in_snowtime():
    print(" ==== #method 8 ===  loop_thru_pairs_in_snowtime()=============")
    for item in snowtime:  
        print(item);
        rad1=item[0];rad2=item[1];
        print(rad1,"and ",rad2)
    print("snowtime list=",snowtime)






##=======================================
## get_max_tab_number_in_list()
##=======================================       
def get_max_tab_number_in_list():  #this fills the max holding_themax[0]
     print("======  #METHOD 2 ========")
     themax = max(add_tab_depth);  #a list of the tabs before switches
     holding_themax[0]=themax;
     print("themax=",themax)


##===========================================================================================
##===========================================================================================
##===============================================================
##   ==this_makes_switch_and_endswitch_pairs_by_tab_levels() ====
##===============================================================  
'''
def this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring):
    print("===THIS MAKES SWITCH AND ENDSWITCH PAIRS BY TAB LEVELS========")
    build_tab_depth(inputstring)                           #METHOD 1
    get_max_tab_number_in_list() #fills holding_themax[0]  #METHOD 2
    build_list_input_list()                                #METHOD 3
    make_switch_and_endswitch_pairs_by_tab_levels()        #METHOD 4
    list_tabs_lists_by_depth()                             #METHOD 5
    combine_tabs_by_length_into_christmastree_list()       #METHOD 6 
    build_pairs_with_jazz()  #combines into sublist        #METHOD 7 
    loop_thru_pairs_in_snowtime()                          #METHOD 8
    print("==bottom of this makes switch and endswitch pairs by tab levels()")
    #print("snowtime=",snowtime)
    print("============================")#this will go into gold_list
        
 '''  
 
     #this gets one pair in showtime designated by x 
def get_pair_in_snowtime(x):
     #print(" get pair in snowtime testing",x)
     #what if I add 0,0 to first position brilliant
     if len(snowtime) == 0:
        pass #print("length of snowtime is zero")
     #print(snowtime) #would be second position
     cool = snowtime[x]
     print("list at position ",x," is",cool)
 

 


######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)


##==============================================================    
#we know that there will be sets of 2 numbers closest to each other
#go thru list and grab two at a time seems simple enough
#based on highest tab number which we would know like 7
#threetabs= [11, 47, 49, 73]
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]

peartree=[]
startime=[]

##======================================
## fill_main_pear_list(listname):  #this build the combined list correctly 
#the lists threetabs,fivetabs,seventabs,ninetabs need to already be filled
#this is just combining them together adding them together
##=====================================

threetabs=[]
endtabslist=[]
endswitchlinenumbers=[]


##======================
##  sound_of_music
##======================
fivetabs=[]



#=============bottom half which is seperates_input_strings============
#import official_switch_case_silver
#from official_switch_case_silver  import *  

def stop():
    print('stop called which calls exit')
    exit()
    
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){


# output is to inputstring[0]
#############################################################
passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)

##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
#not called
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	print("--31858---add_comment_and_line_number_to_all_switches()--------")
	awesome='';counter =0;newstring='';
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
			### new surgery ===dec 20th monday bug fix out of the blue =======
				#if counter == 1: #modified for bu on dec 20th monday each number was off by 1 except first
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
				
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	return newstring #this way I can capture the changed string
##===================================================================================







import re
def first_letter(s):
    m = re.search(r'[a-z]', s, re.I)
    if m is not None:
        return m.start()
    return -1

s = "##catgiraffeapluscompscI"
i = first_letter(s)
print(i)


testthis='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			print('first prize')
	  		print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
'''

coolinthegang='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			    print('first prize')
	  		   print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	    		    print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''


    
        
#print('after ======= attempting lstrip() which I have no confidence in')



newlist=[]
newtime=''
thelist=[]
finaloutput=[]
finaloutput.append(0) #creates slot
'''
this cleans up input javascript code that is supposed to be 
governed by tabs in front ala Python and if a space is discovered
it is neutralized and deleted. 
This first counts the tabs in each line in the string.
second it cuts out all spaces and tabs from left of each line
then it concats a new string with the correct tab count in
front of each line so it's CLEANED UP essentially. 

'''
#bad input
examplestring='''
	      switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
	  		    print('first prize')
	  		    print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	     		      print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''
#cleaned up output becomes
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
		case 4 to 7:
			print('first prize')
			print('you block head Charlie Brown')
		case 9 thru 11:
'''


finalstage=[]
finalstage.append(0)
##========================================
##  cut_out_left_side(inputstring):
##========================================
def cut_out_left_side(inputstring):
    print("cut out left side")
    fancy=''
    for line in inputstring.splitlines():
        #print(line)
        newline = line.lstrip() #I am using lstrip() look at that!!
        fancy += newline + "\n"
    finalstage[0] = fancy
    ## concatting tabs in front + line to redone


##========================================
##  concat_tabs_in_front(fancy):
##========================================
def concat_tabs_in_front(fancy):
    #print("conctat_tabs_in_front()")
    redone='';counter=0
    for line in fancy.splitlines():
        redone += newlist[counter] + line + "\n"
        counter += 1
        if counter >= len(newlist):#prevents out of range error
           break
    finaloutput[0]= redone
    #print("right here the OUTPUT =",finaloutput[0])


#==================================
#   append_result()  pure genius
#   #appends tabs to newlist
#=================================  
def append_result(x):
    tab = "\t"
    result = tab * x;
    newlist.append(result)  
    #this replaces: #if item == 1:result = tab * 1;newlist.append(result)


#puts tab count in each line into thelist
##===============================================================
## count_tabs_in_each_line_and_put_into_thelist(inputstring):
##===============================================================
def count_tabs_in_each_line_and_put_into_thelist(inputstring): 
    del thelist[:];
    del finaloutput[:];
    finaloutput.append(0) #creats one slot space
    for line in inputstring.splitlines():
        answer =line.count("\t") 
        thelist.append(answer)
 
             
#made into a function on saturday, dec 4th morgan hill starbucks 
# refactored on dec 19th for efficiency and management
##=======================================================
##  take_out_junk_spaces_from_left_side(inputstring):
##=======================================================
def take_out_junk_spaces_from_left_side(inputstring):
    #print("take out junk spaces from left side")
    #print(inputstring)
    count_tabs_in_each_line_and_put_into_thelist(inputstring) # METHOD
    for item in thelist:  #fill a list with tabs corresponding to numberof tabs numbers
        x = item;
        append_result(x)                                      # METHOD
        
    cut_out_left_side(inputstring)#puts fancy in finalstage[0]# METHOD
    fancy =finalstage[0]
    concat_tabs_in_front(fancy)                               # METHOD 
    #result in finaloutput[0] for one converted string cleaned up
#####################################################################






def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations    #this fills the together_pair list
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]






#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#print(genius[0])    	


#print("what we are starting with the switch with a nested switch")
#print(find_nested_switch_game)
#print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
#print("this gets the line number of the line that the case starts")
#print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
   # print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            #print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            #print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
   # print("case line numbers",pacman)    
    #print(pacman[2])  
    #print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========




#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            #print(item)
            #print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    #print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    #print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
           #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            #print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    #print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    #print("x=",start_and_finish[1])
    #print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function



columbia_river=[]
gold_list=[]
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
#not called 
def copy_a_nested_switch(r):  #copy just one nested string 
    
    print("======copy_a_nested_switch==32255===")
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    answer=start_and_finish[1]
    start_and_finish[1] = start_and_finish[1] - 1 #added this on dec 20th to show switch word
    #print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
#print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
################################################################################
#print("=======begin Sunday Morning Brew Testing==========================")

def show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water):
    pass  #not printing it out at this time on purpose
    #for line in water.splitlines():
    #    print(line)

def show_the_snowtime_list_of_pairs():
    print("snowtime=",snowtime)   
    #pass
    
def empty_columbia_river_list():
    del columbia_river[:] 
    
def add_main_switch_to_columbia_river(water):
    columbia_river.append(water)  

    
holding_string=[]
holding_string.append(0) 

##============================================================================
##  loop_thru_snowtime_list_copy_switch_bodies_and_add_to_columbia_river():
##============================================================================   
def loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river():
    for item in snowtime:#was gold_list #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];
        num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) # get input string from goldlist
        copy_a_nested_switch(holding_string[0]) # copy string based on switch,endswitch pair 
                                                # puts resulting string into makeitwork[0] and output
        output = makeitwork[0]                  # put nested string into columbia_river list
        columbia_river.append(output)
    #print("length of columbia river =",len(columbia_river))
    #counter =1  #adding here the initial string which will be used to make the main switch


    
##=================================  
## loop_thru_columbia_river() 
##================================= 
def loop_thru_columbia_river():
    #print("now loop thru ====== COLUMBIA RIVER === to see the switch bodies seperated")
    counter =1
    for item in columbia_river:   #it is added just before looping thru i
        print("counter=",counter)
        print(item);
        print("===========");
        counter += 1    
    
          


##==============================================

   #This takes in what has already split the mega nested switch into 
   #switch bodies
gemini=[]
taurus=[]
##======================================================##=========================================
##  ==split_up_big_string_into_nested_switches(myinputstring)==
##  this requires to have the pairs list which is utilizes to create the strings paramaters
##======================================================##=========================================
#not called
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print("--jan 23 -here ---32346 line--damm------split_up_big_string_into_nested_switches()-------------------")
    water =add_comment_and_line_number_to_all_switches(myinputstring)             #METHOD 1
    show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water) #METHOD 2
    empty_columbia_river_list()                                                   #METHOD 3
    show_the_snowtime_list_of_pairs()                                             #METHOD 4
    add_main_switch_to_columbia_river(water)                                      #METHOD 5
    holding_string[0] = water
    loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river()    #METHOD 6
    loop_thru_columbia_river() #prints out seperated switch bodies top down       #METHOD 7               
    water=''
    #maybe clear out holding_string[0] jhjere jan23rd
    ##==============
    print("this is the actual result of creating the strings but not thru blender chain methods yet")
    print("running real data here to create switch strings to bypass205() next")
    print("fill gemini list from snowtime list for testing")
    for item in snowtime:
        gemini.append(item)
    print("fill taurus list from columbia_river list for testing")
    print("length of columbia_river=",len(columbia_river))
    
    for item in columbia_river:
        taurus.append(item)
    print("the switch strings cut up are now printed out top down")
    print("these are the switch pairs in gemini here")
    #for item in gemini:
    #    print(item)
    #    print("========")
    print("these are the switch strings after going thru the chain methods blender")
    #for item in taurus:
    #    print(item)
    #    print("========")
##================================================================        
##================================================================














##=================================================================
## manage_creating_pairs_and_separating_input_switch_strings()
##   --------------this calls 2 methods  ---------------
## * this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
## * split_up_big_string_into_nested_switches(inputstring)
##=================================================================
###======= create switch pairs and separate switch strings ===========####

## december 22nd, 2021  wednesday 7:51 am ===
def manage_creating_pairs_and_separating_input_switch_strings(inputstring):
    print(" ---line 32432----------manage_creating_pairs_and_separating_input_switch_strings()---------- ")
    #empty both critical lists here 
    del columbia_river[:]
    del snowtime[:]
    #print("called manage_creating_pairs_and_separating_input_switch_strings()")
    this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
    split_up_big_string_into_nested_switches(inputstring)
    #I can use this output in a different list so as to not interfere with running code

#===============================================    







#print("====this shows what's in quail at line 40,578===")
#get quial length should be 0, 1, 2 so 3 length


#future = len(quail)


## July 1st, 2021 testing bypass205 to see if it does three strings in a series
## thru the parser and codegenerator and puts it into stanford
	#THIS CALLS TEH CODE IN endswitch(y)
	#I need to empty stanford list right off the bat 
	#this will do thing fake switch nested just to get the mechanics understood July 1st 2021
	## right here we do 3 strings in succession
	#at the top here will be the quail list with three strings
	#empty stanford here to start from nothing
	###### empty stanford list here 
	
#this is ONLY called when there are more than ONE switch
#so an input switch string with nested switches(at least one) inside of it.
#and then the SNIFFER determines if regular switch or multi-combo switch with nesting

##=============================================
### REVERSE STANFORD LIST
##
##=============================================
def reverse_stanford_list(): #this just says what it does simply
	print("-----------reverse_stanford_list() ----------")   
	stanford.reverse()#print stanford would have to have a length of 2 actually for a nested switch in a switch

   
# JULY 10TH, 2021

### important - need to add methods inswitch and infallthu at top
toocool=[]
toocool.append(0)

output=[]
output.append(0)
#this loop sthru stanford list and concats each switch string together bottom up
##====================================================
##   BUILD STACKED CAKE STRING COMBINING STANFORD LIST
##====================================================
def build_stacked_cake_string_combining_stanford_list(): 
    #print("---------build stacked cake string combinging  stanford list----------")
    count =0
    #print("length of stanford insid eof build_stacked_cake =",len(stanford))
    ##  THIS LOOPS THRU STANFORD LIST 
    #concat_triple_string_before_and_after_switches_in_stanford_list
    #this LOOPS thru stanford list and concats together each switch string
    genius="'''" + "\n"#\n"    #and puts it into list toocool[0]
    for item in stanford:
        genius += item
    genius += "'''"
    toocool[0] = genius
    #for line in toocool[0].splitlines():
    #    print(line)
    #final_output[0]
    output[0]=toocool[0]    
    del stanford[:] #empty stanford here  just in case
    #print("now  after build stacked cake string combinging stanford")
    #print("stanford list should be empty",len(stanford))
    
    
###================================================================



    
def second_attempt():
    print("--------- second_attempt()-------------")
    volleyball =''
    #print("===calling second attempt() ===")
    volleyball += "'''" #starter
    for item in stanford:
         #just added this dec 7 to see if needed 
        volleyball += "\n"
        volleyball += "#count="
        volleyball += str(count) + "\n"
        volleyball += item
        volleyball += "\n\n" #spacer 2 lines
        volleyball += "#============ divider =========== \n"
        count += 1
        #print(count)
        #after loop is over
    volleyball += "'''" #after  just added this to see if it is right
    #print('now doing the loop after finishing volleyball')
    #for line in volleyball.splitlines():
    #    print(line)

#second_attempt()

tahoedream='''
global x
x = "one" #it was "one"     #<<=== x must be a string just as matching case == "string", 
                            #<<=== if using a number it will be converted to a string
                            #<<=== so x = 22   will work and be converted to "22"
tahoe=[]
tahoe.append(0)
'''


methods ='''
# ====  switch  
def switch(x):
    if type(x) != str:  
        x = str(x)
    global case
    case = x 
    
# ============  
def fallthru(y):
    eval("switch('" + y + "')")
#==================
def inswitch(n):
    if type(x) != str: 
        n = str(n)
    global case
    case = n
#=====================
# for infallthru    
def infallthru(n):
    eval("inswitch('" + n + "')")
'''





main_function_switch='''

def main_switch(exp):	
	exp = varholder[0]
	
	caselist1 = ['1', '2', '3']
	caselist2 = ['4', '5', '6', '7']
	caselist3 = ['8', '9', '10']
	caselist4 = ['default']
	
	
	switch(exp)#1
	while True:
	
		if case in caselist1: # ['1', '2', '3']
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 12')
			infallthru('4')
	
		elif case in caselist2: # ['4', '5', '6', '7']
			print('kangaroo hop hop!')
			#############
			nested_switch_11(exp) #11
			exp = 3
			nested_switch_62(exp) #62
			##############
			print('taught me how thru write code')
			infallthru('8')
	
		elif case in caselist3: # ['8', '9', '10']
			print('mocha blast')
			print('== 31 flavors===')
			infallthru('default')
	
		elif case in caselist4: # ['default']
			print('the end')
			break
	
		else:
			print('the end')
			break
	

'''



bottom='''main_switch('1')''' #this calls it this triggers the generated code to run 

#exec(tahoedream)







###=============================================================
#need string input name
# dec 31st brainstorming the SEQUENCE methods behaviors 
# jumaniji first to determine if nested switches
# then separate strings and run chain methods
# fill quail list with output 
# THEN call bypass205()






# in a switch string.
#it doesn't count endswitches as switches 
#but I might count endswitches as a backup insurance parachute.

# this calls endswitch() on each item in quail list 
# these are the input strings that were separated from a switch with nested switches within
# that have been split up above and put into the quial list in the order of appearance
# with main first and the nested afterwards in order
# modified on July 10th, 2021















#mrendswitch(red_robin)


#=================================================
####======   BYPASS205() ========   ##############
##=================================================
# BYPASS205() takes in the quail list
# and outputs the stanford list of python switch cases code 
########### bypass 205 ########### july 1st 2021 testing starbucks in gilroy
# in bypass205 and it LOOPS THRU QUAIL LIST AND CALLS Y
#  WHICH IS LOADED INTO PARSER_GUTS(Y) WHICH THEN LOADS IT TO STANFORD LIST
#this bypass205 is different then elsewhere in other files apparently - plus this one works


def bypass205(y): #this runs the input strings thru parser and code gen 
	#print("-------------bypass205(y)---------------") 
	#print("looking in radical_list")
	#for item in radical_list: #this loops thru radical_list that had quail in it 
	#	print(item)
	#print("in m31 list")
	#for item in m31: #was in quail
	#	print(item)
	# what if I put it(mission control) which is really
	# getting the pairs of switches and endswitches and sseparting the strings
	# and filling the quail list and then doing chian methods on it here JUST IN TIME
	
	#print('a theory here to call bypass 205 by attaching it above ')
	#print("THIS IS BYPASS205() officially called translating javascript switch to python switch")
	#print("bypass205() called HERE") #print("==== bypass205 test === it calls parser guts====") #and puts them into stanford list
	#print("this one loops thru the quail list already filled up with strings of switches prepped")#dec 14th notes
	del stanford[:] #this empties the stanford list
	#=======================================================================
	#the goodies are in radical_list and in thenumbers
	#print("inside of bypass205 at top what is in readical_list")
	#print("radical_list=",radical_list)
	#before bypass the first stage fills the quail list of separates switches
	#and runs chain methods and then fills radical_list
	#print("what is the length of radical_list inside of top of bypass205",len(radical_list))
	#print("adding this on line 32578 on January 25th 2020")
	#for item in radical_list:
	#    print(item)
	#print('line 32634 length of radical_list=',len(radical_list))    
	    
	##===============
	del quail[:] #ah it's in radical list 
	for item in radical_list: #from starship running chain methods
		quail.append(item)
	#========== new years eve surgery to fix bug by putting radical_list into quail
	#print("the length of quail list=",len(quail))
	#print("let's loop thru quail first")
	if len(quail) == 0:
		pass #print("quail list is empty ERROR")
		#print("quail=",quail)
		#print("ABORT ABORT ABORT quail is empty at beginning of bypass failure failure")
		
	else:
		pass #print("length of quail list = ",len(quail))
	#loop thru quail list 
	#for item in quail:
	#	print(item)
		
	del switch_numbers_to_transfer[:]
	#print("GET LENGTH HERE FOR ==  thenumbers=", len(thenumbers))
	#print("right here thenumbers are fed into switch_nubmers_to_transfer")
	for item in thenumbers:
		switch_numbers_to_transfer.append(item)
	##====== brainstorming here ===== dec 31st ==============
	#this is calling parser_guts() on each switch string in quail 
	#this would be after the big switch has been separated into individual strings
	#and reduced by chain methods and then put into quail list
	#print("inside of start of bypass205() let's look at quail input")
	#print("this is after the input strings have gone thru the chain_methods")
	#print("============== inside bypass205 =============")
	#print("===== number of strings in quail=",len(quail))
	#print("============== inside bypass205 =============")
	#print("quail list length =",len(quail))
	##### test code ########
	#######################
	### january 16th saturday testing ########
	#######################
	##### deleting quail to see the effect ##################
	#######################
	#del quail[:] #deleting quail list to see the effect
	#######################
	#######################
	#######################
	#######################
	#print("programmablly empteid quail list to see what happens")
	#print('quail length =',len(quail))
	#######################
	#######################
	#########################################
	#if len(quail) == 0:
	#	print("ERROR inside top beginning of bypass205()")
	#	print("WARNING this will not work")
	#else:
	#	print("quail length=",len(quail))
	#########################################
	#for item in quail:
	#	print(item)
	#	print("====================")
	for item in quail: # 0, 1, 2 #so it should call the parser and code gen three times
		y = item #this puts the contents of each string in quail into y 
		#everything below here is the same in parser code
		switchcasetester='';switchcasetester=None;
		del switchcasetester;switchcasetester='';
		mytrace("endswitch() bypass205  in switch_cat called")
		show_input_switch_string() #flag for testing this shows the input string
		###############
		parser_guts(y) #y is put in as a param to paser_guts(y) while looping thru quail list grabbing item(string)
		###############
	#new at this point delete helper lists
	# wednesday january 26th 2022 10:19am
	#print("bypass205 has finished and now I am deleting the input lists after")
	#print("showing what their respective lengths are and then after clearing them")
	#print("==this is the moment after completing bypass205() ====================================")
	#check what their contents are first
	#print("length of testlist_of_strings=",len(testlist_of_strings))
	#print("length of columbia_river=", len(columbia_river)) 
	#print("length of taurus=", len(taurus)) 
	#print("length of gemini=", len(gemini)) 
	#print("length of radical_list=", len(radical_list)) 
	#print("length of m31=", len(m31)) 
	#print("length of quail=", len(quail)) 
	
	
	del testlist_of_strings[:]
	#del columbia_river
	#====
	del taurus[:]
	del gemini[:]
	del radical_list[:]
	del m31[:]
	del quail[:]
	#print("length of testlist_of_strings=",len(testlist_of_strings))
	#print("length of columbia_river=", len(columbia_river)) 
	#print("length of taurus=", len(taurus)) 
	#print("length of gemini=", len(gemini)) 
	#print("length of radical_list=", len(radical_list)) 
	#print("length of m31=", len(m31)) 
	#print("length of quail=", len(quail)) 
	
##################################################==========================	
	
###  end bypass205()  ##################  		


#this calls bypass205()
def testing_input_to_run_thru_bypass205():
    return
    print("just before diving into bypass205() loop thru input quail list")
    #if len(quail) > 1:
        #for item in quail:
        #   print(item)
        #   print("==========")
    print("-------testing_input_to_run_thru_bypass205()------------")
    print("testing emptying quail just before bypass to examine the effect")
   
    if len(quail) == 0:
        print("quail=",quail)
        print("ERROR quail list is empty and is 0")
        print("just before bypass205(y) is called")
        #exit()
    y='' #y is empty here cleared on purpose since it gets it's input from quail list
    ### calls bypass205 here
    bypass205(y) #bypass205() called here 
##===bypass205 called  bypass205 called  bypass205 called ========


#not callingthis now not necessary
def loop_thru_the_stanford_list_which_is_output_of_bypass205():
    return
    #print("---------loop thru the stanford list which is outpout of bypass205()---------")
    #print("stanford list which is raw OUTPUT from bypass205()")
    #for item in stanford:
    #    print(item)
    #    print("=========")
##==============================================================    
#this triggers the test running of bypass205()



#I think that I should just put the method calls here
 #since bypass205 should trigger them in order right here
#==============================================================

def do_bypass205():
    print("-----------do_bypass205()---MIDDLE STAGE -------")
    #breakpoint()  #runs thru the quail lists 
    testing_input_to_run_thru_bypass205()#calls bypass205() here  
    #loop_thru_the_stanford_list_which_is_output_of_bypass205()
    #at this point empty quail list
    print("this is where we empty the quail list here after doing bypass205() inside of do_bypass205()")
    
    for item in quail:
        quail.pop()
    del quail[:]
    #print("quail=",quail)
#where do I call this actually after chain methods are done obviously 

#since we know that in bypass205() we are going to 
# loop thru the quail lists that have already been modified by
# the chain methods this should be the last juncture before it's 
# parsed and generated and conccatted at the bottom
##########
##########
##########
######################################
#this calls bypass205()  which is the parser + codgen for list of switch strings
######################################


#mrendswitch(red_robin) 
##====== calls bypass205() right here ==================
#this could be triggered if run == True
def the_second_stage(): #this calls bypass205 by location
    return
    print(" ===== the_second_stage()========")
    print("calling the seciond stage() which is bypass205")
    y='' 
    bypass205(y)
    
###################=======================


 
   # y='' #y is empty here cleared on purpose since it gets it's input from quail list
    ### calls bypass205 here
   # bypass205(y) 
 
'''   
if run[0] == True:
    #============================
    y='' #y is empty here cleared on purpose since it gets it's input from quail list
    ### calls bypass205 here
    bypass205(y)
    #do_bypass205() # I am trying to figure out where to pu this to call it 
    #============================
    print('finished doing do_bypass205()')
    print("-------------------------------------------")
    print("-------------------------------------------")
    print("-------------------------------------------")
    if len(stanford) == 0:
        print("ERROR stanford list is empty after doing bypass205()")
        print("len(stanford=",len(stanford))
    else:
        print("length of stanford list after bypass205 is",len(stanford))
        
    print("-------------------------------------------")
    print("-------------------------------------------")
    print("-------------------------------------------")    
    print("stanford list length", len(stanford))
    for item in stanford:
        print(item)
        print("==========")
else:
    print('run[0] is False')
    pass
'''



    
#exit()
#this should be called from another method and not out here in the open field
#exit()
##########
##########
##########
#=====================================================







		
		
		
		
	## end of endswitch()
#testing proof of concept of bypas205 to do three generating strings and save them
#don't run them. Just add them to stanford list
def next_steps():
    return
  









silvermine=[]
silvermine.append(0)
number_counter=0
##===========================================================
##  add_switch_number_to_python_output_from_quail_input():  #adds switch number to each python output string
##  uses list switch_numbers_to_transfer
##===========================================================
def add_switch_number_to_python_output_from_quail_input(testoutputstring,number_counter):
    #print("----------add_switch_number_to_python_output_from_quail_input(testoutputstring):--------")
    #print("uses list switch_numbers_to_transfer",switch_numbers_to_transfer)
    createstring=''; # this test is ONLY doing one call of this function 
    counter=0        # so it should work as switch_numbers_to_transfer[0]
    ###====dec 30 th change ==============================
  
    ##-====================================
    for line in testoutputstring.splitlines():
        if "switch(exp)" in line and "nested" not in line:
           # print(line)  #next line accesses switch_numbers_to_transfer[counter]
           # print("counter",counter)
            
            ########################################################################
           # print("this is what it sees",str(switch_numbers_to_transfer[number_counter]))
            ########################################################################
            #this is using list switch_numbers_to_transfer to add number in comment after switch in python
            #WAS USING SWITCH NUMBERS TO TRANSFER switch_numbers_to_transfer
            createstring += line + "#" + str(switch_numbers_to_transfer[number_counter]) + "\n"
            counter += 1
        else:
            createstring += line + "\n"
            counter += 1
            continue
    #print("the output after adding the switch line number after switch")
    #for line in createstring.splitlines():
     #    print(line)
    #this puts the output of the method above into silvermine[0]    
    silvermine[0]=createstring #for output to replace it into the same slot
 ####====== end of fucntion         
 













# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)
got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname): of the python output switch string
##====================================================
def get_switch_number_at_top_of_string(stringname):
	#print("-------------get switch number at top of string()-------------")
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		#print(line)
		#print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			#print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			#print(stringname)
			break
		else:
			counter += 1
	return y;




##==========================================================================
xmastime=[]
xmastime.append(0)
#testing december 2, 2021 4:38pm snowman coding project
#this will be called just before bake_cake combinging the switches together happens
#this would be called on each string in stanford list ##<< important note

# this creates the "def main_switch(exp):" and 
# def inner_switch_x(exp): and converts the inner switches to inswitch and fallthru to infallthru 
# verified working dec 3rd Friday 2021 Starbucks Gilroy.









#line 32832 =====here now ............. right here now =11:50 am=[]=============
###====== prime meridian here =================
###====== prime meridian here ========
###====== prime meridian here ========
###====== prime meridian here ========






'''
prepare_python_switch_string_for_baking
loop_thru_stanford_list_and_add_number_to_each_switch
loop_thru_fancy_new_car
show_output_after_switch_number_added_to_python_output_strings


'''



















####=======================================================================
##   prepare_python_switch_string_for_baking(stringname):
##   #method used: result= get_switch_number_at_top_of_string(stringname)
##========================================================================= 
def prepare_python_switch_string_for_baking(stringname):
    #print('--------prepare_python_switch_string_for_baking()-----------')
    buildstring='';
    the_answer_is= get_switch_number_at_top_of_string(stringname)
     #of python output string
    mynumb = the_answer_is;
    #========================== added on Fri Dec 3rd ====================
    ## this  ADDS the function name to the top  of a switch string;
    # not tabs in front here
    if mynumb == '1': 
        buildstring += "\n\nexp = varholder[0]\n";
        buildstring += "def main_switch(exp):"; 
        # only triggered for main switch scenario
    else:             
        buildstring += "def nested_switch_" + str(mynumb) +"(exp):" # meaning not  1 
    #====================================================================
    ## changes switch to inswitch and fallthru to infallthru
    for line in stringname.splitlines():
    #if mynumber = 1 don't change switch in main scenario
        if "switch" in line and "nested" not in line and mynumb != '1': 
        #if switch 1 skip this
            line = line.replace("switch","inswitch")
        if "fallthru" in line:
            line = line.replace("fallthru","infallthru")
        buildstring += '\t' + line +'\n'
        #this adds 1 tab  to front of each line after def definition
    xmastime[0] = buildstring; 
    
    
 #I just generated this with the code    







##==============================================================
##  loop_thru_stanford_list_and_add_number_to_each_switch():
##==============================================================
def loop_thru_stanford_list_and_add_number_to_each_switch():
    #print("-------loop_thru_stanford_list_and_add_number_to_each_switch()--------")
    counter = 0;number_counter=0;  
    #print("length of stanford is", len(stanford))
    #this loops thru the whole stanford list and adds a number  
    #print("adding switch number comment to python switch output at top")
   # print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    for item in stanford:  #to each switch
        #print('number_counter=',number_counter)           string,  number_counter
        add_switch_number_to_python_output_from_quail_input(item,number_counter) 
        #gets teh number from switch_numbers_to_transfer
        result = silvermine[0]; #maybe in silvermine[0]
        fancy_new_car.append(result)
        number_counter += 1


fancy_new_car=[]


##==================================================
##  loop_thru_fancy_new_car()    
##==================================================
def loop_thru_fancy_new_car():
    return
   # print("------ loop thru fancy new car() -------------- ")
    #return
    #for item in fancy_new_car:
    #    print(item)
    #    print("============")


##==================================================
## fill_stanford_list_from_fancy_new_car()    
##==================================================        
def fill_stanford_list_from_fancy_new_car():
    #print("------- fill stanford list from fancy new car() -----------")
    del stanford[:]
    #for item in fancy_new_car:
    #    print(item)
    #print("===========")
    #print("line 33026 get length of fancy_new_car=", len(fancy_new_car))
    for item in fancy_new_car:
        stanford.append(item)

##==================================================
## loop_thru_stanford_list()   
##==================================================        
def loop_thru_stanford_list():
    #return  #THIS DOES NOTHING CURRENTLY 
    #return
    #print("--------LOOP THRU FINAL STANFORD LIST()--------------------")
    counter=1
    #return
    #for item in stanford:
    #    print("==========")
    #    print(item)
    #    print("-------------------")
    #    print("counter=",counter)
    #    counter += 1
    #print("------end of looooooping thru Stanford Lake Laguninta --")







##==================================================
##  show_output_after_switch_number_added_to_python_output_strings()    
##==================================================        
def show_output_after_switch_number_added_to_python_output_strings():
    #print("----------show_output_after_switch_number_added_to_python_output_strings()------")
    loop_thru_fancy_new_car()  #output of switch number added to a python switch string 
    fill_stanford_list_from_fancy_new_car()
    loop_thru_stanford_list()
    #print("stopping here to see what is in stanford list at this point line 42293")
    #exit()
####============== new test down here now ========================================
#### fresh morning coding     tuesday dec 7th, 2021 morgan hill
####################################################################################



#right here this is going nicley they are all connected together in sequence playing tag

#uses method add_switch_number_to_python_output_from_quail_input()
##===========================================================
## add_number_after_top_switch_in_stanford_list():  #modified and streamlined with methods on Dec 12th, 2021
##  MAJOR METHOD 
##===========================================================
def add_number_after_top_switch_into_stanford_list(): #python output strings
    #print("--------add_number_after_top_switch_in_stanford_list():---------")
    loop_thru_stanford_list_and_add_number_to_each_switch()#after switches with numbers
    show_output_after_switch_number_added_to_python_output_strings() #in stanford list
    
        
#just commented this out
#add_number_after_top_switch_into_stanford_list() #this does the entire stanford list 
#which it loops thru 







##==================================================
## loop_thru_bad_dog()    THIS CURRENTLY DOES NOTHING
##==================================================
def loop_thru_bad_dog():
    return
    print("length of bad_dog line 12344=",len(bad_dog))
    #for item in bad_dog:
    #    print(item)
      
      
        
##==================================================
##  fill_stanford_list_from_bad_dog()   THIS FILLS UP STANFORD LIST
##==================================================
def fill_stanford_list_from_bad_dog():
    del stanford[:]  #fill stnaford list
    for item in bad_dog:
        stanford.append(item)
    #print("stnaford list here is __",len(stanford))


##==================================================
##  reverse_bad_dog_list()   
##==================================================
def reverse_bad_dog_list():
    bad_dog.reverse() 
#new


  
##==-=============================
test_list=[]
test_list.append(0)


##=================================
##==================================================
## say_what_it_is_doing_comment_as_print()    
##==================================================    
def say_what_it_is_doing_comment_as_print():
    return
    #print("bad dog list of final output of all nested switches and main switch")
     
     
     
##==================================================
##  take_bad_dog_list_and_fill_stanford_list()    
##==================================================
def take_bad_dog_list_and_fill_stanford_list():
    loop_thru_bad_dog()
    reverse_bad_dog_list()
    fill_stanford_list_from_bad_dog()
    del bad_dog[:] #new today dec 13th
    say_what_it_is_doing_comment_as_print()
    #loop_thru_stanford_list()
####################################################################################
bad_dog=[]
#uses method prepare ptyhon switch string for baking 
#appending output to bad dog of adding def method at top of each switch string






##========================================================
## adding_def_methods_to_top_of_each_switch_string():
## ** MAJOR METHOD **
##========================================================
def adding_def_methods_to_top_of_each_switch_string():
    #print(" --------adding_def_methods_to_top_of_each_switch_string(): ---------")
    for item in stanford: #what does this do 
        prepare_python_switch_string_for_baking(item) 
        #concats each switch string together (sewing together)
        bad_dog.append(xmastime[0]) 
    take_bad_dog_list_and_fill_stanford_list()
    #print('this should be the final ready output of stanford list')
    #print("=======------------------------")
    #for item in stanford:
    #   print(item)
    
 ###================ end of function ===============
 
fill_nested_switches_list=[]
fill_nested_switches_list.append(0)
#this is going to be used to pass the generated combined switch
# string of nested and main switches bottom up from main
#which is then passed to concat and execute.
 
 
###====
  #stanford_overflow_manager
        #loop thru quail and cut out first 6 slots 
        ###========making formula on jan 26th wednesday night gilroy starbucks=================================
        ## THIS IS DELETING SLOTS FROM RESIDUE OF PREVIOUS SWITCHES
        #THE CORRECT SLOTS ARE ON THE RIGHT SIDE
        ## THE FORMULA FOR DELETING THE OVERFLOW
        ##  TOTAL = LENGTH OF SNOWTIME LIST OF PAIRS + 1 FOR MAIN AND + 1 TO BE GREATER THAN
        ## THIS IS WRITTEN AS total = len(snowtime) + 2
        ## loop thru stanford list with a counter
        ## if the current count (starting from 1) IS LESS THAN TOTAL (LEN(SWOWTIME) + 2
        #POP(0) STRING FROM FRONT OF STANFORD LIST
        # BREAK OUT OF LOOP WHEN THECOUNT NOT LESS THAN TOTAL(LEN(SNOWTIME) + 2
        ########################################################
        # thecount=1
#         print("looping thru stanford here to delete first six slots")
#         for item in stanford:  #this is 'loop number two' #get length based on pairs + 1 + 1
#             if thecount < total:  #snowtime length = 5 + 1 for main and +1 to be more so 7
#                 stanford.pop(0) #delete first slot
#                 thecount += 1
#             else:
#                 break #breaks out of this 'loop number two'

    
#######################################################
## stanford_overflow_manager() ###### january 27th 2022
#######################################################
def stanford_overflow_manager(): #this deletes previous data
    return
    print("stanford overflow manager ")
    print("=what is the length of the stanford list=", len(stanford))
    print('what is th elength of snowtime list=',len(snowtime))
    total = len(snowtime) + 2
    print("total of length of snowtime +2 =", total) #lookign for bug 
    
    print('the length of stanford NEEDS to be reduced to total-1  =',total-1)
    if len(stanford) > total: #this is a new conditional test 
        stanford.reverse() #reversing it
        thecount=1
        for item in stanford:  #this is 'loop number two' #get length based on pairs + 1 + 1
            if thecount < total:  #snowtime length = 5 + 1 for main and +1 to be more so 7
                stanford.pop(0) #delete first slot
                thecount += 1
            else:
                break #breaks out of this 'loop number two'
        stanford.reverse() #reversing it back
    #print("the length of stnaford list after overflow =", len(stanford))         
    #print("the length of stanford should be", total-1)
####===
####################################################################################
#uses method build_stacked_cake sring combining stanford list()
#output is in toocool[0] list
##=============================================================
## stack_the_cake_combining_python_switch_methods_together()
## ** MAJOR METHOD ** 
##=============================================================
def stack_the_cake_combining_python_switch_methods_together():
    #print("----------stack_the_cake_combining_python_switch_methods_together()--------")
    toocool[0]=''; #this calls build stacked cake string combinging stanford list
   # print("length of stanford before stacking the cake",len(stanford))
    
    #print("$$$====length of stanford list =", len(stanford))
    #turning this off apparenlty not needed jan 31st
    ##==================================== this is new this cleans up the stanford list deling residue from previous nested switches' data
    #stanford_overflow_manager()  #### this is new as of january 27th, 2022      
    ###===================================
    #print("length of stnaford list now after modifcation is =", len(stanford))
    #print("this should be the correct stanford list now") 
    #for item in stanford:
    #    print(item)
    #print("starbucks testinghere clearing out quail attempts")
    #print("line 33221 length of quail here is",len(quail))
    ##================= january 25th 2022
    del quail[:]
    quail.clear()
    for x in quail:
        quail.pop(0)
    ################
    if len(quail) > 0:
        del quail[:]
    else:
        pass
    #print("length of quail now is ",len(quail))
    #print("qauil list was not 18 so didn't call the code above")
    #print("quail WAS NOT 18 so the stanford = 12 was not called")
    ###############################################################        
            
            
   # print("==stack it baby==")
    #print("stack_cake_combinging_python_switch_methods_together()")
    #acounter =1
    #for item in stanford:
    #    print(item)
    #    print("=-=-=-=-=-=-=-=-=-=-=--=")
    #   print("coutner=",acounter)
    #   acounter += 1
    build_stacked_cake_string_combining_stanford_list() #this adds ''' above it and ''' below it
    fill_nested_switches_list[0]= toocool[0]

##=================================================================
## the_big_test() #this goes thru each switch string in stanford list
## and adds switch number from quail strings in transfer_switch_list
## then adds def main method and def nested_switch_X
## reversing order so main is at the bottom 
## then concats the strings together within '''
##=================================/==============================
####################################################################################

## methods used:
## add_number_after_top_switch_into_stanford_list()
## adding_def_methods_to_top_of_each_switch_string() 
## stack_the_cake_combining_python_switch_methods_together()

fill_nested_switches_list=[]  #000000 modificaitons
fill_nested_switches_list.append(0) #-0000000 modifications dec 15th 
result=[]
result.append(0)



##===============================================================
## create_def_switch_methods_concatted_together_in_one_string()
##=============================================================
def create_def_switch_methods_concatted_together_in_one_string():
    #for item in stanford:
    #    print(item)
    #print('----------create_def_switch_methods_concatted_together_in_one_string()-------------') 
    add_number_after_top_switch_into_stanford_list()#this is used to label out switches
    adding_def_methods_to_top_of_each_switch_string() #framing each python switch generated output
    stack_the_cake_combining_python_switch_methods_together()

 #testing putting it here for INPUT to the dynamically generated switch case

#put this string into a list with just the string by itself in position 0
method_defs='''
# =======  switch  =================================
def switch(x):
	#if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
	#	x = str(x)
	global case
	case = x 
# =======  fallthru       =========================
def fallthru(y):
	eval("switch('" + y + "')")
#==================
#for inswitch
def inswitch(n):
	#if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
	#	n = str(n)
	global case
	case = n 
#=====================
# for infallthru    
def infallthru(n):
	eval("inswitch('" + n + "')")
'''




result=[]
result.append(0)
##====================================
varholder=[]
varholder.append(0)
varinmain=''
#varinmain = varholder[0] #this is new =============
##=====================================================

def call_this_after_clever_cat(): #it should be fine calling it here 
    #print('------------call this after clever cat()-------')
    del radical_list[:]
    del thenumbers[:]
    del switch_numbers_to_transfer[:]
    del stanford[:]
    del quail[:]
    #print('radical_list=',radical_list)
    #print('stanford=',stanford)
    #print('quail=',quail)
    del columbia_river[:]
    del snowtime[:]
    #print('columbia_river=',columbia_river)
    #print('snowtime=',snowtime)
    #print("columbia_river=", columbia_river)
  
    
def call_this_first_to_empty_strings():
    #print('--------------call_this_first_to_empty_strings()------------')
    del radical_list[:]
    del thenumbers[:]
    del switch_numbers_to_transfer[:]
    del stanford[:]
    del quail[:]
    #print('radical_list=',radical_list)
    #print('stanford=',stanford)
    #print('quail=',quail)
    del columbia_river[:]
    del snowtime[:]
   # print('columbia_river=',columbia_river)
   # print('snowtime=',snowtime)
    
    

##======= this was main_switch(varholder[0])


alltheway=[]
# this concats the strings in the list and then executes the string code
fireone=[]
fireone.append(0)
fireone[0] = False
##########################################################################
def enter_value(x):
	varholder[0]=str(x)  #look at this it takes in the input 

x = topvalue[0];
show_code= True    
lovely=[]
lovely.append(0)
#sneakylist=[]











###==================================
##  concat_items_in_list(x):
##============================////=======
def concat_items_in_list(x): 
	#print('----------------concat items in list(x)---------------------------')
	#create_def_switch_methods_concatted_together_in_one_string() #calls 3 methods
	global coldvar
	#for line in fill_nested_switches_list[0].splitlines():
	#	print(line)
	########## to get it working jan 7th putting this here
	#varholder[0] = 1
	#print('dealing with issue with trigger added to superball line 40481')
	#print("varholder[0]=", varholder[0])
	#print("")
	#coldvar=''
	
	trigger='''\nmain_switch(varholder[0]) '''
	
	#print("trigger=",trigger)
	enter_value(x) #this is fed in from above 
	lovely[0]=x #new on jan 3rd 2022
	#print("so",x, "should have been the input into varholder[0]")
	#print("=====concat items in list()====")
	fireone[0]= True #when this is True it shows the code generated with print
	global superball
	tail = "\n"
	future_nested_switches=fill_nested_switches_list[0] #makes a list a string
	superball='' #clears it  it is cleared right here 
	#it is cleared above this line up front I didn't see this previously
	#=================================================================================
	superball = method_defs + future_nested_switches + trigger + tail
	##================================================================================
	superball = superball.replace("'''",'') #this cuts out ''' from the combined string
	#=================================================================================
	#print(superball)
	future_nested_switches='' #empties it
	show_code= False #right now this is temporary bypass to turn it off
	if show_code == True:
		#print("this is important this is the input feeding the switch")
		#print("input value to the main switch was ",x)
		#razzledazzle = superball
		#sneakylist.append(superball) #this I will access on second pass to create duplicate test jan 5th
		pass #below uncomment to show generated code 
		#print(superball) #prints the generated switch code methods
	else:
		pass  #otherwise it prints nothing 
	#so at this juncture the global var superball has the combined stacked string
	#method_defs + 
	future_nested_switches=''
	trigger='' 
	tail=''
	call_this_after_clever_cat()
	call_this_first_to_empty_strings()


 
#===========================================================================
#===========================================================================
#=========================================================================== 

##============================== 
 
#x= greenbutton
#this calls create def switch methods concattedtogetherin onestring
# concat items in list
#after_running_code_list_status

#this uses stanford list 


##############################
##  bottom_stages()
##############################
#list of all methods it uses
#  create_def_switch_methods_concatted_together_in_one_string()
#  concat_items_in_list
#####===============================
#####===============================
## tahoe_dream.py 
#========================
#this actually works dec 31st, 2021 11:17am PST California, Menlo Park
# Blake Southwood Software Engineer 

## this works dec 31st, 2021
## Blake Southwood Software Engineer 

#import official_switch_case_silver
#from official_switch_case_silver  import *  
#from booster2 import *

#I have to import a list now to do it
thegreenlist=[]
greenlist=[]
greenlist.append(0)

the_main_sequence=[]


def add_to_the_main_sequence(x):
    the_main_sequence.append(x)
    
##===========================
## empty_this_list(me)
##======================================
def empty_this_list(me):
    if len(me) > 0:
        for item in range(0,len(me)):
            me.pop()
        else:
            pass
   
       
        ##===============
        
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'

#new on january 12th, 2022 ==========



fossil=[]
fossil.append(0)
#print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

endswitch_location=[]
switch_location=[]

#new on january 2nd, 2022======================
def clear_out_all_lists_for_reset():
    del endswitch_location[:]
    del switch_location[:]
    del sweetlist[:]
    del holdinglist[:]; 
    del boomerang[:]
    
def happy():
    return
    print("======= happiness========")

def show_the_date_and_time():
    #print("=====show the date and time() called======")
    import datetime
    now = datetime.datetime.now()
    #print("Current date and time : ")
    #print(now.strftime("%Y-%m-%d %H:%M:%S"))


#testing on January 12th Wednesday ====================
def nested_endswitch(inputstring):
    #fossil[0] =inputstring
    # print("we grabbed this string----------")
    #for line in inputstring.splitlines():
    #    print(line)
    #print('some match now')
    x = 2
    y = x * x;
    #print("y=",y)
    
##################=======@@@@@@@@@@@@@...................        
        

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    empty_this_list(switch_location)
    empty_this_list(endswitch_location)
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	#print("### must work now ###get switch and endswitch locations########")
	#print("####3##get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#right here going thru input string look for switch and endswitch
		#and append the line number to either switch_location or endswitch_location
		if "switch" in line and "end" not in line:
			#print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		elif "endswitch" in line:
			#print("endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1
			
			
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	#print(z)                #now I remember that is the first switch which doesn't matter
	#print("I deleted the first switch since I'm not bothering with it")
	#print("switchlocations=",switch_location)
	#print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	#print("this is how many nested switches are here")
	#print("now we should have this many nested switches to contend with",answer)
	#print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
		pass #print("endswitch locations =",endswitch_location)
		#print("out of curiosity print the number of endswitches", len(endswitch_location))
	else:
		pass
		
	

	
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	
	
	
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location
smart_rat=[]
string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
#print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
#print(string)

#print("end of test from the web")
#print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 

# october 11th, 2021 
#testing texas here to do what I want

sweetlist=[]
holdinglist=[]; holdinglist.append(0) #to create slot 0
boomerang=[];   boomerang.append(0)
#def get_switch_parents()

# I need to do a second pass and modify this just modified 
# texas string to show it's inner switch line numbers

##============================================
##  modify_string_before_splitting_it_up():
##============================================
def modify_string_before_splitting_it_up():
    return
    #print("texas string first")
    #for line in texas.splitlines():
     #   print(line)
    #print("=========================") 
    counter =0    
    #print("modify_string_before_splitting_it_up():")
    craftline =''
    for line in texas.splitlines():
        if holdinglist[0] == 0: #this compendates for the first one
            holdinglist[0] = '1' #ASSIGN JUST ONE EQUAL
        else:
            boomerang[0]= holdinglist[0]
    
        if "switch" in line and "end" not in line: #this eliminates endswitch confusion
            tabcount=line.count("\t")#                                   line number          tab count 
            if tabcount == 3: #this compensates for 2nd nested switch at 3 tabs
                boomerang[0]='1' #representing parent switch 
            else:
                pass
            if tabcount == 3:
                boomerang[0]= '1'; #assignment only use one = 
            craftline += line.replace("switch(exp){","switch(exp){ # "+str(counter)+":" + str(tabcount) + " "+"parent switch=" + str(boomerang[0]) + "\n")
            holdinglist[0]=  str(counter)
            #I need to add this to the special dictionary now
            #put it into a list first
            sweetlist.append([counter,tabcount,boomerang[0]])
            counter += 1
        else:
            craftline += line + "\n"
            counter += 1
    #print("this is the output test revisiting this on November 2nd, Tuesday")
    #print(craftline)    
    #print('end of test......... monday morning blues ')  

#modify_string_before_splitting_it_up()

listinput=[]
#exit()


#need to figure out how to add these automatically
  

switchnumbers=[]
tabslist=[]
switchlinenumbers=[]
peach_data=[]




isnt_this_pretty='nada'
pattern_input=[]
pattern_input.append('0')
pattern_input.append('0') #[1] patterninput[1]
pattern_input.append('0') #[2] patterninput[2]

##============================
##  input_tab_combo(x,y):
##=============================
def input_tab_combo(x,y):
    #print("====== input_tab_combo(===", x, y)
    pattern_input[1]=x #5
    pattern_input[2]=y #7

porsche_carerra=[]
capture_switch_lines_nested=[]


plums=[]
plums_data=[]
endswitchlinenumbers=[]
endtabslist=[]


             



#this builds the pairs of switch endswitches by tabs since they ahve to be lined up
#from the switch down to the endswitch in the same tab depth 


 ##=====================this might be teh top of the methods ==========================================================
 ##===============================================================================
 
 
        
## loops thru tabsubs and appends item to tabcount
#=========================
#  little_method(tabcount)            
#=========================
def little_method(tabcount): #threetabs example is the param here in tabcount
    for item in tabsubs:
        tabcount.append(item)
    del tabsubs[:]
        
        
        
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

#==============================
#  build_listinput_list  for threetabs,fivetabs, seventabs,ninetabs, eleventtabs,thirteentabs
#==============================
def build_list_input_list():  
    #print('=======METHOD 3 ====>>>')
    mx = holding_themax[0] #it's using this number 
    input= holding_themax[0]
    #cascading down is how it works
    if holding_themax[0] >= 3: put(3);
    if holding_themax[0] >= 5: put(5);
    if holding_themax[0] >= 7: put(7); 
    if holding_themax[0] >= 9: put(9); 
    if holding_themax[0] >= 11:put(11);
    if holding_themax[0] >= 13:put(13);
    if holding_themax[0] >= 15:put(15);
    #loop thru listinput   
    for item in listinput:
        super_listinput.append(item) #fills super_listinput list
    
  
  
##=================================
##  list_tabs_lists_by_depth():
##================================== 
def list_tabs_lists_by_depth():
    pass
    #print("==list tabs lists by depth=====METHOD 5======>>")
    #print("threetabs=" ,threetabs); print("fivetabs="  ,fivetabs);
    #print("seventabs=" ,seventabs); print("ninetabs="  ,ninetabs);
    #print("eleventabs=",eleventabs);print("thirteentabs=",thirteentabs) 
    


#this takes in the tab depth with x and goes thru the string
#and fills the appropiate tab list if 3 then threetabs, if 5 then fivetabs
##====================================================
## internal_machinery()   designed wed sep 29th, 2021
##====================================================
## key engine inside of function this_makes_switch_and_endswitch_pairs_by_tab_levels()
def internal_machinery(x,inputstring): #this doesn't change anything in the string whatsoever
    #print("===internal_machinery() called=== METHOD 4.5  inside of METHOD 4  ===")
    counter=0
    for line in inputstring.splitlines():
        tab_length = line.count("\t")
        if tab_length != x or "switch" not in line:
            counter += 1; continue
        if tab_length == x: 
            if "switch" in line and "end" not in line:
                tabsubs.append(counter);counter += 1;continue
            if "endswitch" in line:
                tabsubs.append(counter);counter += 1;continue 
    #print("tabsubs = ",tabsubs) #this can be increased to manage n number of tabs depth
    if   x == 3: little_method(threetabs)
    elif x == 5: little_method(fivetabs)
    elif x == 7: little_method(seventabs)
    elif x == 9: little_method(ninetabs)
    elif x == 11:little_method(eleventabs)
    elif x == 13:little_method(thirteentabs)
    else:
        pass
          







##==================================================
## make_switch_and_endswitch_pairs_by_tab_levels() 
##=================================================== 
def make_switch_and_endswitch_pairs_by_tab_levels(inputstring): 
    #print(":======33702========= METHOD 4 ======") 
    neutralize_list(tabsubs) #added on january 21st
    for item in super_listinput: # listinput is dynamically made above
        x = item;
        internal_machinery(x,inputstring)
     

###=============================== 
 
        #del tabsubs[:] #should clear it
###=================
rattabs=[]



##==============================
##  experimental_machinery
##===============================
def experimental_machinery(x,inputstring): 
    counter =0
    #newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    internal_machinery(x,inputstring)
 
    ###============

combined_tabs=[]
christmastree=[]




##============================================
## combine the lists together  #waterfall ifs
##=============================================
def combine_the_lists_together(x): 
    get_length_of_threetabs    = len(threetabs)
    get_length_of_fivetabs     = len(fivetabs)
    get_length_of_seventabs    = len(seventabs)
    get_length_of_ninetabs     = len(ninetabs)
    get_length_of_eleventabs   = len(eleventabs)
    get_length_of_thirteentabs = len(thirteentabs)
    #test if threetabs list is empty
    if get_length_of_threetabs > 0: #then proceed there is at least one
        #this is a waterfall extending numbers to add to christmastree list
        if x >=  3:christmastree.extend(threetabs);
        if x >=  5:christmastree.extend(fivetabs);  
        if x >=  7:christmastree.extend(seventabs);
        if x >=  9:christmastree.extend(ninetabs); 
        if x >= 11:christmastree.extend(eleventabs);
        if x >= 13:christmastree.extend(thirteentabs);
    
    else:
        pass
        #print('all of the tab lists are empty')
        #print("don't bother trying to extend empty tab lists")
       

##========================================================
##  build_tab_list_added_together(largest_tab_number):   Thursday, Nov 4th, 2021 
#   this does this combined_tabs = threetabs + fivetabs + seventabs etc
##========================================================
def build_tab_list_added_together(largest_tab_number):
    del christmastree[:] #clears out the combined_tabs list to erase it
    empty_this_list(christmastree)
    combine_the_lists_together(largest_tab_number) #<<==input is the largest tab number
    
    
 
#==========================================================
# combine_tabs_by_length_into_christmastree_list(input)
#==========================================================
def combine_tabs_by_length_into_christmastree_list():
    #print("======METHOD 6 ===  combine tabs by length into christmastree_list====>>>>")
    themax = holding_themax[0] #this gets the highest tab level (deeply nested)
    build_tab_list_added_together(holding_themax[0])   #METHOD  7
    
   
#================================= 
#  build_pairs_with_jazz()
#=================================  
#this goes thru christmas list of pairs and and makes snowtime list of pairs jazz added to snowtime 
def build_pairs_with_jazz(): 
    #print("=== METHOD 7== build pairs with jazz ====line 33784===>>>>")
    #nuking snowtime here to bypass the problem
    #look in snowtime first to see what the hell is in it
    #print("this is inside of build_pairs_with_jazz() inside of starship line 460")
    #print("starship line 461 snowtime=",snowtime)
    del snowtime[:] #added this hopeful bug fix on january 2nd, 2022 10:38am
    #===================================================
    counter =0
    #print('snowtime=',snowtime)
    empty_this_list(snowtime) #making sure that it starts out empty
    #snowtime=[] #new jan 7th40    print('what is in christmastree=', christmastree)
    for x in christmastree: #loops thru at 2 at a time
        jazz = [christmastree[counter],christmastree[counter+1]]
        snowtime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2 
        #prevents overflow error for out of range error
        if counter >= len(christmastree):
            break
            
            
         
#=======================================
#  build_tab_depth(inputstring)
#========================================            
def build_tab_depth(inputstring):
    del add_tab_depth[:]#added january 20th to clear it out
    #print("build tab depth ==== METHOD 1 ==  build_tab_depth(===line 33810====>>")
    for line in inputstring.splitlines():
        if "switch" in line and "end" not in line: #this is looking for a switch in a line
            get_tab_depth=line.count("\t")         #this is a var that gets the count of tabs
            add_tab_depth.append(get_tab_depth)    #this is for filling the list of each tab depth
        else:
            continue
    #print("add_tab_depth=",add_tab_depth)
    #print("max tab depth=",add_tab_depth[0])
            
      
      
            
            
def loop_thru_pairs_in_snowtime():
    #print(" ==== #method 8 ===  loop_thru_pairs_in_snowtime()=============")
    #pass
    for item in snowtime:  
        #print(item);
        rad1=item[0];rad2=item[1];
       # print(rad1,"and ",rad2)
   # print("snowtime list=",snowtime)




##=======================================
## get_max_tab_number_in_list()
##=======================================       
def get_max_tab_number_in_list():  #this fills the max holding_themax[0]
     holding_themax[0]=''#clear it out just in case
     #print("======  #METHOD 2 ===line 33841=====")
     themax = max(add_tab_depth);  #a list of the tabs before switches
     holding_themax[0]=themax;
     #print("themax=",themax)


##===========================================================================================
##===========================================================================================
##===============================================================
##   ==this_makes_switch_and_endswitch_pairs_by_tab_levels() ====
##===============================================================  
def this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring):
    #print("----THIS MAKES SWITCH AND ENDSWITCH PAIRS BY TAB LEVELS---line 33961-jan 22nd-")
    #print(" this_makes_switch_and_endswitch_pairs_by_tab_levels()")
    #print("===input string for this makes switch and endswitch parist by tab levels============================")
    #for line in inputstring.splitlines():
    #    print(line)
    #print("===============================")    
    build_tab_depth(inputstring)                               #METHOD 1
    get_max_tab_number_in_list() #fills holding_themax[0]      #METHOD 2
    build_list_input_list()                                    #METHOD 3
    make_switch_and_endswitch_pairs_by_tab_levels(inputstring) #METHOD 4
    list_tabs_lists_by_depth()                                 #METHOD 5
    combine_tabs_by_length_into_christmastree_list()           #METHOD 6 
    build_pairs_with_jazz()  #combines into sublist            #METHOD 7 
    loop_thru_pairs_in_snowtime()                              #METHOD 8
    #print("==bottom of this makes switch and endswitch pairs by tab levels()")
    #print("this is at end of this_makes_switch_and_endswitch_pairs_by_tab_leves()")
    #print("snowtime=",snowtime)
    #this will go into gold_list
        
   
 
     #this gets one pair in showtime designated by x 
def get_pair_in_snowtime(x):
     #print(" get pair in snowtime testing",x)
     #what if I add 0,0 to first position brilliant
     if len(snowtime) == 0:
        pass #print("length of snowtime is zero")
     #print(snowtime) #would be second position
     cool = snowtime[x]
     #print("list at position ",x," is",cool)
 

 


######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)


##==============================================================    
#we know that there will be sets of 2 numbers closest to each other
#go thru list and grab two at a time seems simple enough
#based on highest tab number which we would know like 7
#threetabs= [11, 47, 49, 73]
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]

peartree=[]
startime=[]

##======================================
## fill_main_pear_list(listname):  #this build the combined list correctly 
#the lists threetabs,fivetabs,seventabs,ninetabs need to already be filled
#this is just combining them together adding them together
##=====================================

threetabs=[]
endtabslist=[]
endswitchlinenumbers=[]


##======================
##  sound_of_music
##======================
fivetabs=[]



#=============bottom half which is seperates_input_strings============
#import official_switch_case_silver
#from official_switch_case_silver  import *  

def stop():
    print('stop called which calls exit')
    exit()
    
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 


# output is to inputstring[0]
#############################################################
passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)

##===================================================
##  add comment and line number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	awesome='';counter =0;newstring='';
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
			### new surgery ===dec 20th monday bug fix out of the blue =======
				#if counter == 1: #modified for bu on dec 20th monday each number was off by 1 except first
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
				
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	return newstring #this way I can capture the changed string
##===================================================================================







import re
def first_letter(s):
    m = re.search(r'[a-z]', s, re.I)
    if m is not None:
        return m.start()
    return -1

s = "##catgiraffeapluscompscI"
i = first_letter(s)
print(i)


testthis='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			print('first prize')
	  		print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
'''

coolinthegang='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			    print('first prize')
	  		   print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	    		    print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''


    
        
#print('after ======= attempting lstrip() which I have no confidence in')



newlist=[]
newtime=''
thelist=[]
finaloutput=[]
finaloutput.append(0) #creates slot
'''
this cleans up input javascript code that is supposed to be 
governed by tabs in front ala Python and if a space is discovered
it is neutralized and deleted. 
This first counts the tabs in each line in the string.
second it cuts out all spaces and tabs from left of each line
then it concats a new string with the correct tab count in
front of each line so it's CLEANED UP essentially. 

'''
#bad input
examplestring='''
	      switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
	  		    print('first prize')
	  		    print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	     		      print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''
#cleaned up output becomes
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
		case 4 to 7:
			print('first prize')
			print('you block head Charlie Brown')
		case 9 thru 11:
'''


finalstage=[]
finalstage.append(0)
##========================================
##  cut_out_left_side(inputstring):
##========================================
def cut_out_left_side(inputstring):
    #print("cut out left side")
    fancy=''
    for line in inputstring.splitlines():
        #print(line)
        newline = line.lstrip() #I am using lstrip() look at that!!
        fancy += newline + "\n"
    finalstage[0] = fancy
    ## concatting tabs in front + line to redone


##========================================
##  concat_tabs_in_front(fancy):
##========================================
def concat_tabs_in_front(fancy):
    #print("conctat_tabs_in_front()")
    redone='';counter=0
    for line in fancy.splitlines():
        redone += newlist[counter] + line + "\n"
        counter += 1
        if counter >= len(newlist):#prevents out of range error
           break
    finaloutput[0]= redone
    #print("right here the OUTPUT =",finaloutput[0])


#==================================
#   append_result()  pure genius
#   #appends tabs to newlist
#=================================  
def append_result(x):
    tab = "\t"
    result = tab * x;
    newlist.append(result)  
    #this replaces: #if item == 1:result = tab * 1;newlist.append(result)


#puts tab count in each line into thelist
##===============================================================
## count_tabs_in_each_line_and_put_into_thelist(inputstring):
##===============================================================
def count_tabs_in_each_line_and_put_into_thelist(inputstring): 
    del thelist[:];
    del finaloutput[:];
    finaloutput.append(0) #creats one slot space
    for line in inputstring.splitlines():
        answer =line.count("\t") 
        thelist.append(answer)
 
#TEST STRINGS taking out junk spaces




smartlist=[]
thelist=[]
#thelist.append(do1)
#thelist.append(do2)
#thelist.append(do3)
#thelist.append(do4)
#thelist.append(do5)
#thelist.append(do6)

fixedstring=[]
fixedstring.append(0)

#================dec 25th, 2021==============
#   remove_spaces_before_words(inputstring):
#============================================
def remove_spaces_before_words(inputstring):
    buildstring=''
    for line in inputstring.splitlines():
        aline= line.lstrip(' ')#strips off left side spaces
        buildstring += aline + "\n"
    fixedstring[0] = buildstring
    
    
#=========================================================================
# take_out_extraneous_white_spaces_on_the_left_of_each_line():
#=========================================================================
def take_out_extraneous_white_spaces_on_the_left_of_each_line():
    #print(" == take_out_extraneous_white_spaces_on_the_left_of_each_line(): ==")
    #print("line 34478 wait a second is THIS ONE CAlled===") #print("length of thelist=",len(thelist))
    ##NOTE this fills up smartlist
    #print("======line 34473 ====is this the answer ==================================")
    #print("starting what early christmas snowfall is the length of smartlist before appending to it??",len(smartlist))
    #print("============================================")
    #print("what is in quail RIGHT HERE 34476 ===", len(quail))
   
    #print("now what is the length of quail",len(quail))
    #print("dam it")
    for item in quail: #what am I calling the list 
        remove_spaces_before_words(item)             #method
        smartlist.append(fixedstring[0]) #adds output to new list
        #this fills up the list smartlist
    #print("line 34481  smartlist is now",len(smartlist))
    del quail[:] #emptying quail right here 
    #print("let us see what is in quail list line 34278")
    #print("length of quail=", len(quail))
    #for item in quail:
    #    print(item)
    #print("==============")   
    del quail[:] #Delete the contesnts from quail jan 25th 2022
    #print("=========this is at line 34479======")
    #print("LOOK RIGHT HERE length of smartlist =",len(smartlist))
    for item in smartlist: #now fill quail list 
        quail.append(item)
    #print("this is what is in quail list now Rocky won")
    #print('quail length =',len(quail))
    #print("========== after taking out white spaces in front of left side=====")
    #for item in quail:
    #    print(item)
     #   print("======")
        
        
#=========================================================================
# loop_thru_smartlist_after_adding_fixed_strings():
#=========================================================================
def loop_thru_smartlist_after_adding_fixed_strings():
    return 
    #for item in smartlist:
    #    print(item)
        
def loop_thru_list_before_changes():
    return
    # print('what thelist looks like in starting mode')
    # for item in thelist:
    #   print(item)
    #print("=======end of strarting input strings ====")    
##===================================================================
#print("here we go with our christmas morning code to make this work") 
#just commented these out since it was here for purely testing purposes
#loop_thru_list_before_changes()      
#take_out_extraneous_white_spaces_on_the_left_of_each_line()
#loop_thru_smartlist_after_adding_fixed_strings()
#print("end of test to get rid of spaces on left side of precious code")  
##==========================================================================
##===========================================================================    

#exit()


             
#made into a function on saturday, dec 4th morgan hill starbucks 
# refactored on dec 19th for efficiency and management
##=======================================================
##  take_out_junk_spaces_from_left_side(inputstring):
##=======================================================
def take_out_junk_spaces_from_left_side(inputstring):
    #print("take out junk spaces from left side")
    #print(inputstring)
    count_tabs_in_each_line_and_put_into_thelist(inputstring) # METHOD
    for item in thelist:  #fill a list with tabs corresponding to numberof tabs numbers
        x = item;
        append_result(x)                                      # METHOD
        
    cut_out_left_side(inputstring)#puts fancy in finalstage[0]# METHOD
    fancy =finalstage[0]
    concat_tabs_in_front(fancy)                               # METHOD 
    #result in finaloutput[0] for one converted string cleaned up
#####################################################################
#print("here we go big time test..........fireworks...")

    

###========================================================================   

    
#check for position of first character or number in line 
    #check in this line for location of first letter  
    #letter =line.index('s')# or myString.index('c') or myString.index('p') or myString.index('f')
    #print("letter is",letter)
    #no spacesin switch at top so it skips it!!!~!
    #I need the word before
    
    #what if I go thru the line and 
    #first detect a space and proceed till I hit a character
    #so I am only dealing with spaces before the characters
    #and I create a new line modified 





##===================================== border line ======================================








def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations    #this fills the together_pair list
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]






#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#print(genius[0])    	


 ####### august 10th 2021 testing commences.
 
find_nested_switch_game ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	

gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

#print("what we are starting with the switch with a nested switch")
#print(find_nested_switch_game)
#print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
#print("this gets the line number of the line that the case starts")
#print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    return
    linecounter =0
    casecounter = 0
   # print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            #print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            #print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
   # print("case line numbers",pacman)    
    #print(pacman[2])  
    #print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            #print(item)
            #print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    #print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    #print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
           #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            #print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    #print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    #print("x=",start_and_finish[1])
    #print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function



columbia_river=[]
gold_list=[]
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    answer=start_and_finish[1]
    start_and_finish[1] = start_and_finish[1] - 1 #added this on dec 20th to show switch word
    #print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
#print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
################################################################################
#print("=======begin Sunday Morning Brew Testing==========================")

def show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water):
    pass  #not printing it out at this time on purpose
    #for line in water.splitlines():
    #    print(line)

def show_the_snowtime_list_of_pairs():
    return
    #print("=======this is the snowtime list of pairs====january 7th discovery ")
    #print("starship line 1436 snowtime=",snowtime)   
    
def empty_columbia_river_list():
    del columbia_river[:] 
    
def add_main_switch_to_columbia_river(water):
    columbia_river.append(water)  

    
holding_string=[]
holding_string.append(0) 

##============================================================================
##  loop_thru_snowtime_list_copy_switch_bodies_and_add_to_columbia_river():
##============================================================================   
def loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river():
    #print("this is method 6")
    #print("loop thru snowtime and list and copy switch bodies and add to columbia river()")
    #print("here morning coding jan 23rd loop_thru_snowtime_list")
    #print("before this dance look at columbia_river")
    #print("length of columbia_river at this point is", len(columbia_river))
    #for item in columbia_river:
    #    print(item)
    #print("===================")
    for item in snowtime:#was gold_list #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];
        num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) # get input string from goldlist
        copy_a_nested_switch(holding_string[0]) # copy string based on switch,endswitch pair 
                                                # puts resulting string into makeitwork[0] and output
        output = makeitwork[0]                  # put nested string into columbia_river list
        columbia_river.append(output)
    #makeitwork[0] is the outoput from copy_a_nested_switch
    #maybe empty makeitwork[0] here afterwards jan 23rd
    #print("length of columbia river =",len(columbia_river))
    #counter =1  #adding here the initial string which will be used to make the main switch


    
##=================================  
## loop_thru_columbia_river() 
##================================= 
def loop_thru_columbia_river():
    return
    #print("now loop thru ====== COLUMBIA RIVER === to see the switch bodies seperated")
    #counter =1
    #return
    #for item in columbia_river:   #it is added just before looping thru i
    #    print("counter=",counter)
    #    print(item);
    #   #print("===========");
    #    counter += 1    
    
          

#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]    

##==============================================

   #This takes in what has already split the mega nested switch into 
   #switch bodies
quail=[]
sfo_pairs=[]
gold_list=[] #dec 26th sunday 7:56 am
number_of_pairs=[]
number_of_pairs.append(0)
##======================================================##=========================================
##  ==split_up_big_string_into_nested_switches(myinputstring)==
##======================================================##=========================================
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    #print("line 34912 inside of split_up_big_string_into_nested_switches(myinputstring)===")
    #print("testing jan 25th$$$   this is what is in myinputstring for split up big string into nested switches")
    #breakpoint()
    #print("=====INSIDE OF MODULE 1===== to split up big string into separate switch strings==========")
    #maybe I should put the string into a list so I can nuke it later
    #print("loop thru myinputstring line 34735 =========")
    #for line in myinputstring.splitlines():
    #    print(line)
    #print("=============") 
    #print('what is in quail here in splitup big string into nested switches')
    #print("length of quail =", len(quail))
    #print("looping thru quail list")
    #for item in quail:
    #    print(item)
           
    #print("==clearing out holding_string[0]==line 34738===========")
    holding_string[0]='' #clears it january 22nd
    water=''
    #print(" =jan 22nd testing =  split_up_big_string_into_nested_switches(inputstring)  ==")
    ## adds comment with line number after each switch word
    water =add_comment_and_line_number_to_all_switches(myinputstring)               #METHOD 1
    #print("check what is in water here")
    #print("==loop thru water string==== what is in water line 34744 ==== ")
    #for line in water.splitlines():
    #    print(line)
        
    #print("========= what is in water check 1 ======")
    show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water)   #METHOD 2
    #for item in columbia_river:
    #    print(item)
        
    empty_columbia_river_list()                                                     #METHOD 3
    del columbia_river[:] #just added for good meeasure
    show_the_snowtime_list_of_pairs()                                               #METHOD 4
    #for item in snowtime:
    #    print(item)
        
    #print("length of snowtime=", len(snowtime)) #should be number of pairs our number
    ########============================================
    number_of_pairs[0]= len(snowtime) + 1 #put pairs count + 1  ADDING ONE to it to include main
    #print("number of pairs in snowtime list =",number_of_pairs[0]) #6 in this case
    ########=============================================
    #print("snowtime=",snowtime)    #total of snowtime length + 1 to include whole string                                         
    
    #print("before this stage what is in water") #which is the number of pairs
    #print("==loop thru water string===line 34754======= point 2 check what is in water ====")
    #for line in water.splitlines():
    #    print(line)
    #print("======= line number 34757 ===========") 
    #for item in columbia_river:
     #   print(item)
        
    #print('waht is in water line 34963 testing')
    #for line in water.splitlines():
    #    print(line)
             
    add_main_switch_to_columbia_river(water)                                        #METHOD 5
    holding_string[0] = water
    #for line in holding_string[0].splitlines():
    #    print(line)
    atest = holding_string[0];
    #print("this is what is in holding_string[0] jan 23rd time")
    #for line in holding_string[0].splitlines():
    #    print(line) #this would be in holding_string[0]
    #print('line 34965 length of columbia_river=',len(columbia_river))
    loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river()      #METHOD 6
    #print("loop thru columbia_river line 34967")
    #### appending items from columbia river to bluejay here ###########
    #for item in columbia_river:
    #    print(item)
    #    #bluejay.append(item) #this is new january 26th 2021 
    #####================================================================
    loop_thru_columbia_river() #prints out seperated switch bodies top down         #METHOD 7               
    water='' #clears it jan 22nd
    #print("snowtime pairs=",snowtime)
    # print("fill the list sfo_pairs with snowtime list in case I need it")
    #gold_list is filled from snowtime RIGHT HERE
    ##3===================
    for item in snowtime:
        sfo_pairs.append(item)
        gold_list.append(item) #fills gold_list too
        
    #print("looping thru columbia river to fill quail list")
    #print("length of columbia_river=",len(columbia_river))
    #print("*-")
    #print("this is correct here seeing red white blue good.") 
    #for item in columbia_river:
    #    print(item)
    #print("=======")
    #print("quail length at this point is ",len(quail))
    #print("point 34785 what exactly is in quail list right here??")
    #for item in quail:
    #    print(item)
    #   print("..............")   
    #print("==========================//==========")
    #print('quail length before adding to it here is', len(quail))
    if len(quail) > 0:
        #print("looping thru quail list before appending to it from colubia_river")
        #looping thru quail which is obviously not empty
        pass
        #for item in quail:
        #    print(item)
    else:
        pass
    #print("quail list is empty on line 34770")
    #print("======")
    del quail[:] #clear out quail before adding to it obviously jan 25th, 2022 12:51 pm
    #print("length of columbia_river line 34867 =", len(columbia_river))
    #print("what is in columbia_river right here on line 34869 ")
    #for item in columbia_river:
        #print(item)
        #print(":==:==:==:==:")
    #print("======zero in on bullseye ========")   
    #print("length of columbia_river =", len(columbia_river)) 
    for item in columbia_river:  #quail  is filled from colubmia_river
        quail.append(item)
        #fills up quail list 
    #print('here columbia river feeds into quail.')
    ##====================================================
    # print("the switch strings cut up are now printed out top down")
    #turning this off to see what happens 
    
    #sunday january 30th 2022 turning this off to see what hapepns 
    #take_out_extraneous_white_spaces_on_the_left_of_each_line()
    
    
    #I think that it is making the changes to the quail list
    
    #print("looping thru quail list to see what it has========")
    #print("len(quail) =",len(quail))
    for item in quail:
        #print(item)
        bluejay.append(item)
        #print('=====')
    #print("what does this look like here on target with bluejay??")
    #print("length of bluejay=", len(bluejay))
    #print("snowtime=",snowtime)
    #print("length of quail =", len(quail))
    
    #print("looping thru stanford here to delete first six slots")
    #get length based on pairs + 1 + 1
    #
    #def fix_stanford_list():
    #    thecount = len(snowtime) + 2
    #    for item in stanford:  #this is 'loop number two' #get length based on pairs + 1 + 1
    #        if thecount < 7:
    #            stanford.pop(0) #delete first slot
    #            thecount += 1
    #        else:
    #            break
##================================================================        
##================================================================

##=================================================================
## manage_creating_pairs_and_separating_input_switch_strings()
## this calls 2 methods  ---------------
## * this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
## * split_up_big_string_into_nested_switches(inputstring)
##=================================================================
def manage_creating_pairs_and_separating_input_switch_strings(inputstring):

    #print(" --line 34759- jan 23rd testing sucker--manage_creating_pairs_and_separating_input_switch_strings(inputstring)--january 20th ---")
    ##empty both critical lists here 
    #print('==line 35084 ===top of manage creating paris and sepeartin input switch strings ================')
    #print("length of inputstring =",len(inputstring))
    
    #for line in inputstring.splitlines():
    #    print(line)
    #print('=====================')
    # print("what is in quail list here and what is the length of it")
    #print("length of quail in manage creating pairs = ",len(quail))
    #print("====looping thru quail====")
    #for item in quail:
    #    print(item)
        
    del columbia_river[:]
    del snowtime[:]
    #print("called manage_creating_pairs_and_separating_input_switch_strings()")
    this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
    split_up_big_string_into_nested_switches(inputstring)
    ##===================== new on january 26th 2022
    #print("=====january 26th testing this =bluejay and number of pairs===")
    #print("number of pairs in snowtime list =",number_of_pairs[0])
    #print("looping thru bluejay list")##==============================================
    #counter = 1
    #for item in bluejay:
    #    print(item)
    #    print("- - - - - - - -  - -")
    #    print("counter=",counter)
    #    counter += 1
        
    #that's it
    del bluejay[:]
    #print("bluejay=",bluejay)
    ##3=================================================================================
#print("this is where it all starts... make pairs and separate the switch strings")
#inputstring = red_robin
#manage_creating_pairs_and_separating_input_switch_strings(inputstring)


#print('testing booster2 here')
#waterfall_chain_methods_gold_master()
###====================================================================================
#############@@@@@@@@@@@@@  this is stage 1 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########

holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	#print("take_out_myendswitch called=============")
	galaxy = stringname
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			line = line.lstrip() #this should move it to the far left to align with margin
			line = line[0]  #first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	    
	##===========today sunday coding
	
	#then look for this } and reposition it
	
	#this is what I need to modify.
	#so the whole modified string after ripping out endswitch is now in holdthis[0]
	
	#print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
#stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)




innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
#print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    #print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
    #print('this now takes out the { brace after switch if it is there')
    innerswitch=''
   # print("this is what it sees when it starts change_switch_to_method_solved()")
    #for line in inputstring.splitlines():
    #    print(line)
    #print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        pass
        #print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    #print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        #print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            #print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
       # print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
       #check if } in this string an if so take it out
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
               # print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        #print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
            #print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            pass# print("=====no { in string  ======")
            #end if
        #print("=======testing if { taken out of string=======")
        #for line in inputstring.splitlines():
        #    print(line)
        #print("=======testing if { taken out of string=======")
        #check if } in this string an if so take it out #I have deactivated this since it's not needed
        
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
#print("where is my mocha brainfreeze test october 30th...")





#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##===========================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##===========================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	#print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		pass #print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		#print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	#print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	#print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)



def modern_take_out_endswitch(inputstring):
	#print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			#print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			#print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			#print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	#print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():




testlist_of_strings=[]

fillherup=[]
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''




###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	#print("======starter engine called======")
	#print("let us look in this string and see what we can see")
	#for line in the_nest_string.splitlines():
	#	print(line)
	#===========================================	
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #means a switch line
			tabdepth = line.count("\t")
			#print('====================================================')
			#print("tabdepth detect in starter_engine =",tabdepth)
			#print('====================================================')
			n= tabdepth;n = n-1  #need to have one tab in front
			#note tabdepth n needs to be at least 1
			# I may make it default at 1 to run otherwise it fails
			#================================
			if tabdepth < 1:
				passthis[0] = 1; #as a potential bug fix
			else:
				break
			#end if =====================================
			break #no matter what it will break out of this loop 
	passthis[0]= n;
	#print("n =",n)
goldtime=[]
goldtime.append(0)


##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    #print("====modern tab shifter to left====this should be called jan 24th monday ===")
    #breakpoint()
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';
    #print("what is in passthis[0] =",passthis[0])
    #print('this is inside of modern_tab_shifter_to_left(the_nest_string)')
    n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    #print("inside of modern tab shifter to left we have this for n")
    #print("n=",n)
    #print(type(n))
    #print("what is it??")
    #print("what is in the line above")
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
    #print("output of concatted string in goldtime[0]")
    #for line in buildstring.splitlines():
    #    print(line)
### deposit now code here for take out switch body to function properly   
 

###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 #where am I filling inputlist?
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        #print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
       # print("counter=>>",counter)
       # print("=====================")
    #print("at bottom of converts  with more than one inner switch at 3 tabs")
    #print("testing if weasel is returnable at the end of the function")
     #this is after it's done
    #for line in weasel.splitlines():
    #    print(line)
    #return weasel 

	
#print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
inputlist =[]
inputlist.append([11,60])
inputlist.append([62,86])
#print(inputlist)
inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#print("after reversing the list we now have===")
#print(inputlist)
#print("convert switch with more than one inner switch at 3 tabs(stringname)==== string1")
#get_switch_and_endswitch_locations_in_string(test_string1) #presumes one inner switch 


#get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#it needs to make these [[11, 60], [62, 86]]
###testing nov 27th at 10:46am starbucks




switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	


#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	#print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#del total_switches_at_3tabs_depth[:]
	##del switch_list[:]
	#del endswitch_list[:]
	
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	#print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	#print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#======== new jan 7th friday
	#print("inside method get_switch_and_endswitch_locations_in_string")
	#print("switch_list=",switch_list)
	empty_this_list(switch_list) #only empties list if it's not empty
	#switch_list=[]
	#print("length of switch_list=",len(switch_list))
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	#print("inside get_switch_and_endswitch_locations_in_string")
	#print("endswitch_list=",endswitch_list)
	empty_this_list(endswitch_list)
	#endswitch_list=[]
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	#print("switch_list=",switch_list)
	#print("endswitch_list=",endswitch_list)
	#print("end of line...")
	########################======
	
	########################==========
#print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function

#print("should be 1 for this test")
#del switch_list[:]
#del endswitch_list[:]
#print('real test now i really need this puppy to work')




#print('important testing on Saturday morning')
trialinputlist=[]
inputlist =[]

#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================

def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	#print("===inside of build_triall_inputlist==inside of starship ==")
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]
	empty_this_list(trialinputlist)
	empty_this_list(inputlist)
	#print("build_trail_inputlist()..")
	#print(" coding blues ")
	##==================================================================
	pair=''
	#print("========= look what this says right here ======")
	#print("len of switch_list", len(switch_list))
	#print("len of endswitch_list", len(endswitch_list))
	#print("==============================================")
	counter=0; 
	#print('starting out what is length otrailinputlist')
	#print("it's length = ", trialinputlist)
	#print(trialinputlist) #should be empty 
	#print("length of switch_list=", len(switch_list))
	#print("#####@@@@#@#@@#######==========")
	#print("curious here what is in switch_list and endswitch_list")
	#print("=== TESTING JANUARY 7th == bullseye ===========")
	#print("switch_list=",switch_list)
	#print("endswitch_list=",endswitch_list)
	#print("=====================================")
	for item in switch_list:
		#print("switch list counter=",switch_list[counter])
		#print("endswitch list counter=",endswitch_list[counter])
		#print('================')
		pair=[switch_list[counter],endswitch_list[counter]]
		#print("pair=",pair)
		trialinputlist.append(pair)
		counter += 1
	pair='' #clear out pair which is just a mere variable not a list
	#print("var pair=",pair)
	##=========================================================================	
	#print("look for the ball on the green")
	#print("reaching the 18th hole on the green")
	#print("trialinputlist=",trialinputlist)
	for item in trialinputlist:
		inputlist.append(item) #this is putting what is in trailinputlist into inputlist
	#print(":============ look right here for what is different =====")	
	#print("inputlist=",inputlist)
	#for item in inputlist:
	#	print(item)
	inputlist.reverse() #is this needed here or not 

	 
  
  

#inputstring=test_string1
outputstring=[]
outputstring.append(0)
snowboarding=[]
##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	#print("take_out_switch_body      today is november 28th sunday  4:29 pm ")
	#right here look if a switch at 3 tabs if not skip below
	####=== new as of monday december 6th, 2021 =========================
	#determine if 
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
			#print("yes switch at 3 tabs in line")
			#print("frosty says switch at 3 tabs confirmed")
			nestedswitch= True
			break
	#print("frosty the snow man light test for nested switch")
	#print("nestedswitch=",nestedswitch)
	#print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
		#add input into output  this means no changes were done to the switch string
		#print("this switch string DOES NOT have an inner switch")
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	 
	snowboarding.append(lightning[0])  #this is new dec 6th monday
	#for line in lightning[0].splitlines():
	#	print(line)







#making this sucker work no matter what 

#print("the big test begins")
#planB()
#print("now simply loop thru the finished changes in the list")

#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop
#these are the REAL CHAIN METHODS AS OF DEC 11 SATURDAY 2021 8:10 AM ====
result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]
#thought that these were lists but they might be vars, not sure at this point

#print("this is after the input stings have already been seperated")
##=================================
##  move_string_to_left_side()        first method modern tab shifter to left 
##=================================


#neutralize_list(testlist_of_strings)

##================================================================
## what is different is that the data strings are in quail above and are fed into testlist_of_strings
##================================================================
#
# this is using testlist_of_strings as input
#output: result_of_first_method all switch strings modified
def move_string_to_left_side():
    #empty testlist of strings and refill with fillherup
    #print("line number 35403 move_string_to_left_side()")
    #print("line number 35403 in move_string_to_left_side() what is in goldtime[0]=",goldtime[0])
    goldtime[0]='' #should clear it out 
    #print("goldtime[0] should start out empty")
    if len(goldtime[0]) > 2:
        goldtime[0]=''
    #end if
    #print("length of goldtime[0]=", len(goldtime[0]))    
    #print("what is in testlist_of_strings=")
    #why can't I just way if this list is not empty
    #for item in testlist_of_strings:#<============ look in this list jan 23rd
    #    print(item)
    ##===============================
    del testlist_of_strings[:] #this is deleting testlist_of_strings
    how_many_switches=''
    #print("move string to left side()  this is what is in teh quail list on line 35384")
    #print("looking in quail list at this point online 35429 in move_string_to_left_side")
    for item in quail:
        ##====================
        if "red" and "white" and "blue" in item:
            #print("YES the stars and stripes colors are in this")
            how_many_switches=item.count("switch")
            #print("number of switches = ",how_many_switches)
            how_many_donnor_summit=item.count("Donnor Summit")
            #print("number of Donnor Summit =",how_many_donnor_summit)
        else:
            pass
            #print("no red white and blue in this string")
        ##==================
        #print(item)    
    #print("==================")
    ##=======================================
    #print("testlist_of_strings is FILLED from quail list!! good to know")
    #testlist of strings is filled from quail list
    
    ## using quail to hold the strings so I would use this here 
    for item in quail: #gets input strings from fillherup list
        testlist_of_strings.append(item)
    #print("==== passing the baton here =============/////=============")
    #print("verifying that testlist_of_strings has the switch strings from above at this juncture")    
    #print("this is THE TEstLIst OF stRINgs of strings line 35449 ==== jan 23rd ====")
    #counter=1
    #for item in testlist_of_strings:
        #print(item)
        #print("===========")
        
        #print("counter=",counter)
        #counter +=1
    #print("total of the switch stirngs=",counter)
# modern_tab_shifter_to_left  method used
    #print("=====APPLE== modern_tab_shifter_to_left()=====")
    counter = 1
    for item in testlist_of_strings:
        #print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
    #print("result of shifting input strings to left")
    #print("=====APPLE==APPLE   APPLE   APPLE   APPLE   APPLE=====")
    #for item in result_of_first_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
    #    counter += 1
    



#result_of_first_method.append
##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
# output result_of_second_method
# method used: take_out_switch_body(string)  PLUM
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    #print("=====PLUM =january 23rd testing ==== take_out_the_inner_switch_bodies_leaving_switch()")
    #take_out_switch_body method used
    #print("======line 35433 list result of first method ")
    #for item in result_of_first_method: #it has the first nested switch and second nested switch
    #    print(item)
    #print("=====================")
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
        #print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
        #print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    counter =1
    #print("result of taking out inner switch bodies")
    #for item in result_of_second_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
     #   counter += 1
    

#good_plum()





##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
## output: result_of_third_method  PEACH
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    #print("=====PEACH===change_switch_to_method_solved===")
    # change_switch_to_method_solved method used 
    #print("=====linenumber 35473 change_switch_to_method_solved=")
    #for item in result_of_second_method:
    #    print(item)
    #print("======================")    
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        #print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        #print("===== counter =",counter)
        counter += 1
    #########################################
    counter =1
    #print('result of 3rd method on string')
    #for item in result_of_third_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
     #   counter += 1
    
    
    
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
## output: result_of_fourth_method  ORANGE
##=================================================================
def replace_endswitch_with_close_brace(): #orange
    # take_out_myendswitch method used 
    #print("=======ORANGE=take_out_myendswitch===")
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
        #print("=======")
        fizz =  holdthis[0]
        
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        #print("===== counter =",counter)
        counter += 1
   #########################################
    #print('result of 4th method on string')
    counter=1
    #for item in result_of_fourth_method:
        #print(item)
        #print("=========")
        #print("counter=",counter)
    #  counter += 1


#######################################################

    
#this gets the numbers and fills up the list switch_numbers_to_transfer  
switch_numbers_to_transfer=[]
cell=[]
cell.append(0)
##==================================== created dec 6th monday 2021
##  get_switch_number_now(lestring): from quail list before bypass205 is called
##====================================
def get_switch_number_now(lestring): #fills list switch_numbers_to_transfer
    #print("====get_switch_number_now()==line 35895===") #gets it from quail list
    #print("what is in lestring that it is getting the numbers from?")
    #print("the 2nd pass shoudl show red white and blue")
    #print("line number 35474")
    check_if_words_red_white_blue_in_string(lestring)
    #for line in lestring.splitlines():
    #    print(line)
    
    
    counter =0
    #print("==CODE RED COCKROACH TEST BUILDING A TRAP==")
    #print("CRITICAL bug test january 21st in get_switch_number_now line 35984")
    #print("length of shit switch_numbers_to_transfer=",len(switch_numbers_to_transfer))
    #when its first filled get its length
    if len(switch_numbers_to_transfer) > 0:
        pass
        #print("TRUE the list switch_numbers_to_transfer is NOT Empty")
        #print("switch_numbers_to_transfer checking is",switch_numbers_to_transfer)
        #print("I will empty it here")
    else:
        pass
        #print("switch_numbers_to_transfer list length = 0")
        #del switch_numbers_to_transfer[:]
        #neutralize_list(switch_numbers_to_transfer)
            
    #else:
        #print("TEST FALSE meaning switch numbers to transfer is EMPTY")
        #print("length of switch_numbers_to_transfer=",len(switch_numbers_to_transfer))
    #here 
        
    #print("what is in lestring that it is getting the numbers from?")
    #print("the 2nd pass shoudl show red white and blue")
    #for line in lestring.splitlines():
    #    print(line)
    # print("======critical test january 21st friday ========= to see what it sees========")    
    for line in lestring.splitlines():
        if  counter == 1 and "switch" in line and "#" in line and "end" not in line:
             x =line.index("#");
             x=x+1; #because first position is 0
             answer=line[x:]; #does a slice
             cell[0]=answer; #this does nothing january 21st 2022
             switch_numbers_to_transfer.append(answer) #fills up this list
             break;
        else:
             counter +=1
    
    
            
#this fills up the switch_numbers_to_tranfer list used in bypass205 to
#use in the numbering of the switches with a # after each
##====================================================
##  fill_switch_numbers_list_to_transfer():
##  method: get_switch_number_now()
##==================================================  
def fill_switch_numbers_list_to_transfer():
   # print("fill fill_switch_numbers_list_to_transfer() line number 35482 ==")
    #print("line 35497 result_of_fourth_method")
    #print("result_of_fourth_method=",result_of_fourth_method)
    counter=1
    for item in result_of_fourth_method:
         get_switch_number_now(item) #fills list switch_numbers_to_transfer
         counter += 1
    #for item in result_of_fourth_method:
        #counter += 1
 


#print("=========== get switch numbmer in quail list") 
##=============================================
## get the switch_numbers_to_transfer():
#this is trapeze to get the switch number for first switch in each string
#which will be used for make the def nested_switch and main_switch in python mode
##=============================================
def get_the_switch_numbers_to_transfer():
    #print("========what is in chain_output_list line 35710 ===")
    #for item in chain_output_list:
    #    print(item)
    #   print("0-0-0-0-0-0-0-0-0-0-00-0-")
    #print("========what is in chain_output_list line 35710 ===")

    counter=1
    for item in chain_output_list:
        get_switch_number_now(item) 
        #print("number =",counter)
        #print(cell[0]) 
        counter += 1          
    #print("switch_numbers_to_transfer",switch_numbers_to_transfer)
  



  
chain_output_list=[]
##===================================================
## fill_chain_output_list():
##==-================================================
def fill_chain_output_list():
    del chain_output_list[:] #empty it to be sure
    #print("====fill chain output list()====")
    #print("this fills the chain_output_list from result_of_four_method list")
    for item in result_of_fourth_method:
        #print(item)  #just don't print it out
        chain_output_list.append(item)

##======================================================
## loop_thru_chain_output_list_and_fill_quail_list()
##======================================================          
def loop_thru_chain_output_list_and_fill_quail_list():
    #print("loop thru chain output list nad fill quail list()")
    del quail[:] #empties quail list
    for item in chain_output_list:
        quail.append(item)


##======================================================
## loop_thru_quail_list():
##===================================    
def loop_thru_quail_list():
    return
    #for item in quail:
    #    print(item) 
        
def loop_thru_chain_output_list():
    return
    #print("== chain_output_list looping thru it to feed to parser in bypass==")
    #for item in chain_output_list:
    #    print(item)
    #   print("=====================")
        
def fill_output_into_quail_list(): #maybe here is the bug jan 25th 
    del quail[:] #just added this jan 25th Tuesday, 2022 12:48pm
    quail.clear() #just added this jan 25th 2022
    for item in chain_output_list:
        quail.append(item)
    #print("final output from chain methods for input switch strings")
    #print("note: this is the quail list with these modified switch strings")
    #for item in quail:
    #    print(item)
    #    print("=============")
##=============================================
## show_list_switch_numbers_to_transfer()
##=============================================
def show_list_switch_numbers_to_transfer():
    return
    #print("===switch numbers to transfer== stage2 Linus==")
    #print(switch_numbers_to_transfer)  
#fillherup=[]
##===================================
##   quail_overflow_manager():
##===================================
def quail_overflow_manager():
    return
    #print("===quail overflow manager===")
    #print("what is the length of quail list=", len(quail))
    #print('what is the length of snowtime llist=',len(snowtime))
    #print("=====quail_overflow_manager()======")
    total = len(snowtime) + 2
    #total2 = len(snowtime) + 1 #adding 1 for main
    #print('the length of quail needs to be reduced to total-1  =',total-1)
    #slotslice=total-1
    #quail[slotslice:]  #looks like a[-9:] #gets last 9 slots everything else cut off
    
    #do I do this:  quail= quail[slotslice:]
    #print("now length of quail = ", len(quail))
    #I can reverse it possibly.
    ##################===not impliemnted yet =================================
    # I know what the length of the list is SUPPOSED TO Be 
    # I want the last numbers in the list say 6 of them
    # these are on the far right.
    #then reverse the 6 there COOL
    # I can reverse the list and move them to the front
    # copy the first 6 feed into a temporary list genius
    ##################====================================
    #print("======11:20 am ====== did this work ==========")
    
    if len(quail) > total: 
        thecount=1
        for item in quail:   
            if thecount < total: #so does because we know it's 6 and 18 - 12 = 6 
                quail.pop(0) #delete first slot
                thecount += 1
            else:
                break 
    #print("quail list length is now",len(quail))  
    #print("the length of quial should be", total-1)
    #if len(quail) == total -1:
        #print("TRUE they are equal")
    #else:
        #print("FALSE since the length of weuail need to be total-1")
    #print('length of snowtime llist=',len(snowtime))       
              
##====================================
##  do_the_blender_chain_methods()
##====================================
radical_list=[]
#this section takes in input data from the quail list
### THIS IS THE WORKING BLENDER CHAIN METHODS JAN26TH 2022 
def do_the_blender_chain_methods(): #this takes in the quail list as input!!! jan 25th 
    #print("right here quail length = ",len(quail))
    #print(" =====BLENDER CHAIN METHODS .. QUAIL BEFORE GOING THRU BLENDER ======...")
    #for item in quail:
    #    print(item)
    #    print("- - - - - - - - - -")
    #####==============================================
    ### QUAIL LIST REDUCING AUTOMATIC CORRECTION
    #print("==@@@@@@@=====length of quail list right here", len(quail))
    #turning this off not needed apparently 
    #quail_overflow_manager()
    #####=============================================       
    #print("looping thru quail now")
    #for item in quail:
    #    print(item)
               
    #print("================================")
    #print("==do blender chain methods()==jan 24th is this thing turned on ")
    #print("this is the one doing blender chain methods verified on january 24th ")
    move_string_to_left_side()                         # method 1 indents to left
    take_out_the_inner_switch_bodies_leaving_switch()  # method 2 cut out switch bodies leaving switch
    change_switch_to_nested_switch_method()            # method 3 switch becomes nested_switchX
    replace_endswitch_with_close_brace()               # method 4 endswitch becomes }
    fill_switch_numbers_list_to_transfer()             # method 5 list generated used for codegen
    fill_chain_output_list()  
    #loop_thru_quail_list()
    #loop_thru_chain_output_list() #final output to send to rudolph parser now      
    #now I need to put what is in chain_output_list into quail list
    del quail[:]
    fill_output_into_quail_list() #final stage here 
    ####=========================
    #print("======output of BLENDER CHAIN METHODS IN QUAIL LIST======")
    #for item in quail:
    #    print(item)
    #################================================
    for item in quail:
        radical_list.append(item)
    #print("==radical_list==same content should be in quail list")
    #print("=== bottom of do_the_blender_chain_methods() ====")
    #print("radical_list length = ", len(radical_list))
    #print("===look in here baby ==========================")
    #print("this is looping thru radical_list ==jan 25th 2022 morgan hill starbucks =")
    #for item in radical_list:
    #    print(item)
    #print("this is in quail list at this point=== quail list")
    #for item in quail:
    #    print(item)    
##  waterfall_chain_methods_gold_master()  formally called do_it()  #this is the one actually being used.
## uses testlist_of_strings for input
##==================================================
#the way this works is each method does all of the switch strings as a set
#each of these methods does all of the switch strings in the list at once 
#and the results are passed downward cascading for the next method to modify.
#========WATERFALL CHAIN METHODS GOLD MASTER THE REAL DEAL=======
##===================================================================================    
## ====  WATERFALL CHAIN METHODS GOLD MASTER OFFICIAL OFFICIAL OFFICAL OFFICIAL  =====       
##  fills quail list with converted and prepped input switch strings all clean up
## this is called after the strings have been separated from the main nested switch

##=======yes working called== january 26th ============================================================================
def waterfall_chain_methods_gold_master():  #THIS WILL TAKE IN THE QUAIL LIST FOR INPUT
    #print("really is this working or not janyary 26yth :::THIS ONE IS CALLED AT TOP for waterfall_chain_methods at waterfall chain methods this is the string being passed thru")
    #print("==.=.=.=top of waterfall chain methods gold master line 35937.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.==.=.=.=")
    #print("length of quail starting in waterfall=",len(quail))
    #print("=....==WATERFALL CHAIN METHODS Gold Master 1.3()==jan 24th =  imaginary WORLD = ")
    do_the_blender_chain_methods()
    loop_thru_chain_output_list_and_fill_quail_list() #yeah makes sense filling quail list
    show_list_switch_numbers_to_transfer()
    #print("length of quail at AT BOTTOM of waterfall chain methods gold master", len(quail))
    #print("=====.=.=.=.line 35945=.=.=.=.=.=.=.=.=.=.=.=.==.=.=.=.=.=.=.")
   ##====================== jan 2nd new =====================
   # to see what are in the lists after ONE RUN of starship booster 1 and booster 2
   #=========================================================
#new january 2nd, 2022 
def show_contents_of_all_lists():
    return
    #print("====show contents of all lists() inside of starship module ===")
    #if the lists are full in here I need to reset and clear them all
    #print("quail=",quail)
    #print("radical_list=",radical_list)
    #print("testlist_of_strings=",testlist_of_strings)
    #print("snowtime =",snowtime)
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("chain_output_list=",chain_output_list)
    #print("result_of_fourth_method=",result_of_fourth_method)
    #print("cell=",cell)
   # print("result_of_third_method=",result_of_third_method)
    #print("result_of_second_method=",result_of_second_method)
    #print("result_of_first_method=",result_of_first_method)
    #print("tabcount=",tabcount) #will have to clear it too likely 
    #print("snowboarding",snowboarding)
    #print("outputstring",outputstring)
    #print('endswitch_list=',endswitch_list)
    #print("string_name=",string_name)
    #print("fillherup=",fillherup)
    #print("holdon=",holdon)
    #print("holdthis=",holdthis)
    #print("galaxy=",galaxy)

def empty_the_contents_of_all_lists_inside_of_starship():
    #print("===resetting the lists in starship===")
    #print("empty_the_contents_of_all_lists_inside_of_starhip CALLED")
    #print("which means to essentially RESET() the lists in it")
    #print("after deleting them emptying them I will show their contents for proof")
    #print("first empty the said lists ")
    del quail[:]
    del radical_list[:]
    del testlist_of_strings[:]
    del switch_numbers_to_transfer[:]
    del snowtime[:]
    del chain_output_list[:]
    del result_of_fourth_method[:]
    #del cell[:]
    cell[0]=''
    del result_of_third_method[:]
    del result_of_second_method[:]
    del result_of_first_method[:]
    del snowboarding[:]
    del outputstring[:]
    del endswitch_list[:]
    del switch_list[:] #just added this one in case  jan 2nd to fix bug 
    #del string_name[:]
    del fillherup[:]
    del holdon[:]
    #del holdthis[:]
    holdthis[0]=''
    #=============== this one was getting overloaded
    del snowtime[:] #this is new just added it
    del sfo_pairs[:]
    del gold_list[:]
    del columbia_river[:]

    #del build_trial_inputlist[:]
   
    #del stanford[:]
    #del galaxy[:]
    ##==========================================
    # 
#     print("now show me the empty lists")
#     print("quail=",quail)
#     #print("stanford=",stanford)
#     print("radical_list=", radical_list)
#     print("testlist_of_strings=", testlist_of_strings)
#     print("switch_numbers_to_transfer=", switch_numbers_to_transfer)
#     print("chain_output_list=", chain_output_list)
#     print("result_of_fourth_method=", result_of_fourth_method)
#     print(" cell=", cell)
#     print(" result_of_third_method=", result_of_third_method)
#     print("result_of_second_method=", result_of_second_method)
#     print("result_of_first_method=", result_of_first_method)
#     print("snowboarding=", snowboarding)
#     print(" outputstring=", outputstring)
#     print(" switch_list=", switch_list)
#     print(" endswitch_list=", endswitch_list)
#     print("string_name=", string_name)
#     print("fillherup=", fillherup)
#     print(" holdon=", holdon)
#     print("holdthis=", holdthis)
#     print("galaxy=", galaxy)
#  
        
##===========================================================================
##  convert_nested_switch_string_to_strings_in_quail_list(inputstring):
##============================================================================
def convert_nested_switch_string_to_strings_in_quail_list(inputstring):
    manage_creating_pairs_and_separating_input_switch_strings(inputstring)
    waterfall_chain_methods_gold_master() 
    
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    ##======= first two stages in a mini main right here ===========
    
#inputstring = red_robin
#convert_nested_switch_string_to_strings_in_quail_list(inputstring)

#print("=======end of test inside of startship=====")
#exit()

def so_smart():
    #print("------------------------------------")
    #print("======== so_smart() called==========")
    #print("------------------------------------")
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("snowtime=",snowtime)
    #print("thenumbers=",thenumbers)
    #print("switch_list =",switch_list)
    #print("endswitch_list=",endswitch_list) 
    #print("testlist_of_strings=",testlist_of_strings)
    del switch_numbers_to_transfer[:]
    del snowtime[:]
    #del thenumbers[:]
    del switch_list[:]
    del endswitch_list[:]
    del testlist_of_strings[:]
    #print('and the result is now after deleting them')
    #print("we are crap here now line 36299")
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("snowtime=",snowtime)
    #print("thenumbers=",thenumbers)
    #print("switch_list=",switch_list)
    #print("endswitch_list=",endswitch_list)
    #print("testlist_of_strings=",testlist_of_strings)



##==========================
##  empty_this_string(xx):
##==========================
def empty_this_string(xx):
    empty_string = ""
    xx = empty_string
    return xx
    
    
#charmin list doesn't exist
trouble=['one','two']     


  
    
#print("further testing of empty_this_list(me) method")  
empty_this_list(trouble)
#print("trouble=",trouble)


  
  
       
    #===================================    
    #toocool="for item in range(0,len(me)):\n\t me.pop()"
    #print(toocool) #to see what it sees    #quail.pop()
    #print("check this out =======")
    #for line in toocool.splitlines():
    #    print(line)
    #====================   
    #exec(toocool)
##=====================================
##  clear_all_vars_and_lists():
##=====================================
def clear_all_vars_and_lists():
    #print("====clear_all_vars_and_lists()====")
    superball = ''
    varinmain=''
    #method_defs = ''
    future_nested_switches =''
    trigger = ''
    tail = ''
    future_nested_switches=''
    #fill_nested_switches_list=[]#[0]=''
    
    #topvalue=[]
    #lovely=[]  
    #fireone=[]
    #method_defs =''
    future_nested_switches =''
    trigger =''
    tail    =''
    #fill_nested_switches_list[0]=''
    show_code= False
    lovely=[] 
    #empty_this_list(lovely)
    varholder=[] 
    #empty_this_list(varholder)
    coldvar =''
    mynumb = ''
    x=''
    y=''
    toocool=[]
    #empty_this_list(toocool)
    #silvermine=[]
    number_counter=0
    xmastime=[]
    #empty_this_list(xmastime)
    mynumb = ''
    the_answer_is = ''
    buildstring=''
    result = ''
    result=[]
    #empty_this_list(result)
    silvermine=[]
    #empty_this_list(silvermine)
    createstring=''
    number_counter=0
    #example clearing a list 
    #for x in alltheway[:]:
    #   alltheway.remove(x)
    #======================================
    fill_nested_switches_list=[]
    #empty_this_list(fill_nested_switches_list)
    #for x in fill_nested_switches_list[:]:
    #    fill_nested_switches_list.remove(x)
    #stanford=[]
    #for x in stanford[:]:
     #   stanford.remove(x)
    #quail=[]
    ##=============================================
    #print("length of stanford=",len(stanford))
    # if len(stanford) > 0:
    #    automatic_list_emptier(stanford)
    #else:
    #    pass
        
    ##===========================

    ##########======================================
   # print("length of quail=",len(quail)) #6
    empty_this_list(quail) #pure genius  #0
    stanford=[]
    #print('stanford=',stanford)
    #empty_this_list(stanford)
    #print("testing here .......")
    brown = "charlie"              
   # print("brown=",brown) #'charlie'
    brown=''  #this is how I will just do it
    #print('brown=',brown)  # gone
    
    
    
    
    
    
    #print('it should be empty now baby')
    ##########
    #print("length of quail now should be 0, it is",len(quail))
    #=========================
    #for x in quail:
    #   quail.remove(x)
    #print("this is inside clear_all_vars_and_lists")
    #print("quail should be 0 here",len(quail))
    #empty_this_list(bad_dog)
    bad_dog=[]
    #for x in bad_dog[:]:
     #   bad_dog.remove(x)
    #empty_this_list(test_list)
    test_list=[]
    #for x in test_list[:]:
    #   test_list.remove(x)
    #empty_this_list(fancy_new_car)
    fancy_new_car=[]   
    #for x in fancy_new_car[:]:
    #    fancy_new_car.remove(x)   
    
    ##==========================
    del endswitch_location[:]
    del switch_location[:]
    #empty_this_list(endswitch_location)
    #empty_this_list(switch_location)
    #empty_this_list(sweetlist)
    #empty_this_list(holdinglist)
    #empty_this_list(boomerang)
    del sweetlist[:]
    #print("sweetlist=",sweetlist)
    
    del holdinglist[:]; 
    del boomerang[:]
    z=''
    answer=''
    

def testing_this_idea():
    return
    #print("this is in starship10")
    #print("length of quail=",len(quail))
    
#==========here friday jan 7


def clear_switch_number_lists():
    switch_numbers_to_transfer=[]
    thenumbers=[]


thenumbers=[]
#creating churchill list
churchill=[]
real_switch_numbers_to_transfer=[]

##==============================================
## phase_one_of_nested_switches_procedures(
##==============================================  

#greenbutton=''

def after_running_code_list_status_not_active():
    return #essentially kills the function
    
    
    #print('superball=',superball)


         
def after_running_code_list_status():
    #print('after_running_code_list_status()')
    #print("THIS SHOULD HAVE BEEN CALLED !!!! JAN 20,2020")
    #print("====after running code list status (CONTENTS)======")
    #print("= these should all be EMPTY =============")
    if len(sfo_pairs) > 0:
        del sfo_pairs[:]
   # print("sfo_pairs=",sfo_pairs)
    for item in sfo_pairs:
        sfo_pairs.pop()
    sfo_pairs.clear()
    for item in sfo_pairs:
        sfo_pairs.remove(item)
    #print("show me the money")
    #print("sfo_pairs=",sfo_pairs)
    #print("snowtime=",snowtime)
    neutralize_list(snowtime)
    #print("snowtime=",snowtime)
    neutralize_list(super_listinput)  
    #print("super_listinput=",super_listinput)  
    neutralize_list(gold_list)
    #print("gold_list=",gold_list)
    neutralize_list(trialinputlist)
    #print("trialinputlist=",trialinputlist)
    neutralize_list(inputlist)
    #print("inputlist=",inputlist)
    neutralize_list(add_tab_depth)
    #print("add_tab_depth=",add_tab_depth)
    neutralize_list(snowtime)
    #print("snowtime=",snowtime)
    neutralize_list(gold_list)
    #print("gold_list=",gold_list)
    neutralize_list(endswitch_location)
    #print("endswitch=",endswitch_location)
    neutralize_list(switch_location)
    #print("switch=",switch_location)
    neutralize_list(quail)
    #print("quail=",quail)
    neutralize_list(thenumbers)
    #print("thenumbers=",thenumbers)
    neutralize_list(stanford)
    #print("stanford=",stanford)
    neutralize_list(churchill)
    
    #print("churchill=",churchill)
    neutralize_list(radical_list)
    #print("radical_list=", radical_list)
    neutralize_list(switch_numbers_to_transfer)
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    neutralize_list(real_switch_numbers_to_transfer)
    #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #print("quail=",quail)
    neutralize_list(radical_list)
    #print("radical_list=",radical_list)
    neutralize_list(testlist_of_strings)
    #print("testlist_of_strings=",testlist_of_strings)
    neutralize_list(switch_numbers_to_transfer)
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    neutralize_list(chain_output_list)
    #print("chain_output_list=",chain_output_list)
    neutralize_list(result_of_fourth_method)
    #print("result_of_fourth_method=",result_of_fourth_method)
    
    #neutralize_list(cell)
    cell[0]=''
    #print("cell=",cell)
    #print("holdthis[0]=",holdthis[0])
    holdthis[0]=''
    #print("holdthis[0]=",holdthis[0])
    
    neutralize_list(result_of_third_method)
    #print("result_of_third_method=",result_of_third_method)
    
    neutralize_list(result_of_second_method)
    #print("result_of_second_method=",result_of_second_method)
    
    neutralize_list(result_of_first_method)
    #print("result_of_first_method=",result_of_first_method)
    #print("tabcount=",tabcount) #will have to clear it too likely 
    neutralize_list(snowboarding)
    #print("snowboarding",snowboarding)
    neutralize_list(switch_numbers_to_transfer)
    neutralize_list(switch_numbers_to_transfer)
    #print('this list MUST be empty') 
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    
    #print("outputstring",outputstring)
    neutralize_list(christmastree)
    #print("christmastree",christmastree)
    neutralize_list(switch_list)
    #print("switch_list=",switch_list)
    neutralize_list(endswitch_list)
    #print('endswitch_list=',endswitch_list)
    #neutralize_list(string_name)
    #print("string_name=",string_name)
    #print("fillherup=",fillherup)
    #print("holdon=",holdon)
    #neutralize_list(holdthis)
    #print("this needs to have one slot [0]holdthis=",holdthis)
    #print("galaxy=",galaxy)
    #print("======================")
    #print("pair=",pair)
    neutralize_list(trialinputlist)
    #print("trialinputlist'",trialinputlist)
    neutralize_list(inputlist)
    #print("inputlist=",inputlist)
    neutralize_list(sfo_pairs)
    #print("sfo_pairs=",sfo_pairs)
    neutralize_list(gold_list)
    #print("gold_list=",gold_list)
    #print("======the new ones here=====")
    neutralize_list(threetabs)
    neutralize_list(fivetabs)
    neutralize_list(seventabs)
    neutralize_list(ninetabs)
    neutralize_list(eleventabs)
    neutralize_list(thirteentabs)
    # print("threetabs=",threetabs)
    # print("fivetabs=",fivetabs)
    # print("seventabs=",seventabs)
    #print("ninetabs=",ninetabs)
    #print("eleventabs=",eleventabs)
    #print("thirteentabs=",thirteentabs)
    #print("add_tab_depth=",add_tab_depth)
   

    
    #print('superball=',superball)
    



'''
import starship10
from starship10 import *
from starship10 import switch_numbers_to_transfer
from starship10 import radical_list  
'''


#import cupcake
#from cupcake import *

#this is what was filled from quail in starship after chain methods modifies the input switches
topvalue=[]
topvalue.append(0)



    
#####==========================================
##=============================================
#import official_switch_case_silver
#from official_switch_case_silver  import *  
#print("top of rudolph.py ")
#print(" ")
stanford=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
def message_from_Woodstock():
    return
    #print('hello from Woodstock the bird file')
    
message_from_Woodstock()

#print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

endswitch_location=[]
switch_location=[]

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    endswitch_location=[]
    switch_location=[]

# december 29th fun
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 

#important no comments in case line otherwise it messes up the parser
#learned this yestrday December 31st which prevented the code from running


##======================== massive dirt simple test to make sure it totally work s=======
waffles ='''
	switch(exp){  
		case 1 thru 3: 
			print("to the moon Alice!")
			print('first prize')
			print('Charlie Brown and Snoopy flying against Red Baron')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp)  
				case 'blable':
					print("we are inside of sw 11 now wildness")
					
					print("I just typed this like Snoopy")
					result[0]="snoopy"
					fallthru
				case 'more':
					print("and this fell thru from snoopy above")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
	endswitch
'''

waffles2 ='''
	switch(exp){  
		case 1 thru 3: 
			print("starship to the moon and then mars, never!")
			print('first prize')
			print('starship booster will not succeed for a year or two')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp)  
				case 'blable':
					print("we are inside of sw 11 now wildness")
					
					print("I just typed this like Snoopy")
					result[0]="snoopy"
					fallthru
				case 'more':
					print("and this fell thru from snoopy above")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			exp = 'rocket'
			switch(exp)  
				case 'rocket':
					print("oh this is very interesting the fifth element")
					print("I wonder if it will work ")
					result[0]="starship"
					fallthru
				case 'more':
					print("one never knows what a woman is thinking ")
					break
				default:
					print("out of rocket fuel ")
			endswitch 
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
	endswitch
'''
#endswitch(waffles)
#jumanji
#trying a simple one to see what happens
#for testing exp = 1


### wednesday december 29th, 2021 10:02 am ====DECEMBER 29TH WEDNESDAY ADDITION ==========================
###### this will be called from imported starship file

#it was here that is now in cupcake


##=====/////=================////////////////============================================
inputstring=''
#inputstring = waffles # red_robin # red_robin 

resultis=[]
resultis.append(0)
##=============================================
##  determine_if_nested_switch(inputstring):
##=============================================
def determine_if_nested_switch(inputstring):
	#print("---------determine_if_nested_switch(inputstring):-------")
	realnumber = inputstring.count("endswitch") #it's possible there are no nested switches
	realnumber = realnumber + 1 #this account for the first switch which isn't counted
	if realnumber == None or realnumber == 0:
		realnumber = 1 #this is in case there are no endswitches meaning no nested switches
	#end if
	#print("see if this number is different")
	#print("counting the endswitch + 1 we get ",realnumber)
	if realnumber >= 2:
	    #print("voila we have nested switches ")
	    resultis[0]= True
	else:
	    #print("nope, just one single switch ")
	    resultis[0]=False
	    

#determine_if_nested_switch(red_robin) #waffles2	 
#print("for waffles we have")
#print("jeeze if nested switch=",resultis[0])
   
   

#======


def clear_switch_number_lists():
    switch_numbers_to_transfer=[]
    thenumbers=[]


thenumbers=[]
#creating churchill list
churchill=[]
real_switch_numbers_to_transfer=[]

def fill_the_numbers_list():
    for item in switch_numbers_to_transfer:
        thenumbers.append(item)

def loop_thru_numbers_list():
    return
    #print("these are the switch nubmers to tranfser in the numbers")
    #for item in thenumbers:
    #    print(item)   

def fill_real_switch_numbers_to_transfer_list():
    if len(real_switch_numbers_to_transfer) >0:
         real_switch_numbers_to_transfe=[] #empty it
    else:
        pass
        
    for item in switch_numbers_to_transfer:
        real_switch_numbers_to_transfer.append(item)
    #print("what was just imported and saved is real_switch_numbers_to_transfer from starship")
    #print(" we have",real_switch_numbers_to_transfer)
    #print("...")   
    #print("the switch numbers to transfer are..",thenumbers) #this is a dependency   
    #print("these numbers are from starship")
    
    
def show_the_numbers_list():
    return
    #print("these are the switch_numbers_to_transfer ")    
    #print("thenumbers=",thenumbers)
    #for item in thenumbers:
    #   print(item)

def loop_thru_radical_list():
    return #print("loop thru radical_list")
    #for item in radical_list:
    #    print(item) 

def fill_radical_list_with_quail():
    del quail[:]
    for item in radical_list: #from starship list which is really quail
        quail.append(item) 

def fill_churchill_list_from_quail():
    #print("this is what is in quail made by starship from radical_list to quail")
    for item in quail:
        #print(item)  
        churchill.append(item) 
        
        
        
## THIS IS PHASE ONE MINI MAIN FOR DOING FIRST TWO STAGES
##  MAKE PAIRS OF SWITCH AND ENDSWITCH
##  SEPARATE THE SWITCH STINGS

##==============================================
## new_phase_one_of_nested_switches_procedures( #modified on jan 18th, 2022
##==============================================                      
def new_phase_one_of_nested_switches_procedures(inputstring):
    number_for_quail_should_be=''
    #print("verifying inputstring unique for each nested switch case at this point")
    #print("==checking input string in new_phase_one==")
    #for line in inputstring.splitlines():
    #   print(line)
        
    # print("==line36405 ===phase one of nested switches procedures()==1.0 on jan 18th 2022============")
    convert_nested_switch_string_to_strings_in_quail_list(inputstring) #from starship
    # for item in quail:
    #    print(quail)
    #get length of pairs snowtime
    ############# bug fix surgery january 28th 2022
    #print("len(snowtime)=",len(snowtime))
    #add 1 to snowtime for the main stirng
    number_for_quail_should_be = len(snowtime) + 1
    #print('number for quail should be==',number_for_quail_should_be)
    #print("===== then I compare this with the total for switch numbers to transfer")
    #print('and if switch numbers to transfer is > than cut it in half')
    fill_the_numbers_list()
    loop_thru_numbers_list()
    fill_real_switch_numbers_to_transfer_list()#switch_numbers_to_transfer list
    #print("doing comparision test here ----- line 36957 ---")
    #print("did this work 36959")
    #print("real_switch_numbers_to_transfer=", real_switch_numbers_to_transfer)
    
    show_the_numbers_list()
    loop_thru_radical_list()
    fill_radical_list_with_quail()  #radical_list filled
    fill_churchill_list_from_quail()#churchill_list
    #print("this is new here ")
    switch_numbers_to_transfer=[]
    #real_switch_numbers_to_transfer=[]
    #thenumbers=[]
    #for item in thenumbers:
    #    switch_numbers_to_transfer.append(item)
        
     #this is fix but of creating a doulbelist in switch numbers to transfer
     #and basically cutting it in half    
     
    #real_switch_numbers_to_transfer=[]
    #thenumbers=[] 
    #print("=============================================")   
    #print("dam switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #print("thenumbers =",thenumbers)
    #print("=============================================")
    ################################################################
    #print("switch numbers to transfer =", switch_numbers_to_transfer)
    templist=[]
    getlength=''
    bingo = False
   #print("length of quail =", len(quail))
    #print("============================================")
    #print("value of passcounter[0]=",passcounter[0]) #this is added when mission_control triggered
    #print("============================================")
    # if LENGTH of quail list LESS THAN LENGTH of switch numbers to transfer
    #Fuzzy logic starts here
    #print("======fuzzy logic solution= stage 1 ==")
    if number_for_quail_should_be < len(switch_numbers_to_transfer):
        bingo = True #I should put this into a list thebingo[0]
        #we know it would double it so /2
        #print("number for qauil should be=",number_for_quail_should_be)
        #print("length of switch numbers to transfer=",len(switch_numbers_to_transfer))
        getlength=len(switch_numbers_to_transfer)
        newnumber=getlength/2 + 1 #see if this fixes it
        counter=1
        #print("it sees this in switch_numbers_to_transfer")
       # print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
        for item in switch_numbers_to_transfer:
            if counter < newnumber:  #so it will go thru half
                templist.append(item)  #templist will always be correct #########
                counter += 1
            else:
                break
    #print('templist =',templist)
    
    if bingo == True:
        switch_numbers_to_transfer =[]
        # print("look right here Mountain Camp ....")
        #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
        #print("thenumbers =",thenumbers)
        # real_switch_numbers_to_transfer=[]
        # thenumbers=[]
        for item in templist: 
            switch_numbers_to_transfer.append(item)     
    
    ########################   I MIGHT NEED A pass COUNTER TO RECTIFY THIS ############ 
    #IMPORTANT !!! THIS SECTION HERE IS ONLY TRIGGERED STARTED ON SECOND PASS
    #IMPORTANT !!! AND SECOND PASS IS DETECTED BY  
    #IMPORTANT !!! if number_for_quail_should_be < len(switch_numbers_to_transfer):
    #IMPORTANT !!! bingo = True
    #IMPORTANT!!! THIS WILL *NOT* BE TRIGGERED ON THE FIRST PASS using a COUNTER now passcounter[0]
    ########################  
    ## passcounter[0] is added to inside of mission_control each time it's called
    #this only needs to be triggered AFTER the first pass
    
    #print("passcounter[0]=", passcounter[0])
    #print("======fuzzy logic mode  2 ==========.....==================")
    #print("PHASE 2 of Fuzzy logic to prevent overflow due to multiple nested switch processing referred to as passes")
    #print("testing...january 29th  .==PREDICTIVE FIX PROBABILITY== AND OUTCOME...testing...")
    # print("this should result in quail length reduced to 6 and stanford list reduced to 6 also")
    # if passcounter[0]> 1:
    #         print("passcounter[0] is GREATER than 1")
    #         print("passcounter[0]=",passcounter[0])
    #         
    #         print("look right here Mountain Camp ..these should be OVERFLOWING HERE ..")
    #         print("should be okay to show real_switch_numbers_to_transfer and thenumbers")
    #         #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #         #print("thenumbers =",thenumbers) 
    #     else:
    #         print("do nothing unless passcounter[0] > 1")
    #         print("if it is here then it MUST be == 1: ,passcounter[0]=",passcounter[0])
    #         print("THIS MUST Be ONLY 1 if it is here at this point")
        
    
    #   print("==line 37057=====inside of phase 2 for overflow correction =======")
    #     print("templist=",templist)
    #     print("length of templist=", len(templist))
    #     print("======================================")
    #     if passcounter[0] > 1: #so this will not be called for the first pass 
    #         print("passcounter[0] counter =",passcounter[0])
    #     ========================================
    #         print("switch_numbers_to_tranfer is now", switch_numbers_to_transfer)
    #         print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #         print("the LENGTH of real_switch_numbers_to_transfer=",len(real_switch_numbers_to_transfer))
    #     if the real switch number to transfer is corrupted correct it
    #         return
    '''
        print("templist=",templist)
        print("this is ONLY TRIGGERED if they are NOT the same length====")
        if len(real_switch_numbers_to_transfer) > len(templist):
            
            print("now we empty it")
            #print("thenumbers=",thenumbers) #this refills real switch numbers to transfer from temp
            real_switch_numbers_to_transfer=[]
            for item in templist:  #refill real_switch_numbers_to_transfer
                real_switch_numbers_to_transfer.append(item)
            print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
           
        print("this is only TRIGGERED if the two lists are NOT the same length====")
        if len(thenumbers) > len(templist):
            print("thenumbers=",thenumbers)
            print("the length of thenumbers list =",len(thenumbers))
        
            thenumbers=[]
            for item in templist:  #refill thenumbers list 
                thenumbers.append(item)
            print("thenumbers=",thenumbers)    
            bingo = False
        print("look AT THIS DAM it anyways LINE HERE===")
    else:
        print(" ### here passcounter MUST be 1 at this juncture 37060 line number ")
        print("passcounter[0]=", passcounter[0])
        
 '''       
        
   #####=========================     
    ###====================================================
    #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #print("thenumbers=",thenumbers) 
 
#================================================================================




#greenbutton=''
#======
def test_list():
    #print("test_list called to loop thru quail and stanford")
    return
    #for item in quail:
    #    print(quail)
    #print("===========")
    #for item in stanford:
    #    print(item)


#think of this as endswitch(red_robin)

#test_list()


        

	
##==================================
##==================================
##==================================
##==================================


   



    






listinput=[]
      
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

###=================
rattabs=[]

combined_tabs=[]
christmastree=[]

 
fox=[]  #this is just a simple test 



######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)
##==============================
##  get_pair_in_pairslist   example  get_pair_in_pairslist(1)
##==============================
#output param1[0] and param2[0] for a pair 

test_pairs = {
  "22":  "[22,33]",
  "44":  "[44,66]",
  "55":  "[55,58]",
  "77":  "[77,86]",
  "88":  "[88,99]",
  "102": "[102,110]"
}
#print(test_pairs)
##========================================
## get_pair_for_switch_number(x):  #this accesses the test_pairs dictionary
##========================================
def get_pair_for_this_switch_number(x):
    print("x=",x)
    y = test_pairs[x]
    #y = eval("test_pairs.get(x)")
    print("pair =",y)
   


#make_sets_from_three_tabs()

#threetabs=[]
#endtabslist=[]
#endswitchlinenumbers=[]





    
 





###=================================================
#when running from frosty.py comemnt the two lines below out
#inputstring = string_to_use
#create_list_of_pairs_now(inputstring); #commented out dec 15th for testing


#Santa_Cruz_Python_Preprocessor/fourth_of_july2good.py /

def message_from_linus():
    return
    #print('hello from Linus file')
 
#message_from_linus()   
#import official_switch_case_silver
#from official_switch_case_silver  import *  
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 



# output is to inputstring[0]

passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)


def show_quail_and_stanford_lists():
    return
    #print("===== show quail and stanford lists length=these are nice to see what is in them==")
    #print("quail length =",len(quail))
    #print("stanford length =", len(stanford))
    #print("switch_numbers_to_transfer=", len(switch_numbers_to_transfer))
    #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #print('thenumbers=',thenumbers)
    #print("templist=",templist)
    #real_switch_numbers_to_transfer=[]
    #switch_numbers_to_transger=[]
    #thenumbers=[]
    #templist=[]
    #print("switch_numbers_to_transfer=", switch_numbers_to_transfer)
    #print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #print('thenumbers=',thenumbers)
    #print("templist=",templist)
    

##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	#this is called and runs on jan 8th 
	#print('what is the date jan 8th saturday morning software')
	awesome='';counter =0;newstring='';
	#print(inputstring)
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
			#end if
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		    ####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring
	#for line in newstring.splitlines(): #was redrobin.splitlines()
	#	print(line)
	#print("AFTER ADDING the line number as comments to the switches in red robin baby ")	
	#print(newstring)   #it prints red_robin switch combo string with the line numbers added in comments
	#print("smart_switch_numbers=",smart_switch_numbers)  #this is new here too 
	return newstring #this way I can capture the changed string





quail=[]



def empty_switch_and_endswitch_list_locations():
    print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]
def get_switch_and_endswitch_locations(z): #from string z input parameter
	return #this is not called !!!!
	#return we START BUILDING
	#print("thbis is what I am testing now now now")
	#print("  get switch and endswitch locations###  called line 322 #####")
	#print("######get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		
		if "switch" in line and "end" not in line:
			print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		
		else:
			counter += 1 
	
	counter=0
	for line in z.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line:
			#print(line)
			#print("look right here endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1 
		#'''
	#print("at this point this is what we have...after testing BIG YELLOW BIRD go bird")
	del switch_location[0] #takes out first number not needed
	#print("switch_location=",switch_location)
	#print("endswitch_location=",endswitch_location)
	#test_string1exit()
	#print("this over writes the contents of these two lists ")		
	
	#print(z)                #now I remember that is the first switch which doesn't matter
	#print("I deleted the first switch since I'm not bothering with it")
	#print("switchlocations=",switch_location)
	#print("on line 180 endswitchlocation=",endswitch_location)
	
	#print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	
	#print('switch_location=',switch_location)
	#print('endswitch_location=',endswitch_location)
	#the input is above
	




	
	
	##################################################################################
	############## working on this on saturday, october 23rd, 2021 ###################
	##################################################################################
	#print(" rain fall status ")
	counter=0
	
	
	
	counter=0
	print("starting at counter =0")
	
	#print("=============== starbucks morgan hill =====")
	#print(switch_location)
	#print(endswitch_location)
	#print("emptying together pair here")
	del together_pair[:] #delete it just in case to start with clear chalkboard
	#print("=======") #THIS FILLS THE TOGETHER_PAIR LIST OF SWITCH,ENDSWITCH 
	#print("this loop fills the together_pair list of switch,endswitch numbers")
	#print("this is so much dam fun oh yeah")
	total1 = len(switch_location)
	total2 = len(endswitch_location)
	##print("total1 =",total1)
	#print("todal2=",total2)
	#print("this is where we START BUILDING the ===TOGETHER PAIR =====")
	for item in switch_location:
		solution = "[" + str(switch_location[counter]) + "," + str(endswitch_location[counter]) + "]" 
		print("solution=",solution) #to see what it looks like 
		together_pair.append(solution)
		print("counter=",counter)
		counter += 1
		
		#this should prevent stack overflow of the list range added november 9th 
		if counter >= len(switch_location):
			#print("stack overflow called since counter > = len(switch_location)")
			break
		else:
			continue
			
	#print("now we will loop thru the together_pair to see that the pairs are in there")
	del endswitch_location[-1] #should delete 100
	#print("this is what is in TOGETHER_PAIR at line 254")
	for item in together_pair:
		print(item)
		apple = item.split(",")
		#print("======")
		#print(apple[0])
		sweet1 = apple[0].replace("[",'')
		##print(sweet1)
		#print(apple[1])
		sweet2 = apple[1].replace("]",'')
		#print(sweet1,sweet2)
	

	






#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#this accesses coolstring august 5th, 2021
#this is to set the inner switch positions in the main switch input strings
#after the bodies of the nested switches have been stripped out

##########################################
##  put_switch_locations_into_switch_list()  #this is making the nested_switch_ number  
##########################################
def put_switch_locations_into_switch_list(inputstring): #just added param
    #print("##2### put_switch_locations_into_switch_list ###")
    #print("##2## put switch locations into switch list ###")
    #print("put switch locations into switch list")
    #### get swith and endswitch locations called here 
    get_switch_and_endswitch_locations(inputstring) #it's right here 
    #make sure switch_list starts out empty initialized
    if len(switch_list) > 0:
        del switch_list[:]
    else:
        pass
    ##================== this is new jan 3, 2022
        
    for item in switch_location: #this is only going thru switch_location
        switch_list.append(int(item))  #was -1 on here #off by one in the string for some reason
    # print(" ");print("switch_list=")
    #print(switch_list)

#######################################
##  swap_switch_to_nested_method()  #this is making the nested_switch_ number  
#######################################
def swap_switch_to_nested_method(stringname,linenumber,series_num):
	print("============== swap_switch_to_nested_method() ==========")
	str_list = stringname.split('\n')
	#print('changing line',linenumber)
	#series_num = number_series[0] 
	str_list[linenumber] = "\t\t\tnested_switch_" + str(series_num) + "(n)"
	stringname = "\n".join(str_list)
	genius[0]=stringname   #strings are immutable but lists are mutable(changeable)

######################################	

#this is the control center main that runs this operation
#this numbers the nested switch methods top down
#genius[0]=coolstring  #assignment here <<<==================


#######################################
##  loop_thru_switch_locations():
#######################################
def loop_thru_switch_locations(regularstring):  #looping thru  switch_list[10,18]
    #print("##1##loop thru switch locations ## line number 3464 ####")
    #print("##1##loop thru switch locations ######")
    #trick put_switch_locations_into_switch_list
    #method called
    put_switch_locations_into_switch_list(regularstring) #method
    #print('this filles switch_list of switch line numbers')
    #print(genius[0])
   # print("what is the order of the switch_list I think it's reversed to do bottom up")
    #print(switch_list)
    #print("------------")
    #print("switch_list=",switch_list)
    le_number=1 #default numbering nested string 
    for item in switch_list: #loops thru switch_list WITH SWITCH LOCATIONS (LINE NUMBERS)
        print("item in switch_list",item)
        #string,switch,line number
        # swap_switch_to_nested_method here 
        #method this one is the holy grail that actually works
        ###############################
        swap_switch_to_nested_method(genius[0],item,le_number) 
        coolstring =genius[0]
        le_number += 1  #adding to the nested number here
#######################################




##==========================================================|
## swap_nested_switches_with_methods_in_main_switch_string
##==========================================================|
def swap_nested_switches_with_methods_in_main_switch_string(inputstring):
    #print("===swap_nested_switches_with_methods_in_main_switch_string()== line number 309=") 
    loop_thru_switch_locations(inputstring) 
   







#-------------------  july 10th, 2021   11:03 pm  -------starbucks coding-------
#I am hard coding the location of the switch words. I need to have it search on it's own
# but I recall I have code that does that elsewhere
#now I need to find the code that makes the correct nested switch list locations


######======================
#loop_thru_switch_locations() #where to find the inner switches to replace with a nest method
######======================


##================================================================
##===  mission_control() got rid of holiday redundant
##===============================================================
#think of this one as endswitch(x)

def new_mission_control(acase,thestring): #this calls module 1 
    #print("----- first_module stage 1 ----new_mission_control---")
    greenlist[0] = acase
    #added jan 22, 2022============
    neutralize_list(radical_list)
    neutralize_list(quail)
    neutralize_list(stanford)
    neutralize_list(m31)
    #print("the input string to new_mission_control")
    #print("----inside of new mission control the input string is...----==================---------")
    check_if_words_red_white_blue_in_string(thestring)
    
    '''
    if "red" and "white" and "blue" in thestring:
        print("YES GREEN LANTERN red white and blue in string")
    else:
        print("NO RED ALERT no red, blue, white")
    '''    
        
    #for line in thestring.splitlines(): #all correct at this point
    #    print(line)
        
    #print("--------==================---------")
    #print("-----end of input nestedswitch here-----")
    clear_switch_number_lists() #before just clear them
    new_phase_one_of_nested_switches_procedures(thestring) #calls make switch pairs and separate strings
    thestring=''
    #print("ending this after calling mission_control")
    #print("this produces the contents of switch strings in the quail list")
    #for item in quail:
    #    print(item)
    #    print('============')  

#===============
#print("stopping it right here for good measure at starbucks in hollister")

##########========
##================
def empty_these_lists_now():
    for item in stanford:
        stanford.pop()
    del stanford[:]
    #delete lists here with a function call
    #print("attempting to empty the relevant lists now")
     #this should show the list status after emptying them
    del sfo_pairs[:]
    del gold_list[:]
    #=================
    for x in gold_list:
        gold_list.remove(x)
    for x in gold_list:
        gold_list.pop()
    ##================
    for x in sfo_pairs:
        sfo_pairs.remove(x)
    for x in sfo_pairs:
        sfo_pairs.pop()
    ##===============
    del real_switch_numbers_to_transfer[:]
    for x in real_switch_numbers_to_transfer:
        real_switch_numbers_to_transfer.remove(x)
    for x in real_switch_numbers_to_transfer:
        real_switch_numbers_to_transfer.pop()
    ##===============================
    # christmastree
    del christmastree[:]
    for x in christmastree:
        christmastree.remove(x)
    for x in christmastree:
        christmastree.pop()
    clear_lists()
    after_running_code_list_status()



def clear_lists(): #added jan19th 
	#print("----- clear_lists()---called---")
	del quail[:]
	del stanford[:]
	del together_pair[:]
	del switch_location[:]
	del endswitch_location[:]
	lovely[0]=''
	greenlist[0]=''
	del switch_numbers_to_transfer[:]
	del thenumbers[:]
	del switch_location[:]
	del snowtime[:]
	varholder[0]=''
	num=''


#end function=======================
def show_these_lists_at_bottom_after_a_run():
    #print("show these lists at bottom after a run()....=====")
    #print("first I will delete these lists...")
    holding_string[0] =''
    pobox[0] = ''
    holding_themax[0]=''
    goldtime[0]=''
    #for item in switch_numbers_to_transfer:
  
    del switch_numbers_to_transfer[:]
    for x in switch_numbers_to_transfer:
        switch_numbers_to_transfer.remove(x)
    for x in switch_numbers_to_transfer:
        switch_numbers_to_transfer.pop()
        
    #neutralize_list(columbia_river)
    del columbia_river[:]
    for x in columbia_river:
        columbia_river.remove(x)
    for x in columbia_river:
        columbia_river.pop()
    
    neutralize_list(listinput)
    holding_string[0]=''
    #print("holding_string[0]  =",holding_string[0])
    #print(" pobox[0]=", pobox[0])
    #print("crud switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #print("columbia_river=",columbia_river)
    #print("holding_themax[0",  holding_themax[0])
    #print("listinput", listinput)
    #print("goldtime[0]", goldtime[0])
    #neutralize_list(addthis)
    del addthis[:]
    for x in addthis:
        addthis.remove(x)
    for x in addthis:
        addthis.pop()
    
    
    neutralize_list(breakposition)
    neutralize_list(cherish)
    ##=======
    neutralize_list(combined_tabs_jazz)
    neutralize_list(fallthrulocations)
    neutralize_list(friend1)
    neutralize_list(fruits)
    neutralize_list(getfirstword)
    neutralize_list(got_the_number) 
    neutralize_list(greenmilelist) 
    neutralize_list(gti)  
    neutralize_list(homer)
    neutralize_list(listofbreaks)
    neutralize_list(nested_switch_data)
    neutralize_list(woodstock)
    neutralize_list(thenewpairs)
    neutralize_list(blueberries)
    #neutralize_list(smart_switch_numbers)
    del smart_switch_numbers[:]
    for x in smart_switch_numbers:
        smart_switch_numbers.remove(x)
    for x in smart_switch_numbers:
        smart_switch_numbers.pop()
    #print("smart_switch_numbers=",smart_switch_numbers)
    #neutralize_list(smartlistlocations)
    del smartlistlocations[:]
    for x in smartlistlocations:
        smartlistlocations.remove(x)
    for x in smartlistlocations:
        smart_switch_numbers.pop()
    #print("smartlistlocations=",smartlistlocations)
    neutralize_list(snowman)
    neutralize_list(test_string1)
    neutralize_list(test_string2)
   
    
#bypass205 is way down here weird
#====================
#   bottom_stages
##====================
def bottom_stages(num,mystring): #calls concat_items_in_list() and exec(string)
    switch_numbers_to_transfer=[] #just in case zap it clean
    show_quail_and_stanford_lists()
    check_if_words_red_white_blue_in_string(mystring)
    new_mission_control(num,mystring)  #hard coded with 1 for now
    ###################################
    show_quail_and_stanford_lists()
    y='' #y is empty here 
    ########== module 2 ==##########################
    total=''
    total = len(snowtime) + 1
    bypass205(y) ##<<<<-=============================bypass205()
    show_quail_and_stanford_lists()
    ########== module 3 ==############################
    create_def_switch_methods_concatted_together_in_one_string()
    ####################################
    topvalue[0]=greenlist[0]
    sly = greenlist[0]#1 #topvalue[0]  ===== just changed this on january 18th
    concat_items_in_list(sly)#this builds the concatted string superball
    lovely[0]=greenlist[0]#1 was lovely[0] = 1
    ########EXECUTION HERE ##############################
    show_quail_and_stanford_lists()
    exec(superball, globals())  #this EXECUTES THE CODE HERE  
    ### added these two lines on january 30th. All I am trying to do is empty the list 
    quail=[]
    stanford=[]
    columbia_river=[] # need to know exactly which lists feed into quail (that's the issue)
  
    switch_numbers_to_transfer=[]
    real_switch_numbers_to_transfer=[]
    thenumbers=[]
    #print("length of switch_numbers_to_transfer",len(switch_numbers_to_transfer))
    
    del testlist_of_strings[:]
    del fancy_new_car[:]
    fancy_new_car.clear()
    for item in fancy_new_car:
        fancy_new_car.pop(0)
    #print("length of fancy_new_car=", len(fancy_new_car))
    #print("fancy_new_car=", fancy_new_car)
    ###########==================
    #print("deleting list contents and showing that they are empty now")
    after_running_code_list_status()
    empty_these_lists_now()
    #new added january 21st
    neutralize_list(super_listinput)
    # print("super_listinput=",super_listinput)
    neutralize_list(add_tab_depth)
    #print("add_tab_depth=",add_tab_depth)
    neutralize_list(listinput)
    neutralize_list(super_listinput)
    #print("add_tab_depth=",listinput)
    #print("add_tab_depth=",super_listinput)
    neutralize_list(switch_numbers_to_transfer)
    #print("hello switch_numbers_to_transfer=",switch_numbers_to_transfer)
    ##========================
    neutralize_list(result_of_first_method)
    neutralize_list(result_of_second_method)
    neutralize_list(result_of_third_method)
    neutralize_list(result_of_fourth_method)
    ######
    #print("===========")
    #print("radical_list=",radical_list)
    neutralize_list(radical_list)
    #print("radical_list=",radical_list)
    #print("m31=",m31)
    neutralize_list(m31)
    del snowboarding[:]
    # print("snowboarding=",snowboarding)
    #print("m31=",m31)
    #print("now for the Grand finally===>>>>")
    #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #show_these_lists_at_bottom_after_a_run()
    #print("smart_switch_numbers=",smart_switch_numbers)
    #neutralize_list(smartlistlocations)
    #print("smartlistlocations=",smartlistlocations)
    for x in smart_switch_numbers:
        smart_switch_numbers.pop()
    del smart_switch_numbers[:]
    #print("smart_switch_numbers=",smart_switch_numbers)
    
    for x in smartlistlocations:
        smartlistlocations.pop()
    del smartlistlocations[:]
    #print("smartlistlocations=",smartlistlocations)
    show_quail_and_stanford_lists()
    #print("contents of smartcasemanager=",smartcasemanager)
    
    #print("see if this helps empty it smartcasemanager")
    #for item in smartcasemanager:
    #smartcasemanager.pop()


  

###########
###########
###########

wilson=[]
#print("wilson=",wilson)
#print("wilson length=",len(wilson))
#so if len(listname) == 0 then print nothing


##=====================================================================
## check_if_lists_switch_numbers_to_transfer_and_thenumbers_are_empty():
##======================================================================
#created on jan 22nd 2022 saturday morning morgan hill
def check_if_lists_switch_numbers_to_transfer_and_thenumbers_are_empty():
    #print("=========checking if list switch_numbers_to_transfer is empty=======")
    if len(switch_numbers_to_transfer) > 0:
        #print("==RED==ERROR switch numbers to transfer is NOT empty")
        #print("pleaseswitch_numbers_to_transfer=",switch_numbers_to_transfer)
        #print('will now proceed emptying it')
        neutralize_list(switch_numbers_to_transfer)#should empty it
        #print('after neutralizing the list we have: should be empty now')
        #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
        #print("now..[GREEN]")
    else:
        pass
        # print("[GREEN]  switch_numbers_to_transfer list is empty good")
        #print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #####===============================================
    #print('checking if list thenumbers is empty')
    if len(thenumbers) > 0:
        #print("==RED==ERROR thenumbers is NOT empty")
        #print("thenumbers=",thenumbers)
        #print("will now proceed emptying it")
        neutralize_list(thenumbers) #should empty this list
        #print("after neutralizing the list we have should be empty now")
        #print("thenumbers=",thenumbers)
        #print("now [GREEN]")
    else:
        pass
        #print("[GREEN] thenumbers is empty good")
        #print("thenumbers=",thenumbers)
        
    #print("end of test of lists switch_numbers_to_transfer and thenumbers")

#I will ahve the endswitch down here which will be the main for calling the sequence list here.
#############################=========================
##  main_control_sequencer()
##############################=========
num =''
def main_control_sequencer(num,mystring):#====================
    #add 1 to pass counter
    
    #attempting to clear the lists 
    passcounter[0] += 1 #this is where the counter resides and is added too. 
    #print("----------===== main_control_sequencer()=====-----")
    
    switch_numbers_to_transfer=[] #should delete it starting out
    real_switch_numbers_to_transfer=[]
    real_switch_numbers_to_transfer=[]
    thenumbers=[]
    snowtime=[] #make sure this sucker is emptied
    result_of_first_method=[]
    result_of_second_method=[]
    result_of_third_method=[]
    result_of_fourth_method=[]
    radical_list=[]
    smart_switch_numbers=[]
    testlist_of_strings=[] #just added this today
    columbia_river=[]
    stanford=[]
    quail=[]
    smartlist=[]
    # print('right here when we start what do we have to see')
    #     print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
    #     print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #     print("real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
    #     print("thenumbers=",thenumbers)
    #     print("snowtime=",snowtime)
    #     print("result_of_first_method=",result_of_first_method)
    #     print("result_of_second_method=",result_of_second_method)
    #     print("result_of_third_method=",result_of_third_method)
    #     print("result_of_fourth_method=",result_of_fourth_method)
    #     print("radical_list=",radical_list)
    #     print("smart_switch_numbers=",smart_switch_numbers)
    #     print("testlist_of_strings=",testlist_of_strings)
    #     print("columbia_river=",columbia_river)
    #     print("stanford=",stanford)
    #     print("quail=",quail)
    #     print("smartlist=",smartlist)
    #     #added this on jan 22nd to clear out mystring bug
    #     ###===============================================
    #     print("==defensive programming ===============///=============")
    #print("at the beginning of a new nested switch verifying that")
    #print("thenumbers list and switch_numbers_to_transfer are empty")
    #check_if_words_red_white_blue_in_string(mystring)
    #print("and if not then automatically emptying them both")
    check_if_lists_switch_numbers_to_transfer_and_thenumbers_are_empty()
    #if the lists are not empty they get emptied here; they are tested separately
    #print("=================///=================///=============")
    
    sliver=''
    pobox[0]= mystring
    sliver = pobox[0]
    #print(" in main control sequencor the input string is")
    #print("=======0=0=0=0=0=0=00=0========")
    #for line in sliver.splitlines():
    #    print(line)
        
    mystring=''
    #bottom_stages called here #this is the method that does it all above 
    bottom_stages(num,sliver) #and calls bypass205 just before it too
    num=''
    mystring=''
    sliver=''
    

   
##############
#print("doing testing now....")
#num = 1#1    
#main_control_sequencer(num,red_robin)#red_robin  #this will be the the modifed endswitch eventually 

#####################
# this simulates endswitch(string) that will be called above this in actual code
##==============
 #this will be the the modifed endswitch eventually 
# this simulates endswitch(string) that will be called above this in actual code
##==============

#num = 8    
#main_control_sequencer(num,red_robin)



#main_control_sequence()