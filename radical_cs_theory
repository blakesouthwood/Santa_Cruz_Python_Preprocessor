
Dijkstra: "A Program is an Implementation of a Design"
Peris: "I want a programming language where I say what I want done."

Theory: Bypass communicating with the computer directly and don't use the programming language but
instead, attack communication by going through the design level interface program with abstraction levels and a deep
a knowledgebase  using Chat GPT and in English describe running function behavior. 
The code that is generated is running pseudocode (so it's human readable) which runs and uses methods
and macros. The pseudocode is structured and converted to a sequence of small reusable methods like the 
DNA sequence that creates the internal behavior of all functions to create the desired dynamic 
behavior. This promotes reuse and involves less thinking. There will be a pseudocode debugger too.


I wanted to be able to build the same project that I just coded in Python which
took me two years to design and build it in a week instead. What I meant is 
I just want to design it. I don't want to code it at all. I want the code 
completely generated. Oh I want to be able to design the program with an interactive tool
that uses AI to assist me. I just want to describe what each function needs 
to do when it runs but now how to make the function work internally, because 
I shouldn't have to think at that level anymore. This solution will use GPT.

I recently wrote a switch case for python and macros and it works
using a preprocessor. After completing this project I realized that
there needed to be a better way to code. 

I have been playing around with Chat GPT and Gemini and previously
I used to look up how to do a behavior on stack overflow.

My theory is this: Bypass communicating with the dumb machine that can't learn
and don't use the programming language to write functions. Instead what we do is
go through the design side with abstraction levels and we can have human knowledge
programmed in using fuzzy logic or AI such as  Chat GPT and describe the running behavior
desired that we want to create (LET ME SAY THIS AGAIN WE DESCRIBE THE DYNAMIC BEHAVIOR THAT
THE FUNCTION CREATES) or for diehards  use a methodized pseudocode language with macros 
that runs and this pseudocode language calls a sequence of methods that work that create the 
behavior of the pseudocode which is the internal behavior. So we don't ever have to think
at the boolean logic level to compose pseudocode and then in the programming language
if we don't want to.

So this then creates a dilemma. The computer doesn't know what a behavior is. But at the
design level we can describe behaviors. The issue is when we create behaviors we forced 
to think at the machine level of nothingness and use pseudocode as the blue print for 
creating internal behavior that is in boolean logic with no verbs to create the effect 
of the dynamic behavior of a function.

What is programming? It is communicating how to create behavior in functions that tells the
dumb unlearning computer how to create the dynamic behavior THAT IS NOT DESCRIBED.

I have been chatting with Chat GPT for a week hashing out the merits of this theory since
there will be doubters. Here is the log of the discussions.




