#this actually works dec 31st, 2021 11:17am PST California, Menlo Park
# Blake Southwood Software Engineer 

from starship import *
from starship import switch_numbers_to_transfer
from starship import radical_list  
#this is what was filled from quail in starship after chain methods modifies the input switches

#####==========================================
##=============================================
#import official_switch_case_silver
#from official_switch_case_silver  import *  
print("top of rudolph.py ")
print(" ")
stanford=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
def message_from_Woodstock():
    print('hello from Woodstock the bird file')
    
message_from_Woodstock()

#print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

endswitch_location=[]
switch_location=[]

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]

# december 29th fun
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 
xred_robin ='''
	switch(exp){  
		case 1 thru 3: #in rudolph dec 30th test
			print("where\'s off to mars!")
			print('first prize')
			print('you bad ass coder Charlie Brown christmas')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp)  
				case 'blable':
					print("do inside of sw itch 11")
					####################
					switch(exp){ 
						case 'tahoe':
							print("do inside of sw 15")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){    
								case 'tahoe':
									print("do chinquapin")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			#exp = 3
			switch(exp)
				case 'burger':
					print("do something")
					####################
					switch(exp){   
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch
			##############
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')
}
'''	
##======================== massive dirt simple test to make sure it totally work s=======
waffles ='''
	switch(exp){  
		case 1 thru 3: 
			print("to the moon Alice!")
			print('first prize')
			print('Charlie Brown and Snoopy flying against Red Baron')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp)  
				case 'blable':
					print("we are inside of sw 11 now wildness")
					
					print("I just typed this like Snoopy")
					result[0]="snoopy"
					fallthru
				case 'more':
					print("and this fell thru from snoopy above")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
	endswitch
'''
#trying a simple one to see what happens
#for testing exp = 1


### wednesday december 29th, 2021 10:02 am ====DECEMBER 29TH WEDNESDAY ADDITION ==========================
###### this will be called from imported starship file
##==================================================================
inputstring=''
inputstring = waffles # red_robin # red_robin 

print('THIS IS INSIDE OF RUDOLPH - WE IMPORTED  starship.py ')
print("=====================dec 31st friday coding ==== must solve the bug ======")
print("===this chops up the big switch into individual switches and ====")
print("===then runs each switch string thru chain methods to prepare it for the parser in bypass205()=====")
print('......')
convert_nested_switch_string_to_strings_in_quail_list(inputstring) #from starship

thenumbers=[]
for item in switch_numbers_to_transfer:
    thenumbers.append(item)

print("these are the switch nubmers to tranfser in the numbers")
for item in thenumbers:
    print(item)    
real_switch_numbers_to_transfer=[]
for item in switch_numbers_to_transfer:
    real_switch_numbers_to_transfer.append(item)

print("what was just imported and saved is real_switch_numbers_to_transfer from starship")
print(" we have",real_switch_numbers_to_transfer)
print("...")
#exit()


print("the switch numbers to transfer are..",thenumbers) #this is a dependency   
print("these numbers are from starship")
#creating churchill list
churchill=[]
#if I don't use a whole string to start to split up and create individual switches
# and send thru the chain methods then the switch_list_to_transfer is not calculated.

print(" ")
print("these are the switch_numbers_to_transfer ")    
print("thenumbers=",thenumbers)
for item in thenumbers:
    print(item)
print("this is radical_list of switch strings after chain methods ...")
print("================ nearly 2022 =====")
print("loop thru radical_list")
for item in radical_list:
    print(item)
    print("===========")
print("========.=..=.this is where the STARSHIP DATA COMES BACK HERE =.=.=.=.=.=.=.=.=.=.====")    
del quail[:]
for item in radical_list: #from starship list which is really quail
    quail.append(item)
print("===quail list in rudolph now ==from starship data=======")
print("this is what is in quail made by starship from radical_list to quail")
for item in quail:
    print(item)  
    churchill.append(item)  #quail substitute list is churchill
    ###========================================================================================
    #I need to compare the generated chain methods output in quail with gold1 - 7 to get diff 
    #to figure out why the actual code generated is off slightly
    ##==========================================================================================
    print("- - - - - - - - - - - - - -")
print("end of quail list looping inside of rudolph file")
print("end of looping ...")
print("this is running inside of rudolph did it work or not??")
print('end of first attempt to fill up quail list with switch strings prepped')
del stanford[:]
print("length of stanford =",len(stanford))
#exit()
##=================================================================
## and right here I will have the list of generated prepped strings
## in quail list so I need to declare quail list abobe this section obviously.
#  after filling the quail list here I need to print it out to verify that
#  it has filled the quail list with the input string red robin above
#  has been correctly separated  like down below already has


#then at the bottom I will comment out the gold1 thru gold7 strings
#which are put into the quail list as the starter though I will do those first
#to continue testing this 

 ##==============================================================   
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	#print("### must work now ###get switch and endswitch locations########")
	#print("####3##get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#right here going thru input string look for switch and endswitch
		#and append the line number to either switch_location or endswitch_location
		if "switch" in line and "end" not in line:
			print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		elif "endswitch" in line:
			print("endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1
			
			
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	print(z)                #now I remember that is the first switch which doesn't matter
	#print("I deleted the first switch since I'm not bothering with it")
	print("switchlocations=",switch_location)
	print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	#print("this is how many nested switches are here")
	#print("now we should have this many nested switches to contend with",answer)
	#print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
		print("endswitch locations =",endswitch_location)
		#print("out of curiosity print the number of endswitches", len(endswitch_location))
	else:
		pass
		
	#print("this might be simpler to test and use actually======/////???????//////===")
	#print("======================================")
	#print(" ===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === ")
	#print("I need to delete teh first swithc location")
	
	#del switch_location[0] #ALREADY DELETING FIRST SWITCH ABOVE BECAUSE IT'S NOT NEEDED NOT NESTED
	#print('switch_location=',switch_location)
	#print('endswitch_location=',endswitch_location)
	
#print("testing getting switch and endswitch locations")
#get_switch_and_endswitch_locations(red_robin)	
#exit()
	
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	
	
	
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location
smart_rat=[]
string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
#print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
#print(string)

#print("end of test from the web")
#print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced
old_coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block orange head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru

		default:
			print('the end')
}
'''

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
mocha_nested_switchtest ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Chuck Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 


# october 11th, 2021 
#testing texas here to do what I want

#print("TEXAS TEXAS TEXASbig horn test===")
#print("this adds line numbers to switch and makes a list of nested switch combos")
#print('quick test adding line numbers to switch and endswitch')

sweetlist=[]
holdinglist=[]; holdinglist.append(0) #to create slot 0
boomerang=[];   boomerang.append(0)
#def get_switch_parents()

#print("modifying red_robin string as texas to add comment of switch linenumbers and capturing")
#print("the nested switches within it at each juncture too.")
#print('testing TEXAS TEXAS TEXAS ====')
# I need to do a second pass and modify this just modified 
# texas string to show it's inner switch line numbers

##============================================
##  modify_string_before_splitting_it_up():
##============================================
def modify_string_before_splitting_it_up(inputstring):
   
    #print("texas string first")
    #for line in texas.splitlines():
    #    print(line)
    #print("=========================") 
    counter =0    
    #print("modify_string_before_splitting_it_up():")
    craftline =''
    for line in inputstring.splitlines():
        if holdinglist[0] == 0: #this compendates for the first one
            holdinglist[0] = '1' #ASSIGN JUST ONE EQUAL
        else:
            boomerang[0]= holdinglist[0]
    
        if "switch" in line and "end" not in line: #this eliminates endswitch confusion
            tabcount=line.count("\t")#                                   line number          tab count 
            if tabcount == 3: #this compensates for 2nd nested switch at 3 tabs
                boomerang[0]='1' #representing parent switch 
            else:
                pass
            if tabcount == 3:
                boomerang[0]= '1'; #assignment only use one = 
            craftline += line.replace("switch(exp){","switch(exp){ # "+str(counter)+":" + str(tabcount) + " "+"parent switch=" + str(boomerang[0]) + "\n")
            holdinglist[0]=  str(counter)
            #I need to add this to the special dictionary now
            #put it into a list first
            sweetlist.append([counter,tabcount,boomerang[0]])
            counter += 1
        else:
            craftline += line + "\n"
            counter += 1
    #print("this is the output test revisiting this on November 2nd, Tuesday")
    #print(craftline)    
    #print('end of test......... monday morning blues ')  

#modify_string_before_splitting_it_up()

listinput=[]



'''
print("===================")
print("line #, Tabs, parent sw")
#for item in sweetlist:
#    print(item)
#print('------------')
dunkapple=[]
#dunkapple.append(0) #leave empty
for item in sweetlist:
    #print(item)#0,1,2   this line, tabs, parent(previous switch)
    #print("accessing each one with control now")
   # print(item[0]) #11
   # print(item[1]) # 3 tabs 
    #print(item[2]) # 1 
    super=[item[2],item[0]]
   # print(super)
   # print("==============")
    icetea=[item[2],item[0]]#1,11
    dunkapple.append(icetea)
#I am doing the opposite.
#print("I need to have what nested switch is inside of a switch")
    
#go thru sweet list make list pairs for the parent and it's children
#print("looping thru correct order now===== time for pumpkins")
#for item in dunkapple:
#    print(item)
#    print(item[0],item[1])
#output
'''

'''

#
# we have 1,11 and 1,49  so two inner switches
#
# so it would be in main switch 1 and then 11,49
#

#print("I'm making this so only one tab difference")     
#print("sweetlist=",sweetlist)    
#here is september 18th saturday coding candy
#print("now we have list in dunkapple parent switch and it's nests")
#print(dunkapple)
#print('looping thru dunkapple........')
counter=0
ghostlist=[]
for item in dunkapple:
    #print("we have",item)
    #print(item[0],item[1]) # I could fill a new list with all of item[0]and test if number in list
    ghostlist.append(item[0])
    if item[0] == '23': #this looks for 15
        #print("small victory")
        test = True
    else:
        #print('nope not there yet')
        test = False
        
    counter += 1
    if counter >= len(dunkapple):
        break
    else:
        continue
        
        #now see if there is more than one nested switch like in 1
        
        
# I would skip the first item in the list 1, 1,1 it's useless and unnecessary 
#print('new test if numbers in this first item list of pair')
if '23' in ghostlist:
    pass #print("yes 23 in there in ghostlist")
else:
    pass #print("nope not in there")
    
if '53' in ghostlist:
    print("yes 53 in there in ghostlist")
else:
    print("nope not in there")

if '49' in ghostlist:
    print("yes 49 in there in ghostlist")
else:
    print("nope not in there")            
print("dunking for apples")
print('test if 23 in item[0]=',test)

#for item in dunkapple:
#    print(item,counter)
 #   #fun = split.item
 #   counter += 1
        



#print("and then the switches with no nests") 
#print("if number in second slot and not ever in first slot it's a single")

#need to figure out how to add these automatically
#print([23])
#print([53])   
#print('===== youtube time =====')
switchnumbers=[]
tabslist=[]
switchlinenumbers=[]
peach_data=[]



#at this point peach_data should already be filled
#testing determine what switches are parent-child by tab and sequence
# so 
#print("testing access of data after filling peach_data")
#peach_data[1]= ['1', '1', '1']
#peach_data[2]= ['2', '11', '3']
#peach_data[3]= ['3', '15', '5']
#peach_data[4]= ['4', '23', '7']

isnt_this_pretty='nada'
pattern_input=[]
pattern_input.append('0')
pattern_input.append('0') #[1] patterninput[1]
pattern_input.append('0') #[2] patterninput[2]

##============================
##  input_tab_combo(x,y):
##=============================
def input_tab_combo(x,y):
    #print("====== input_tab_combo(===", x, y)
    pattern_input[1]=x #5
    pattern_input[2]=y #7

porsche_carerra=[]
capture_switch_lines_nested=[]

##============================
##  access_row_in_peach_data(x)  #after it's already filled 
####==========================        
def access_row_in_peach_data(x): #return what has 3 :5 pattern of tabs
     #print("access_row_in_peach_data",x)
     #print("................................")
     #print("................................")
     
     #print("access row in peach data() called")
     #print("====....= why are they remaking Twister movie ===...===......=====....===000055555======")
     #print("input param =",x)
     #if peach_data[2][2] == '3':
     counter =0
     #print("let us look and see what is in peach_data")
     #for item in peach_data:
     #    print(item)
     #so by design the switch number is the same for first slot
     get_length= len(peach_data)
     #print("the length of peach_data =", get_length)
     #print("=======")
     #now accessing already filled matrix
     #loop thru peach_data and flag peach_data[number][x] and [x + 1]
     # so compare 2 at a time initially if x == 3 and x + 1 = 5
     #this looks for a 3 5 pattern in peach_data
     #print('testing a comparision for 3 5 pattern')
     #print("about to do boolean logic check for 3 and 5 pattern")
     #print('the machine sees')
     
     #test if sequence ===========================================
     #x = 2
     #these are numbered numerically down so this is obvious
     #print("simple sequence test in peach_data")
     #if peach_data[x][0] == '2' and peach_data[x+1][0] == '3':
     #   print(peach_data[x][0])    # x=2
     #   print(peach_data[x +1][0]) # x=3
     #else:
     #   print("what it didn't work")
     #print("=== ending simple sequence test ===")
     #print("tryin gto avoid this mess")
     #print(isnt_this_pretty)
     
     #print('starting with x for loop thru peach_data',x)
     # loop 
     x = 1 #hard coded as 1 for now
     #this is a loop here 
     for item in peach_data:
        #print("these determines if reaching end of peach_data list and bails")
        ###======= this ends the loop if x = get_length or get_length-1 =======
        #print('value of input x now is..',x)
        #this is to break out of the peach_data loop for fail safe
        ###############################################
        # this is safety to jump out of loop to avoid out of range error 
        if x == get_length or x == get_length-1: #so it's not hard coded with 4
            #print("bailing reached end of peach_data list")
            break  ##<< === break here to bail from loop 
        else:
           # print("===========")
            #print("everything is still good to proceed")
            #print("===========")
            pass
        
        #print("=============")
        #to find the 3 5 pattern of tabs comparing 
        #print('this is new monday, sept 20th, 2021 testing so I can change the input vars')
        
        #print('practice')
        #needto return the switch line number 
        #print(pattern_input[1])
        #print(pattern_input[2])
        #print('end of putting data into list for juggling on the fly')
        #=====hard coded test =======================================
        #if it searching starting from peach_data[2] which is the 2nd switch
        #print("first comparision =", peach_data[x][2])
        #print(" second comparision =",peach_data[x +1][2])
        #print('for this if the x input =',x)
        #print("================================") #do I need to do 3,5,3 or just 3,5
        #if peach_data[x][2] == 3 and peach_data[x =1][2] == 5:
        #del capture_switch_lines_nested[:] #this was inside loop here now for testing
        
        if peach_data[x][2] == pattern_input[1] and peach_data[x +1][2] == pattern_input[2]:
            #print("THIS WORKED using pattern_input[1] and pattern_input[2]")
            #print(" PORSCHE time and Tahoe castle")
            #print("yes a 3:5 pattern found")
            #then return their line numbers
            #x = 2 in this example tryin to retrieve 11,15 line numbers
            #print(peach_data[x][1] + " " + peach_data[x + 1][1])
            alpha1 = peach_data[x][1]; alpha2= peach_data[x +1][1]
            #print("these should be the line numbers 11 and 15 how we manage and track switches")
            #print("so we have ", alpha1, "and ",alpha2)
            ### print this is new 
            porsche_carerra.append([alpha1,alpha2])
            #del capture_switch_lines_nested[:]  # comemnted out to see what happens
            capture_switch_lines_nested.append([alpha1,alpha2])
            #print("what do we see here...the switch line numbers for 3, 5")
            #print(capture_switch_lines_nested[0]) ##======
            badass = capture_switch_lines_nested[0]
            #print('the name of the list of switch lines parent and child')
            #print("capture_switch_lines_nested[0]",capture_switch_lines_nested)
            
            #print("testing this.")
            #print("right here line 457 we have ", capture_switch_lines_nested)
            #print("let it be right")
            
            #copy contents for later
            #coolwhip =capture_switch_lines_nested[0] 
            #smart_rat.append(coolwhip)
            #print("smart_rat has ..",smart_rat)
            #print(smart_rat)
            #then take out duplicates
            
            
            #for item in capture_switch_lines_nested:
            #    smart_rat.append(item)
            
            one = badass[0]
            two = badass[1]
            #print("one=",one)
            #print("two=",two)
            #print("end of this bunny show")
            #print("what is in smart_rat list")
            #print(smart_rat)
            #print(":.........")
            x += 1
            #print("x here is",x)
            #print("get_length of data of peach_data=",get_length)
        else:
            #print("no joy")
            x += 1  #adding 1 to input x bottom of loop
            
     #print("here we have ",capture_switch_lines_nested) 
     #print("above this should be 2 lists 2 sets of numbers")
     #this fills smart_rat with the item sfrom capture switch lines nested
     for item in capture_switch_lines_nested: 
        smart_rat.append(item)
     #print("gold medal time finally...")
     #print(smart_rat) 
     counter =0
     for item in smart_rat:
        #print(item)
        a1 = item[0]
        a2 = item[1]
        #print(a1)
        #print(a2)
     #print(":==============")
   
     #if pattern 3:5 and sequence is a, b= a + 1
     #   get line numbers peach_data[2][1]
     #   peach_data[3][1]
##============================
##  look for 3 5 pattern()
##============================    
def look_for_3_5_pattern():  #result 11,15 and  49,53
    #print("===== look for 3 5 pattern ===")
    input_tab_combo('3','5')
    #print("look for 3 5 pattern of tab depth and return switch sequence numbers")

##============================
##  look for 5 7 pattern()
##============================     
def look_for_5_7_pattern():
    #print("===== look for 5 7 pattern ====")
    input_tab_combo('5','7')
    #print("look for 5 7 pattern of tab depth and return switch sequence numbers")
    
plums=[]
plums_data=[]
endswitchlinenumbers=[]
endtabslist=[]

#print("did we make it here......")
##=============================================================
## magic_potion   saturday september 18th, 2021 time 11:14 am
##=============================================================
def magic_potion(inputstring):
    #print("============== magic_potion() called ============")
    #print("================....===========")
    #print("  ===== switch matrix adding...")
    #for line in inputstring.splitlines():
    #    print(line)
    #switch_count=0    
    switch_count = 0 #for first
    #switchlinenumbers.append(0) #skips 0 not counted
    counter =0
    newstring='data on analyzing a multinested string to number the switches and tabs' + "\n"
    collosal=''
    print("This  finds the switch locations ----")
    for line in inputstring.splitlines():
        if "switch" in line and "endswitch" not in line:
            print(line)
            tabsnow= line.count("\t")
            tabslist.append(tabsnow)
            switchlinenumbers.append(counter)
            switch_count += 1
            bump =''
            if tabsnow == 1:
                bump = " "
            else:
                pass
            newstring +=  "sw_order_num= " + str(switch_count) + " " + "switch_line=" + str(counter) + bump + " tabs =" + str(tabsnow) +  "\n" 
            collosal = [str(switch_count),str(counter),str(tabsnow)]
            peach_data.append(collosal)
            counter += 1
        else:
            #newstring += "\n"
            counter += 1
    #del switchlinenumbers[0]        
    #print("switchlinenumbers",switchlinenumbers)
    #print("tabslist=",tabslist) 
    #print("now we will print out what it sees")
    #print("switch counter,switch line number,tab length")
    #print(peach_data)
    # print("=======")
    #print("insert 000 in first data ")
    peach_data.insert(0,[0,0,0]) #this is to eliminate computer math with 0
    # for item in peach_data: #already filled
    #    print(item)
    
    #print("show first row now")
    ##################
    ##################=====
    #=======================================
#print("============== experiment ==== sep 28th =2021 making the pairs ===")
#print("and stacking switches and endswitches by tab depth.")
#print("this only does 3 tab depth")

#switch_lines=[]
'''

'''                
#make_parent_child_set(red_robin)

def little_test():
    print("little test here")
    number = 2
    if number in range(1,4):
        print("yes ",number, " it's in the list")
    else:
        print("no number ", number, " not  in list")

#little_test()

'''



#this builds the pairs of switch endswitches by tabs since they ahve to be lined up
#from the switch down to the endswitch in the same tab depth 


'''
#NOTE:
def little_method(fivetabs):
  for item in tabsubs:
    fivetabs.append(item) 
  del tabsubs[:] 
'''
        
## loops thru tabsubs and appends item to tabcount
#=========================
#  little_method(tabcount)            
#=========================
def little_method(tabcount): #threetabs example is the param here in tabcount
    #print(" little_method() called")
    for item in tabsubs:
        tabcount.append(item)
    del tabsubs[:]
        
        
        
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

  
  
  


###=============================== 
 
        #del tabsubs[:] #should clear it
###=================
rattabs=[]
##==== goldmedal test()  this just does threetabs 
def goldmedaltest(): #this makes stacks column switch endswith for 3 tabs
	#print("=======goldmedal test=== this one is correct== its gotta work now please ---")
	inputstring = waffles #red_robin
	#print("original working code for 3 tabs that worked previously")
	counter =0
	for line in inputstring.splitlines():
		#print(line)
		#######################
		tab_length = line.count("\t")
		if tab_length != 3 or "switch" not in line:
			counter += 1;continue
		#######################
		if tab_length == 3:
			if "switch" in line and "end" not in line:
				#print("if switch called")
				#print("======switch in line===")
				rattabs.append(counter)
				#print(rattabs)
				counter += 1;continue
			if "endswitch" in line:
				#print("if endswitch called")
				#print("======endswitch in line======")
				rattabs.append(counter)
				#print(rattabs)
				counter += 1; continue

#print("result of goldmedal test =")
#goldmedaltest()



#was in experiemntal machinery below
'''
    for line in inputstring.splitlines():
        print(line)
        tab_length = line.count("\t")
        if tab_length != 3 or "switch" not in line:
            counter += 1;continue
        ##################
        if tab_length == 3:
            if "switch" in line and "end" not in line:
                print("if switch called")
                print("======switch in line===")
                dumbtabs.append(counter)
                print(threetabs)
                counter += 1;continue
            if "endswitch" in line:
                print("if endswitch called")
                print("======endswitch in line======")
                threetabs.append(counter)
                print(threetabs)
                counter += 1; continue
    print("this one blast time for 31 flavors THIS IS THREE TABS === ---")
    print("threetabs=",threetabs)
'''
    
    
    
    
    
#print('testing the internal machinery method engine now')
#threetabs=[]
#endtabslist=[]
#endswitchlinenumbers=[]
#dumbtabs=[]
##==============================
##  experimental_machinery uses internal_machinery method
##===============================
def experimental_machinery(x,inputstring):
    #print("======experimental_machinery called==========")  
    counter =0
    newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    #print(newstring)
    internal_machinery(x,inputstring)
 
    ###============
    #switches and endswitches at 3 tabs should be even number
#print("dumbtabs =",dumbtabs)

#print("== bees ==== this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring) ====")
#print("try_all_three(inputstring)")
#print("=====halloween ghosts trying all three 3 5 7 tabs now====")
#print(" === to the moon when will starship land ===")
#print("======= TESTING NEW CODE HERE WEDNESDAY to get the larget tab depth in string")
# this determines the highest tab count for a line with a switch
# which is used to create the listinput list

#try all three()  Did this one on Wednesday late sep

#threetabs=[[22,33],[44,66]]
#fivetabs =[[55,58],[77,86]]
#seventabs=[[88,99],[102,110]]

combined_tabs=[]
christmastree=[]

##============================================
## combine the lists together  #waterfall ifs
##=============================================
def combine_the_lists_together(x): 
    #print("=====COMBINE THE LISTS TOGETEHR(X)....")
    #print("blast off test of combine_the_lists_together(x)",x)
    #print("at top of combine_the_lists_together use assertion x =",x)
    #print("combine_the_lists_together CALLED of the wild combine the lists of tabs pairs together so sweet now ")
    #print("ASSERTIONS times") #will either be 0 or a number
    get_length_of_threetabs    = len(threetabs)
    get_length_of_fivetabs     = len(fivetabs)
    get_length_of_seventabs    = len(seventabs)
    get_length_of_ninetabs     = len(ninetabs)
    get_length_of_eleventabs   = len(eleventabs)
    get_length_of_thirteentabs = len(thirteentabs)
    #test if threetabs list is empty
   # print("testing if length of threetabs list GREATER THAN 0")
    if get_length_of_threetabs > 0: #then proceed there is at least one
       # print("YES length of threetabs IS GREATER THAN 0",get_length_of_threetabs)
        #this is a waterfall extending numbers to add to christmastree list
        if x >=  3:christmastree.extend(threetabs);
        if x >=  5:christmastree.extend(fivetabs);  
        if x >=  7:christmastree.extend(seventabs);
        if x >=  9:christmastree.extend(ninetabs); 
        if x >= 11:christmastree.extend(eleventabs);
        if x >= 13:christmastree.extend(thirteentabs);
    
    else:
        pass #print('all of the tab lists are empty')
        #print("don't bother trying to extend empty tab lists")
       
    #print('at le bottom of function combine_the_lists_together christmastree list now has')
    #print(christmastree)
    #print(":what is in the christmas list above here starbucks")
    #print("the chrsitmastree list is what should be whole at this point HER!!!")
    


##========================================================
##  build_tab_list_added_together(largest_tab_number):   Thursday, Nov 4th, 2021 
#   this does this combined_tabs = threetabs + fivetabs + seventabs etc
##========================================================
def build_tab_list_added_together(largest_tab_number):
    #print("=== build_tab_list_added_together(x)======>>>>")
    #print("this combines separate lists together into one list all be it clumsily")
    #print("larget_tab_number =",largest_tab_number)
    del christmastree[:] #clears out the combined_tabs list to erase it
    #print("about to call combine_the_lists_together wed nov 17th ")
    ## calling combine the lists together here 
    combine_the_lists_together(largest_tab_number) #<<==input is the largest tab number
    
    
    
    
#this calls it  
#print("FIRST ATTEMPT ====3====")     
build_tab_list_added_together(3) #produces togetherlist=threetabs + fivetabs + seventabs   
#print("combined_tabs=",christmastree)
#for item in christmastree:
#    print(item)
#print("======this should have the lists above it= ")
 #clear it out 
#print("NEXT ATTEMPT =====5===")
build_tab_list_added_together(5) #produces togetherlist=threetabs + fivetabs + seventabs   
#print("christmastree=",christmastree)
#for item in christmastree:
#    print(item)
#print("NEXT ATTEMPT =====7===")
build_tab_list_added_together(7) #produces togetherlist=threetabs + fivetabs + seventabs   
#print("christmastree=",christmastree)
#for item in christmastree:
#    print(item)

 

 
 
fox=[]  #this is just a simple test 
def wildtest(themax):
    #print("themax =",themax)
    #print("called wildtest to add to list")
    if themax == 3: 
      fox.append(3) #.append(3)
      
    if themax == 5: 
      fox.append(5)
      
    if themax == 7: 
      fox.append(7)
      
      
    #if themax == 9: fox = [3,5,7,9]
    #if themax == 11:fox = [3,5,7,9,11]
    #if themax == 13:fox = [3,5,7,9,11,13]
    #if themax == 15:fox = [3,5,7,9,11,13,15]

#print("starting fox list =",fox)
#wildtest(3)   
#wildtest(5)   
#wildtest(7)  
#print("fox list =",fox)
#print("above it should say 3,5,7")
#print("road to tahoe is up hill")



         



            
            
            
            
            
#=======================================
#  build_tab_depth(inputstring)
#========================================            
def build_tab_depth(inputstring):
    print("==== METHOD 1 ==")
    print("build tab depth ==== METHOD 1 ==  build_tab_depth(=======>>")
    print("")
    for line in inputstring.splitlines():
        if "switch" in line and "end" not in line: #this is looking for a switch in a line
            get_tab_depth=line.count("\t")      #this is a var that gets the count of tabs
            add_tab_depth.append(get_tab_depth) #this is for filling the list of each tab depth
        else:
            continue
    print("add_tab_depth=",add_tab_depth)
    print("max tab depth=",add_tab_depth[0])
            
##=======================================
## get_max_tab_number_in_list()
##=======================================       
def get_max_tab_number_in_list():  #this fills the max holding_themax[0]
     print("==== METHOD 2 ==")
     print("====================  #METHOD 2 ========")
     #add_tab_depth = input
     themax = max(add_tab_depth);  #a list of the tabs before switches
     holding_themax[0]=themax;
     print("themax=",themax)


#==============================
#  build_listinput_list  for threetabs,fivetabs, seventabs,ninetabs, eleventtabs,thirteentabs
#==============================
def build_list_input_list():  #line 976
    print("==== METHOD 3 ================")
    print('====================METHOD 3 ==== line 976===>>>')
    print("this is .. build_list_input_list() ...")
    print("it gopher sees right here ",holding_themax[0])
    #holding_themax[0]
    mx = holding_themax[0] #it's using this number 
    print(type(holding_themax[0]))
    print("is it REALLY say 7  above this line???")
    if holding_themax[0] >= 3: put(3);
    if holding_themax[0] >= 5: put(5);
    if holding_themax[0] >= 7: put(7); 
    if holding_themax[0] >= 9: put(9); 
    if holding_themax[0] >= 11:put(11);
    if holding_themax[0] >= 13:put(13);
    if holding_themax[0] >= 15:put(15);
       
    print("at bottom of ifs what is in listinput")
    print(listinput)
    for item in listinput:
        super_listinput.append(item)
    print("super_listinput =",super_listinput)
  
  

#this takes in the tab depth with x and goes thru the string
#and fills the appropiate tab list if 3 then threetabs, if 5 then fivetabs
##====================================================
## internal_machinery()   designed wed sep 29th, 2021
##====================================================
## key engine inside of function this_makes_switch_and_endswitch_pairs_by_tab_levels()
def internal_machinery(x,inputstring): #this doesn't change anything in the string whatsoever
    print("")
    print("==== METHOD 4.5 ==")
    print("===internal_machinery() called=== METHOD 4.5  inside of METHOD 4  ===")
    print("=== this is just sick bad ass ========")
    print("inputstring",inputstring);print("tabsubs ",tabsubs, " ",x)
    counter=0
    for line in inputstring.splitlines():
        tab_length = line.count("\t")
        if tab_length != x or "switch" not in line:
            counter += 1; continue
        if tab_length == x: 
            if "switch" in line and "end" not in line:
                tabsubs.append(counter);counter += 1;continue
            if "endswitch" in line:
                tabsubs.append(counter);counter += 1;continue 
    print("tabsubs = ",tabsubs) #this can be increased to manage n number of tabs depth
    if   x == 3: little_method(threetabs)
    elif x == 5: little_method(fivetabs)
    elif x == 7: little_method(seventabs)
    elif x == 9: little_method(ninetabs)
    elif x == 11:little_method(eleventabs)
    elif x == 13:little_method(thirteentabs)
    else:
        print("nada")
        print("these are the tab lists from three to thirteen rudolph fly")
        print("3 and 5 tabs =",threetabs ," ",fivetabs)    
        print("7 and 9 tabs =",seventabs ," ",ninetabs)   
        print("11 and 13 tabs  =",eleventabs," ",thirteentabs)   


  
  


##==================================================
## make_switch_and_endswitch_pairs_by_tab_levels()
## methods: internal_machinery() 
##=================================================== 
def make_switch_and_endswitch_pairs_by_tab_levels(inputstring): 
    print("make_switch_and_endswitch_pairs_by_tab_levels()")
    print("==== METHOD 4 ==")
    print(":=============== METHOD 4 ======") 
    for item in super_listinput:     # listinput is dynamically made above
        x = item;
        internal_machinery(x,inputstring)
     
    #print("  make_switch_and_endswitch_pairs_by_tab_levels(): ")
    #print("listinput list =",listinput)
    #print("THIS IS CALLING INTERNAL_MACHINERY METHOD ")   
    #for item in listinput:     # listinput is dynamically made above
    #    x = item;
    #    internal_machinery(x,inputstring)   #METHOD internal_machinery()






  
##=================================
##  list_tabs_lists_by_depth():
##================================== 
def list_tabs_lists_by_depth():
    print("==== METHOD 5 ==")
    print("==list tabs lists by depth=====METHOD 5======>>")
    print("threetabs=" ,threetabs); print("fivetabs="  ,fivetabs);
    print("seventabs=" ,seventabs); print("ninetabs="  ,ninetabs);
    print("eleventabs=",eleventabs);print("thirteentabs=",thirteentabs) 
    

#==========================================================
# combine_tabs_by_length_into_christmastree_list(input)
#==========================================================
def combine_tabs_by_length_into_christmastree_list():
    print("== combine tabs by length into christmastree_list======")
    print("==== METHOD 6 ==")
    print("======METHOD 6 ===  combine tabs by length into christmastree_list====>>>>")
    themax = holding_themax[0] #this gets the highest tab level (deeply nested)
    print("where is my coffee now")
    print('let us look in the three tabs list threetabs, fivetabs, seventabs')
    print(threetabs,fivetabs,seventabs)
    build_tab_list_added_together(holding_themax[0])   #METHOD  7
    print("christmastree=",christmastree)
    print("")
    



#================================= 
#  build_pairs_with_jazz()
#=================================  
#this goes thru christmas list of pairs and and makes snowtime list of pairs jazz added to snowtime 
def build_pairs_with_jazz(): 
    print("")
    print("==== METHOD 7 ==")
    print("=== METHOD 7== build pairs with jazz =======>>>>")
    print("")
    counter =0
    print("inside of build pairs with jazz the christmastree list show")
    print("christmastree=",christmastree)
    for x in christmastree: #loops thru at 2 at a time
        print(christmastree[counter],christmastree[counter +1])
        jazz = [christmastree[counter],christmastree[counter+1]]
        print("appending jazz to snowtime list now")
        #list snowtime starts virgin and then we append jazz pairs to it
        snowtime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2 
        ##=========================================================
        #prevents overflow error for out of range error
        print("this is the resulting pair list that is so coveted")
        print("this used the jazz pair pair system that works")
        print("snowtime list=",snowtime)
        if counter >= len(christmastree):
            break
            
            
            
gold_list=[]                   
def loop_thru_pairs_in_snowtime():
    print("==== METHOD 8 ==")
    print(" ==== #method 8 ===  loop_thru_pairs_in_snowtime()=============")
    print("snowtime list=",snowtime)
    for item in snowtime:  #snowtime list is loaded into gold_list
        gold_list.append(item)
    print("gold_list=",gold_list)  
    #    print(item);
        #rad1=item[0];rad2=item[1];
        #print(rad1,"and ",rad2)
   





#def goldtime():
#    print("goldtime callled goldtime goldtime")
#    for item in super_listinput:     # listinput is dynamically made above
#        x = item;
#        internal_machinery(x,inputstring)
# REFACTORED on nov 8th , 2021 to reduce the complexity modified nov 9th


##========================================================
## this_makes_switch_and_endswitch_pairs_by_tab_levels
##========================================================  
def this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring):
    print("=======THIS MAKES SWITCH AND ENDSWITCH PAIRS BY TAB LEVELS========")
    #welcome to - time 10;43 am nov 9th-")
    print("this is unreal; this_makes_switch_and_endswitch_pairs_by_tab_levels()")
    build_tab_depth(inputstring)                               #METHOD 1
    get_max_tab_number_in_list() #fills holding_themax[0]      #METHOD 2
    build_list_input_list()                                    #METHOD 3
    make_switch_and_endswitch_pairs_by_tab_levels(inputstring) #METHOD 4
    list_tabs_lists_by_depth()                                 #METHOD 5
    combine_tabs_by_length_into_christmastree_list()           #METHOD 6 together
    build_pairs_with_jazz()  #combines into sublist            #METHOD 7 in christmas list
    loop_thru_pairs_in_snowtime()                              #METHOD 8
    #this will go into gold_list
        
        
'''
=== METHOD 7== build pairs with jazz =======>>>>

inside of build pairs with jazz the christmastree list show
christmastree= [11, 47, 49, 73, 15, 38, 53, 64, 23, 33]

==== #method 8 ===  loop_thru_pairs_in_snowtime()=============
snowtime list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]
#after running it======= The Road Runner ==================
'''
        
        
        
        
    
 
 
     #this gets one pair in showtime designated by x 
def get_pair_in_snowtime(x):
     print(" get pair in snowtime testing",x)
     #what if I add 0,0 to first position brilliant
     if len(snowtime) == 0:
        print("length of snowtime is zero")
     print(snowtime) #would be second position
     cool = snowtime[x]
     print("list at position ",x," is",cool)
    #christmastree = [11, 47, 49, 73] [15, 38, 53, 64][23, 33]
    #next reduce to pairs
    #christmastree = [[11,47],[49,73],[15,38],[53,64],[23.33]]

print("mocha test now mocha mocha mocha mocha mocha")    
#get_pair_in_snowtime(1)
#get_pair_in_snowtime(2)
print("does it return this,[11,47],[49,73]")
print("lightning storm ===")
 
fruits = ['apple', 'banana', 'cherry']
x = fruits.index("cherry")

print(x)
print("is this thing turned on")
print(fruits[1])
searchlist=[22,44,55,77,88,102] #shadows actaul pairs with jsut first number 
snowballs=[[22, 33], [44, 66], [55, 58], [77, 86], [88, 99], [102, 110]]
snowballs.insert(0, [0,0])
for item in snowballs:
	print(item)

######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)
##==============================
##  get_pair_in_pairslist   example  get_pair_in_pairslist(1)
##==============================
#output param1[0] and param2[0] for a pair 
def get_pair_in_pairslist(x): 
	print("get pairs in pairslist()")
	wild= snowballs[x]  #this is accessing snowballs list 
	print("pair=",wild)
	alpha = wild[0]
	beta = wild[1]
	print("data=",alpha," ",beta)
	param1[0] = alpha
	param2[0] = beta
	print("we have these returns param1[0] and param2[0]",param1[0],"and",param2[0])
	
	
print("=============should be 55,58======")
get_pair_in_pairslist(3)
print("now 1")
get_pair_in_pairslist(1)
print("now 2")
get_pair_in_pairslist(2)
print("now 4")
get_pair_in_pairslist(4)



#[[22, 33], [44, 66], [55, 58], [77, 86], [88, 99], [102, 110]]


test_pairs = {
  "22":  "[22,33]",
  "44":  "[44,66]",
  "55":  "[55,58]",
  "77":  "[77,86]",
  "88":  "[88,99]",
  "102": "[102,110]"
}
print(test_pairs)
##========================================
## get_pair_for_switch_number(x):  #this accesses the test_pairs dictionary
##========================================
def get_pair_for_this_switch_number(x):
    print("x=",x)
    y = test_pairs[x]
    #y = eval("test_pairs.get(x)")
    print("pair =",y)
    0
#still trying to remember why I will need this   
print("testing using a dictioanry to search by switch number for pair")
get_pair_for_this_switch_number('22')
get_pair_for_this_switch_number('44')
get_pair_for_this_switch_number('55')

# I will need to go thru this pair list and HARVEST the first number and include
#it's index number and then feed that into a dictionary


#print("now go thru it and see if it goes thru the the list
print("testing looping thru list and getting each pair")
# I am testing this since I need to go direclty to a pair and extract it for copying strings
counter = 1
for item in snowballs:
	get_pair_in_pairslist(counter)
	counter += 1
	if counter >= len(snowballs):
		break
    
##==============================================================    
#we know that there will be sets of 2 numbers closest to each other
#go thru list and grab two at a time seems simple enough
#based on highest tab number which we would know like 7
#threetabs= [11, 47, 49, 73]
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]

peartree=[]
startime=[]
#loop thru threetabs
print("TEStING PeAR TREE backyward with plum tree to see if it works")
print("add result to final_pears_list")
print("does this one work and print x,y")
#my_list = [1,2,3,4,5,6,7,8,9,10]
print("about to see if christmas will come early this year or not")

##======================================
## fill_main_pear_list(listname):  #this build the combined list correctly 
#the lists threetabs,fivetabs,seventabs,ninetabs need to already be filled
#this is just combining them together adding them together
##=====================================
def fill_main_pear_list(listname):
    print("=====fill_main_pear_list called with listname======")
    counter=0 #this must be at 0
    for x in listname:
        print(listname[counter],listname[counter +1])
        jazz = [listname[counter],listname[counter+1]]
        startime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2
        if counter >= len(listname): #prevent from going out of bounds
            break
    print("startime list=",startime)
    print("what did this work.......or not ....did it")
    if holding_themax[0]>= 3:fill_main_pear_list(threetabs);
    if holding_themax[0]>= 5:fill_main_pear_list(fivetabs);
    if holding_themax[0]>= 7:fill_main_pear_list(seventabs);   
    if holding_themax[0]>= 9:fill_main_pear_list(ninetabs);
        
    #put in list highest tab number say 7
    
    
    
    
    
       
       
       
print("final startime filled with three tabs, five tabs, seven tabs in pairs")
print("battle star galactica")
print("startime=",startime)

print('testing fill main pear list with christmastree ')
#fill_main_pear_list(christmastree)
#it = iter([11, 47, 49, 73])
#for x, y in zip(it, it):
#    print(x, y)
#    jazz=[x,y]
#    peartree.append(jazz)
#    print("peartree =",peartree)

#print("peartree[0]=",peartree[0]) 
#print("peartree[1]=",peartree[1])
#apple1 = peartree[0][0]
#apple2 = peartree[0][1]
#print("apple1",apple1," and apple2", apple2)
#print(apple1,apple2) 
#for item in threetabs: #this is a list
#    print(item)
#    counter += 1
#    
#for item in threetabs: #this is a list
#    print(item)
#    counter += 2
    
    #counter += 1
    #print(item)
    #sly2 =item
    #counter += 1
    #print(sly1,sly2)
    #item = item.split()
    #chimp1 = item[0]
    #chimp2 = item[1]
    #print(chimp1, chimp2)
    #counter += 2 #count by 2 genius
   # print("wow will this work")
    #jazz = "[" + str(item[counter]) + "," + str(item[counter +1]) + "]"
    #peartree.append(jazz)
    #print(peartree)
    
print("end of starbucks show..")   
    


#def build_list_now_from_pairs  
    
    #print("threetabs[0]=",threetabs[0]) #simpler just use this one
    
    #app = len(threetabs)
    #print("threetabs length =",app)
    #print("")
    #if app == 4:
    #    print("yep")
    #    first.append(threetabs[0]) #11
    #    first.append(threetabs[1]) #47
    #    print(first,"first[0]=",first[0],"first[1]=",first[1])
    #    #"second =[" + str(threetabs[2]) + "," + str(threetabs[3]) + "]"
    #   #print(second)
    #    print(type(first))
    #else:
    #   print("falsy")
    



def make_sets_from_three_tabs():
    print("get length of threetabs")
    print(threetabs)

make_sets_from_three_tabs()

threetabs=[]
endtabslist=[]
endswitchlinenumbers=[]
##======================
##  sound_of_music
##======================
def sound_of_music(inputstring):
    return #kill it
    print("sound of dam music called=====using intnernal_machinery() =====")  
    print("sound of dam music called==========")
    print("sound of dam music called==========") 
    counter =0
    newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    print(newstring)
    
    #inputstring = red_robin
    #x=3
    #internal_machinery(x,inputstring)
  
    ###===================================
    print("this one blast time for 31 flavors THIS IS THREE TABS === ---")
    print("threetabs=",threetabs)
    ###============
    #switches and endswitches at 3 tabs should be even number
print("threetabs =",threetabs)







##======================
##  sound_of_music
##======================
fivetabs=[]
def sound_of_music2(inputstring):
    return #kill it
    print("sound of dam music called")   
    counter =0
    #newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    #print(newstring)
    x=5
    internal_machinery(x,inputstring)
    print("time for 31 flavors THIS IS THREE TABS === ---")
    print("fivetabs=",fivetabs)
    ###============
    #switches and endswitches at 3 tabs should be even number
print("threetabs =",threetabs)
#threetabs= [11, 47, 49, 73]

#============================
'''
  #for line in inputstring.splitlines():
    #    print(line)
    #    tab_length = line.count("\t")
    #    if tab_length != 5 or "switch" not in line:
    #       counter += 1;continue
    #    ##################
    #    if tab_length == 5:
    #        if "switch" in line and "end" not in line:
    #            print("if switch called")
    #            print("======switch in line===")
    #            fivetabs.append(counter)
    #            print(fivetabs)
    #            counter += 1;continue
    #        if "endswitch" in line:
    #            print("if endswitch called")
    #            print("======endswitch in line======")
    #            fivetabs.append(counter)
    #            print(fivetabs)
    #            counter += 1; continue
    '''
    
##======================
##  sound_of_music
##======================
seventabs=[]
def sound_of_music3(inputstring):
    return #kill it
    print("sound of dam music called")   
    counter =0
    newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    print(newstring)
    #this should be a method inside of it 
    x=7
    internal_machinery(x,inputstring)

    
    
    print("seventabs=",seventabs)
    print("time for 31 flavors THIS IS seven TABS === ---")
    print("seventabs=",seventabs)
    ###============
    #switches and endswitches at 3 tabs should be even number
print("seventabs =",seventabs)
#threetabs= [11, 47, 49, 73]





#threetabs= [11, 47, 49, 73]
    #should be 1, 11, 15, 23
    #33  38 47
    ###=============================
    
    #print(peach_data[2][0]) #2 #this row will always be empty 
    #print(peach_data[2][1]) #11
    #print(peach_data[2][2]) # 3
    #print("test if peach_data[2][2] == '3': ")
    #print("testing if switch2 has 3 tabs in front of it")
    #if peach_data[2][2] == '3':
    #    print("= TRUE ==party time===")
    #else:
    #    print("==FALSE ===does not compute===")
    #print('peach_data[1]=',peach_data[1])
    #print('peach_data[2]=',peach_data[2])
    #print('peach_data[3]=',peach_data[3])
    #print('peach_data[4]=',peach_data[4])
       
    #print("=========")
    #for line in newstring.splitlines():
    #    print(line)
    #oh yea I need to make a method that does this all at once.
    #I can have it hop thru a list to change the number
#print("now three tabs")
#three tabs
#right here we add red_robin

#sound_of_music(red_robin)

#print(" below the first one sound of music")
#print("now five tabs")
#five tabs

#sound_of_music2(red_robin)

#print("now seven tabs")
#seven tabs
###============================================================================
##  create_list_of_pairs_now(inputstring):
##  methods:  this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
##=============================================================================
def create_list_of_pairs_now(inputstring):
    print("inside of create_list_of_pairs_now(inputstring) in woodstock.py")
    for line in inputstring.splitlines():
        print(line)
        
    print("====create list of pairs now(0  dec 13th monday ===========================")
    print("this calls: this_makes_switch_and_endswitch_pairs_by_tab_levels")
    print("make it so star trek")
    
    print("what red_robin looks like in create_list_of_pairs_now in woodstock before calling try_all_three=====")
    print(inputstring)
    print("see how it looks above if there are double switches and endswitches yet")
    this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
    
   
    print("after running it======= The Road Runner  2.0 ===================")
#exit()
###=================================================
#when running from frosty.py comemnt the two lines below out
#inputstring = string_to_use
#create_list_of_pairs_now(inputstring); #commented out dec 15th for testing

print('now show the pairs list')
#commented out of course..
#exit()


#### end of woodstock file ####
#=================================================================================
### starty of Linus file ###
#from woodstock import gold_list


#Santa_Cruz_Python_Preprocessor/fourth_of_july2good.py /

def message_from_linus():
    print('hello from Linus file')
 
#message_from_linus()   
#import official_switch_case_silver
#from official_switch_case_silver  import *  
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 



# output is to inputstring[0]

passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)
##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	awesome='';counter =0;newstring='';
	print(inputstring)
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
			#end if
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		    ####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring
	for line in newstring.splitlines(): #was redrobin.splitlines()
		print(line)
	print("AFTER ADDING the line number as comments to the switches in red robin baby ")	
	print(newstring)   #it prints red_robin switch combo string with the line numbers added in comments
	print("smart_switch_numbers=",smart_switch_numbers)  #this is new here too 
	return newstring #this way I can capture the changed string





#def too_swift(inputstring):
#    print("==========too_swift() called=======")
#    print("dirt stimple test showing lines with switch, end switch and }")
#    for line inputstring.splitlines():
#        if "switch"in line:
#           print(line)
#        if "}" in line:
#            print(line)
#too_swift()

print('done for the exit sign')        


print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

print("testing add comment and line number after all switches")
add_comment_and_line_number_to_all_switches(waffles) #was red_robin
print("REd ALERT critical test first method  test first method ...")
#exit()


def empty_switch_and_endswitch_list_locations():
    print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]
def get_switch_and_endswitch_locations(z): #from string z input parameter
	return
	#return we START BUILDING
	print("thbis is what I am testing now now now")
	print("  get switch and endswitch locations###  called line 322 #####")
	print("######get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#wrong='''	
		#rechecking to see if this works 
		if "switch" in line and "end" not in line:
			print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		#if "endswitch" in line:
		#	print("look right here endswitch found",counter)
		#	endswitch_location.append(counter)
		#	counter += 1
		else:
			counter += 1 
	
	counter=0
	for line in z.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line:
			print(line)
			print("look right here endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1 
		#'''
	print("at this point this is what we have...after testing BIG YELLOW BIRD go bird")
	del switch_location[0] #takes out first number not needed
	print("switch_location=",switch_location)
	print("endswitch_location=",endswitch_location)
	#test_string1exit()
	print("this over writes the contents of these two lists ")		
	#hard coding it in here why 
	#switch_location    =[1,11,15,23,31,62,66]
	#endswitch_location =[100,60,51,46,41,86,77]	#might hav eto resverse these 	
	
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	#del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	print(z)                #now I remember that is the first switch which doesn't matter
	print("I deleted the first switch since I'm not bothering with it")
	print("switchlocations=",switch_location)
	print("on line 180 endswitchlocation=",endswitch_location)
	
	print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	print("this is how many nested switches are here")
	print("now we should have this many nested switches to contend with",answer)
	print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	#if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
	#	print("endswitch locations =",endswitch_location)
	#	print("out of curiosity print the number of endswitches", len(endswitch_location))
	#else:
	#	pass
	print("I need to test that this part still works here in fourth of july 2 .py")	
	print("this might be simpler to test and use actually======/////???????//////===")
	print("======================================")
	print(" ===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === ")
	print("I need to delete teh first swithc location")
	
	#working on this on Saturday, October23, 2021 to get this stage done 
	#del switch_location[0] #ALREADY DELETING FIRST SWITCH ABOVE BECAUSE IT'S NOT NEEDED NOT NESTED
	print("does this look right testing on Sunday gloomy rainy day")
	print('switch_location=',switch_location)
	print('endswitch_location=',endswitch_location)
	#the input is above
	
	
	print("....")
	print("the input for filling the blueberries dictionary are the lists switch_location and endswitch_location")
	print("==================")
	print("the enchanting world of making blueberry pie")
	
	
	
	
	##################################################################################
	############## working on this on saturday, october 23rd, 2021 ###################
	##################################################################################
	print(" rain fall status ")
	counter=0
	#working on creating input list for blueberries dictionary: can't believe I didnt do this yet
	print("what the hell is going on here")
	#print("switch_location=",switch_location)
	#for item in switch_location:
	#	print(item)
	#print("so how did that go...")
	
	print("endswitch_location=",endswitch_location)
	#for item in endswitch_location:
	#	print(item)
	print("so how did that go...")
	
	
	counter=0
	print("starting at counter =0")
	
	print("=============== starbucks morgan hill =====")
	print(switch_location)
	print(endswitch_location)
	print("emptying together pair here")
	del together_pair[:] #delete it just in case to start with clear chalkboard
	print("=======") #THIS FILLS THE TOGETHER_PAIR LIST OF SWITCH,ENDSWITCH 
	print("this loop fills the together_pair list of switch,endswitch numbers")
	print("this is so much dam fun oh yeah")
	total1 = len(switch_location)
	total2 = len(endswitch_location)
	print("total1 =",total1)
	print("todal2=",total2)
	print("this is where we START BUILDING the ===TOGETHER PAIR =====")
	for item in switch_location:
		solution = "[" + str(switch_location[counter]) + "," + str(endswitch_location[counter]) + "]" 
		print("solution=",solution) #to see what it looks like 
		together_pair.append(solution)
		print("counter=",counter)
		counter += 1
		
		#this should prevent stack overflow of the list range added november 9th 
		if counter >= len(switch_location):
			print("stack overflow called since counter > = len(switch_location)")
			break
		else:
			continue
			
	print("now we will loop thru the together_pair to see that the pairs are in there")
	del endswitch_location[-1] #should delete 100
	print("this is what is in TOGETHER_PAIR at line 254")
	for item in together_pair:
		print(item)
		apple = item.split(",")
		print("======")
		print(apple[0])
		sweet1 = apple[0].replace("[",'')
		#print(sweet1)
		print(apple[1])
		sweet2 = apple[1].replace("]",'')
		print(sweet1,sweet2)
		print("where's the party")
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	##################### end of method #################################3
#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]  	
	
	

print("what are they actually")
print("starbucks coding NEXT TO RED ROBIN===== big storm coming...")
#Sget_switch_and_endswitch_locations(red_robin) #yeah it's calling red robin!!!
print("result of switch and endswitch locations in red robin")
print("examine the contents of the lists switch_location and endswitch_location")
print('switch_location=',switch_location)
print('endswitch_location=',endswitch_location)




string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
print(string)

print("end of test from the web")
print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced
old_coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown time')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
}
'''
coffee_now='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
	
#this is coolstring with the nested switches already taken out for all levels+
coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown please')
			switch(exp){
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){   #here        representings stripped out inner nest
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			switch(exp){     #heret 
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			switch(exp){
			switch(exp){
			fallthru
		default:
			print('the end')
}
'''

#working on this July 15th, 2021 10:16am Starbucks
#get_switch_and_endswitch_locations(coolstring)
#output to these lists
#switch_location #skips the first main switch not included
#endswitch_location (if any)
#get_switch_and_endswitch_locations(coolstring)
print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#this accesses coolstring august 5th, 2021
#this is to set the inner switch positions in the main switch input strings
#after the bodies of the nested switches have been stripped out

##########################################
##  put_switch_locations_into_switch_list()  #this is making the nested_switch_ number  
##########################################
def put_switch_locations_into_switch_list(inputstring): #just added param
    print("##2### put_switch_locations_into_switch_list ###")
    print("##2## put switch locations into switch list ###")
    print("put switch locations into switch list")
    #### get swith and endswitch locations called here 
    get_switch_and_endswitch_locations(inputstring) #it's right here 
    for item in switch_location: #this is only going thru switch_location
        switch_list.append(int(item))  #was -1 on here #off by one in the string for some reason
    # print(" ");print("switch_list=")
    #print(switch_list)

#######################################
##  swap_switch_to_nested_method()  #this is making the nested_switch_ number  
#######################################
def swap_switch_to_nested_method(stringname,linenumber,series_num):
	print("============== swap_switch_to_nested_method() ==========")
	#print("input: linenumber", linenumber)
	#print("input: series_num", series_num)
	
	#print("##4## swap switch to nested method - numbered ###")
	#print("##4## swap switch to nested method - numbered ###")
	#print(" THIS IS BEING CALLED TO DO THE MAGICswap switch to nested method called....")
	str_list = stringname.split('\n')
	#print('changing line',linenumber)
	#series_num = number_series[0] 
	str_list[linenumber] = "\t\t\tnested_switch_" + str(series_num) + "(n)"
	stringname = "\n".join(str_list)
	genius[0]=stringname   #strings are immutable but lists are mutable(changeable)

######################################	

#this is the control center main that runs this operation
#this numbers the nested switch methods top down
#genius[0]=coolstring  #assignment here <<<==================


#######################################
##  loop_thru_switch_locations():
#######################################
def loop_thru_switch_locations(regularstring):  #looping thru  switch_list[10,18]
    print("##1##loop thru switch locations ## line number 276 ####")
    print("##1##loop thru switch locations ######")
    #trick put_switch_locations_into_switch_list
    #method called
    put_switch_locations_into_switch_list(regularstring) #method
    print('this filles switch_list of switch line numbers')
    #print(genius[0])
    print("what is the order of the switch_list I think it's reversed to do bottom up")
    print(switch_list)
    print("------------")
    print("switch_list=",switch_list)
    le_number=1 #default numbering nested string 
    for item in switch_list: #loops thru switch_list WITH SWITCH LOCATIONS (LINE NUMBERS)
        print("item in switch_list",item)
        #string,switch,line number
        # swap_switch_to_nested_method here 
        #method this one is the holy grail that actually works
        ###############################
        swap_switch_to_nested_method(genius[0],item,le_number) 
        coolstring =genius[0]
        le_number += 1  #adding to the nested number here
    print("#### end of loop thru switch locations() ####")
    print('the EXIT sign is green')
#######################################



print("STAR TREK TEST FULL PHOTON LASERS add numberednested method McCoy looks good now beam me up ")
print("starting with this input main string with nested switch bodies cut out")
print("tahoe dream")
##==========================================================|
## swap_nested_switches_with_methods_in_main_switch_string
##==========================================================|
def swap_nested_switches_with_methods_in_main_switch_string(inputstring):
    print("===swap_nested_switches_with_methods_in_main_switch_string()== line number 309=") 
    loop_thru_switch_locations(inputstring) 
    print("this is the output string of the transformation from input string")
    ## this is after loop thruw switch locations method is completed
    print("this is the main input switch string after adding nested methods")
    print("the output of this transformation of swapping switch for nested_method")
    #this is the input string transformed 

#this calls it
genius[0]=coffee_now  #assignment here <<<==================
print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
swap_nested_switches_with_methods_in_main_switch_string(coffee_now)
print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
print(genius[0])

#this calls above
print("=== begin tron test ==line 323 =TESTING september 1st here we go=-=== to see if this sucker works === august 27th ==== please work ==")
print("this is testing the main switch string module changing nested switches")
print("that already had their bodies cut out and swaping in a nested method")
genius[0]=coolstring  #assignment here <<<==================
print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
swap_nested_switches_with_methods_in_main_switch_string(coolstring)
print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
print(genius[0])
print('end of test of swap nesetd switches with methods in main switch string ')
print(" oh that's what this does...da ")
print("====line 332 ==end of this tron test september 1st=====")
print("======end of this tron test september 1st=====")
#exit()  #stop it here
	#string_change =coolstring
#stringname=coolstring
print("now change the inner switches to the nested method numbered")
#swap_switch_to_nested_method(coolstring,10,1)	  #####======

print("after first change ====>>>>>>>")
#coolstring =genius[0]                            #########==========

#series_num = number_series[0] 
#swap_switch_to_nested_method(coolstring,18,2)	  ########=========
print("after the 2nd change ...")
#coolstring =genius[0]
##print(genius[0])                                ################============
print("done with this test of the new method")
  #building the method to make this magic happen automatically


#-------------------  july 10th, 2021   11:03 pm  -------starbucks coding-------
#I am hard coding the location of the switch words. I need to have it search on it's own
# but I recall I have code that does that elsewhere
#now I need to find the code that makes the correct nested switch list locations

#they are being harded coded in here I should be getting them from above

#switch_list.append(11) #was 10,18,31
#switch_list.append(19)
#switch_list.append(32)## added a third switch to test it more thoroughly 

##============================================================================
print("here put switch_locations into switch_list")
## this is new added Thursday july 15th 2021 prevents off by one error
## it takes input of nested switch line number locations from switch_location
## and puts them into switch_list (but again not the first main switch)   

#this one just commented out
#put_switch_locations_into_switch_list()
print("about to test it with the loop thru switch method ====")
print("today is july 22nd, 2021 thursday refining the algorithms and methods")
## calling LOOP THRU SWITCH LOCATIONS (INNER)

######======================
#loop_thru_switch_locations() #where to find the inner switches to replace with a nest method
######======================


print("did it work=============MMMMMMMMMM----======MMMMMMMMM==========")
print("we called loop_thru_switch_locations() which calls swap_switch_to_nested_method()")
print("we should have successfully swapped out the inner switches with nested_method numbered")
print("today is july 15th, 2021 at Starbucks connecting the functions")
print(genius[0])    	
print("olympic gold medal to make it this far.")
print("==IT SHOULD BE ABOVE THIS LINE WITH THE NESTED NUMBERS METHODS INNER SWITCHES==")
print("now I need to work on copying the nested strings to a list")
print("and then taking out the nested strings from the main switch string except for switch")
    
#this one works just need to test it as a method above 
#str_list = coolstring.split('\n')
#print('changing line 11')
#str_list[10] = "\t\t\tnested_switch_1(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)

#print(string_change)
#stringname = string_change
#############
#str_list = coolstring.split('\n')
#str_list[18] = "\t\t\tnested_switch_2(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)


#what if I go thru a list to make teh changes
#=====================================================
#z = 'test4'

#choose to 'Update Now'
# when the newest MacOS Mojave 10.14. 6 Supplemental Update

#say we add it to first case 2nd line after case just bump down whatever
#is on that line. copy that line just for saftey and add it to the tail
#with \n at beginning and end of that line


### look for nested switch called    switch_nest()  
# get case number which case is it, first, second, third for this test
#then get line number of case section determine what line it's on.
#(the nested switch method)

output_string_test='''
 switch(x) #main switch    #<<====== switch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "one":
            print("this is the first case in the main switch")
            #switch_nest() #force feeding it for testing switch case function actually 
            ######################
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word')   
                     
        if case == "two":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word') 
            
        if case == "three":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
           
            
'''

######## testing 2nd and 3d level deep nested switch cases july 29th, 2021


# will mess around with this later. 

triple_nested_switchtest ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown wowee')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	



cicelyalaska ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown nope')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown rr')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	



snowman='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown oooo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									#################### this one is new 
									switch(exp){  #fourth level deep   Level 4    
										case 'obama':
											print("do something")
											print("good")
											fallthru
										case 'ufos are real':
											print("better")
											break
										default:
											print("nice job")
									endswitch 
							#############
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== interesting test here for just 3 here ==')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
		case 1 thru 3:
			print("where\'s this will be one match for 3, 5!")
			print('first prize')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
						default:
							print("welcome to the party") 
						endswitch
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
			print('you block head Charlie Brown www')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									####################
									switch(exp){  #fourth level deep   Level 4    
										case 'coolish':
											print("do something")
											print("yep")
											fallthru
										case 'auburn':
											print("nice")
											#######################
											switch(exp){  #fifth level deep   Level 5    
												case 'coolish':
													print("do something")
													print("yep")
													fallthru
												case 'auburn':
													print("nice")
													break
												default:
													print("we are done here")
											endswitch 
											break
										default:
											print("we are done here")
									endswitch 
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	

'''
loop thru string
get switch locations and tabs coount
then make list of numbers of switches inside tab 3 switch
only thing that I cna think of.
make list with sublists
'''

answer=triple_nested_switchtest.count("endswitch")
print('counting the nested switches to see how it goes ====Boo ')
print("the number of nested switches based on endswitch=",answer)
for line in triple_nested_switchtest.splitlines():
    print(line)
print("=== the end ====")
print("================")

#answer we seek is case section 2, line 2
################===============================
#33 june 28th, 2021 9:26 pm now 

#where I detect the nested switch  location and starting and ending point
# I copy the nested switch and delete it from the main switch
# I add a method where thes switch word is.
# My compromises to get it working faster are the nested switch
# must end with endswitch  and not a curly brace
# this makes it easier to get working and aids readability

#the switch main switch is chopped off at the begining of the inner switch
#the bottom after the nested switch ends with endswitch is copied
#to the top half but only after the nested method is added to th eline
#where the nested switch was 



# when code is running there is nothing to see.
# If we have moving behavior (which is invisible)
# that is what matters -but like what Fred Brooks says
# software is invisible. So I need to make it tangible and visable.

#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========



# starting testing here to see if I can reduce the code to make sense

 ####### august 10th 2021 testing commences.
 
find_nested_switch_game ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown dam')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	

gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

print("what we are starting with the switch with a nested switch")
print(find_nested_switch_game)
print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
print("this gets the line number of the line that the case starts")
print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
    print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
    print("case line numbers",pacman)    
    #print(pacman[2])  
    print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            print(item)
            print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
            print("we have a match")
            print(line)
            #linecounter += 1 if it's endswitch don't add one
            print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    print("the end of this nested switchis",endnestedswitchline[0])
    print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    print("x=",start_and_finish[1])
    print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function

print("will do red robin string with the sets of pairs individually to verify it's right")
print("testing Sunday, NOvember 7th, just got 3rd booster shot ----")
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
################################################################################
################################################################################
################################################################################
################################################################################
columbia_river=[]
#gold_list=[]
################################################################################
################################################################################
################################################################################
################################################################################
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    print("= copy_a_nested_switch() called== just now 10;43 am ====")
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
print("=======begin Sunday Morning Brew Testing=======")

# uses methods:
# add_comment_and_line_number_to_all_switches
# inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
# copy_a_nested_switch(water)
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]] 

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

print("testing looping thru gold_list which I imported at top of Linus from woodstock")
#from woodstock import gold_list
#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]0
print("did this get filled up or not gold_list=",gold_list)
for item in gold_list:
    print(item)
print("======")
#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]  
################################################################################
################################################################################
################################################################################
###3==============================
#it uses the gold_list to copy the nested strings      
##=============================================================
##  split_up_big_string_into_nested_switches(myinputstring)
##=============================================================
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print("===split up big string into nested switches()===")
    water =add_comment_and_line_number_to_all_switches(myinputstring) #stringname goes here
    for line in water.splitlines():
        print(line)
    del columbia_river[:]  
    print("gold_list=",gold_list)
    columbia_river.append(water) #this adds the mega initial string first for the main string
    print('at this point the length of columbia_river should be 1 and it is',len(columbia_river))
    for item in gold_list: #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
        copy_a_nested_switch(water)  #copy string based on switch,endswitch pair 
        print("====================")#puts resulting string into makeitwork[0] and output
        output = makeitwork[0]       #put nested string into columbia_river list
        columbia_river.append(output)
    print("length of columbia river =",len(columbia_river))
    counter =1
    #adding here the initial string which will be used to make the main switch
    print("now loop thru columbia river to see the switch bodies seperated")
    for item in columbia_river:
        print("counter=",counter)
        print(item);print("===========");counter += 1
##================================================================        
print("........mmmmm...time 10:20 am Sunday dec 12th")
print("end of crucial test copying the strings and putting them into a list")
#split_up_big_string_into_nested_switches(red_robin)
#exit()   
print("okay from this point forwards I have access to the columbia_river with the strings in it") 
     
     
     
     
     
     
     
     
     
     
     
     
     
     
#######======================================== ## find_nested_switch_game
#the input is the whole string afgter having added comment of swithc line number in loopstring[0]
#x =11; y = 60;
##=======================================
##  testing_code_copying_string_adding_it_to_list()
##========================================
def testing_code_copying_string_adding_it_to_list(x,y):
    print("testing code copying string adding it to list")
    inputs_pair_to_copy_a_string(x,y)
    #water is the modified string with line number (but need to only add the line numbers once as comment
    copy_a_nested_switch(water) #this takes in switchstring with switch numbers added as comment
#######=========================================
    output = makeitwork[0]        #this would have to be after the call to copy a nested switch
    columbia_river.append(output)

#testing_code_copying_string_adding_it_to_list(11,60)


print("now printing out columbia river")
print("length of columbia river =",len(columbia_river))
for item in columbia_river:
    print(item)
    
#exit()
 





start  = 7  #hard coded beginning of nested switch
finish = 14  #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################
start_and_finish=[]
start_and_finish.append(0) #position [0] #ignore
start_and_finish.append(start) #position [1]
start_and_finish.append(finish) #position [2]
#so we have
start_and_finish[1] = 7
start_and_finish[2] = 14
#############################
r=gameday
#linecounter=0
makeitwork=[]
makeitwork.append(0)
print('======SECOND ATTEMPT======')
#######========================================
copy_a_nested_switch(r) #this gets put into r as a parameter
#######=========================================



#lines 1 thru 9 
 #this looks for the line number of endswitch for the nested switch
print("testing getting a COPY TOP HAT OF MAIN SWITCH")
print('this also grabs and displays the inner switch first line')
#the inner switch needs to be the last line of this string
##================================================
start = 1 #starting from 11 not 10
finish = 10
#linecounter=0
abovenestedswitch=''
print("this was put into a function on July 15th, 2021 ===")
####################################
## copy_top_hat_of_main_switch(): #this grabs the string of the main switch above 
# the first nested switch in this case there is only on 
####################################
terriblysmart=''
def copy_top_hat_of_main_switch(): #this is grabbing the top of 
    #the switch case just above the first nested switch 
    print("======copy top hat of main switch()====")
    global abovenestedswitch
    linecounter=0 #string name find_nested_switch_game
    for line in find_nested_switch_game.splitlines():
         # between >= 1 and <= 10
        if linecounter >= int(start) and linecounter <= int(finish):
            abovenestedswitch += line + "\n"
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result copy above  first nested switch case ")        
    print(abovenestedswitch)
    terriblysmart = abovenestedswitch

#copy_top_hat_of_main_switch()  #not called yet

print("end of copying top half above nested switch ")  
print("it should end with switch which we will edit")

mystringtest='''
	switch() #7
		case 'funny':
			print('fun')
		case "da":
			print('yeah')
		default:
			print('bye')
	endswitch #14
'''					
					

####################
#replace switch

#linecounter= 0
newlist=[]
newlist.append(0)
#newlist[0]
# I just put this into a function to have control over it 
#COPY COATTAILS BOTTOM OF BIG SWITCH AFTER NESTED SWITCH END
################################################################
## copy_coattails_bottom_of_big_switch_after_nested_switch_end():
################################################################
def copy_coattails_bottom_of_big_switch_after_nested_switch_end():
    print("copy_coattails_bottom_of_big_switch_after_nested_switch_end()")
    linecounter=0
    start = 21 #INPUT PARAMS TO GRB need to put these in a list for efficiency
    finish = 32
    outerswitch=''
    for line in find_nested_switch_game.splitlines(): #string looping thru
        #   IF BETWEEN line numbers 21 and 32 
        if linecounter >= int(start) and linecounter <= int(finish):
            outerswitch += line + "\n"
            linecounter += 1
        else:
            linecounter += 1
            continue   
        
    print("testing getting a COPY COATAILS BOTTOM OF BIG SWITCH")
    print(outerswitch)
    newlist[0]=outerswitch
##===================================================





#this is turning code into a function on july 15th, 2021
#######======
#copy_coattails_bottom_of_big_switch_after_nested_switch_end()
#######=======





#here is where i make this temporary list that I will put the
#input strings of the main switch and the one nested switch for testing

inputstringswitches=[]

###################
##    swap(a,b)
###################
def swap(a,b,c): #c = starbucks[1]
    cooler =c.replace(a,b)
    return cooler #starbucks[1] =string with changes made
    
    
  
#this puts the nest_method on the line selected in the tophalf of the string
#################################
## swap_switch_for_nest_method(n)
################################# 
def swap_switch_for_nest_method(n): # I will add more values later perhaps 3 or 4 for coordinates
    global abovenestedswitch
    abovenestedswitch=terriblysmart
    print("called swap_switch_for_nest_method(n)",n)
    abovenestedswitch = abovenestedswitch.replace("switch(exp){","nested_switch_" + str(n) + "(n)")
    print(abovenestedswitch)
    print("===================")

#june 29th, 2021


def scan_input_string_for_number_of_switches():
    print('work on this')#I have this figured out now elsewhere
    
    
#commented this out on august 3rd testing making big method 
   
#this needs to be put into a method and called below actually
def fishfood(): #necessary testing that's all
    print('about to try new swap method')    
    swap_switch_for_nest_method(2) #feeds it the number 2 for testing
    outerswitch=newlist[0]
    outerswitch= makeitwork[0]
    maybe=abovenestedswitch + outerswitch
    print('we have stripped the nested switch from the main switch')
    print("and inserted a method for now")
    print(maybe)
    ######### put first main switch into inputstringswitches
    print("adding main switch and nested switch taken out into list")
    print("the next step will be to run it thru the silve_module")
    print(" to create teh strings output in python")
    inputstringswitches.append(maybe) #should be position 0

    print("and the nested switch is here before it's converted")
    print(makeitwork[0]) #roadrunner
    #roadrunner = roadrunner.replace("endswitch","}")
    ######### put nested switch into inputstringswitches
    inputstringswitches.append(makeitwork[0]) #should be position 1
    print("====== go for the gold =======")
    print("this shows the resulting strings accessed thru the list that")
    print("they were put into so I can access them now for running silve module")
    print("==--------------==")
    print("here is the result now")
    print(inputstringswitches[0])
    print("now the nested switch")
    #print(inputstringswitches[1])
    galaxy=''
    galaxy = inputstringswitches[1]
    print(galaxy)
    print("Now I replace endswitch with }")### replace endswitch with }
    inputstringswitches[1] = galaxy.replace("endswitch","}")
    print("now looking into inputstringswitches[1] endswitch should be gone")
    print(inputstringswitches[1])
    print("==== end of first major step ==in process of transformation ==")

#################===========
#fishfood()
#################===========




#############################
##  get_inner_switch_line()
#############################
def get_inner_switch_line():
    print("can we get serious here I mean really")       
    bronze=0     
    linecounter=0
    secondswitchline=0  
    for line in find_nested_switch_game.splitlines():
        if "switch" in line: 
            print(line) 
            linecounter += 1 
            print("switch line number = ",linecounter)
            secondswitchline = linecounter
            break
        else:
            linecounter += 1  
            continue
    print("line with inner switch =",secondswitchline)
    print("==================")
#the inner nested switch will obviously end within the same case it starts in.

###########==============
#get_inner_switch_line()  
###########===============


                
###########################################################
print("")
print("====")
print("")
print("get line number of each switch")
print("each number after first switch is a nested switch")
print("get the line number of each switch")
switcharoo=[]
switcharoo.append(0)

linecounter=0





#######################################
##  get_number_of_nested_switches():
#######################################
def get_number_of_nested_switches():
    print("get_number_of_nested_switches()")
    linecounter=0
    #this looks for the line number of 2nd switch for now more later  
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "switch(" in line:  #grabs first line
            print(line)
            switcharoo.append(linecounter)
            
            linecounter += 1
            continue  
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
              
            #if "switch_nest()" in line:
            #   print(line)
    print("line number of switches",switcharoo)  
    print(switcharoo[2])                

casecounter=0
case_count=0

##########========================
#get_number_of_nested_switches()
##########========================
###############################################################
################ testing call of these methods at once
###========== august 3rd test Tuesday nice air conditioning ====
def nested_switch_trapeze_tricks():
    print("==== nested_switch_TRAPEZE_tricks() called=====")
    loop_thru_switch_locations()
    get_case_line_numbers(find_nested_switch_game)
    get_larger_number_less_than_case()
    get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
    copy_a_nested_switch(find_nested_switch_game)
    copy_coattails_bottom_of_big_switch_after_nested_switch_end() 
    fishfood()
    get_inner_switch_line() #not sure if I need this one
    switcharoo=[];switcharoo.append(0);linecounter=0
    print("the nubmer of nested switches=")
    get_number_of_nested_switches()  # here it is 

#this calls it right here 
#nested_switch_trapeze_tricks()
#print("end of running nested_switch_trapeze_tricks() Gee what does it do")

####=============================== end of the line here==========



################################
## get line number of cases()
################################
def get_line_number_of_cases():
    print("get_line_number_of_cases()")
    for line in find_nested_switch_game.splitlines():
    #get each case number 
    #check if switch in it
        if "case" in line:  #grabs first line
            case_count += 1
            print("case_count=",case_count)
            print(line)
        
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
     
#answer 2nd case section    
#nested switch on line 10        
 #answer line 2 inside of case
 #case section 2 starts on line 8
''' OUTPUT
 get line number of each case section
		case 1 thru 3:
1
		case 4 to 7:
2
			case blable:
3
			case more:
4
		case 8 to 10:
5
case line numbers [0, 2, 8, 11, 14, 23]
Line 8 is case second section
We therefeore know that if switch is on line 10
then switch is on the 2nd line after the case section starts
====
get line number of each switch
each number after first switch is a nested switch
get the line number of each switch
	switch(exp) {  
			switch(exp){
line number of switches [0, 1, 10] <<<=== line 10 nested switch
'''
'''
 print('kangaroo hop hop!')
			switch(exp){
			case blable:
			   print("do something")
			   print("yep")
			case more:
			   print("nice")
			default:
			   print("we are done here")
			}'''  
    
    
    
#Monday june 28th, 2021 thinking
#get switch line number and case it's in and line number inside of case
#and what line the switch ends with }
#which I need to know to copy it. I can set the loop to start
#on a particular line and to concat a string and stop
#after coping a set number of lines. 
#Based on line count between switch and } which I can do first
#if line.startswith("switch") do until line startswith("}")




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






   
#def fantastic(): #we would know case number and therefore line number
#   newcounter=0
#  for line in output_string_test.splitlines():
#       if "case" in line:
 #          line_number.append(newcounter) 
       
       #and
       
       #I think that for the parser thats analyzing the input string
       #but the outoput python is quite different.
       #the nested method will be one line
       #so it's really  just adding the one line string
       #to a set of say 5 lines and moving the existing lines down 1 line
       
   #say second line after case 
   #test if something on that line
   #inner_switch_1('test7')
print("what can I do with lists")
print("the night is still young. competing with harvard and stanford")
red=[]
orange=[]
blue=[]
pink=[]
pink.append("\tempty")
red.append("\tone")
orange.append("\tdam")
blue.append('\ttuna')

super = pink[0]  + '\n'  +red[0] + '\n' + orange[0] + '\n' + blue[0] +'\n'
print(super)
red[0] = "\tnestedswitchmethod" 
pink[0]= "\tfunny"
super = pink[0]  + '\n' + red[0] + '\n' + orange[0] + '\n' + blue[0] +'\n'
print(super)

print("========")
line_1=[]
line_2=[]
line_3=[]
line_4=[]
line_5=[]
line_6=[]
line_7=[]
extra_line_1=[]
extra_line_2=[]
extra_line_1.append(0)
extra_line_2.append(0)
football =[]
football.append(0) #method name 
football[0]="\tinner_switch_1('test4')"

line_1.append(0)
line_2.append(0)
line_3.append(0)  #for example nested switch is line 3
line_4.append(0)
line_5.append(0)
#line_6.append(0)

#line_7.append(0)
 #say it's 4 line case 
line_1[0]="\tprint satement line 1"
line_2[0]="\tprint satement line 2"
########################################
line_3[0]="\tprint satement line 3"
line_4[0]="\tprint satement line 4"
print("================")
#if it's on line 3 we take top off to separate it 
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
# new
print("beginning state")
extra_line_1[0]=line_3[0]
extra_line_2[0]=line_4[0]

print("copying that will be don")
print(extra_line_1[0])
print(extra_line_2[0])

print("====bit flipping==== ")
print("putting nested switch in position 3 which is line 3")
line_3[0]=football[0] #designated line for nested switch 
line_4[0]=extra_line_1[0] #this is a novel approach restarting from 1
line_5[0]=extra_line_2[0]

print("after adding the switch nested method in position 3")
print('we then have this:')
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
print(line_5[0])
print("=========== now adding teh strings to magic concatting them ")
magic=''
magic = line_1[0] +"\n" +line_2[0] +"\n" + line_3[0] +"\n"+ line_4[0] +"\n" + line_5[0]
print(magic)  
print("=====================")  
print("let teh games begin")    
print("done")
#line_5[0]="line 5"
#line_6[0]="line 6"
#line_7[0]="line 7"
#line_8[0]="line 7"
mylist=[]
mylist= ["starter","one","two","three","four","five"]




def sosmart():
    mylist.insert(0,"starter")
    mylist.insert(1,"one")
    mylist.insert(2,"two")
    mylist.insert(3,"three")
    mylist.insert(4,"four")
    mylist.insert(5,"five")
    
    
def put_nested_switch_into_line(x):
    mylist.insert(x,"nested_switch") #it replaces the whole line
    print(mylist)
    
def reset_list():
    for item in mylist:
        del item
    
    print(mylist)

print("333333333333======333===================")
print("new attempt here  Friday June 25th -0--")
fruits = ['apple', 'banana', 'cherry']
fruits.insert(1, "orange")

print("======= water tower see how well this works=======")
print(mylist)
put_nested_switch_into_line(2)
sosmart() #resets it
put_nested_switch_into_line(1)
sosmart() #resets it
put_nested_switch_into_line(3)
sosmart()
print("===000000000000100000000000======")

# I ahve to split it in half somewhere and we have top above nested switch line
#and then we have the nestline
#and we have the bottom 

#so if we have lists for each line number of case section up to say up to 10 lines for now
#say switch will go on line 3 of 6 lines for an exmaple
#line 1 and line 2 are top
#line 3 is nest_switch_method
#line 4 to n is the bottom




     
case_guts='''
\tprint("aaaaaa in the main switch")
\tprint("bbbbbb below")
\tprint("ccccc#result of innerswitch running
\t#what ddddddd?? use a list to capture it
\tfallthr eeeeeeeu('word'
'''
    
    #method inner switch withnumber (input will likely be from a list later)
add_this="\tinner_switch_1('test4')\n"
nested_method_name=[]
nested_method_name.append(add_this)
crystal=[]
crystal.append(0)# [0]


#get input string of case section
#
# I need to get the line number where the switch is supposed to go
# based on the input C style location of the nested switch
# based on which case it is in (the sequence starts from 1)
# then detect the line number in order within that case where the switch starts
#
#
  
#exmaple, we need to add nested switchmethod to line 2
#so we copy line1

top=[]
middle=[]
bottom=[] 
put_in_here=[]

#### fudge ########    
def fudge():
    #def copy_one_line_inside_case(x)
    astring=''
    soupstring=''
    line_counter =0
    print(case_guts)  
    
    print("===========STAGE 1=========")  
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == 1:  #grabs first line
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print('first line string=',astring)
    #################
    newstring=''
    coolstring=''
    line_counter =0
# copy from the line where we want to insert (line 2) 
# thru to last line in case section
    print("============STAGE 2===========")
    #this copies 2nd string to string n (the rest)
    
    for line in case_guts.splitlines():
        if line_counter >= 2:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
        
    print(newstring) #this copies all of the lines into newstring
    put_in_here.append(newstring)
    #this is the switch method string on top of rest of case body lines
    #copy from targetline insertion line thur last line
    # we then add the nested switch method to the rest of the case 
    ##########################################
    #this will be a new helper method
    
    #def add switchline to rest of case body()
    #this is necessary BEFORE adding first line
    print("=================STAGE 3=================")
    egg=[]
    nested_switch_method_name=[]
    fossil=[]
    #fossil.append(0)
    #fossil[0] = nested_switch_method_name[0] + put_in_here[0]
    coolstring = add_this + newstring#how so I insert to front of a string
    #higher =nested_method_name[0] + put_in_here[0]
    egg.append(coolstring) #egg[0]
    
    #middle.append(coolstring)
    print(coolstring)
    glory=''
    #this adds the first string followed by coolstring
    #########################
    #this adds the line(s) above the insertion line 
    #put first string ontop of rest of lines of 
    #this adds the first line which was skipped to the new switch line
    #with the rest of the case body
    
    
    #def add_top_above_lines_above_switch_line(a,b)
    #a = string with the switch_method name
    #b = rest of the lines
    print("==========STAGE 4==========")
    nested_switch_method_name.append(astring)
    glory = astring + coolstring#[0] #now it's a list
    print("glory shows")
    print(glory)
                #method name in list     #nested method name + rest of lines in case
    egg[0] = nested_switch_method_name[0] + egg[0] #coolstring
    print('from list now') #string add_this
    print(egg[0])
    #bottom.append(glory)
    #print("now printing from the list bottom[0]")
    #print(bottom[0])
#   def add

#then replace first line with new line methodnested name
#    then add paste first line to new beginning of string
print('copy string from line 2 bbs')
fudge()
#now I can insert in line 2

print("========= result of fudge  ============ ")
print("========= Fudge Happy Potter Hogwarts ========")

#convertList = ' '.join(map(str,list1)) 















###################################
## copy one line inside of case (x)
####################################
def copy_one_line_inside_case(x):
    print("copy one line inside case()")
    astring=''
    soupstring=''
    line_counter =0
    #print(case_guts)    
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == x:
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print(' line',x,' string=',astring)
 ####################   
 #copy just the line entered within the case body
copy_one_line_inside_case(1) 
copy_one_line_inside_case(2)
copy_one_line_inside_case(3)
copy_one_line_inside_case(4)
copy_one_line_inside_case(5)






#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========








################################################
##  get_below_after_method_insertion()
################################################
def get_below_after_method_insertion(y):
    newstring=''
    coolstring=''
    line_counter =0
    #this copies 2nd string to string n (the rest)
    for line in case_guts.splitlines():
        if line_counter >= y:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
    print('below after method insertion',y)   
    print(newstring) #this copies all of the lines into newstring
    #this is the switchm

#this grabs lines within the case after the input line number to the end
get_below_after_method_insertion(2)
get_below_after_method_insertion(3)
get_below_after_method_insertion(4)
get_below_after_method_insertion(5)
 
egg=[]
#def stage_three(a,newstring):#("====STAGE 3====")
#    print('stage_three called')
#    coolstring = add_this + newstring#how so I insert to front of a string
#    egg.append(coolstring) #egg[0]


#stage_three(add_this,newstring)

### stage four ########
#def stage_four():
#    print('stage-four called') #method name in list     #nested method name + rest of lines in case
#    egg[0] = nested_switch_method_name[0] + egg[0] #coolstring
#    print('from list now') #string add_this
#    print(egg[0])  
    
#stage_four()    
#it's going to be in the code gen phase actually where I add the
#one line (so much easier) to the particular case that it's in
#and on the line number within that case below a particular line
#But I the main switch is generated so it should have a marker
#like nested_switch_1_3('test4')
#case number in series and line number within that case

# 
# 
# x=1
# def paste_inner_switch_method_into_string(x):
#      print("===================")#this goes thru the string and detects a nested switch
#      case_counter =0
#      for line in output_string_test.splitlines():    #and copies it and puts it into 
#         case_counter += 1    #acgtaully it gets the start and stop location line numbers
#         if "case" in line:
#             print("case detected in line")
#             case_counter += 1
#             if case_counter == x:
#                 print("this should be our match")
#                 print("this is case number ",case_counter,"and x=",x)
#                 print("therefore we do the MAGIC SHIT HERE")
#                 fantastic()
#                 break
#         else:
#             continue
# 
# list1=[]
# list1.append(0)
# def test_this():
#  #put it into a list
#     list1[0]="inner_switch_1('test7')"
#     say it's line 
# 
# #possibly have it scan thru the output python generated
# I might need a marker  #comment where to put it based on
# just the case. I can finangle where in a case I add it 
# since it's just a method and after I get it placed
# then I can change where in the case it is since it's
# within the case body so I have latitude and the body case 
# will be isolated so there should be some leeway. 





happydays='''
line =""
varholder=[]
varholder.append('0')
###############################============
	
# ===== inswitch ========
def inswitch(n):
	if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
		n = str(n)
	global case
	case = n.lower() 
#=====================
# for infallthru    
def infallthru(n):
	eval("inswitch('" + n + "')")
global x
x = "one" #it was "one"     
tahoe=[]
tahoe.append(0)
victory=[]
victory.append(0)
#######################
### inner switch_1(n):
#######################
def inner_switch_1(n): #test2 is the test
	print("=======inner_switch called==1==",n)
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break   
###================
inner_switch_1(zoo[1]) #this calls it with zoo[1]
'''
##========================
##  darkness()
##========================
def darkness():
    #print("darkness() =========")
    #print(happydays)
    touble=''
    ##print("darkness called=====>>>>>>>>>=====>>>>")
    #print("happy days analyze the pattern for the tabs and how many ")
    counter =0
    print("===================")#this goes thru the string and detects a nested switch
    for line in happydays.splitlines():    #and copies it and puts it into 
        counter += 1    #acgtaully it gets the start and stop location line numbers
        if "\t" in line:
            # print("tab detected in line")
            trouble =line.count("\t")
            # print(line)
            # print("tabs=",trouble," ",counter)
            trouble=''
        else:
            continue
            
darkness()
  
  
  
  
  
  
           
#print("HERCULES TEST RIPPING OUT TABS FROM FRONT")   
'''
to set adding tabs i realized there are two modes
regular switch and nested switch
and to subtract a tab i need to cancel nuke tabs in a line then add the desired number
to get what i want
'''  
import re
myString = "\t\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
#print(myString)
#print("now rip out the tabs")
myString = re.sub(r"[\t]*", "", myString) #was * where I have 2
#print(myString)   
#print("now add a tab")

myString = "\t" + myString
#print(myString)    
myString = "\t" + myString #add second tab
#print(myString)              
            




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






##### this makes the input for zoo[1] lowercase
###############################
## make_input_lower_case() ####
###############################
def make_input_lower_case():
    answer = zoo[1]
    answer = answer.lower()
    zoo[1] = answer    

# what i doing here is putting the dynamic built inners switch python code into a list.
# this is just beautiful and brilliant.

fiddle=[]
fiddle.append(0)
fiddle.append(happydays) #appends the string and puts it into fiddle[1] and exec()
#print(fudge[1])
print("TESTING BLADE RUNNER SERIES =what does an innerswitch by itself need")
print('it is all in one big string about to execute it')
#THIS IS CRITICAL INPUT IN   zoo[1]
zoo[1] = 'test3'# testing (user input lower or upper)
make_input_lower_case() #this converts the input for nested
#see if it works
print(fiddle[1])

exec(fiddle[1]) #this is executing the nested switch method above




sewage = ''
#for item in fiddle[1]:
#    sewage += item
#print("sewage=",sewage)
#print("=====")   
#x =sewage.replace("\t","\t*") #this is so I can see the tabs



#right here 

## add this to it:  
#def inner_switch_3(n): # 
samplecode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n) #3 
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''

#modified on november 12th 2021 friday to get this sucker working 
##====================================
##  get_switch_number_in_comment()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
#this looks ofr the first switch at 3 tabs need to modify it to 1 tab depth. aha 
def get_switch_number_in_comment_in_output_python_code_string(stringname): #this might be for when
	print("get_switch_number_in_comment_in_output_python_code_string(stringname)")
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number_in_comment_in_output_python_code_string() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	for line in stringname.splitlines():
		print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0 #this looks for inswitch at 1 tab depth length 
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "inswitch" in line and "end" not in line and tablength == 1:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number ",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;



flynow=[]
###============================================================================
##  put_output_python_nested_switch_code_into_def_inner_switch_numbered(string):
##==============================================================================
#try this november 12th struggling here 
#I want to see this
'''
def inner_switch_3(n): 
    print("=======inner_switch called==3==",n)
    casetest1 = ['test5','test6']
    #this is switch inside of inner_switch
    inswitch(n)                           #<<====== inswitch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "test1":
'''

def put_output_python_nested_switch_code_into_def_inner_switch_numbered(stringname):
	print('===== TESTING RED ALERT ======')
	print("put outpout python nested switch code into def inner switch numbered")
	#this calls a method to get this switch number to use to number this nested switch
	thenumber= get_switch_number_in_comment_in_output_python_code_string(stringname) #use other code similar to this
	#print("the number it returned is",thenumber) #thenumber=22 #for testing
	string_to_add= "def inner_switch_" +thenumber.strip() +"_(n):\n"
	concatstring = string_to_add + stringname;
	#print("lets see if it actually worked or not and concatted it correctly")
	##################################
	for line in concatstring.splitlines():
		print(line)
	flynow.append(concatstring) #so the resulting string modified exists.
	#########################

#thenumber=22
#string_to_add= "def inner_switch_" + str(thenumber) + "(n):" 
put_output_python_nested_switch_code_into_def_inner_switch_numbered(samplecode)
#makeitso = string_to_add + samplecode;

def testit():
    print("testit called to see if I put def nested method at top of string")
    print("doing samplecode first in virgin form")
    for line in samplecode.splitlines(): #unchanged original output string
	    print(line)
    print(":")
    print("end of test run....")
    print(":")
    print("and now after putting def nestd switch numbere at top")
    print("did this sucker work....please...")
    #for line in makeitso.splitlines():
	#    print(line)
#testit() 
    
dumbstringcode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
			
	switch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			fallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print (" case behavior works in Python now!")
			print("")
			fallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			fallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested  ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner  1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''


fridge=[]
fridge.append(0)


print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
#================================================
x =dumbstringcode.replace("switch","inswitch")
dumbstringcode=x
y = dumbstringcode.replace("fallthru","infallthru")
supergood = y
#=================================================
####### this fixes a bug of the inner switch getting an extra in and it's taken out
#######3=======
print("--------000000000000---testing changing switch and fallthru ====")
print("-------=0000000000000  into inswitch and infallthru ------")
print("testing conversion of a python string of a nested switch")
print("to tranform it into inswitch(), infallthru()")
print("this should be the working version of ")
print("have changing switch to inswitch and fallthru into infallthru")
print(supergood)
print("did it finally work or not===========>>>>>")
z = supergood  #this fixes a bug where the nested switch method is wrong
y = supergood.replace("inner_inswitch","inner_switch")
print("and this should fix the bug of accidentally namming inner_switch")
exam = y
print(exam)
print("===== end of good working code ==============")

#for line in dumbstringcode.splitlines(): #switch case in JS
 #   #print("smartcounter =",smartcounter)
 #   
 #   if "\t\t\tswitch" in line:
 #        umbrella += "inswitch(n)\n"
 #   if "fallthru" in line:
 #       umbrella += "infallthru(
 #       
 #              
       #this is the range I want to print



#this is where the swo string is I was looking for.

print("july 3rd test 2021 6:53 pm")
print("testing nested switch string BETA TESTING ====0")
#find_nested_switch_game ='''
#clever('4')
swo ='''
	switch(exp) { #first true test 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  rrr')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     # inner s w i t c h      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#this one has two nested switches that I will try next. 
swo_next ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  ggg')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # inner s w i t c h     =============  
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #=========================
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 28    ===============   
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch   #38===================================
			fallthru
		
		default:
			print('the end')
}
'''	
# I seem to recall a bug usin

#this is testing sensing a multiline switch with more than one switch
####===============
#testing moved here for safety
# CHECK FOR THE NUMBER OF SWITCHES WITHIN THE INPUT STRING
nested_switch=[]
nested_switch.append(0)
nested_switch[0]= False # by default
################################################################################
#determines if a string input is a nested switch with at least one inner switch
################################################################################

###################
##  jumanji(y)       tests if string input has at least one nested switch
###################  sets nested_switch[0] = True
def jumanji(y):  #instead of this I just do a count for endswitch which is just one line of code. 
	print("--------------------------")
	print(" --- J U M A N J I -------")
	print("--------------------------")
	#print("this determines if it's a nested switch with a nested switch or more in it")
	#print("testing jumanji() counting switches and endswitches")
	#just some sample ifs to read what's the input look like 
	#print("this is looking into the string below")
	#print(swo)
	#print("--- end of string that we will analyze ---")
	#print("")
	#print("get count of lines startingwith switch in the string")
	#this counts switch number in the string
	switchcounter=0
	for line in y.splitlines(): #determine if switch is in line
	#this looks for switch in the line but endswitch can't be in this line
		if "switch" in line and "end" not in line:
			switchcounter += 1  ## SWITCH COUNTER
			#print("switchcounter=",switchcounter)
			#print("yea this starts with switch")
			continue
		else:
			continue
	print("total switches =",switchcounter)
	
	##============================
	#this counts endswitch number in the string
	print("get count of lines startingwith endswitch in the string")
	endswitchcounter=0		
	for line in y.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line: 
			endswitchcounter += 1  #END SWITCH COUNTER
			#print("endswitchcounter=",endswitchcounter)
			#print("yea this starts with endswitch")
			continue
		else:
			continue
	print("TOTAL endswitches =",endswitchcounter) #endswitchcounter
	#print("end of this checker ===========")
	print(" total switches",switchcounter, "and total endswitches",endswitchcounter)
	
	#this sets the flag in nested_switch[0] if at least one nested switch
	#===============================================
	#if one or more switch and one or more endswitches
	if switchcounter > 1 and endswitchcounter >=1: #actually if endswitchcounter 1 it's True
		nested_switch[0] = True
	else:
		nested_switch[0] = False
	
	#print("the result of this test for if this has nested switch(es)") 
	#print("this is the list with the critical nested_switch[0] value")
	#print("WHAT DOES THIS SAY --  it should be True")   
	print("nested_switch[0] = ",nested_switch[0])
	#print("=================")
	#print("=================")
	#print("this  below this is dog breath that doesn't work")
	#print("====== end of this initial switch counter filter that will eventually")
	#print("=== trigger bypass205 to do multiple switches ====")
	
	
#end jumanji()  ===================||	
	
jumanji(swo)  #called here to test it
print("just called jumani with swo and if nested switches below will be True")
print(nested_switch[0])
#this should be the output the nested switch copied








#this is still using endswitch they aren't swopped out yet

## July 5th, 2021  testing Monday July 5th line number 1593
# July 18 added a second nested swithch to test on lines 28 to 38
samplestring ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown  yes')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======28       
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch  #======== ============38
			fallthru
		
		default:
			print('the end')
}
'''	


samplestringzoo1 ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown zoo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			print('hello world')
			switch(exp){  # ===== 24===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'rats':
					print("do autumns")
					print("yep")
					fallthru
				case 'more':
					print("badness")
					break
				default:
					print("we tesla done here")
			endswitch  #========== 34  ==========notice this for it is key 
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======39       
				case 'autumn':
					print("falling leaves")
					print("a night on the town ")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much cranberries")
			endswitch  #======== ============49
			fallthru
		
		default:
			print('the end')
}
'''	


#######################
#### testing ######
### samplestring with switches taken out ####
#### and nested methods replacing it ########
######## july 22 ###testing #####
##### this represents the accurate main switch with proper indentation
samplestring_main ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ff')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			nested_switch_1(n)
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			nested_switch_2(n)   #this is new 28       
			fallthru
		
		default:
			print('the end')
}
'''	


#nested_switch_2(n)
#july 21st 2021 get teh number of lines in the string
# count endsswitches to get number of nested switches
# do the main switch last which erases(skips) the nested switches
#here I count the number of lines in the string to get last line 
# the tricky part was figuring out when to grab the main switch but I couuld actually
#do it first it doesn't matterand make a copy of it and modify the copy


#so I would add a third record to the pears dictionary 1, 44
######=== total lines in the string for the main switch =========
#using the whole string I know that the nested switches will be on the first line
thecounter=0
for line in samplestring.splitlines():
    print(line)
    thecounter += 1
    
print("the total lines =",thecounter)
print("================ wile e coyote =======")






# ibm list is used for holding switch strings 
ibm=[]
ibm.append(0)

use_number=[]
use_number.append(0) #[0]

#def between(x,condition,y):
    
#experimentatl copy the nested switch ignore the rest and only Do one.


#this only copies one nested switch within the main switch
#this i pased on knowing the input 
#these are hard coded here

#just put this here to see if it works correctly
# saturday july 17th, 10:11 am starbucks
#print("STARBUCKS CRUCIAL testing saturday morning")
'''
this is first emptyhing the switch and endswitch locations lists
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





#print("the one below this line should produce 2 switches and one with 10,20")
#this find the location one one pair of a nested switch and end switch

#this gets the start and end from samplestring
#empty_switch_and_endswitch_list_locations()



#this has the output of filling these lists
#switch_location
#endswitch_location

#print("stopping this now to see what it looks like with the switch list and endswitch list")
#return  # to stop the program
''' THIS IS THE OUTPUT OF RUNNING THE FUNCTION ABOVE
===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === 
I need to delete teh first swithc location
switch_location= [10, 28]
endswitch_location= [20, 38]
'''

#print("=== shazam level about to try fancy stuff ====")

#loop
#pairlist is actually a list 
pairlist=[];theforce=[]
#this would just add the switch location
alpha='';beta ='';counter =0;jedi='';
#this reads in data from switch_location
#               and from endswitch_location
#======================================================
# fill_pairlist_with_switch_and_endswitch_pairs(yy):
#======================================================
def fill_pairlist_with_switch_and_endswitch_pairs(yy):
    #print("====fill pairlist with switch and endswitch pairs()=====")
    #print(" godzilla ruled over rodan ")
    get_switch_and_endswitch_locations(yy) #===== using sample stringh 
   # print("this is grabbing the switch locations which are dynamically added to a dictionary for pairlist")
    print("the length of switch location =",len(switch_location))
    print("the length of end switch locatoin =",len(endswitch_location))
    print("==============...............============")
    # loop thru list switch_location ==============================
    counter =0;allpha='';beta='';           #so this is one small set switch and endswitch line numbers
    for item in switch_location: #this loops thru the list switch_location          
        alpha = switch_location[counter]
        beta  = endswitch_location[counter] #they should be the same length 
        #here the positions are appended to pairlist dictionary
        pairlist.append([alpha,beta])       #always in sets of 2 #adds alpha and beta as list into pairlist  list
        print("pairlist=",pairlist)
        counter += 1
    print("======================")
    newcounter=0
    print("the length of the pairs =",len(pairlist));print('let me see what is in pairlist')
    print("pairlist=",pairlist)
    for item in pairlist:  #this is the combined pairlist
        print(item)
        sosmart = pairlist[newcounter] #here I access first and second numbers in pairlist
        print(sosmart[0]);print(sosmart[1]) 
        print("====== JEDI TEST ========")#not to be confused with jumanji above 
        #this takes in data from switch_location list and endswitch_location
        # and glues them together into a new pair list into 
        # list called theforce
        #this is constructing filling the data in the dictionary pair values
        jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
        print('jedi=',jedi) #like this [12,16]
        
        #put pairs into list into jedi and append to theforce
        theforce.append(jedi) #the pair is added  to theforce list
        turbo  =theforce[newcounter]
        newcounter += 1
    print("theforce=",theforce)
    print("the length of theforce list =",len(theforce))
    #print("did we make it this far... in a galaxy")
    #adding loop here to test this
    #print("doing a newest test  christmas tree of the pairs in list theforce")
    acounter=0
    print("====magic brew time=====")
   # print("== the filled list with pairs of switch endswitch is called theforce ===")
    for item in theforce:
        print(item)
        #print("=======")
        cool =item
        print("cool=",cool)
       
        print("acounter=",acounter)
        x=''
        x = cool.split(",")  # see if this trick works
        print(x[0], x[1]) # see if this trick works
        #print("end game")
        acounter += 1
        continue
    #print("end of printing each item in theforce")
###=====





thisdict ={}


def cleanse(x):
    x = eval(x)
    return x;
    
#modified this method on august 11th wednesday, 1:11pm
############################################
##     adding data list to dictionary
############################################
def adding_data_list_to_dictionary(dictname,key,newdata_list):
    #print("LOOK AT THOS at input params see if they are right first")
    print(dictname)
    print(key)
    print(newdata_list)
    return #temporarily halts this from running
    
    print("called adding data list to dictionary")
    #tryit =eval("" + dictname + "[" + key + "]" + "= " + newdata_list +"")
    #tryit =eval("" + 
    angel =dictname
    thekey= key
    newdata_list
    print(angel)
    print(thekey)
    print(newdata_list)
    print("====>>>====>>>end of games...")
    #print(tryit) #to see what it sees
    
    #thisdict["4"] = "[12,22]" #adding data list as string to dictionary
    
    #eventually I will add 1 to dictionary length
    
    ##########################################
    #dictname + key + [12,22] input format 
    ##########################################
    #dictionary name should be known
    print(thisdict)
    for item in thisdict.values():
        print(item)
    print("testing getting value in dictionary by key")
    x = thisdict["4"]
    
    #x = thisdict.get("4") #this should work also
    print(x) #together
    x = eval(x)#just dreamed this up and it worked
    print("this represents getting the x and y for a nested switch locations")
    print("first number",x[0])#seperate
    print("second number",x[1]) #separate
    
    
        
#OUTPUT
'''
called adding data list to dictionary
{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, '4': '[12,22]'}
Ford
Mustang
1964
[12,22]
testing getting value in dictionary by key
[12,22]
first number 12
second number 22
'''
print("fast wile e coyote test  adding data list to a dictionary")
print("==========")
print("==========")

# october 28th, 2021 thirstday
# I need to go thru combined pair list three + five + seven and feed it into a dictionary

## its really get index pair in struct
#### get_number_in_struct(x)   THIS WORKS!!!!!!!!!!! oct 26th



pair_returned=[]

##======================================
##  get_number_in_struct(x):
##==================================
def get_number_in_struct(x):
    print("get_number_in_struct(x) called")
    print("the input was x",x)
    print("get_number_in_struct(x) called too cool")
    print("get ",x)
    #using eval() to do thisdict.get(x)===###################
    apple_pie=eval('thisdict.get(x)')
    print("=====///get number in struck(x) called---------///")
    print("get number ", str(x), " in struct with x called")
    print("apple-pie=",apple_pie)
    super = apple_pie
    if apple_pie == None:
        print("it is None")
    else:
        print("why not",super[0],super[1])
        print("now splitting it into the two numbers within the pair of switch endswitch")
        print(super[0])
        print(super[1])
        #doing this to have common lists for passing on to other functions later
        pair_returned.append(super[0])
        pair_returned.append(super[1])
        print("pair_returned at this point has",pair_returned)
#=============================================


    
#adding_data_list_to_dictionary(thisdict,'5','[12,22]')
print("washing machine time add this '5','[12,22]')")
print("thisdict",thisdict)
numb = '6'

thisdict[numb] = [23,47] #this worked
print("pretty autumn testing")
goaway=''
goaway = thisdict['6']
print("fishfood =",goaway)
print('dirt simple test')
'''
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now 
  "2": [11,60],
  "3": [15,51],
  "4": [23,46],
  "5": [31,41],
  "6": [62,86],
  "7": [66,77]
 #no comma after last data piece apparently
}
'''

#=======================
#add data to struct
#======================

print("no time for pumpkin carving")
#numb = number and aset = [start,stop]
aset=''
numb=''
# this method works on oct 26th 2021
##==============================================
## add_data_to_struct(thisdict,numb,aset)
##====================================================================
def add_data_to_struct(thisdict,numb,aset):
    return #abandoning this too confusing going with just a list of lists
    print("add data to struct")
    print("numb=",numb)
    print("aset=",aset)
    #numb='12' #the number will keep a rolling total and added automaticaly
    thisdict[numb] = aset  #this just seems too simple.
    print(thisdict) 
    
#add_data_to_struct(thisdict,numb,aset)
##============================

gooddata=[]
##==========================================
## get value in dict (name ofdict,x)
##==========================================
def get_value_in_dict(name_of_dict,x): # we will know the dict it won't change
    return #abandonning this for being too confusing and unworkable at this time
    print("plumtree=",plumtree)
    print(thisdict)
    print("get value in dict",x)
    nn = plumtree.get(str(x))
    print("================")
    print("using key",x,"it retrieved from the plumtree dictionary",nn)
    print("================")
    # I was assuming (wrongly) that all keys input would be in dictionary; unknown
    if x in thisdict: #it can't be this simple
        y=eval("plumtree[x]")
        print(y)
        del gooddata[:] #clears it out 
        print(y[0],y[1])
        gooddata.append(y[0])  #this returns with the index[0][1]
        gooddata.append(y[1])
    else:
        print('x',x,'is not in dictionary plumtree')
    
#this builds a new record
#numb='2'
#aset =[11,47]
#thisdict[numb] = data1
#print('input of 2 for [11,47]')
print("==tuesday testing ==add data to dictionary and then access it")
#add_data_to_struct(thisdict,numb,aset)
'''
if '2' in thisdict:
    print('yes 2 is in thisdict')
else:
    print("nope no 2 in thisdict")
#get_value_in_dict(thisdict,'1')
'''
##==========================

print('testing right here === bingo time === adding data to a struct')
#aset =[10,30]
#numb='2'
print('before adding the numbers pairs')
#add_data_to_struct(thisdict,numb,aset)
###=================================


#print(thisdict)
print("should have 2 and 11,47 added to it above")
print("==== boo ==========")
print("cool little test here getting data from dictionary struct")

# GET NUMBER IN STRUCT
#get_number_in_struct('2') #should be [11,47] #it really gets the pair data
#what exactly does this return
#print("output is this ========> ",pair_returned[0],pair_returned[1])
#print("should be  11 and 47")
##===========================
print("cafe borrone coding time")
#aset=[21,37]
#numb='12'
#dictname=thisdict
#add_data_to_struct(dictname,numb,aset) ###====================
#apple_pie=thisdict.get('12')
#apple_pie = aset
#print("should be 21, 37",apple_pie)
#aa = apple_pie[0]
#bb = apple_pie[1]

#print(aa)
#print(bb)
#print("====")
#print("get thisdict 9")
#print("========= happy coding time ====")
#get_number_in_struct('9')
#get_number_in_struct('12') 
#print('should return [21,37]')
#print("====== mocha ice drink ====")
#this retrieves the data based on 9
#print('porsche time...........')



#apple_pie=thisdict.get('12')
#print("apple pie =",apple_pie)
#print("where are we now")


#print("stanford football test...")

#print(thisdict)
#print("======values======")
#for x in thisdict.values():
#    print(x)
#print("==========")
#print("=======items=====")
#for y in thisdict.items():
#    print(y)

#x='2' 
#get_number_in_struct(x)
#x='6' 
#get_number_in_struct(x) 
#x='9' 
#get_number_in_struct(x)
#x='12' 
#get_number_in_struct(x)       
#print("======= gameover ======")
#I will need to loop thru the dictionary blueberries
# so now I am on my way of loading the dictionary which will
#just happen once after the pairs are created.

#print(apple_pie) #should be [22,44]
#print("=====")


#x='9' 
#get_number_in_struct(x)   
#print("should return [22,44]")
#thisdict["GTI"] = [75,85]
#print(thisdict) #should include Cherry=[23,47]
#apple_pie=''
#print("below this it should be 23,47")

#x='6' 
#get_number_in_struct(x)   #should return [23,47]
#print(apple_pie[0])# = 23
#print(apple_pie[1]) # = 47
#apple_pie=thisdict.get('GTI') #should return [23,47]
#print(apple_pie)


#creating a dictionary with initial values (brilliant)
#this is new for oct 7 thursday, 2021 morgan hill starbucks
#data =dict() #create empty dictionary
#data =dict(a=1,b=2,c=3)   #short and sweet fill with initial values
#print(data)

#change a value in a dictionary
#thisdict["year"] = 2018

#if "model" in thisdict:
#    print("yes model is one of the keys in thisdict")
#    
#    #add item to dictionary
#    thisdict["color"] = "red"
#    
#update command
#thisdict.update({"color":"red"})


'''
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now 
  "2": [11,60],
  "3": [15,51],
  "4": [23,46],
  "5": [31,41],
  "6": [62,86],
  "7": [66,77]
 #no comma after last data piece apparently
}
'''
plumtree={} #new dictionary
####=======================================================
#feed list of pairs into dictionary (such as blueberries)
print("testing looping thru list")
#this represents a list of sublists of the switch,endswitch pairs
#I need to make testlist
testlist=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]

returnlist=[]
returnlist.append(0)
#I can make my own custom methods to get from list
#the list is actually referenced starting from 1 where I start the counter
##==============================================
##  get_pair_from_testlist(x):
##==============================================
def get_pair_from_testlist(x):
    print("=========get_pair_from_testlist=========")
    print("testing get_pair_from_testlist",x)
    counter = 1
    print("inside the loop we see for x this ",x)
    for item in testlist: #it doesn't really loop, it's a one pass loop
        #if number entered bigger then length of list warn then break    
        if x > len(testlist): #error detection bypass worked 
            print("ERROR went beyond number length in list")
            print("please enter a number less than ",len(testlist))
            break
        #if number entered less than 1 warn then break
        if x < 1: 
            print("ERROR number must be 1 or higher")
            break
        if counter == x: #it matched with a doable number
            print(item)
            alpha = item[0]
            beta  = item[1]
            print(alpha,beta)
            returnlist[0] = [alpha,beta]
            print("returnlist[0] =",returnlist[0])
            break
        else:
            break
##==============================================================

            
get_pair_from_testlist(1)
get_pair_from_testlist(1)
print("the pair is ",returnlist[0][0],"really cool",returnlist[0][1])
get_pair_from_testlist(-1)
get_pair_from_testlist(0)
get_pair_from_testlist(2)
get_pair_from_testlist(3)
get_pair_from_testlist(4)
get_pair_from_testlist(5)
get_pair_from_testlist(6)
get_pair_from_testlist(7)
get_pair_from_testlist(22)

#Okay. I need to fill the testlist from the threetabs, five tabs seven tabs nine tabs



#the list with the pairs is in testlist

#this dictionary is being abandoned for over complexity and confusion
# november 3ed 10:03 am morgan hill

#this reprents looping thru the testlist and filling data into the dictionary and populating it
##====================================================
##  fill_the_struct_dictionary_with_the_list()
##====================================================
def fill_the_struct_dictionary_with_the_list():
    return
    print('fill the struct dictionary with the list')
    counter=1
    # loop
    for item in testlist:
        print(item)
        aset=[item[0],item[1]]#this creats teh apirs 
        numb=str(counter) #making it a string here . clever
        thisdict=plumtree
        #add_data_to_struct()
        add_data_to_struct(thisdict,numb,aset) ###==============
        print("=======")
        counter += 1

        print("plumtree DICTIONARY now looks like this")    
        print(plumtree)
        print("here we go time to see it work===looping thru plumtree struct=====")
        for x in plumtree.values():
            print(x)
    
        print("===========")    
        for k, v in plumtree.items():
            print(k, v)
#what I am working on his dynmcially loading the 
#from the list to filling the blueberries dictionary
#this returns the index[0][1]
#THIS IS THE METHOD TO FILL A STRUCT RECORD HOLDER FROM A LIST 
#print("I need to empty plumtree dictionary first")
#plumtree.clear()
#print("just emptied plumtree dictionary")
#fill_the_struct_dictionary_with_the_list()




### MORE TESTING HERE ACCESSING THE DICTIOANRY PLUMTREE TO GET THE PAIRS DATA

#print("testing if this will actually work or it's an illusion")
#get_value_in_dict(plumtree,'1')


#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])
#print("====... did it work terrible =")



#get_value_in_dict(plumtree,'2')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'3')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'4')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'5')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'6')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'7')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])


#print('testing getting pair based on number in plumtree')
#apple_pie=plumtree.get('2') #notice it's not a string
#print("it is for '2' this",apple_pie)

#apple_pie=plumtree.get('1') #notice it's not a string
#print("it is for '1' this",apple_pie)

#apple_pie=plumtree.get('2') #notice it's not a string
#print("it is for '2' this",apple_pie)

#apple_pie=plumtree.get('3') #notice it's not a string
#print("it is for '3' this",apple_pie)

#apple_pie=plumtree.get('4') #notice it's not a string
#print("it is for '4' this",apple_pie)

#apple_pie=plumtree.get('5') #notice it's not a string
#print("it is for '5' this",apple_pie)


def testing_pair_list():
    return #not testing this right now
    print("length of theforce=",len(theforce))
    print("together_pair=",together_pair)
    print("======testing pair list() == fireworks time in tahoe ====")
    print("theforce[0]=",together_pair[0]) #first pair coordinates start stop
    print("theforce[1]=",together_pair[1]) # second pair coordinates start stop
    print("===starting loop thru list theforce =======")
    newcounter=0
    print("dog breath test")
    for item in together_pair:
        print(item)
        #this only works for two numbers 2 number long currently
        dog = together_pair[newcounter] #here I access first and second numbers in pairlist
        x = dog.split(",")  # see if this trick works
        print(x[0])
        print("doing surgery cutting off first character")
        charlie=''
        charlie = x[0]
        super=x[1]
        print("super=",super)
        print("=====")
        charlie = charlie[1:]
        print("charlie =",charlie)
       
        super =super[:-1]
        print("super=",super)
        print("===...=.=.=.=.=.=.=.=.=.=.")
        print("===...=.=.=.=.=.=.=.=.=.=.")
        charlie=''
        charlie = x[0]
        charlie = charlie[4:]
        print("charlie =",charlie)
        #print(x[1])
        print("==========")
        newcounter += 1 #python doesn't have ++
        
    print("=== end of looping thru list =======")
    
    
print("MAJOR TEST august 7th, 2021 morgan hill starbucks mocha time")    
print("testing this dam code again...")    

#=======================================================
## this makes the pair list for locations of nested switches august 7th, 2021 
print("DOING TEST of PAIRS of switch and endswitch necessary to do copy and skip comamnds")
print("===================== big test today wednesday =========")
print("what this entails is the mechanics of switch and endswitch locations")
print("which need to be dead on to work correctly for separating the nested strings")
print(" ---- THIS MUST WORK DEAD ON --- for the show of separating teh strings")
print("  --- so this creates the information needed to correctly separate the strings")
print(" === puff the magic dragon time here august 11th ===")
fill_pairlist_with_switch_and_endswitch_pairs(samplestring)
testing_pair_list() #this shows the outpout of grabbing the switch
# and endswitch pairs (sets)



#this way I can use the pair list to copy the nested switches
#========================================================

#print("oh wow does this actually PEAR TREE SHAKE  work pairlist below")
#print("number of pairs =",len(pairlist)) #this is beautiful!!!

#print("oh wow look at this pairlist I made=== starbucks mocha===...")
#print("the length of pairlist =", len(pairlist))
#print('after first attempt')
#sosmart =pairlist[0] #first position
#print("wow will this work >> that would be so cool")
#print(sosmart[0])
#print(sosmart[1])




#print("====== JEDI TEST ========")
#this is constructing filling the data in the dictionary pair values
#jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
#this is building a pair [4, 8]   #an example 

#print("celebration time it almost works completely fireworks")
#print('jedi=',jedi)
#theforce.append(jedi)


#print("I simply add the jedi string which is a list (brilliant)
#print("to theforce list sooo nice")
#make a method here 

#fill jedi with one set 
#print("=======NEXt JEDI TEST ======")
#sosmart =pairlist[1] #second position meaning second nested switch 


#print("wow will this work >> that would be so cool")
#print(sosmart[0])
#print(sosmart[1])
#x = 10
#y = 20
#jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
#print("celebration time it almost works completely fireworks")
#print('jedi=',jedi)

# feed jedi set of 2 numbers into the forcelist with an append
#was theforce
#theforce.append(jedi)

#print("theforce=",theforce)
#print("the length of theforce list =",len(theforce))

########################
#print("the =========== force here ========force shows",theforce)
#print("theforce[0]=",theforce[0]) #set one of pair of a switch start and endswitch
#print("theforce[1]=",theforce[1]) # set second pair of a switch and endswitch locations

# so this is building the pears lists of switch endswitch so then I would add the pearslist
#to a dictionary now I think. 

############













#this would just add the switch location


#I can createa  new list to make the pairs first
#go thru grabbing the first number first
#then on the second loop add the second the endswitch

#fill the pears dictionary now
#exit()


#print("switch_location=",switch_location)
#print("endswitch_location=",endswitch_location)

#what is the output???
print("snow man here ")
print("I need to have it flow into the range below lists")
#these are hard coded in here 
print("the output from get swtich and endswitchlocatin for samplestring")
print("right below this line")
print(" RODAN FLYING......")

#for some strange reason the get swithc and endswitch locations are off by 1

#switch_location[0] -=  1
#endswitch_location[0] -=  1
#print("what type is it switch_location[0]",type(switch_location[0]))
#test =switch_location[0] 
#test=test-1
#switch_location[0] = test
#print("switch_location now",switch_location)

#test =endswitch_location[0] 
#test=test-1
#endswitch_location[0] = test
#print("endswitch_location now",endswitch_location)

##============================================================
#these are in switch_location and in endswitch_location


######################################################
list_of_switch_range=[]
list_of_switch_range.append(0)
list_of_switch_range.append(0) #was 10 hard coded 
list_of_switch_range.append(0) #was 20 hard coded

#list_of_switch_range[1] = switch_location
#list_of_switch_range[2] = endswitch_location
##############################################################
## july 17th, 2021 11:12 am
print("IS THIS WORKING OR NOT ==========")
#here we feed the input switch and endswitch into range lists
#THIS WORKS FOR JUST ONE INNER NESTED SWITCH 

anest_string='''
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''
print("wild wild west test...")

###########################################============
#experimenting on nov 4th thursday 
get_first_switch_test='''
			switch(exp){ #21         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''

get_first_switch_da='''
			switch(exp){ #  54         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					switch(exp) # 98
					break
				default:
					print("we are done here")
			endswitch 
'''

# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)
got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname):
##====================================================
def get_switch_number_at_top_of_string(stringname):
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		print(line)
		print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;


# here I would add the strings in quail after they have been separated
# and they are in the list mytestlist. I then apply a method to each
# string to get teh switch number at the top and append it 
# to the list got_the_number
 # I will need to loop thru the quail list of the seperated switch strings
 # and append the strings within to mytestlist
 #so actually I would loop thru quail list and call get switch number

mytestlist=[]
mytestlist.append(get_first_switch_test)
mytestlist.append(get_first_switch_da)
del got_the_number[:] #clear out this list at the beginning

#loop thru list with thes trings
#feed the strings into method get switch number at top first switch
##=====================================================
## get_first_switch_number_from_all_strings()  fly jets
##=====================================================
def get_first_switch_number_from_all_strings():
    print("get_first_switch_number_from_all_strings()")
    for item in mytestlist: #this will be quail list before parser
        get_switch_number_at_top_of_string(item)


get_first_switch_number_from_all_strings()
print("really got_the_number=",got_the_number)
# this will be my so-called twin list
# that I will use 
# for the python outoput strings in the stanford list
# to use to make the nested_method names for the defs


#exit();

#
'''
 this transfers the line location of switch and endswitch
 to list of switch range 1 and 2 from 
 switch_location and endswitch_location
'''
#28,38 for second string
# I am skipping using this now NOT using this method 
##################################################
##  get_one_nested_switch_start_and_finish()
##################################################
def get_one_nested_switch_start_and_finish():  # this gets the input from switch_location[0]
    print("get_one_nested_switch_start_and_finish()")
# and from  endswitch_location[0]

## this takes in the two lists of list_of_switch_range[1] and list_of_switch_range[2]
    print("=== ||=== get one nested switch start and finish line numbers")
    #force feeding it the second nested switch location input data 
    #these are hard coded for testing 
    #switch_location[0]    = 28  #july 18th testing 2nd nested switch
    #endswitch_location[0] = 38  #july 18th testing 2nd nested switch 
    list_of_switch_range[1] =switch_location[0] #force it in here
    list_of_switch_range[2] =endswitch_location[0]
    #list_of_switch_range[0]=0
    #list_of_switch_range[1]=10
    print(list_of_switch_range[1])
    print(list_of_switch_range[2])
    #list_of_switch_range[2]=20


the_nest_string= fridge[0] 



print("real string test from columbia river")

counter1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown  ffgh')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
			exp = 3
			switch(exp){ #49
				case 'burger':
					print("do something")
					####################
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''


#===========
counter2='''
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
'''
#===========
counter3='''
			switch(exp){ #49
				case 'burger':
					print("do something")
					####################
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''

#===========
counter4='''
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
'''

#===========
counter5='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
'''
#===========
counter6='''
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
'''

testing_string_list=[]
testing_string_list.append(counter1)
testing_string_list.append(counter2)
testing_string_list.append(counter3)
testing_string_list.append(counter4)
testing_string_list.append(counter5)
testing_string_list.append(counter6)
#this is what has the string_with_nested_switches in it
# THIS TAKES TABS OUT OF THE ENTIRE NESTED SWITCH 

teststringgonow='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''
funky='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch 
'''

###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	print("======starter engine called======")
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #had "not"
			tabdepth = line.count("\t")
			n= tabdepth;n = n-1  #need to have one tab in front
			break
	passthis[0]= n;print("n =",n)
goldtime=[]
goldtime.append(0)
##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    print("====modern tab shifter to left=======")
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
    print("output of concatted string in goldtime[0]")
    for line in buildstring.splitlines():
        print(line)
  


#modern_tab_shifter_to_left(get_first_switch_da)
print("===== intermission 1=====")
#modern_tab_shifter_to_left(teststringgonow)
print("===== intermission 2=====")


print("testing indenting all 7 strings using modern tab shifter to left()")
for item in testing_string_list:
    modern_tab_shifter_to_left(item)
    print("==== line =====")
print("let them play in the snow")    
#exit()
print("================================")
print("================================")
print("============go baby work ====================")
print("================================")
catching_first_change=[]
print("testing going thru loop and calling one method to start ")
print("TEST MODE NOW...")
for item in testing_string_list:
    print(item)

#=================================== friday nov 19th =============================
# this is where I am applying a method to each item in input switch strings list
###===============================================================================
## THIS IS GOING THRU LIST AND CALLING METHOD modern_tab_shift_to_left(item) to each string
## and then putting modified switch string into list catching_first_change
counter=1  #FILLING CHATCHING_FIRST_CHANGE LIST FROM TESTING_STRING_LIST
for item in testing_string_list: #just filled this above
    #print(item)
    #method shift string to left
    modern_tab_shifter_to_left(item) #now put it into a new list
    #result put into goldtime[0])
    #add modified string to list catching_first_change
    #result of method effects on string goes into goldtime[0]
    #which is then appended to new list
    catching_first_change.append(goldtime[0])
    print("counter =",counter)
    print("=========================")
    
print("the exit sign is GREEN ....")  
print("the output change in list now..")
#print here we empty the original list and then refill it with inbetween list
del testing_string_list[:]   
print("this is filling the list testing_string_list from list catching_first_change")
for item in catching_first_change:
    print(item)
    testing_string_list.append(item)
print("================================")
print("=======strings modified in origional list testing_string_list ============")
##== here we see what's in the list

print("now blue orion looking thru original strings in list after being modified")
for item in testing_string_list:
    print(item)
 
  
#exit()










##########################################
##  take_out_x_tabs_from_front_of_line(n):
##########################################
def take_out_x_tabs_from_front_of_line(the_nest_string):
	starter_engine(the_nest_string);n=passthis[0]
	print("take out ",n," tabs from front of line - of string")
	print("take_out_x_tabs_from_front_of_line(n)") #make this is into a method 
	print("n=",n)
	#get tab count in line with switch and counter =1
	#should be governed by the first line with switch 
	
				
	wildness=''
	print('half way down n =',n)
	for line in the_nest_string.splitlines(): #nest_string
		
		newline = line[1:]
		print(newline)
		
		if n == 4:
			wildness += line.replace("\t\t\t\t","\t") 
		if n == 3:
			wildness += line.replace("\t\t\t","\t") #strips one right
		if n == 2: #this leaves 1 tab in front of each line
			wildness += line.replace("\t\t","\t") #strips one right
		if n == 1: # we only one one tab in front of the switch word as the guidepost
			pass #do nothingwildness += line.replace("\t\t","\t") #strips one right
		wildness += "\n"
	print("after minor surgery see if this works")
	print(wildness)
	fridge[0] = wildness
	return wildness # this worked

#3 take out 2
the_string='''
				switch(exp){ #  54
					case 'blable':
						print("do something")
						print("yep")
						fallthru
					case 'more':
						print("nice")
						switch(exp) # 98
						break
					default:
						print("we are done here")
				endswitch 
'''

#2 take out 1
the_second_string='''
		switch(exp){ #  54
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				print("nice")
				switch(exp) # 98
				break
			default:
				print("we are done here")
		endswitch 
'''


toocool=the_string.replace("\t","",1)
for line in toocool.splitlines():
    print(line)
trythis=toocool    
print("after first reduction")    
gonow=trythis.replace("\t","",1)
for line in gonow.splitlines():
    print(line)
    
print("did it twice")    
        
print("go away")
take_out_x_tabs_from_front_of_line(the_string)
print("road block here")
take_out_x_tabs_from_front_of_line(the_second_string)
print("hiking up Loma Road")
#exit()

#store in a dictionary each pair of switch and end switch params
# then I loop thru it with the numbers

####============ july 19th 2021  Monday ===================
# I already have the code to build a list of all switches and endswitches
# but I need to put them into a dictionary when I do that search to capture them as pairs

##================================

'''
swtich endswitch location
for trackcing hwer eto grab each nested switch
list with nestd swithc method name with number loop thru it
alist=[]
so = "10,20"
alist.append(so)
thisdict={
"brand":"Ford",
"2":alist[0],
"year":1964
}
#grab content by number
x = thisdict.get("2")
print(x)
# macro between
# put n thru m in a list
# then just this
# if x in list_of_numbers
'''

print("testing dictionary to hold switch endswitch pairs (pear tree)")
print(" ==== testing using a dictionary now ==== mayflower ship===")
alist=[]
alist.append(0)
alist.append(10)
alist.append(20)
alist.append(30)
alist.append(40)

color_table={
    "brand":"mocha",
    "Red": [10,20],
    "3": [30,40]
}

coffee = color_table["Red"][0]
print(coffee)
coffee = color_table["Red"][1]
print(coffee)
#grab content by number
#coffee = thisdict.get("2")
#print(coffee) #it should print 10,20
#print("now another one")
#coffee = thisdict.get("3")
#print(coffee) #it should print 10,20


friend1=[]
friend2=[]

thisdict =	{
  "1": [4,7],
  "2": [10,20],
  "3": [21,30]
}
for x in thisdict.values():
  print(x)
  cool = x
  print(cool[0])
  print(cool[1])
  friend1.append(cool[0])
  friend1.append(cool[1])
  print("good times")
  print(friend1)
  





### successful test for between macro ################### july 19th, 2021 ########## 

print("testing between macro and how it will work")
mylist=[]

mylist.append(3)
mylist.append(4)
mylist.append(5)
mylist.append(6)

testlist =[]
testlist=[1,2,3,4,5,6,7,8,9,10]
#####################
##  between test()
#####################
def between_test(): #between macro 
#it would have to be like this
#if a between(x,y)
    print("BETWEEN TEST HERE ----")
    print("bla bla bla")
    print("between test")
    #x = 7
    print("the final outcome..")
    # if x >= switchline and x <= end switchline  #meaning  from start number thru endnumber
    #if x is between switchnumber and endswitch number
    #the list would contain the start number thru the stop mumber 
    # if x is between startnumber and endnumber:
    counter=0 #the logic is to be between x and y it's inclusive of x and y also
    for item in testlist: #so we look for a narrow range within the large input range
        if item in mylist:
            print("yes",item)
            counter += 1
            
        else:
            print("nope",item)
            counter += 1

print("=====do test of between macro proof of concept=====")
between_test() #this tests if we have a list of numbers 1 to 6

print("testing this with between")
zoo = 4
#if zoo between 1 and 6:
alist=[]
alist=[1,2,3,4,5,6]
print("======= BEtWEEN TESt ========")
print("testing the replacement for using betwen")
print("if zoo(4) is between 1 and 6")
if zoo  in alist:
    print("yes it's between 1 and 6",zoo)
else:
    print("nope",zoo)


###=========================
##   between() macro
##==========================
def between(x,y,z):
    print("between called for if x in list between y and z")
    if x in alist: #1 thru 6
        print("True yes ",x, "between ", y, " and ",z)
    else:
        print("False,",x," is not between ",y," and ",z)



print("doing between macro tests....")
between(4,1,6)
between(10,1,6)
between(0,10,25)


#also next add
##==================
##  after macro
##  before macro
##================

############## testing using  a dictinary to store
############## pears of switch and endswitch pairs

#this will be generated. but I think that
# I might have the dictionary pears already existing.

###====================== dictionary storage area =================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================

#dictionary called pears
peartree = {}  


#given name peartree of dictionary
def get_value_of_key_original(x): #peartree hardcoded in
    car=eval("peartree.get('" + str(x) +"')")
    print(car)
    return car #so if it is a list it should return a list right?z

#given name peartree of dictionary
def get_value_of_key(dict,x):
    car=eval("" + dict +".get('" + str(x) +"')") #maybe
    print(car)
    return car #so if it is a list it should return a list right?z


########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists
####################################################################||
### PRACTICING ADDING DATA TO A DICTIONARY CALLED PEARTREE  
#####################
## do this baby 

#what I need to do is add to a dictionary dynamically 
#####################
def do_this_baby():
    print("do this baby caled")
    print("===do this baby() adding data to peartree dictionary called ......====")
    print("practicing ADDING data to see if it works (this will be done dynamically later")
    peartree['1'] = [10,20]
    peartree['2'] = [28,38]  #uses small anonymous list for data
    print(peartree)
    x = peartree.get("1")
    print("x=",x)
    
    
def add_data_to_peartree(x,z):
    answer =''
    answer = "peartree['" + str(x) +"'] = z " #[10,20]
    print("just before exec add data to peartree")
    print(answer)
    exec(answer)
    
fool_on_hill= '[10,20]'
print("TESTING adding data to a dictionary")
add_data_to_peartree(1,fool_on_hill)
print("peartree has in its contents=")
print(peartree) 







#testing adding data record to dictionary dynamically.
#Declare a dictionary (empty) 
print("dynamiclaly add data to dictionary = DRIVE THRU ")
print("testing dynanmically adding data to a dictionary Drive Thru")
data = {'a': 1, 'b': 2, 'c': 3}
print(data)
data.update({'d':3,'e':4})  # Updates 'c' and adds 'd'
print("====after adding d and e dictioanry data======")
print(data)

fun={} #dictionary called fun
print("first the fun dictionary is empty")
print(fun)
#input values to dynamically add data for teh switch endswitch to dictionary

print("adding data to drivethru dictionary ")
print(" RED WHITE AND BLUE ")
drivethru={}
#drivethru.update('1': '[10,20]')
#drivethru.update('2': '[30,40]')
#3drivethru.update('3': '[50,60]')
#drivethru.update('4': '[70,80]')
#print(drivethru)

#zerohour=get_value_of_key(3)
#print("zerohour=",zerohour)

cherish=[10,20]
skyblue =[28,38]

def get_dictionary_size(x): #length
    shit= len(x)
    print("size of this dictionary",x," is",shit)
    print("so the result is ",shit)
    return shit;
    


print("This is doing an update here --->")
fun.update({'1':cherish,'2':skyblue})
print("hard coded here printing out the dictionary fun")
print(fun)
print("========")
num1='3'
num2='4'
silver =[42,46]
gold =[50,52]

#put these into a list also
crystal=[]
crystal.append(0)
crystal.append(num1)
crystal.append(num2)

dust=[]
dust.append(0)
dust.append(silver)
dust.append(gold)



#=
##==============================
def dynamically_add_data_to_dictionary(a,x,y):
    print("testing... dynmically add data to dictionary a, x, y")
    print("Tesitng using lists now which are changeable on the fly")
    a.update({crystal[1]:dust[1],crystal[2]:dust[2]}) #totally dynamic attempt here
    print(a)
print('did this work adding to dictionary')
##################################################################
print("here dynamic attempt --boo scoopy doo van does this work----->>")
dynamically_add_data_to_dictionary(fun,gold,silver)
print("3  =[42,46]")
print("4  =[50,52]")

print('after updating fun dictionary dynamically  strawberry fields===')
print(fun)
print(fun.get("1"))
rat=fun.get("1")
print("below should be 10 and 20 for the result")
print(rat[0])
print(rat[1])

print(fun.get("3"))
rat=fun.get("3")
print("below should be 42 and 46 for the result")
print(rat[0])
print(rat[1])

print(fun.get("4"))
rat=fun.get("4")
print("below should be 50 and 52 for the result")
print(rat[0])
print(rat[1])

print("==== end of adding to data to dictionary dynamically ===")
for k,v in fun.items():
    print(k, v)
    print(v[0],v[1])
    print("----------")

#modidfy this get value to use dictoinary name as parameter  
print("here we are testing get_value_of_key(dictname,keynumber)  (fun,3)")  
#note dictionary name as param MUST BE A STRING in quotes 
love=get_value_of_key('fun',3) #dictionary name and key number

print('the value of key  in fun =',love)
print("should return 42, 46")
print(love[0]) #42
print(love[1]) #46

print("testing getting the length of the fun dictionary")
golddust=''
golddust =get_dictionary_size(fun) #so I would call this before adding to it so
print("so now we can get the number for number of items in a dictionary")
print("we have ", golddust," as the length for dictionary fun")
#that I can add just the new data list [3,4] example and not think about key number
# basedon the length I just add 1 to it
print("above this line should be the size of the dictionary fun pumpkins")
######################################################################
print("now to empty dictionary called fun")
fun.clear() #empties dictionary
print(fun)
    
##===============================
## get_size_of_dictionary  (name of dictionary)
##===============================
def get_size_of_dictionary(zoo):  #this is so I know what next record should be
    print("get_size_of_dictionary")
    answer = len(zoo)
    print("get size of dictionary zoo",answer)
    #how do I loop thru a dictionary
    print(":this is printing out peartree ")
    for x in peartree:
        print(x)
    print("====")
    print("")
    print("this loops thru dictionary thisdict")
    for x in thisdict.values():
        print(x)
    print("")   
    print("===loop thru dictionary== this.dict ==")
    for x, y in thisdict.items():
        print(x, y)




car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

def playing_with_dictionary_structs():
    print("playing with dictionary access...")
    x = car.get("model")
    print("testing getting car model")
    print(x)

playing_with_dictionary_structs()

   
#but I just thought I can have a running total in a list too
def do_something():
    print("Muppets Animal")
    result=''
    do_this_baby() # I think that the list peartree was empty when I was testing it
    print(peartree)
    print("get size of dictionary ... a test")
    #how do I determine if a list is empty
    if len(peartree) > 0:
        result= len(peartree)
        print("length of peartree =",result)
    else:
        print("peartree is empty and equal to 0")
        print(len(peartree))
    print(result)
    return result
######################################
do_something()

    


print("doing simple test here to get value of key number in peartree dictionary")
print("====Domino's Pizza= dominios pizza dominios pizza=")
firstone=get_value_of_key_original(1) #its using peartree
print('the value of key 1 in peartree =',firstone)
print("does this work or not???")
print(firstone[0])
print(firstone[1])

print("===== pizza hut ===has terrible pizza =")
secondone=get_value_of_key_original(2)
print('the value of key 1 in peartree =',secondone)
print("peartree[2][0] =",secondone[0])
#print(type(secondone[0]))
#print(str(secondone[0]))
#print(type(secondone[0]))
super = secondone[0]
#this force it into becoming a string actually 
#print(eval('secondone[0] == ' + str(super)))
print(super)
print("where is it")
print("type=",type(super))
if secondone[0] == 28: #int actually
    print("this tests :  if secondone[0] == 28:")
    print('too funny no chance in hell====it will never work ')
else:
    print("no way will it work")
    
print("peartree[2][1]=",secondone[1])
foolish = secondone[1]
foolish = str(foolish)
print(type(foolish))
print("now it's a string")
print("end of htis test")
 #peartree['1'] = [10,20]
 #peartree['2'] = [28,38] 
    

#example getting the size of dictionary peartree    
get_size_of_dictionary(peartree)




###############################################
## dnanmically add one record to dictionary
###############################################
def dynamically_add_one_record_to_dictionary():#will need some params
    print("starbucks morgan hill checking this out")
    print("dynamically add one record to dictionary ()") #what about input param
    #first pass go thru dictionary to determine it's current length put that into a list
    super=''
    super=get_size_of_dictionary(peartree)
    #so to add 1 to super for next record
    testtheory='[42,60]' #this is hardcoded here but testing at this stage so it's ok
    #super += 1
    #combine = firsthalf + secondhalf 
    #print(combine)
    #eval(combine)
    #print(combine) 
    #hard coded adding data to dictionary here obviously
    
    peartree['3'] = [42,60] #there would have to be 4 slots already to work
    print(peartree)
    get_size_of_dictionary(peartree)
    print("now yellow BIG BIRD test =========")
    ### look here this is correct below that owrks 
    fish =  "peartree['4'] = [66,80]"
    exec(fish)
    print("experimenting here adding new item to dictionary peartree for testing")
    ##======================================
    thenumber = 5; 
    y1 = 82; 
    y2 = 94
    salmon =  "peartree['" + str(thenumber) + "'] = [" + str(y1) +","+ str(y2) + "]" 
    #this would be blueberries 
    print("salmon=",salmon)
    #salmon= "peartree['5'] = [82,94]"
    #salmon= peartree['5'] = [82,94] #this one is correct
    exec(salmon)
    
    #and I can use 'peartree' as a var and connect it will try that next. 
    #what I built up above needs to look like this string 
    
    ###==========================
    #I need a database for each function that is searchable
    #with a tag of what it does - behavior
    #I could do it in javascript with my switch case
    ###=============================
    
    
    get_size_of_dictionary(peartree)
    print("is peartree 4 here with 66,80")
    print("looping thru dictionary peartree here on oct 23rd")
    for x, y in peartree.items():
        print(x, y)
    #output
    #output='''   
    #    1 [10, 20]
    #    2 [28, 38]
    #3 [42, 60]
    #4 [66, 80]
    #5 [82, 94]
    ##########################
    num = 5
    numb1 = 200
    numb2 = 280
    firsthalf  = "peartree['" + str(num) + "'] ="
    secondhalf = "[" + str(numb1) + "," + str(numb2) + "]"
    print('look here very carefully....')
    print('secondhalf=',secondhalf)
    together = firsthalf + secondhalf
    print("look at below this line does it look right GROUCH")
    print(together)
    exec(together)
    
    
    
    get_size_of_dictionary(peartree)
    #print(peartree['5'])
    print("get value of 5",peartree.get('5'))
    ###########################
    '''
    loop thru peartree:
        print(item)
    '''
    for item in peartree:
        print(item)
        
    for x in peartree.values():
        print(x)
        
    print("chocolate somores. ")
    sweet =get_value_of_key_original(1)
    print("sweet key 1 =",sweet)
    
    get_value_of_key_original(2)
    get_value_of_key_original(3)
    get_value_of_key_original(4)   
    get_value_of_key_original(5)
   

#this will be used to take in a set of two numbers switch endswitch
#to add to the pears dictionary
#### makes [24,34] from ab and returns it
#### make list with two pieces of data (ab)
def make_list_with_two_pieces_of_data(a,b):
    jedi=''
    jedi = "[" + str(x) + "," + str(y) + "],"  #notice it adds the comma on the tail
    return jedi
    
#making peartree['1'] is not tough

#what about this
#dynamically build it [10,20]
x = 10
y = 20
jedi = "[" + str(x) + "," + str(y) + "],"  #notice it adds the comma on the tail

print("")
print(" lightning round")
print("testing dynamically creating a two slot list to add to a dictionary")
x = 22
y = 33
raz=make_list_with_two_pieces_of_data(x,y)
#this does this
#  jedi = "[" + str(x) + "," + str(y) + "]," 
print("should return [22,33]")
print(raz)



print("celebration time it almost works completely fireworks")
print('jedi=',jedi) #creates [10,20],

print("interesting test to dynamically add a record to peartree dictionary")
print("KERMIT THE FROG test riding a bicycle")
run=get_size_of_dictionary(peartree)
print("size of dictionary before adding to it ",run)
dynamically_add_one_record_to_dictionary()
run=get_size_of_dictionary(peartree)
print("size of dictionary now is ",run)
#######################################################
do_this_baby()
print("did this work or not")
print("july 20th, 2021 wow time flies")
print(peartree)
###################################################################||

#######################
peartree = {}   #this will always exist and needs to exist to work.
buton=[]   #this is the passing of the buton in track and field relays
buton.append(0) #two positions here in this inner list
buton.append(0)
########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists

### PRACTICING ADDING DATA TO A DICTIONARY CALLED PEARTREE  


# test input
# this adds a datum to peartree
# this is the method to add a 
# new switch pair to dictionary peartree

#it was add_this <<=========
# now it's this
#####################################
## add_data_to_pears()
#####################################
### the dictionary name is hardcoded as peartree
# peartree is a dictionary
# buton is a list with two slots 

def add_data_to_pears(x,apple):
    print("add_data_to_pears()",x,apple)
    peartree[x]=apple  #this is where the list is added
    print(peartree)

#adding data to dictionary pears here 
 #july 21st 
 #simple var with data is a list anonymous which is what I will construct
apple = [10,20] #<<====== right here I need to produce this from the switch output
x = '1'    
add_data_to_pears(x,apple)  #feeding a new switch pair into peartree

##======
apple = [28,38]
x = '2'  #here I have to provide the number, now I can figure out what 
#it needs to be by getting the length of the dictionary and adding 1 to it.
#for th enext input of data to add to the dictionary. 
add_data_to_pears(x,apple)
##======

print('tahoe test')
print("testing getting a list out of the dictionary in terms of whats in it")
cd=get_value_of_key_original(2) #see if it returns [28,38]
print(cd)

################################################
###### TESTING FILLING A DICTIONARY ############
###############################################@

# I will nede a loop
# july 21st, 2021
#this looks into peartree for a key to return a value
# the values it put into buton[0]and buton[1]
 
# this is accessing the peartree
##############################
##  ACCESS_SWITCH_1_N
##############################
def access_switch_1_n(t):
  print("access_switch_1_n() called")
  print(peartree.get(t)) #was '1'
  one=peartree.get(t)
  print(one[0])
  print(one[1])
  #################
  # added July 21st
  buton[0]= one[0]
  buton[1]= one[1]
  print("this is looking into buton list")
  print("================//================")
  print("buton[0]=",buton[0])
  print("buton[1]=",buton[1])
  print("================//================")
  ##################
  print("I can now grab")
  print("the nest switch params")
  print("from the pear tree")
  print("to feed  copy nest method")
  print("first",one[0],"second",one[1])

#this is accessing the pears dictionary to get the data by the key
### this calls the method above   
t='1' 
access_switch_1_n(t) #accesses key 1


t='2' 
access_switch_1_n(t) #accesses key 2


###############################

# output 
'''
add_this called
{'1': [10, 20]}
add_this called
{'1': [10, 20], '2': [28, 38]}
access switch called
[10, 20]
10
20
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 10 second 20
access switch called
[28, 38]
28
38
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 28 second 38
'''
#<href="https://discover.cs.ucsb.edu/commonerrors/pythonerrors.html"> python common errors UC Santa Barabara</a>

########
b=''
##############################################
## ACCESSING DATA IN PEARTREE DICTIONARY #####
##############################################
def accessing_data_in_peartree_dictionary():
    print("====accessing data in peartree dictionary ==")
    print("====Accessing data  from peartree dictionary()....====")
    print("accessing keys in the peartree  which I would do with a loop later.")
    #print now accessing the dictionary that has been filled with data
    #x = peartree("1")
    print(peartree)
    x =peartree['1']  #adding data to a dictionary
    print(x)
    print(x[0],x[1])
    print("============")
    #x = peartree("2")
    x=peartree['2']  #adding data to a dictionary 
    print(x)
    print(x[0],x[1])
    print("how did it go Hogwarts after flying the car over London")
    
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    
    #this is where I access the dictionary
    # and call the code to get the nested swith
    # based on the switch and endswitch location params
    
    print("==== now trying a LOOP thru peartree =====")
    counter =1  #starting from 1
    for item in peartree: #looks in peartree in this example and splits pair set to display
        x = str(counter)
        b = peartree[x] #this was "1"
        print(b[0],b[1]) #these will always be the same 
        counter += 1
## output is correct
'''
==== now trying a LOOP thru peartree =====
10 20
28 38
'''
#this is for the numbering and access to the nested switches
# and governing them and number the nested_switches and managing it all perfectly.
#================ thursday, august 19th, 2021 solution =============================
#so with this approach number is simple 1 to n for each tab level
#only thing that I change is level depth of indentation
#so if we have main switch and then 3tab depth then 5tab depth
#level0, level1, level2
#level stands for nested switch depth
#so I can use the numbering 1 thru n for each switch
#and use the numbering system and just add the level[0] in a list
#level[0] is main 1, 2, 3, 4, 5 #nested numbering
#level[1] tab depth 5 is first level nested switch if nested within 1, 2, 3
#level[2] tab depth 7 is second level nested with , 1, 2, 3
#level[3] tab depth 9 is third level 
#def loop thru pears dictionary and call  nested switch
#==================================================================

#this calls the method above:        
accessing_data_in_peartree_dictionary()

### this would be after filling this with switch_location and endswitch_location method

print("practicing with this hardcoded input data for switch and endswitch to prove it works")
print("down at pears tree here hard coded ")
# this represents a dictionary called pears already loadded with data
#=================================================
########################
##  PEARS DICTIONARY
########################
#pears =	{  #for pear tree in backyard (2 of them)
#  "1": [10,20], # I can make these now 
#  "2": [28,38],
#  "3": [1,44]
#}

#testing with this new data multiple nested switches

#this hardcoded I put this in here. it's not automated yet
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently

}

#for red_robin
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now  1 tab level start and stop
  "2": [11,60], #3 tabs
  "3": [15,51], #5 tabs
  "4": [23,46], #7 tabs # yes it is a stacked at 3 tab level already 
  "5": [31,41], #9 tabs
  "6": [62,86], #3 tabs
  "7": [66,77]  #5 tabs
 #no comma after last data piece apparently
}


#nest_string has pears
#and then blueberries added. 
#solved it.
 
#da = blueberries.get("2")
#print("getting data in blueberries")
#print(da)

'''
11 is in 1
62 is in 1
15 is in 11
23 is in 15
31 is in 23
66 is in 62
'''


def lametest():
    print("doing lametest()")
    if 11 in range(1,86):
        print("true")
    else:
        print("false")
    
lametest()

#new pears

#creates this

#this string already has numbered switches with comments 
#note that the numbering of the switches isn't starting from 1 down.
#testing this sep 30  #switch11 is the main switch
foolish='''
			switch(exp){  #11  first level deep                   Level 1... 3tabs
				case 'blable':
					print("do something") #formula is switch number + 1 thru second number
					#################### cut out 16 thru 38
					switch(exp){ # 15  #second level deep          Level 2    5 tabs=================
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23  #third level deep   Level 3   7 tabs  
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33 === 7 tabs 
							#############
							break
						default:
							print("we are done here")
					endswitch #38   # 5 tabs========================
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
			exp = 3  #note that this switch is stacked below the bottom stack at 3 tabs
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  # 53second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''
#end result will be .......
##=======================
''' main string is 11 thru 73
        pair   tab count
  "1": [11,47],[3] # I can make these now #but it has two starting points SECTIONS
  "2": [49,73],[3]
  
  "3": [15,38],[5] 
  "4": [53,64],[5]
  
  "5": [23,33] [7]
#main 1  to 3 tab depth level 1 ONE
only switches at 3 tabs 
#it should be 
###########
mainswitch number followed by it's nested switches which will be methods
====switch numbers two columns===
first position [0] is first switch id line number for that string
second list can have more than one number represents the switchnest numbers
now figure out how I calculate this and fill it as a listwith sublists
[1] [11,49]
[11][15]
[49][53]
[15][23]
[23][0]
'''
# what this does is add ..  # 66  the line number after each switch(exp){

print("TWIN LIST let's take a look and see what's in it")
#print("let's look inside of twinlist",twinlist)
#they have to be in the same order as the actual switch cases

'''
##================
======1:3==========                   switch1 > switch11 and switch49  =========
switch1
     switch11 method 3 tabs first number from pair 11,47
     switch49 method 3 tabs first number from pair 49.73
end73
#==============================       switch11 > switch15  =======
only switch at 5 tabs between 11 and 47
#minor 3 tab to 5 tabs  Copy 11 thru 47 TWO
switch 11  3 tabs
     switch 15#method  5 tabs   must be between 11 and 47
switchend47
#=============================         switch49 > switch53    ======
#minor 3 tab to 5 tab   THREE
only switch at 5 tabs between 49 and 73
switch 49
     switch 53 method must be between 
endswitch73
##====================  FOUR           switch15  > 23 =======
#minor  5 to 7 tabs   
only swith at 7 tabs between 15 and 38
switch 15
     switch 23 method
##====================  FIVE           switch23  none ======== by itself
#minor none 7 tabs not nested because no 9 tabs its an end tail
switch 23      
$$$$$$$===================================================$$$$$$$$
# I need to be able to generate the pattern
if tab depth == 3 then
first number of pair[0] is nested switch 11 and 49
     switch11 method  first number from pair 11,47
     switch49 method 
     
=======3:5
if tab depth == 5 then
first number of pair[0] 15 goes inside minor 
three tabs to five tabs
switch 11
     switch 15#method   must be between 11 and 47
switchend47
===== 3:5
[49,73],[3]=== [53,64],[5] if secondpair[0] > firstpair[0] and 
switch 49
     switch 53 method must be between 
endswitch73
#testing this
combinedtabs=[]
combined_tabs = threetabs + fivetabs + seventabs
#threetabs= [11, 47, 49, 73] done 
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]
'''
print("testing merry christmas code")
print("obviously this is a thinking and engineering problem")
threetabs = [[1, 2],[3, 4]] 
fivetabs  = [[5, 6],[7, 8]]
seventabs = [[9, 10]]
#testing this
fuel=[threetabs,fivetabs,seventabs]
combinedtabs_jazz=[]
combine=''
fulllist=["threetabs","fivetabs","seventabs","ninetabs","eleventabs","thirteentabs","fifteentabs"]

#def grab_these_tabs(x):
    


upto7 = "threetabs + fivetabs + seventabs"
combined_tabs_jazz = eval(upto7)
print("combined_tabs_jazz=",combined_tabs_jazz)
for item in combined_tabs_jazz:
    print(item)
    

#laketahoe
combined_tabs=[]
##========================================================
threetabs= [[11, 47],[49, 73]] 
fivetabs = [[15, 38],[53, 64]]
seventabs= [[23, 33]]
#this combines the theetabs, fivetabs and seventabs
combined_tabs = threetabs + fivetabs + seventabs

counter=1 #looping thru combined_tabs list
for item in combined_tabs:
    alpha = item[0];beta  = item[1]
    print("pair=",item," "," counter=",counter,", first=",alpha,", second= ",beta)
    print("=========================")
    counter += 1
print("did she work")

for item in combined_tabs:
    print(item)
    
#output
'''
pair= [11, 47]    counter= 1 , first= 11 , second=  47
=========================
pair= [49, 73]    counter= 2 , first= 49 , second=  73
=========================
pair= [15, 38]    counter= 3 , first= 15 , second=  38
=========================
pair= [53, 64]    counter= 4 , first= 53 , second=  64
=========================
pair= [23, 33]    counter= 5 , first= 23 , second=  33
=========================
did she work
'''
    
#this is what is in combined_tabs now
print("showing off combined tabs list")
for item in combined_tabs:
    print(item)
print("===================")    
#see if this works
#=================================================


table=[]
table.append(0)
#============================================================
## check_if_nested_switch_inside_this_switch(astring): 
## returns table[0] = False or True
# coded on dec 6th monday 12:== noon ish

#==========================================================
def check_if_nested_switch_inside_this_switch(astring):
    print("check if nested switch inside this switch")
    counter=0
    table[0] = False
    for line in astring.splitlines():
        tabcount=line.count("\t")
        if tabcount == 3  and "switch" in line and "end" not in line:
            table[0] = True
            print(line) #proof is in the pudding - how good is it
            break
            
            
            
            
            
##### this does absolutely nothing 
# I need to make a method to add main switch to string list
def add_main_switch_params_to_dictionary():
    print("how it will work")
    #methods count end switches
    #Take answer add 1
    #loop thru input switch string get total number of lines
    #"3" : [1,44],  #is the result
    #call method to add it to dictionary


#pears['3'] = [4,7] #example
# 38-15+ 1=24  formula end number - first number = x then x + 1
#first number keep, skip out to 23 lines (length of string of nested switch)

print("====dictionary pears====")
print(pears)
print("==========")
print("====dictionary peartree====")
print(peartree)

print("==== practicing with dictionary called pears ========")
#access the dictionary one key in particular to get the value
#print('pears[3] which is the key number')
#x = pears["3"]
#print("x = ",x) #this should be 4,7
#print("============")
 
 
def say_something(x):
    print("say something test here")
    print('cool[0]=',x[0], "cool[1]=",x[1])
     


print("PRACTICING LOOP THRU THE PEAR DICTIONARY WITH HARD CODED DATA FOR TESTING")
print("============")
print("== PEARS  dictionary now LOOPING THRU IT===")
print("listening to teh Beach Boys to see if it works ----")
#looping thru dictionary called thisdict
'''
for x in pears.values(): #looping thru pears dictionary holding switch and end switch pairs locations
    
    print(x)
    cool = x
    #print(cool[0])
    #print(cool[1])
    print(cool[0],cool[1])
    #say_something(cool)
    copy_one_nested_switch_string(m82)
    print("========================")
       
''' 
#this will be a method but of course
'''
for line in inputstring.splitlines(): #	
		#this will be the second loop======
		# if counter is between start and finish #just after start and less than = to finish
		if counter > start and counter <= finish: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
	print("===output from skipping some lines====")
	print('it created this string')
	print(concatthis)
'''	
	


#######=========================================
#
##==============================================
def do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring):
	print("do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up")
	#this 
	genius[0] = inputstring
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	
	


#testing
spilled_coffee ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 ==========
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 ===============
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #26 ==============
			
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



skitahoe ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
		case 'more1':
			switch(exp) 16
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #23
			print('party time')
			switch(exp) #25
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #32
		case 'more2':
			print('more parties')
			switch(exp) #34
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #41
			print('are we there yet')
			switch(exp) #43
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #50
			print('how many this week')
			switch(exp) #52
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
				print('bye')
			endswitch #59
			print('what the..')
			break
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



flag_test=[]  
toosmart=[]
toosmart.append(0)
baton=[]
baton.append(0)
 
flag_test.append(False) #set flag_test by default to False
#flag_test[0]
# x is the name of the string to be modified
switch_list=[]
endswitch_list=[]
thenewpairs=[]

##============================
##  buildpairlist()  created nov 21st, sunday to manage doing the main switch 
##============================  and cutting out switches at three tabs for main switch 
def build_pair_list(stringname):
	print("====== build_pair_list called ======")
	counter =0
	#flush lists
	switch_list=[]
	endswitch_list=[] #should reset them both 
	#thenewpairs=[]
	#del endswitch_list[:]
	#this fills up the switch_list line
	#===================================
	# LOOP FILLS UP SWITCH_LIST 
	#===================================
	#loop thru stringname and fill up switch list
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line:
			switch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	counter =0
	#loop thru stringname and fill up endswitch list
	#this fills up the switch_list line
	# =======================================
	# LOOP FILLS ENDSWITCH LIST 
	#========================================
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "endswitch" in line :
			endswitch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	del switch_list[0]     #delete first switch number which is on line 1
	del endswitch_list[-1] #delete last number endswitch which is end of entire string
	print("after deleting first and last switch we have..")
	print("switch_list=",switch_list);print("endswitch_list=",endswitch_list)
	counter=0 #build the pairs and put them into sweet; then append sweet to thenewpairs list
	#===================================================================================
	# LOOP FILLS THENEWPAIRS LIST WITH SWEET WHICH HAS SWITCH,ENDSWITCH LINE NUMBERS
	#===================================================================================
	for item in switch_list:
		sweet=[switch_list[counter],endswitch_list[counter]]
		thenewpairs.append(sweet)
		counter += 1
	print("this is what we want to see at starbucks")
	print("thenewpairs=",thenewpairs)
	#==================================
	# LOOP PRINTS OUT THE NEWPAIRS LIST
	#==================================
	for item in thenewpairs:
		print(item)
		print('stop here for now')
		#exit()
	#REVERSE THE NEWPAIRS LIST BECAUSE IT HAS TO BE DONE BOTTOM UP TO THE STRING 
	thenewpairs.reverse() #they have to be skipped bottom up to work properly
	print("thenewpairs=",thenewpairs)	
	print("resulting list of thenewpairs =",thenewpairs)



pinkpanther=''
##===========================================
##  skipping_some_lines() #this works
##===========================================
def skipping_some_lines(thestring,start,finish):#input string, switch number then endswitch line number  ....start line nest switch and finish  endswitch
	return
	print("METHOD  skipping_some_lines() called==========")
	print("======= skipping_some_lines() ================called",start,finish)
	# if I have a flag that it's been triggered then afterewards 
	# print("this is the input string used stating skipping_some_lines")
	# for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0]) =============================
	#if flag_test[0] == False: #meaning first pass  and what it's set to by DEFAULT
	smart=thestring;
	baton[0]=thestring #this is new
		#change it to True now
	flag_test[0] = True #this should now be tru e========================
	#else: #meaning TRUE this is run after first run of skipping_some_lines()======
		#what this does is use the new concatted changed string changed on the fly with each pass
		#for second and all subsequent passes it uses baton[0]
	thestring = baton[0]#====================
	#print('what is in baton[0]',baton[0])
	##==========================================================
	# the issue is that on the second pass it is using the original string
	# and it needs to be using the modified string
	# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
	# because the numbering system of the string starts from 1 too.
	### look that we have the counter here set to 1 by default 
	counter=1; concatthis =''; #finish = finish + 1 
	print("start=",start,"finish=",finish) #I took out x = 
	#smart=x;
	print("inside of skipping lines before going thru the loop this is the value of")
	print("the input string it will mess around with")
	#print(smart)
	print("=== ah now I get it these are the lines that it MUST SKIP and we want what is before and after this range to create the modified string =")
	print("it sees in start",start)   #this is a number
	print("it sees in finish",finish) #this is a number too
	##=================
	#so I would build pair list of inner switches at 3 tabs and then loop thru them to skip them
	#this is new on sunday november 21st 2021
	#what I want to skip on the fly without range data
	
	#------------------------------------------------
	#from switch at 3 tabs until endswitch at 3 tabs
	#skip the lines inbetween leaving switch word
	##----------------------------------------------
	
	
	##=============== this is a new addition to automate the grabbing of inner switches ====
	# this creates pairs of the switch, endswitch pairs 
	#if start == 1 and finish == 1: #meaning figure out pairs on the fly
	
		
	#exit()
	counter=0
	#for item in thenewpairs:
	#	start  = item[0]; print("start=",start)
	#	finish = item[1]; print("finish=",finish)
	#check thype
	print("checking tyhpe of thestring")
	print(type(thestring))
	print(thestring)  #it shows 0
	print("what is it?")
	print("starting baton[0] has teh initital input string in it")
	for line in thestring.splitlines(): #smart = x
			#this preserves the switch word and skips the rest of nested switch body including endswitch
			# if counter is between start and finish #just after start and less than = to finish
			#just added start +1 and finish + 1
			#tabdepth= line.count("\t")
			#if tabdepth == 3 and "switch" in line and "end" not in line:
			#		start = counter
			# use while loop of course
			#so it's upside down and backwards to create the same meaning.
			# probably need to do a prescan but maybe i can do it without doing prescan
			#get location of switch and endswitch at 3 tabs
			#while "endswitch" not in line:
			#####################==================
		if counter > start+1 and counter <= finish +1: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
		##=======================================
	baton[0]=concatthis;
	print("===output from skipping some lines====")
	#print('it created this string')
	#print(concatthis)
	print("how does it look===>>> by lettuce field")
	del ibm[:] #this should empty it
	print("this is the output result of skipping some lines")
	#print(concatthis)
	#what I am doing here is putting what has been concatted in the string into toosmart[0]
	#this has red_robin hardwired into the code 
	#just commented out line below november 10th, 2021 to see wehat happens 
	#toosmart[0]= red_robin #it did say toosmart[0] = red_robin
	#just commented these out thanksgiving
	#baton[0] = concatthis  #here the concatthis has been put into baton[0]=======
	#pinkpanther=concatthis==============
	##==========================================================
	### mocha test ### this is new November 10th, 2021  ########
	never_defeated[0]= baton[0]  #just added this line 
	###########################################################
	##==========================================================
	concatthis='' #this resets concatthis to empty-
	print('in baton here we have')
	#print(baton[0])
	print('==============')
	print("now the result is here....!!!!@@@@@$$$$$")
	print(never_defeated[0])
	#ibm[0] = concatthis	  #this has the switch string with the nested switch cut out
	#putting concatthis into ibm[0] here 
	ibm.append(toosmart[0])
	print("at the bottom of the skipping some lines to take out inner switch")
	print(" it sees this in ibm[0]")
	#exit()	
	#print(ibm[0])
		#just moved this over one tab	
#exit()
#end skipping_some_lines  ========================================================
print("Levels TEST on wonderful Monday winter wonderland ")
print("this will take out the inner switch between") 
never_defeated=[]
never_defeated.append(0)

#for line in skitahoe.splitlines():
#   print(line)




#it was previously this
def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
    return
    print('this one is sooo critical')
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    skipping_some_lines(stringname,start,finish)
    #this means that the output string should be placed into never_defeated[0]
    for line in never_defeated[0].splitlines(): #prints it after takening out. 
        print(line)
        

##===========================================================================
##  modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#this was redesigned and modified on sunday november 21st at 8:30am to 
# work with skipping some lines with no known locations of inner switches at 3 tabs
# and it calls method build_pair_list to find them and reverse them for input for skipping_some_lines
# and I have to subtract 1 from start and finsh
#this one is used to get the main switch and take out switches at 3 tab depth

# and loops thru list feeding start and finish  params and calling skipping_some_lines()
# #  the input for start and finish will be 1 by default but they will be overwritten
# #  by the build pair list on-the-fly.
print('this one is sooo critical')
def modified2_cut_out_inner_switch_body_leaving_switch_word(stringname):
    #it is modified so it can change more than one inner switch into a switch, infinite
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    ###======= this is ingenius=========
    #METHOD BUILD_PAIR_LIST(STRINGNAME) 
    if len(thenewpairs) > 0:
        print("==TRUE thenewpairs >0 it is ===== ",len(thenewpairs))
        del thenewpairs[:] #delete contents of thenewpairs list if it's not empty yet
    #end if
    #if len(never_defeated[0]) > 0:
    never_defeated[0]='' #deletes it
    build_pair_list(stringname)           # goes thru thenewpairs list and
    for item in thenewpairs:              # fills start and finish into skipping_some_lines params
        start  = item[0];
        finish = item[1]; # print("start,finish=",start," ",finish)
        skipping_some_lines(stringname,start-1,finish-1)#so close now 
        #the result of the concatting goes into never_defeated[0]
    #this means that the output string should be placed into never_defeated[0]
    print("let us see what we have jazz blues line 6166 ....")
    #so it's output is in  never_defeated[0]
    thisstring = never_defeated[0]
    return thisstring; #see if this works  it is important that we return the string
    print("let's see what it has in it and if it converts the inner switch bodies to switch word...")
    for line in thisstring.splitlines(): #prints it after takening out. 
        print(line)
    cat_scales[0]= never_defeated[0]
    print("now loop thru pinkpanther")
  
        
#manipulate_string(item) #shifts it to the left

# this is the one that is new as of november 21st and it does the main switch with
# inner switches at 3 tabs that it takes out leaving just the switch word.
#============ original============ modified2
output_list=[]
output_list.append(0)
# testing spilled_coffee string 
stringname=spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print("input string is spilled_coffee  =========")
print("doing first attempt of converting inner switch bodies to just the switch word")
mybaby =''
mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)
print("did this sucker work tuesday november 23?")
print("now loop thru the output if it generated it")
print("this is the resulting output processed by the modified2_cut_out... function")
for line in mybaby.splitlines():
    print(line)
    #print("======") 
print("end of first string test for reducing switch bodies to switch word") 
print("=== made it to this point after first attempt completed ===")  
print("now a SECOND ATTEMPT AT CALLING THIS METHOD NOW. WEIRD AT LEAST FIRST PASS WORKS ==")
## testing skitahoe string
#stringname=skitahoe;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print("just testing 2nd one with skitahoe string to see if it works ==input sstring is spilled_coffee")
mybaby =''
#worked by itself
print("doing skithaoe string now=============")
stringname=skitahoe
mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)

for line in mybaby.splitlines():
    print(line)
#exit()   
    
print("===end of show on thanksgiving==attempt 2 =")    
#exit()


#exit()

print("catscales=",cat_scales[0])
print("=====rats======")
print("never_defeated[0]",never_defeated[0])

goldring = never_defeated[0]
print("is this going to finally work or not")
output_list.append(goldring)
print("WHAT IS BELOW THIS DAM LINE")
print(output_list[0])
print("now loop thru goldring s")
for line in goldring.splitlines():
    print(line)

print("seeing if this works")
for line in never_defeated[0].splitlines():
    print(line)
    
#ram = never_defeated[0].replace("switch","rocks")
#never_defeated[0]= ram
#for line in never_defeated[0].splitlines():
#    print(line)
#exit()
#==================================
print("end of deifnitely working modifies2 cut out inner switch body.()")


#stringname=skitahoe; start=7; finish = 14; #this sucker was moving....    
#cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
print("let us see what we have.")

#need to indent it I think.
#produces this output it is NOT indented yet 
goldfish='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
			print("nicely")
			break
		default:
			print("we are done here")
	endswitch 
'''
			
			
			

print(" RED RED RED cut out switch body leave only switch word baby")
print(" red alert testing cut out switch body leaving switch word tesitng 4 ..")    
#exit()

#this is testing with dummy data above in test_code_now
#taking out the inner switch body
print("halloween is coming snoopy and woodstock test")

#print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1
print("take out 10 thru 20") #but actually keep 10 and takeout including20
#x = test_code_now
#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
print("rose test")








#modified so it doesn't matter where the inner switch is 
# they will all be at 3 tabs
#the first switch must be at 1 tab and inner switches need to be at 3 tabs one depth in
#THIS IS NEW CODE WEDNESDAY CODING...november 10th ........
##########################################################################################
#####################################################################################
 #creates first slot in list for string
	#print("actually this builds lists of switch and endswitch locations and makes pairs")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print(" checking to see if more than ONE inner switch at three tabs and ")
	#print("if so then put them into a list")
	#print("the first loop determines how many inner switches at 3 tabs")
	#print("the second loop will go thru a list of the pairs - ah yes but ")
	#print("not implimented yet ")
	
	#print("it sees in finish",finish) #this is a number too
	

# "actually this builds lists of switch and endswitch locations and makes pairs")
# what it does: creates pairs set of start, finish after getting list of switch and endswitch lines
# then it will loop thru pairs set in reverse order and cut out switch bodies bottom up 


## new november 10th 2021 !!:37am
#JUST TRY IT


#this requires this function below to be called first though
#  smart_cut_out_inner_switch_bodies_at_three_tabs(samplestring)
pairset=[]
genius=[]
genius.append(0)

never_defeated=[]
never_defeated.append(0)
list_of_inner_switches_at_three_tabs=[]
list_of_inner_endswitches_at_three_tabs=[]




##========================================================
## loop_thru_pair_set_and_call_skiplines(samplestring)
##=========================================================
def loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring):
	print("len(never_defeated) =",len(never_defeated))
	#never_defeated[0] = thestring #this takes the initial string put into never_defeated[0]
	never_defeated.append(thestring) #maybe this is what I need to do to fix this bug
	print(never_defeated[0]) 
	counter =0
	#loop thru pairset of sets of switch,endswitch (already reversed to go bottom up)
	for item in pairset: #the pairset list was filled in smart_cut_out_inner_switch_bodies_at_three_tabs
		alpha = item[0];beta  = item[1];print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		#METHOD skipping_some_lines()============= uses never_defeated[0] stirng in list
		skipping_some_lines(thestring,start-1,finish-1) #added -1 on Mon Nov 22nd 2021 9:00 AM
		#doing this to see if it cut out the inner switch body 
		print("this is showing the changes reducing switches in never_defeated[0]")
		mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
		print("this is what the switch string looks like after taking out a switch body")
		counter += 1
	








##====================================================================
##  make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring)
##====================================================================
def make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):
	print("METHOD make_Pair_set_of #### called  ... make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):")
	counter =0
	print('let us look at this string to see what it sees')
	print("========//////////==========///////==============")
	for line in inputstring.splitlines():
		print(line)
	print("========//////////==========///////==============")
	for line in inputstring.splitlines(): #smart = x
		#this preserves the switch word and skips the rest of nested switch body including endswitch
		#for this line get tab_depth
		#print("this is where I add the switch line number to list of inner switches at three tabs")
		tab_depth= line.count("\t") #but this presumes just one inner switch there could be more
		#if 3 tabs True AND switch in line and end not in line and counter > 1 
		if tab_depth == 3 and "switch" in line and "end" not in line and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_switches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)		
	#second new loop but looks for endswitch locations at 3 tabs 
	counter =0
	for line in inputstring.splitlines(): #smart = x
		print(line)		
		tab_depth= line.count("\t")
		#print("this is where I add the endswitch line number to list of inner switches at three tabs")
		if tab_depth == 3 and "endswitch" in line  and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_endswitches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("==================")
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)	
	print("list_of_inner_endswitches_at_three_tabs=",list_of_inner_endswitches_at_three_tabs)		
	print("===================")
	print("===== end of phase 1 =====")
	##======================================================================================
	print('doing Friday debugging oh what fun it is to ride in a one horse open sleigh')
	if len(list_of_inner_switches_at_three_tabs) == 1:
		print("this means only ONE dam pair")
	else:
		print("the length is =",len(list_of_inner_switches_at_three_tabs))
		cat = len(list_of_inner_switches_at_three_tabs)
		print("the length of inner switches at three tabs is ",cat)
	###=================================================================	
	print("now I need to make pairs")
	get_number = len(list_of_inner_endswitches_at_three_tabs)
	
	if get_number == 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	##3=======================================================================		
	if get_number > 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	else:
		pass #print("there is only one switch endswitch so do regular mode just one inner switch at 3 tabs ")
	if get_number > 1:
		pairset.reverse()  # REVERSE PAIRSET SO THAT I CAN CHANGE THE INNER SWITCHES BOTTOM UP
	
	print(pairset)
	print("loop thru pairset") #to go thru input string and reduce inner switches to just switch word bottom up
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
	##======================================
	print("method to go thru pairset and call skipping_some_lines(start,finish)")
	do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring)
	#########====================================
		#skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	#skipper needs to cut out from bottom up 
	#skipping_some_lines(x,start,finish):
	#it will call a method

#this must be called after one switch string has had it's inner switches reduced to switch word
#def reset_to_initial_conditions(): #brainchild on NOv 11th, Thursday morning#
#	print(" ====reset_to_initial_conditions()======"#)
#	never_defeated[0] =""
#	list_of_inner_switches_at_three_tabs=[]
#	list_of_inner_endswitches_at_three_tabs=[]
#	pairset=[]
#	baton[0]= "" #should clear it out
    

#def show_output_string_after_changes():
#    mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
#		print("this is what the switch string looks like after taking out a switch body")
#		print('resulting string change is for counter',counter)
#		for line in mouse.splitlines():
#			print(line)    
#this makes pairset list of switch and endswitch 
#this is only run ONCE
fullhouse=[]
##============================================================================
##  take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word
##----------------------------------------------------------------------------
##  Methods: make_pair_set_of_inner_switches_at_three_tabs_depth(thestring) oh wow genius here
##  Methods: loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
##  Methods: skipping_some_lines(x,start,finish)
##  Methods: determine_if_inner_switch_inside_of_this_switch_string(weasel)
##  result of modified string put into  fullhouse.append(never_defeated[0])
##============================================================================
def take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring):
	return
	print("THIS NEEDS TO WORK NOW==")
	print(" take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring)")
	baton[0]=thestring
	print("called ....take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestring)") 
	make_pair_set_of_inner_switches_at_three_tabs_depth(thestring)
	print("this is scenario where if one inner switch it's not filling the pairset")
	print("pairset=",pairset)
	loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
	print("list_of_inner_switches_at_three_tabs=", list_of_inner_switches_at_three_tabs)
	print("list_of_inner_endswitches_at_three_tabs=", list_of_inner_endswitches_at_three_tabs)
	print("pairset=",pairset)
	print("this should be the result of the switch with inner switches cut to just switch word, bodies gone")
	for line in never_defeated[0].splitlines():
	    print(line)
	##################################################
	## adding resultof output of methods of taking out inner switches into never_defeated[0]
	## which is put into list fullhouse using append
	### this is where the result of the change string put into never_defeated[0]
	### is appended to list fullhouse
	fullhouse.append(never_defeated[0]) #needs to be here obviously
	#-------------------------------------
	#if it is here then it's called ONLY after the first one has completed and thereafter
	#==================================================
	## this resets super important lists utilized 
	never_defeated[0]=''
	list_of_inner_switches_at_three_tabs.clear()
	list_of_inner_endswitches_at_three_tabs.clear()
	pairset.clear()
	baton[0]= ""
	



print("====STARTING ATTEMPT 1====== charlie brown music is the best jazz ====")


take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(spilled_coffee)


#exit() 
print("this is after the first string and taking out inner switch bodies...")
#print("====STARTING ATTEMPT 2====== charlie brown music is the best jazz ====")
#reset_to_initial_conditions()
	##==========================

##=======================
#take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestringzoo1)


#reset_to_initial_conditions() #this must be done after each transformation
print("the final OUTPUT is here ...")
print("length of fullhouse should be 2 is now",len(fullhouse))


#for item in fullhouse:
#    print(item)

####################################################
#print("size of FULLHOUSE is..",len(fullhouse))
#for item in fullhouse:
#    print(item)

print("time to go sledding")
#exit()


print("now I will try to do a few stings with it.") 
print("end of this initial test of ")
result_of_check_if_inner_switch=[]
result_of_check_if_inner_switch.append(0)

#coded on november 19th friday at 10:48 am morgan hill starbucks
##====================================================================
## determine_if_inner_switch_inside_of_this_switch_string(weasel):
##====================================================================
def determine_if_inner_switch_inside_of_this_switch_string(weasel):
    print("determine_if_inner_switch_inside_of_this_switch_string(weasel):")
    ## START INNER LOOP ======= devised on nov 19th friday 10L30 am ===========
    innerswitch= False #this must be set to False before each call below 
    result_of_check_if_inner_switch[0] = False
    for line in weasel.splitlines(): #this looks for an inner switch at 3 tabs depth
        tabdepth = line.count("\t")
        if tabdepth == 3 and "switch" in line:
            print("where's the party THIS string has an inner switch ")
            innerswitch = True
            result_of_check_if_inner_switch[0] = True
            break
        else:
            continue
        print("....")
    print('this has to be called after the loop is done')
    print("result_of_check_if_inner_switch[0]=",result_of_check_if_inner_switch[0])
    #end loop ===================


funtestlist=[]

print("big bird for prez")
print("testing in my mind wed november 10th test ..going thru list and calling take out switch bodies.")
funtestlist=[samplestring,samplestringzoo1] #samplestringzoo1
#use the list I made earlier catching_first_change

# what this does is loop thru the seperated switch strings and 
# applies a method take out nested switch bodies leaving switch word


#ratmaze_list=[]
#=====================
#  try_the_mocha()
#=====================
# method determine_if_inner_switch_inside_of_this_switch_string(stringname)
# method take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
#=====================
def try_the_mocha(): #this has the separated strings in it (that's helpful)
    print("try the mocha() testing.......... running the rat maze and learning it...")
    fullhouse.clear()
    print("let us see the SEPARATED strings in this list")
    for item in catching_first_change:
        print(item)
    print("===== okay is this it ===")
    
    print("length of catching first change should be 6",len(catching_first_change))
    counter=0  #this is running the method for second stage of chain_methods
    for item in catching_first_change: #funtestlist: #strings in funtest list
        weasel = item
        ## determines if there is an inner switch in THIS string ==========
        determine_if_inner_switch_inside_of_this_switch_string(weasel)
        innerswitch= result_of_check_if_inner_switch[0]
        print('innerswitch if true or false it is .. =',innerswitch)
        if innerswitch == True:  #if there is an inner switch then apply the method below  
            ######## this method  cuts out all inner switch bodies ######################
            take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
            #fullhouse.append(never_defeated[0]) this line is at bottom of method take_out_nested..
            #never_defeated[0] #this string is the result of the method above in never_defeated[0]
            #############################################################################
        else:
            fullhouse.append(weasel) #so the original string unchanged is added to fullhouse llist
            #this means no innerswitch in this switch string 
            #it's False no inner switch
        counter += 1
        
        ###=========================================================
    print(" end of double loop ")
    print("after going thru catching first change list it should be 6 for counter")
    print("counter =",counter)
    print("len(fullhouse)=",len(fullhouse))
    print("let us look in here if switch stirngs with no inner switches okay and exist at least")
    for item in fullhouse:
        print(item)
    del catching_first_change[:]
    #this fills the output list into catching_first_change list 
    for item in fullhouse:
        catching_first_change.append(item)
        
    print("now big test of second chain method #taking out switch bodies")
    print("this should print out 6 stritngs")
    counter=1
    for item in catching_first_change:
        print("counter=",counter)
        print(item)
        print('=========')
        counter += 1
        
    

print("this is for all of the marbles out of style")
try_the_mocha()    
print('did it work razzle dazzle pumpkins')



#exit()





#modified to get nested switch #so after the first switch in the string 
#so it gets the switch that is nested.
###============================
## get second switch number
##=============================
def get_second_switch_number(stringname): #this might be for when
# I create copies of the switch body strings
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		if "switch" in line and "end" not in line and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;
	
	
#input1 = rose[0]
#input2 = rose[1]
#print(input1)
#print(input2)
bigstringtest='''
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
    										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch #tail
							
									break
								default:
									print("we are done here")
							endswitch #46  2
'''

print('output should be it shoud return this string')
'''
							switch(exp){ #23
      								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2
							'''
							
print('october 12th testing doing actually test taking out inner switch')

bigstringtest1='''
	switch(exp){ #1
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #9
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch #tail
							
			break
		case 'tahoe bound':
				print('fun time now')
				exp ='fishy'
				switch(exp){ #25
					case 'fishy':
						print("do something")
						print("yep")
						fallthru
					case 'where now':
						print("nice")
						break
					default:
					print("we very done")
				endswitch #tail
				print('end of the game time')	
		default:
			print("we are done here")
	endswitch #46  2
'''

start = 10 #rose[0]+1
finish=20 #rose[1]+1
total = finish -start; #gives us 10
x= bigstringtest  #string name to cut out the range from 10 to 20 
skipping_some_lines(x,start,finish)
print(toosmart[0])
print('leaving this November 10th test now for skipping lines in string')
#exit()







peachtree=[]
several_three_tab_switches_list=[]
## get second switch numbers check if many #returns list of inner switch id numbers
##########################################################
## get_second_switch_numbers_check_if_many(stringname):
############################################################
def get_second_switch_numbers_check_if_many(stringname): #this might be for when
	print("get_second_switch_numbers_check_if_many(stringname): Grinch stole christmas")
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter=0
	targetswitch =0
	for line in stringname.splitlines():
		tablength = line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:
			targetswitch += 1 
			counter += 1
		else:
			counter += 1
	#end loop
	print("this should return 2")
	print("number of switches at 3 tabs meaning first level =",targetswitch)
	
	#first check if tab length == 3
	counter=0
	smart=False #default setting
	for line in stringname.splitlines():
		tablength=line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3 and counter > 1 and "#" in line:
			x = line.split("#")  
			y = x[1];print(y)
			if ":" in y:
				y=y.replace(":","")
			print(y)
			several_three_tab_switches_list.append(y)
			peachtree.append(several_three_tab_switches_list)
			smart= True
			counter += 1
			continue
		else:
			counter += 1
			continue
		#print if the list is empty put a 0 in it
		print("special case test")
	if smart != True:	
		several_three_tab_switches_list.append(0)
		peachtree.append(several_three_tab_switches_list)
	#end loop
	print("this is key its NOT LOOKING FOR DEEPLY nested but only at 3 tabs >>")
	print("we are here now after filling switch list with inner switches at level 3 tabs")
	#print("several_three_tab_switches_list=",several_three_tab_switches_list)
	#print("this should return a list whith these two numbers in it 11 62")
	#for item in several_three_tab_switches_list:
	#    weasel=get_switch_number(testcode)
	#   


##==========================================================
# the issue is that on the second pass it is using the original string
# and it needs to be using the modified string
# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
# because the numbering system of the string starts from 1 too.
	
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1	
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)
#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##===========================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##===========================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)



def modern_take_out_endswitch(inputstring):
	print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():




test_string1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie yyy')
			fallthru	
		case 4 to 7:
			print('kangaroo hop hop!')#
			#############1
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################5
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default
											print("we very done") 
									endswitch 
							#############k
									break
								default
									print("we are done here")
							endswitch #46  
							#############k
							break
						default
							print("we are done here")
					endswitch #51   
					#############)
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #60  
			exp = 32
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #86   
			##############)
			print('taught me how to write code')
			fallthru	
			 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		default
			print('the end')
	endswitch #100  
'''
test_string2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #23
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #31
								case 'fishy':
									print("do something")
									print("yep")
									fallthru
								case 'where now':
									print("nice")
									break
								default:
									print("we very done")
							endswitch 
					#############
							break
						default:
							print("we are done here")
					endswitch #46  2.......
					#############
					break
				default:
					print("we are done here")
			endswitch #51   3 ...
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''

test_string3='''
	switch(exp){ #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #23
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #31
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'where now':
							print("nice")
							break
						default:
							print("we very done")
					endswitch 
			#############
					break
				default:
					print("we are done here")
			endswitch #46  2.......
			#############
			break
		default:
			print("we are done here")
	endswitch #51   3 ...
'''

test_string4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  .
'''

test_string5='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch #41
'''

test_string6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'snow fire':
					print("nice")
					#############
					break
				default:
					print("we are done here")
			endswitch #77 5 .....
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86
'''

test_string7='''
	switch(exp){ #66
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'snow fire':
			print("nice")
			#############
			break
		default:
			print("we are done here")
	endswitch #77 5 .....
'''
# instead what if I feel a list of switches at 3 tabs and endswitches at 3 tabs
# and make pairs and then use the skip robe which already works and that way 
# I will reuse working code and based on the length of the switch list I just
# look in both lists at the same location position 0 and then 1 etc.
print("big test....starbucks morgan hill ========")

switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	
#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	print("end of line...")
	########################======
	
	########################==========
print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function

print("should be 1 for this test")
#del switch_list[:]
#del endswitch_list[:]
print('real test now i really need this puppy to work')





#del total_switches_at_3tabs_depth[:] #empty it first 
#del switch_list[:]
#del endswitch_list[:]
#print('real test now in string with more than one inner switch at 3 tabs should be 2')
get_switch_and_endswitch_locations_in_string(test_string1)
#mylist=[]
#mylist.append(5)
print("did it even work or not?!")
#exit()

'''
print("======experimenting with test_string1========")
if total_switches_at_3tabs_depth[0] > 1:
    number_to_loop = total_switches_at_3tabs_depth[0]
    print("number to loop=",number_to_loop)
else:
    print("nope only one inner switch at 3 tabs")   
if number_to_loop == 2:
    print("True that number to loop = 2")
    print("1st loop == ")
    x = 0
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
    print("2nd loop === ")
    x=1
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
#end if
'''      
#mylist.append(17)
print("doing test_string6")

print("halloween is nearly here test======..........")
print("switchlist =",switch_list)
print("endswitchlist =",endswitch_list)
print("==============")
#start  = switch_list[0]
#finish = endswitch_list[0]
#currently skip rope method only does one switch to endswitch set so I would use a loop
#and put skip rope in it to do multiple ones


# input 62, look in dictionary to get the 86
# input 11, look in dicitonary get the 60 
print('testing test_string2 ...')
#start = 5
#finish = 41
#this needs to be called first 
print('testing test_string2')
###====-=====================================================
print("this has to be done fifrst need to get switch and endswith lcoations")
print("=======")
#delete_helper_lists_first() #trying this out

print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string

print('we have switch_list=',switch_list)
print("endswitch_list=",endswitch_list)
print('........... what do the lists say above ....')
start  = switch_list[0]  #5
finish = endswitch_list[0]  #41   #below this means that it's empty, False to set flag
string_after_cutting_out_inner_switch_body[0]= False #set this to False first
print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
print("======testing string2======")
skip_rope_skipping_some_lines(test_string2,start,finish)
###=======================================================
#exit()
###======================================================================
print("=======testing test_string6======")
#this is only designed to cut out ONE inner switch 
print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
skip_rope_skipping_some_lines(test_string6,start,finish)

print('now string1 with 2 nested switches=== star trek time====')
print("testing 1..")
#need to find the switches locations and work from the bottom up so do second inner switch first
#that's how the macros work bottom up that way I can use the numbering input correctly. 


### here it has to do the cutting out in reverse since more than one inner switch to cut out
### I learned this trick from my macros solution
#### relooking at this on oct 22nd friday, at 10:46 am 2021
###=========================================================================
#this will be a special method for dealing with reducing down 2 or more inner switches to switch word
print("PUFF THE MAGIC DRAGON === THIS SHOULD ALREADY WORK== ")

# need to make this into a method that has some fuzzy logic
print("TESTING WITH 62 AND 86 SKIPPING ROPE")
#this needs to be put into a method 
#this needs to be set to False to work correctly.
#first we set it to False


#what this does is go thru a list that is in reverse order to cut out thru skipping
# a string to take out inner switches at 3 tab level.  it actually works.
# I need to have a modified one if only one list 

#we will have a loop ::; put this together on Friday, October 22nd, 2021 at 11 am
#string_after_cutting_out_inner_switch_body[0]= False 
#if len(inputlist) == 1:  good if only one list and reverse calls it does nothin
#what this does is loop thru a list of switch endswitch at 3 tabs and does more than one


###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 #where am I filling inputlist?
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
        print("counter=>>",counter)
        print("=====================")
    print("at bottom of converts  with more than one inner switch at 3 tabs")
    print("testing if weasel is returnable at the end of the function")
     #this is after it's done
    #for line in weasel.splitlines():
    #    print(line)
    #return weasel 

	
print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
inputlist =[]
inputlist.append([11,60])
inputlist.append([62,86])
print(inputlist)
inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#print("after reversing the list we now have===")
print(inputlist)
#print("convert switch with more than one inner switch at 3 tabs(stringname)==== string1")
#get_switch_and_endswitch_locations_in_string(test_string1) #presumes one inner switch 
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
#print("====real deal here ===GET SWITCH AND ENDSWITCH LOCATIONS========")
#print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
#get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#it needs to make these [[11, 60], [62, 86]]
###testing nov 27th at 10:46am starbucks
#print('important testing on Saturday morning')
trialinputlist=[]
inputlist =[]

#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================
def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]
	#print("build_trail_inputlist()..")
	counter=0;
	for item in switch_list:
		pair=[switch_list[counter],endswitch_list[counter]]
		trialinputlist.append(pair)
		counter += 1
		
	#print("look for the ball on the green")
	print("trialinputlist=",trialinputlist)
	for item in trialinputlist:
		inputlist.append(item)
	print("inputlist=",inputlist)
	for item in inputlist:
		print(item)
	inputlist.reverse() #is this needed here or not 

	
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
#print('end of the show sunday morning blues coding')
#print("Super silly string 1 PHASE 1 taking out two nested switches at 3 tabs location bottom one first")
#print('end of the show sunday morning blues turkey day 2')
#print('doing the same string a 2nd time to see if it works')
#print("............................................")
#print("now trying test_string2")
#del switch_list[:]
#del endswitch_list[:]
#print("do you see what I see??")
#inputstring=test_string1
outputstring=[]
outputstring.append(0)
snowboarding=[]
##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	print("take_out_switch_body      today is november 28th sunday  4:29 pm ")
	#right here look if a switch at 3 tabs if not skip below
	####=== new as of monday december 6th, 2021 =========================
	#determine if 
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
			#print("yes switch at 3 tabs in line")
			#print("frosty says switch at 3 tabs confirmed")
			nestedswitch= True
			break
	#print("frosty the snow man light test for nested switch")
	print("nestedswitch=",nestedswitch)
	print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
		#add input into output  this means no changes were done to the switch string
		#print("this switch string DOES NOT have an inner switch")
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	#print("frosty snowboarding")
	#december 6th looking where I am not adding31 and 66 
	
	#print("this is new code now today is Monday november 29th now Dec 6th.")
	#print("what is in lightning[0] now")
	#print(lightning[0])
	
	#print("resulting final output of take_out_switch_body:") 
	snowboarding.append(lightning[0])  #this is new dec 6th monday
	for line in lightning[0].splitlines():
		print(line)


 
print("========TAKE OUT SWITCH BODY()========")
take_out_switch_body(test_string1) #the first one has more than one inner switch it takes out
take_out_switch_body(test_string2)
take_out_switch_body(test_string3)
take_out_switch_body(test_string4)
take_out_switch_body(test_string5)
take_out_switch_body(test_string6)
take_out_switch_body(test_string7)

#gotta take out } in switches 

counter=1
for item in snowboarding:
    print("counter=",counter)
    print(item)
    print("========")
    counter +=1
    
    

#exit()
   
#def finally_reduce_inner_switches_at_three_tabs_into_switch_word(inputstring):
print("where is the christmas tree test===== doing test_string  1 ===========")
get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
build_trial_inputlist()	 #this is new 
print("right here what is in inputlist=",inputlist) #needs to be reversed
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
print("end of christmas tree test test string 1 with 2 nested switches at 3 tabs")
#exit()

print("where is the christmas tree test===== doing test_string   2 ===========")
get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string2)
print("anotehr one 3")
print("where is the christmas tree test===== doing test_string  3 ===========")
get_switch_and_endswitch_locations_in_string(test_string3) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)


print("where is the christmas tree test===== doing test_string  4 ===========")
get_switch_and_endswitch_locations_in_string(test_string4) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)


print("testing another one now===== doing test_string  6 ==========")
get_switch_and_endswitch_locations_in_string(test_string6) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)

#exit()

# method chaining
# getone.getteo.getthree()

#=======
#Bottom of chain methods result if methods goes into
#output[0]

#Where is transform_string() called

#https://www.google.com/amp/s/nypost.com/2021/11/11/ufos-buzzing-us-warships-may-be-aliens-top-spy-chief/amp/

#Good stuff

#https://m.youtube.com/watch?v=azZ4XAZuVk4




print(inputlist)
#inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

#exit()

#inputlist =[]
#inputlist.append([10,36])


#get_switch_and_endswitch_locations_in_string(test_string3)
print('end of the show sunday morning blues turkey day 3')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)

#rint('end of the show sunday morning blues turkey day 4')
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)
inputlist =[]
inputlist.append([5,16])
print('end of the show sunday morning blues turkey day 6')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)
print("wow wow")


#string_after_cutting_out_inner_switch_body[0]= False  #just filler but a flag meaning empty

#exit()
#print("testing input 62, 86 skipping rope")
#start=62; finish=86  #[62,86] #input values fed into it 
#skip_rope_skipping_some_lines(test_string1,start,finish)#62,86

#start=11; finish=60  #[11,60]
#skip_rope_skipping_some_lines(test_string1,start,finish)#11,60

print(" super silly string 2 PHASE 2 taking out 2nd nested switch (the higher first one done second) at 3 tabs")
print("TESTING WITH 11 AND 60 SKIPPING ROPE")
print("testing 11,60 inputs for skip rope skipping some lines ")
print("testing 2...") 







print("after doing this which needs to be made into a function with a loop")
print("it will need input of [[11,60],[62,86]] that I reverse if more than one in it")
#listname.reverse()
#so I can use teh same string to do both cuts out of inner switches 
#first     62,86
#second is 11,60

#exit()
#skip_rope_skipping_some_lines(string_name,start,finish)
#critical_list= [[11, 62], [15], [23], [31], [0], [66], [0]]
#end of show

# tuesday, october 19th, 2021  time 9:52 morgan hill starbucks
#==================================
# cut_out_switch_body_no_params   october 19th tuesday
#==================================
#abandoned this appraoch 
# objective is to go through string and take out switch bodies without inputs
'''
def cut_out_switch_body_no_params(string_name):
	print("cut out switch body no params===")
	counter=1; concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#start  = input_to_get_inner_switch[0]
	#finish = input_to_get_inner_switch[1]
	
	#what about a quick search for locations of switch and endswitch
	for line in string_name.splitlines(): 
		if "switch" not in line and "endswitch"  not in line and tabdepth != 3:
			print(line)
		#notice start +1 based on line number 
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line and tabdepth == 3:
		#actaully I don't want 
			concatthis += line + "\n"; counter += 1; continue
			print(line) #it won't print the switch word since it's skipping it
			
		 else: 
			 counter += 1; continue
		if "endswitch" in line and tabdepth == 3:
			print(line)#get current line then break
			concatthis += line + "\n"; counter += 1; continue
			#break
	print("===output from skipping some lines====")
	print('it created this SILLY STRING === multi colored silly string=')
	print(concatthis)
	for line in concatthis.splitlines():
		print(line)
	print("=======")
	print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
##========== new version 
	print("here we have the halloween special START SKIPPING ROPE...")
	print("the output string looks like this")
	weasel=string_after_cutting_out_inner_switch_body[0]
	for line in weasel.splitlines():
	    print(line)
'''	
	
	
print("testing cutting out the inner switch bodies to see if it works")	
#cut_out_switch_body_no_params(test_string6)
### this is now working correctly taking into account
# that lines start from 0 not 1 and I need to skip and include the switch word


#next go thru list of stirngs and take out inner switches bodies


#Never theorize before you have data.Invariably you end up twisting facts to suit theories instead of theories to suit facts. -Sherlock holmes.
#There is nothing more deceptive than an obvious fact


##================================= testing at starbucks gilroy christmas tree
#####transform_string() #12379






##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
def next_metamorphosis_take_out_inner_switch(string_name,switch_number):
	print("==next_metamorphosis_take_out_inner_switch)====")
	print("==next_metamorphosis_take_out_inner_switch)====")
	switch_tab_depth=''
	counter=1 #look we are starting to count from 1
	startcount =0
	endswitchline=0
	end_switch_tab_depth=''
	#get inner switch location all we know is the switch line number 31 in this case 
	#get switch_tab_depth
	print("the switch_number=",str(switch_number))
	for line in stringname.splitlines():   #switchnumber 31
		if "switch" in line and  "end" not in line and "#" in line and str(switch_number) in line:
			print("31 in line and switch in line and end not in line and # in line ALL TRUE")
			switch_tab_depth = line.count("\t") #gets tab depth
			startcount= counter
			end_switch_tab_depth=switch_tab_depth #see if this works now
			break
		else:
			counter += 1
			continue
	#get endswitch location
	print("startcount =",startcount) #targer switch line number 
	print("target switch_tab_depth =",switch_tab_depth)
	print("END OF PHASE 1 ...")
	
	#get endswitch tab depth
	print("============================")
	counter = 1 #get endswitch tab depth
	for line in string_name.splitlines():
		this_line_tabs= line.count("\t")
		if "endswitch" in line and counter > startcount:
			this_tab_depth = line.count("\t")
			if counter > startcount and this_tab_depth == switch_tab_depth: #this means endswitch must be AFTER switch
				endswitchline = counter
				#the tab depth MUST be the same as the target switch tab depth 
				break
			else:
				counter +=1
		else:
			counter += 1
			continue
			
	print("end_switch_tab_depth=",end_switch_tab_depth)
	print("the end switch line=",endswitchline)
	print("=============================")
	print("END of PHASE 2...")
	counter =1
	for line in string_name.splitlines():
		if "endswitch" in line and counter == endswitchline:
				endcount = counter
				break		
		else:
			counter += 1
	
	startcount = startcount-1 #because we skip switch and keep it. 	
	print("output of next_metamorphosis()")
	print("startcount=",startcount) #oh this is brilliant
	start = startcount
	print("the endswitch line =",endswitchline)
	finish = endswitchline
	print('start=',start)
	print('finish=',finish)
	input_to_get_inner_switch.append(start)  #[0]
	input_to_get_inner_switch.append(finish) #[1]
	print("start=",input_to_get_inner_switch[0])
	print("finish=",input_to_get_inner_switch[1])
	print("switch_tab_depth=",switch_tab_depth)
	#now I can run the skip lines code that requires the start and finish range numbers
	print(" END of PHASE 3 ...")
	print("again this doesn't modify the switch string it just gets input data")
	print("for the next phase which is skipping rope")
	
#notice start +1 based on line number 
#		#because numbers are off by 1 since starting at 0 not 1 in counting
#		#if counter > start +1 and counter <= finish: 
#		if "endswitch" not in line and this_tab_depth == switch_tab_depth: 
#			print(line) #it won't print the switch word since it's skipping it
#			counter += 1; continue
#		else: 
#			concatthis += line + "\n"; counter += 1; continue
#	print("===output from skipping some lines====")
#	print('it created this SILLY STRING ====')
#	print(concatthis)
	
#for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0])
	#if flag_test[0] == False or flag_test[0] == None: #meaning first pass  and what it's set to by DEFAULT
	#    smart=x;
	#    #change it to True now
	#    flag_test[0] = True #this should now be tru e
	#else: #meaning TRUE this is run after first run of skipping_some_lines()
	#    x = baton[0]
	### look that we have the counter here set to 1 by default 
	



#===========================
print("HERE WE START METAMORPHOSIS ENTERING THE MATRIX...")
#this one has to be called first since it creates the start and finish lines for this string
#based on what the switch number is in the comment which it will look for
#and the inner switch line numbers will be known beforehand
#because they are automatically added 

#def take_out_inner_switch_bodies(thestring):
#first I need to get the nested switch number (assuming one at this point)
## I need to make this into a method witht he two functions below
#working on this october 14th, 2021 gilroy 6:55pm

#I need to get the inner commented switch number 
###=====================================================
print("three, two,one, blast off===>>>")
string_name= bigstringtest # <=== string is in here 
#I need to put the method here that gets the switch comment number
#switch_number=31 #I need to get this number automatically
#this will be different if there are more than one inner switch at 3 tabs length
#I still need to clean up the copied switches so the first switch is at 1 tab
#and the next next level switches start at 3 tabs
#for this first attempt we will limit the inner switches to just one
axis=get_second_switch_number(bigstringtest) #returns 31
#should be 31 
print("axis should be 31",axis)
switch_number = axis #finally getting closer to victory
####===============================
#I have code that get the inner switch number if only one
#and I have code that can find all inner switches at 3 tab level depth 
#what this does is rip out the nested switch body leaving the switch
# word in the nest_list after separating the switch bodies
#this is an important step and I just figured out how to
# detect if more than one inner switch at the three tab level depth
## make this into a method now

# I also got the code to get the second switch in a string line number  in the comment
#which will invariably be different from the true line number, but that's okay.
#=================================================
#=================================================
#=================================================
#=================================================
##========== halloween darkness  oct 14th ===================


print("cinderella")

get_second_switch_numbers_check_if_many(foolish)
print("the result of the  if_many method is to put the inner switches numbers at 3 tabs")
print("into the list which is below")
print("several_three_tab_switches_list=",several_three_tab_switches_list)
print("")
print(" back to the future should be above for stirng foolish")

print("testing bigstringtest1")
print("let us see if this works...")
print("the dark knight is here")
del several_three_tab_switches_list[:]
print('here we go')
get_second_switch_numbers_check_if_many(bigstringtest1) #using bigstringtest1 now
start=''
finish =''

print('end of this test of get second swithc numbers check if many')
print('waiting to get it working')


#I need to go thru each string and count the switches at 3 tabs
#do the loop jazz too.
##=========================================================
##  count_inner_switches_at_first_level(inputstring)
##=========================================================
def count_inner_switches_at_first_level(inputstring):
	print("=====count inner switches at first level=== so at 3 tabs ==")
	counter =0
	innerswitch = 0
	for line in inputstring.splitlines():
		tabdepth = line.count("\t") #added and "end" not in line to eliminate endswitch bug
		if "switch" in line and "end" not in line and tabdepth == 3:
			print("the line number is ",counter)
			linewithswitch =counter
			innerswitch += 1
			counter += 1
		else:
			counter += 1
			
	print("innerswitch count at 3 tabs in this string=",innerswitch)
	print("the line number of the sole inner switch is",linewithswitch)
	return innerswitch;

inputstring = bigstringtest1
#this counts inner switches at 3 tabs indentation in a switch string
total=count_inner_switches_at_first_level(inputstring) #calls the method above


print(" we are done here, of the number of inner switches at 3 tabs = ",total)
#where do I get the inner switch number??
print("=========.........")
print("=========....halloween pumpkins are coming.....")
print("=========.........")
 #this calculates the start and finish of one nested switch 
string_name=bigstringtest1 #I need to find the get switch number for inner switch
switch_number=several_three_tab_switches_list[0] #this presumes only one inner switch
switch_number = int(switch_number) #right here a miracle occurs==== 
print(type(switch_number)) #this gets the start and finish numbers for inner switch to cut out
next_metamorphosis_take_out_inner_switch(string_name,switch_number)
print("it should be 9 and 20 and it shows...")
#all this does is create the start and finish line numbers of one inner switch
print(input_to_get_inner_switch[0])  
print(input_to_get_inner_switch[1])
print("string_name=",string_name,"start=",start,"finish=",finish)

print("go for the gold medal===================")
string_name= bigstringtest1
#I am feedingit 9 and 20 to start with here 
#here the inner start and finish of an inner switch is inserted
start =input_to_get_inner_switch[0]#9  #=input_to_get_inner_switch[0]  #9 #1 after switch line number so it really does 10 compensating 
finish=input_to_get_inner_switch[1]#)20 # =input_to_get_inner_switch[1] #=20
print("SKIPPING ROPE NOW to modify the string and cut out inner switch")
skip_rope_skipping_some_lines(string_name,start,finish)
#skip rope takes out the inners switch leaving the inner switch word.
print("The GREEN EXIT SIGN NOW")
#exit()
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================

#skip_rope_skipping_some_lines(string_name,start,finish)
#it needs to return values to start and finish as input for 
#skip_rope_skipping_some_lines(string_name,start,finish)

#now I need to count switches in a string
#and as a backup safety count endswitches also.


#I can work on these separately actually 
################
teststring1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the awesome dog house!")
			print('first prize')
			print('you block head Charlie Brown  hhh')
			fallthru
			
		case 4 to 7:
			print('kangaroo hippity hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do this is sw 15")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do this is sw 23")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do this is sw 31")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  
							#############
							break
						default:
							print("we are done here")
					endswitch #51   
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   
			exp = 3
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do this is sw 66")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86   
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
	endswitch #100  
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [11, 60]
#counter= 2
teststring2='''
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [15, 51]
#counter= 3  THIS IS 5 TABS IN FIRST LINE 
teststring3='''
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
'''


#==========-----------seperated nest strings -----------------
#getting data in blueberries [23, 46]
#counter= 4 this one works 
#I have to reduce these downto first tab and then three tabs
teststring4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch 
			#############
			break
		default:
			print("we are done here")
	endswitch #46  2.......
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [31, 41]
#counter= 5
teststring5='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [62, 86]
#counter= 6
teststring6='''
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [66, 77]
#counter= 7   THIS IS 5 tabs in first switch line 
teststring7='''
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 5 .....
'''

#==========-----------seperated nest strings -----------------
print("moving tabs out.")
print("testing moving extra tabs out of a string")
print("this is looping thru teststring3 ")
print("Grand Canyon test Friday")
print("I will take out 5 tabs from the front of each line")
for line in teststring3.splitlines():
    print(line)
print("end of test of printing out teststring3")
print(" ")
counter =0
switch_actual_tabs=[]
switch_actual_tabs.append(0)
import re
onetab="\t"  # here is onetab declared with one tab inside of it
fishbowl=[]
fishbowl.append(0)




#sunday confirmation number sundayoct 17th, 2021
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''
#this swaps endswitch with }
#what this does is replace endswitch with '}
###===================================
##  take_out_endswitch(stringname)
###===================================
def take_out_endswitch(stringname):
	print("take_out_endswitch()  called=====")
	answer=''
	galaxy = stringname
	print(galaxy)  #using replace endswitch with }
	#this replaces all endswitch(es) to }
	holdthis[0] = galaxy.replace("endswitch","}") #added here
	#bug what if there is already a curly brace but no endswitch
	print(holdthis[0])
	#move it to left
	answer = holdthis[0]
	newstring=''
	for line in holdthis[0].splitlines():
		if "}" in line and "\t" in line:
			line = line.lstrip()
			newstring += line
		else:
			newstring += line + "\n"
			
	holdthis[0] = newstring
	
	print(holdthis[0])
	for line in holdthis[0].splitlines():
		print(line)
		
	#return answer;
	
	#galaxy = holdthis[0]
	#holdon[0] =holdthis[0]
	#return galaxy
	
	
	
	
	

##==========================================
## shift_nest_string_to_left(stringname)   made on oct 15th, 2021 8:57 am
##==========================================
def shift_nest_string_to_left(stringname):   #cuts out tabs and adds new tabs automatically
    print("========= shift_nest_string_to_left(stringname ===... =====")
    for line in stringname.splitlines():
        print(line)
    #print("this is th einput string====")
    newline=''
    counter=0
    thismatters=''
    print("shift_nest_string_to_left() called")
    for line in stringname.splitlines():
        tabslength = line.count("\t") #this is set up for string3 initially. 
        print("tabslength=",tabslength)
        #counter +=1
        if counter == 1 and "switch" in line: #just added this oct 15th 
            #print(line)
            #print("we care about THIS ONE",tabslength)
            switch_actual_tabs[0] = tabslength
            #print("switch_actual_tabs[0]===",switch_actual_tabs[0])
        else:
            print("he well")
        print("=================>>>=======")
        #For teststring3  if 5 tabs in first line then tabslength-4  because it has 5
        ##==================================================================
        clever=0 #starting give it default value of 0 
        #this one works
        if switch_actual_tabs[0] == int(5): #5-4
            clever = 4
            #print("let's see if clever is an int here")
            #print(type(clever))  
            
        #for some reason this if below is not working right    
        if switch_actual_tabs[0] == int(3): #3 - 2 #reducing to 1 tab on first line
            clever = 1
            #print("let's see if clever is an int here")
            #print(type(clever))  
        #so if 5 -4 giving us 1
        #if 6 -5
        #if 7 -6 giving us 1
        #if 4 -3
        #if 3-2
        #if 1 do nothing
        #this is based on it having 5 tabs in line one and minus 4 tabs
        #if tabslength == 3:
        #    tabslength = 1; #which is -2
            
        #if tabslength == 5:
        #    tabslength = 1 #which is -4
        #I think what I need to do is determine indentation before first switch to gauge it    
        print(" switch_actual_tabs[0]=", switch_actual_tabs[0])
        #total_tabs_to_add=''
        ##########################################
        #if 5 tabs then -4
        #if 3 tabs then -2
        total_tabs_to_add=''   #this was 4 changed it to celver
        print("at this point what is the value of clever",clever)
        total_tabs_to_add =int(tabslength) - int(clever) # reducing it to 1 taking 4 tabs off  #right here 
        print("====")
        print("at this point what is the value of total tabs to add",total_tabs_to_add)
        #print("position 1 type test")
        #print(type(total_tabs_to_add))
       
        #this is what I took out above and replace with below 
        #total_tabs_to_add = ''
       # print("testing boolean condition here ....")
        print("tablength in first switch line =",tabslength)
        #====== if tablength = 5 -==========================
        if tabslength == 5:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 4 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
        #end if
        print("====")
        #number one rule code does exactly what you tell it to do. 
        #====== if tablength = 3 -==========================
        if tabslength == 3:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 2 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
            
        #print("position 2 type test")
        #print(type(total_tabs_to_add))
        
        #if tabslength == 3:
        #    total_tabs_to_add = tabslength - 2 
        #end if
        #print("=====")
        #print("position 3 type test")
        #print(type(total_tabs_to_add))
       
        #print("so this line will have this many tabs in front",total_tabs_to_add)
        total_tabs_to_add = total_tabs_to_add * onetab #times 1 tab #0 x 1 = 0
        print("RESULT= total_tabs_to_add to each line",total_tabs_to_add)
        myString = line
        output   = re.sub(r"[\t]*", "", myString)    #takes all tabs out of this line
        newline += total_tabs_to_add + output + "\n" #this puts the tabs in front of the stripped string line
        counter +=1
        continue
    #print('the result is..')
    print("this prints out the output what the changed indentation shift to left looks like")
    #return newline
    fishbowl[0] = newline  #the output of shifting to left 
    for line in newline.splitlines():
        print(line)
#print("drink coca-cola test")
#print("TESTING 3")    
#print("starbucks breakfast of friday testing..")
#print("testing indenting correclty teststring3")
#shift nest string to left
shift_nest_string_to_left(teststring3) #good 5 TABS DOWN TO 1
print("red alert test 3 shift nest stirng to left side ... test 3 ")
print("look carefully at this and make sure that it's right with just one tab at top")
print("testing with string skitahoe")
shift_nest_string_to_left(skitahoe) 
print('first we will do this simple test with no tabs see if it returns 0')
practicestring='''
switch(exp){
    case 1:
        print('hello')
'''
tabsinthisline =''
for line in practicestring.splitlines():
    if "switch" in line:
        tabsinthisline = line.count("\t")
        print("tabsinthisline=",tabsinthisline)
        break
        
print("TESTING string 7 now indenting it to the left")
shift_nest_string_to_left(teststring7) #good 5 TABS DOWN TO 1
print("red alert testing shift string to left")




	
	
	
#exit()

#exit()
print("end of testing of doing indentation shifting to string")
print("oct 26th nearly done with this.. line 6127 ")
#exit()

print("this is where I am indenting the switch strings already in a list")
print("I need to indent them to work on them further to prepare them for the parser")

gold_list_results=[]
newstring=[]
newstring.append(0)
##=================================
##  manipulate_string(addstring) #this appends the changed switch strings to gold_list_results
##=================================
print('testing taking out 2 ')
def manipulate_string(addstring):
    print("======manipulate_string() called line 8524=======")
     #the objective is to reduce tabs so only 1 tab in front of first switch in string
    cutout=''
    print("let us ORIGINLAL INPUT STRING HERE look at the starting input string before modifying it")
    for line in addstring.splitlines():
        print(line)

    print("== red white and blue ==============")
    print("=======pinpointing bug on november 30th =============================")
    print("getting tab count in front of first switch here")
    for line in addstring.splitlines():
        if "switch" in line and "end" not in line:
        #this determines the number of TABS in this line
            tabsinthisline = line.count("\t")
            print("tabsinthislines=",tabsinthisline)
            print("the tabs in front of first switch are",tabsinthisline)
            #the objective is to have only 1 tab in front of first switch
            # which then propogates down the length of the entire string
            if int(tabsinthisline) > 1:    #example
                cutout = tabsinthisline -1
                print("tabsinthisline =",tabsinthisline);
                print("cutout =",cutout)
                break
            if tabsinthisline == 1: #which means do nothing we want just 1 tab first
                cutout = -1; #this is using -1 as a flag
                break
            if tabsinthisline == 0:
                break
            # do nothing   193241613
     #take out just 2 tabs
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    super=''
    lastchar=''
    for line in addstring.splitlines():
        #if "switch" in line and "end" not in line:
        tabsinthisline = line.count("\t")
        #it does all lines of the string taking out the first 2 tabs which are chars
        if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
            sliced = line[cutout:] #this can be a variable
            #print("sliced sees",sliced)
            #phase A ============================
            
            #print("================================")
            #print("======phase A sliced=",sliced)
            ### bug fix ##===========================
            #reput in on dec 5th sunday 
            #print('this fixes the bug that was putting junk after each line')
            #print('adding extra : ) u #')
            #print('see if it works ... again')
            ###############################
            ###### testing bug fix dec 5th sunday ######################
            #this tests if last character is #,),u,:
            #print("the last char is sliced[-1]",sliced[-1])
            #tail = sliced[-1]
            #looklist=[]
            #looklist=["#",")","u",":"]
            #if tail in looklist: 
            #   print("yes last char is either #,),u,:")
            #   sliced=sliced[:-1]
            #else:
            #  print("none of the garbage characters are the last char")
            #   pass
            ################################
            ################################    
            ##========================================
            
            
            #if len(sliced) >0:
            #    lastchar=sliced[-1]
            #    #print("lastchar =",lastchar)
            #   # print("TRUE weird last character",lastchar)
            #    if lastchar == ":" or  ")" or  "u" or   "#":
            #        sliced=sliced[:-1]  
            #========================== bug fix on nov 30th Tuesday hollister starbucks===============================    
            #    sliced=sliced[:-1]
            #else:
            #    print("last char must be 0")
               # print("length of sliced =",len(sliced))
            #print("after teh change the line looks like ",sliced)
            #print("====did it work or not=============")
            
            
            ################################################################
            ## this takes out the last char at end of the line
            #get last character
            #=============================
            #sliced=sliced[:-1]
           # if any of these are True  :),u,#
            #print("====  testing if last character : ) u # ==== ")
            #if lastchar == ":" or  ")" or  "u" or   "#":
             #   print("TRUE weird last character",lastchar)
            #    sliced=sliced[:-1]
            #else:
            #    print('current last char is',lastchar)
                
               
                
            #if sliced[-1] == ":" or  sliced[-1] == ")": or sliced[1] == "u": #
            #    sliced=sliced[:-1]
            #end if
            #===============
            
            #sliced=sliced[:-1] #this is new but when does this occur and why?
            #this is new nov 30th, tuesday hollister starbucks
            
        else: #this means its equal to 0
            #scenario zero tabs in front of first switch starting
            if tabsinthisline == 0:#this handles if there are zero tabs in front of switch line
                sliced = "\t" + line; # add one tab if zero tabs.
                #phase B ============================
                
                #print("================================")
                #print("=====phase B sliced=",sliced)
            else:
                #phase C ===================
                sliced =  line; #maning this has at least 1 tab already
                
                #print("================================")
                #print("=====phase C sliced=",sliced)
        super += sliced + "\n" # this does all lines in the string
        #=== super 1 ==================
        #print("SUPER 1 =",super)
        #scenario if it's already perfect at 1 tab length in front of switch
        if cutout == -1:  #this means tabs in this line determined to be 1
            super += line 
            #super 2  =====================
            
            print("================================")
            #print("SUPER 2 sliced=",super)
        #end if
    print("================ taking out 2 tabs quickly and dirtily")    
    print("this is the output SUPER lines to see the result")
    print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
    for line in super.splitlines():
        print(line)
    return super #this should do it now this is what is returned a string called super
    
    
    newstring[0]= super #shift_nest_string_to_left(string)
    #this appends the super string to gold_list_results list 
    gold_list_results.append(super)
    #the string sare in gold_list_results
print('testing cutting out first two tabs from front of string')
print("===TESTING CUTTING OUT FIRST TWO TABS FROM FRONT OF EACH STRING OF CODE==")
print("moving everythign to left side for formatting this sucker see if gold nears")


print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
#output=[]
#output.append(0)
#myinput=[]
#myinput.append(0)
print(" chain methods test with 3 methods that hand off output as input to next method")
print('testing 3 methods in a row november 23rd santa cruz avenue menlo park ')
print("==================================")
print("first let us see the string in the starting representation") 
#for line in teststring6.splitlines():
#    print(line)
#print
#output[0]='' #to shift string identation to the left
print(" **  method 1  **  indent to left   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
#del myinput[:]
#myinput.append(teststring6)
#input[0] = teststring6
############===============
#manipulate_string(myinput[0]) #indent to left  what is the outpout put into 
############==========
#output[0]=newstring[0] 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#razzle = output[0]
#myinput.append(razzle)
#3toosmart = razzle
#mystringname= toosmart #spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print(" **   method 2  ** cut out sitch bodies  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#right here it can't read the stringname
print("==========starting point======================")
print("================================")
#print("stringname=",mystringname)
#for line in mystringname.splitlines():
#    print(line)
    
#print("checking cat scales list [0] now===========")
#for line in cat_scales[0].splitlines():
#    print(line)
    
#mycat = never_defeated[0]
###################==============
#stringname=mycat;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)

#print(never_defeated[0])
#start=1,finish=1;
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
###################==========
print("please work now did this sucker work tuesday november 23?") 
print('result of taking out inner switches ') 
#output[0]=cat_scales[0]    #outoput 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#del myinput[:]
#myinput.append(output[0]) #does this one work  
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")

#################==========
#take_out_endswitch(input[0])
#################===========
#outoput in holdon[0]
#output[0] = holdon[0]
#print("result of taking out bottom endswitch ")
#for line in output[0].splitlines():
#    print(line)

print("above this line is the totally modified string from 3 chained methods ")


###============= test nov 24th wednesday 2021 target parking lot

test_string4='''
	switch(exp){ #44
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #51
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  
'''

#You can use double or single quotes:
#testing on my iphone. last night. 
testingthis='''
	switch(exp) #23:
		case 'tahoe':)
			print("do something"))
			print("yep"):
		case 'fallen leaf lake':)
			print("nice")#
		####################1
			nested_switch_31:(exp) #31:
			#############k
			break:
		default:)
			print("we are done here").
} 
'''

moregarbage='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize'))
			print('you block head Charlie Brown   ooo')
			fallthru	
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############1
			nested_switch_22:(exp) #22
			exp = 32
			nested_switch_33:(exp) #33
			##############)
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:)
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
} 
'''

trythisone='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown---')
			fallthru	
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			nested_switch_11:(exp) #11
			exp = 32
			nested_switch_62:(exp) #62
			##############)
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
} 
'''

##==============================
##  remove_garbage_on_right_margine(inputstring):    called after manipulate_string
##==============================
#removes garbage on right margine and takes out : in nested_switch if it exists
def remove_garbage_on_right_margine(inputstring): #this fixes garbage characters afterwords
	print('----------cherry on top called----------------------')
	cutout=''
	print("let us ORIGINAL INPUT STRING HERE look at the starting input string before modifying it")
	for line in inputstring.splitlines():
		print(line)
	return  ##  this stops the method cold 
	counter=0
	print('starting to enter cherry on top really serious need to get it working')
	adder='';last_char=''; result = False
	for line in inputstring.splitlines():
		print(line) #if "switch" in line and "end" not in line:
		#need test if last line is a number then don't chop it off
		
		print("length of line=",len(line))
		#if length of this line is more than zero
		if len(line) > 0:
			last_char = line[-1]; #returns a character or number or space whatever it is 
		#ourstring = "switch(exp){ #22"
		last_char_in_line_is_number = last_char.isdigit()
		#  checks if last char in line is a number
		#############################
		if last_char_in_line_is_number == True:
			print("last character is definitely a number")
			##########################################
			print("last_char a number is",last_char)
			#if anumber == True:
			print("SECOND SCENARIOthe last character is a NUMBER")
			adder += line + "\n"
			print("last_char=",last_char)
			continue
		
    #need to ahve it check for "))"
		################if line ends with junk ==========================
		if last_char == ":" or last_char == ")" or last_char == "u" or  last_char == "#": #maybe any character
			#need to check if last 2 are )) only cut off one, otherwise
			# if it's only ) and then don't cut it off
			
			print("FIRST SCENARIO :, ),u, #")
			adder += line[:-1] + "\n" #this deletes the last character from the line
			print("last_char=",last_char)
			
			
		########### if line ends with a space 	
		if last_char == "": #meaning it is an empty space
			print("THIRD SCENARIOlast char is a SPACE")
			adder += line + "\n"
			print("last_char=",last_char)
			
			
			######## this handles if the line ends with a number
			#elif last_char.isdigit():   
			#	print("SECOND SCENARIOthe last character is a NUMBER")
			#	adder += line + "\n"
			#	print("last_char=",last_char)
		print("counter=",counter)
		counter += 1
	###########################################################
	############################################################	
	#decided to get rid of : inside of nested_switch here
	#this fixes this bug  >>  nested_switch_11:(exp) #11:
	print("NOW remove dots inside of nested_switch line if they exist")
	
	verycool=''	
	
	
	for line in adder.splitlines():
		#check if nested switch in this switch string
		if "nested_switch" in adder:
			#print("TRUE nested_switch in line")
		
			if "nested_switch" in line and ":" in line:
				#print("nested switch is True")
				verycool += line.replace(":","") + "\n"
			else:
				verycool += line + "\n"
			
		else:
			verycool += line + "\n"
			#print("no nested_switch in this switch string")
			pass	
	print("FINAL OUTPUT FOR THIS STRING======>>>>>")
	for line in verycool.splitlines():
		print(line)    
	print('afterwards not working yet just trying to get last char of each line')	
	print('resulting fixed removed garbage looks like this.....')
	
	
		#it does all lines of the string taking out the first 2 tabs which are chars
		#if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
	newstring[0]=verycool #bug was right here.	
	inputstring=''
 ################################ 
	#print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
	#for line in super.splitlines():
	#	print(line)
	#newstring[0]= super 
	#print('the final output with cleaned up garbage should be here')
	#print("outpout of cherry on top ==== attempt 1 ")
	#for line in newstring[0].splitlines():
	#	print(line)
	
print("STARTING test 1")
print("take care of garbage on right margine and remove : in inner nested_switch")
#remove_garbage_on_right_margine(moregarbage)
#for line in newstring[0].splitlines():
#    print(line)
#exit()    
    
#print("next one")
#print("STARTING test 2")
#remove_garbage_on_right_margine(trythisone)
#for line in newstring[0].splitlines():
#    print(line)

print('what about this one')
print("STARTING test 3")
#remove_garbage_on_right_margine(test_string4)
#for line in newstring[0].splitlines():
#    print(line)
#print("STARTING DONed")
#exit()









print("Hello")



def method1(inputstring):
     return;
     concat =''
     print("==method1==")
     concat += inputstring
     concat += " fish"
     print(concat)
     return concat

def method2(output1):
     return;
     concat =''
     print("==method2==")
     concat += output1
     concat += " mice "
     print(concat)
     return concat

def method3(output2):
     return;
     concat =''
     print('==method3==')
     concat += output2
     concat += " \nrain fall heavy"
     return concat

print("above the rocket launch")


####===========================================================
def try_these_chain_methods(inputstring):
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("looping through inputstring to see the starting state")
    for line in inputstring.splitlines():
        print(line)
    ##==========    
    print("==trying these three methods and see if it works or not==")
    output1 = manipulate_string(inputstring) #shift string to left
    print("reached after first method called")
    print("mOnday morning Blues testing of manipulate_string method")
    #print(newstring[0])
    
    #takes out extraneous :, ),#,u on right side AND removes : inside of nested_switch word
    remove_garbage_on_right_margine(output1) #this should work now Takes out garbage on far right
    output1 = newstring[0] #extranious #: ) empty lines have : u
    for line in output1.splitlines():
        print(line)
        
    #return    #stoppinghere 
    ##=========
    start =1; finish=1;
    output2 = modified2_cut_out_inner_switch_body_leaving_switch_word(output1,start,finish,)
    print("reached after second method called")
    ##=========
    output3 = take_out_endswitch(output2)
    print("reached after third method called")
    print("this is the final output string from the three chain methods",output3)
    ##=========
    for line in output3.splitlines():
        print(line)
print("serious three raptor engine test launch")        
inputstring= teststring6        
#try_these_chain_methods(inputstring)
print("finishing calling test chain methods")
print(" end of today's test ")
#exit()    
#starting teststring6
#take the string to test it
#shift_nest_string_to_left(string)
#manipulate_string(item) 







	


	
##=====================================
## swap_endswitch_with_curlybrace() this uses the method take_out_endswitch()
##======================================
##=presumes that quail list already filled up with seperated strings
devious_list=[]
peachtree=[]
#so this function loops thru quail list and checks if endswitch in a string in quail
def swap_endswitch_with_curlybrace(): #using testlist_of_strings
    print("=== swap_endswitch_with_curlybrace() ===========")
    print("this requires that quail list must already be filled with switch strings")
    counter=0
    #assert len(quail) > 0 #it did say quail list 
    if len(gold_list_results) > 0: #meaning there is something in quail list
        #looping thru quail list
        for item in gold_list_results:  #notice that this works by looping thru quail list and changing strings with endswitch
            if "endswitch" in item:
                print("yes endswitch is in this string")
                #it happens here TAKE OUT ENDSWITCH(ITEM)
                take_out_endswitch(item) #calling take_out_endswitch saved to holdon[0]
                #print(holdon[0])
                print("its appended to devious_list here via holdon[0]")
                devious_list.append(holdon[0])#this line just might not be working correctly need to look at it further
               # testlist_of_strings[counter] = holdon[0] #this puts it back into testlist slot
                holdon[0]=''
                counter += 1
                continue
            else:
                print("nope no endswitches")
                counter += 1
                continue
    else:
        print("testlist_of_strings list is empty so can't do swap endswitch with curylbrace")
    print("let's see if this works or not does this thing actually work")
    print('strawberrie fields are forever')
    # see if it takes endswitch out and puts } in its place
#end function



#three test in a row here of method calls 



  
testlist_of_strings=[]
testlist_of_strings.append(teststring1)
testlist_of_strings.append(teststring2)
testlist_of_strings.append(teststring3)
testlist_of_strings.append(teststring4)
testlist_of_strings.append(teststring5)
testlist_of_strings.append(teststring6)
testlist_of_strings.append(teststring7)

print("===== testing this using a loop =====")
print("this left shifts and indents each switch string to prepare for going thru bypass205()")
counter=0  #this shifts (indents) the whole switch string to the left with 1 tab in front of switch
print("this prints out the switch strings after left Red Shift== to one tab")
cow_hide=[]
fuel=''
##==============================================
##  starting_what_switch_strings_look_like():
##==============================================
def starting_what_switch_strings_look_like():
    print("starting we have...")
    for item in testlist_of_strings:
        print(item)

##==============================================
##  left_shift_all_switch_strings():
##==============================================    
def left_shift_all_switch_strings(): #this goes thru testlist_of_strings
    print("now we will shift the switch to the left margine")
    counter=0
    for item in testlist_of_strings:
        print("counter =",counter)
        manipulate_string(item) #this calls manipulate_string(item) to shift the switch string to the left
        #adds change to axis put into newloop appended 
        counter += 1
#output is in gold_list_results list
print("   ")
print(" this is AFTER the switch strings have been seperated and put into a list")
print(" called testlist_of_strings  ")
print(" testing  ==left shift jazz== ")
starting_what_switch_strings_look_like()
left_shift_all_switch_strings()



print("DID IT WORK OR NOT the changes stick is it still === LEFT SHIFTED=====")

print('we are here now nov 23rd tuesday morning morgan hill.')




#for item in devious_list:
 #   print(item)
critical_list=[]
print('plum tree test') #hours spent getting this tow ork oct 17th, 2021 9;52pm
def goodtimes():
    #requires gold_list
    print("good times()")
    print("looping thru gold list results list")
    for item in gold_list_results:
        print(item)
        del several_three_tab_switches_list[:] #delete it first to erase the chalkboard
        stringname=item
        get_second_switch_numbers_check_if_many(stringname) #output here
        print("several_three_tab_switches_list=",several_three_tab_switches_list)
        print(several_three_tab_switches_list)
        why= several_three_tab_switches_list
        print("why=",why)
        print(type(why)) #gets the type of var why is.
        results=list(map(int,why)) #changing the string numbers into ints then it works
        #this adds to this list the inner switch numbers for each switch string
        print('results=',results)
        #some will have none, some will have 1, and some will have more than 1
        critical_list.append(results)
        print('critical_list=',critical_list)
        #print(peachtree)
goodtimes()    
print("end of show")    
print("resulting three tab inner switches in each of the switch strings")


def cool():
    print('==========cool function==== is this working yet====')
    for item in critical_list:
        print(item)

cool()

   
    
    
    #holdthis[0] = galaxy.replace("endswitch","}")
#I need to replace the inner switches with methods now
####========== sunday october 17th, 2021 



#what is below here isn't working right for some odd reason

print("about to call swap_endswitch_with_curlybrace() ===")
print("this replaces each endswitch with } to prepare for bypass205()")
#this one is designed to go thru quail list
print("here we take out the endswitch in each string and replace it with }")
swap_endswitch_with_curlybrace() #have it work with gold_list input already left justified
print('about to loop thru devious_list to see if it swapped endswitch with } or not')
for item in devious_list:
        print(item) 
#print("now we will loop thru the testlist_of_strings to see the endswitch is gone now")
#for item in testlist_of_strings:
#    print("counter =",counter)
#    print(item)
#    counter += 1
    


print("TESTING string 1 now=======>>")
manipulate_string(teststring1)   
#exit()
'''
print("TESTING string 2 now========")
manipulate_string(teststring2)   
print("TESTING string 3 now========")
manipulate_string(teststring3)   
print("TESTING string 4 now=========")
manipulate_string(teststring4)   
print("TESTING string 5 now========")
manipulate_string(teststring5)   
print("TESTING string 6 now=========")
manipulate_string(teststring6)   
print("TESTING string 7 now=========")
manipulate_string(teststring7) 
#shift_nest_string_to_left(teststring6)  #3 tabs  DOWN TO 1
#this one is not working 
'''
print("test 2")
print("testing indenting correclty teststring1")
#shift_nest_string_to_left(teststring1) 

print("test 1")
print("testing indenting correclty teststring2")
#shift_nest_string_to_left(teststring2) 

#this doesn't work yet
#now to a loop 
#listtest=[]
#listtest=[teststring1,teststring2,teststring3,teststring4,teststring5,teststring6,teststring7]
#print("testing going thru all strings and indenting them ")
#counter =0
#print("====starting looping thru each teststring=====")
#for item in listtest:
#    shift_nest_string_to_left(item)
#    print("========")
#    print("counter=",counter)
#    counter += 1
    
      
# ==================================================================================
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1
# =================== thursday coding ================================================

#so the formula is whatever never it starts from subtract that
#so if it starts at line number 11 at beginning of string with switch
#so if we do 31 down to 41 we subtract 11 from first number and second number
#so it's really 20 down to 31
#or I could have it start #31 in line and switch in line
#loop until same tab depth and "endswitch" in line


 #add item to dictionary
#pears['3'] = [4,7] #example
print(pears)
 #access dictionary
#x = pears("1")
 
 #remove item from dictionary
#thisdict.pop("model")
 
 
#now when I loop thru switch and endswithc lines
#have it fill the dictionary with the data



#######================================================================#########==========

#######================================================================#########==========
rose=[]
rose.append(0)
rose.append(0)

#######================================================================#########==========

#input1 = rose[0]
#input2 = rose[1]
#23,46

#start = rose[0]+1
#finish= rose[1]+1

#skipping_some_lines(x,start,finish)
#print(toosmart[0])


#always do one nest. Just change the switch start and stop sooo simple


## MAIN TRIGGER FOR TESTING THIS CODE OF EXTRACTING NESTED SWITCH STRINGS 
###################################################
## #this means I need to feed in the one switch location and one endswitch location
## that need to have been already figured out



##  copy_one_nested_switch_string(m82)   <<=======     this is the main trigger for the test july 18th 
##  I will need to add another paramter to determine which nestd switch is grabbed 
def extra(): # does nothing
	print("did it work??")
	
	print("#method  get_switch_and_endswitch_locations()")
	######### just commented out line below july 19th 1:10 pm
	
	#get_switch_and_endswitch_locations(m82) # presumes only one nested switch inside param would be passed here to to pass thru this is new  method call
	######## I will need to take out this method above out of this function
	######## this currenlty only takes in the first switch by design 
	#this builds a list of switch_location and endswitch_location all of them
	# but this function conpy one nested stirng ONLY USES the first switch and first endswitch
	###################################################################
	#this gets switch_location[0] and endswitch_location[0]
	print("copy one nested switch string ()")
	print("get start of nested switch and end of nested switch")
	print("#method get_one_nested_switch_start_and_finish()()")
	#get_one_nested_switch_start_and_finish() # method call 
	#this just copies the locations of switch and endswitch into 
	
	
	
nest_string=[]	
######################################################
##  def copy_one_nested_switch_string(m82,zebra,cow)
######################################################
#this fills nest_string list with copies of the switch body strings
#and takes out front two tabs from string
def copy_one_nested_switch_string(m82,zebra,cow): #so I would add a param to determine which nest to grab july 18th 
	print("==== copy_one_nested_switch_string() =====")
	print("===========.................==============")
	#print("let's look at the input")
	#print(m82)   #main string name
	print(zebra) #switch    location
	print(cow)   #endswitch location
	
	print("========COPY ONE NESTED SWITCH STRING()== called=====")
	#input_string[0]=samplestring
	counter=0		
	buildstring=''
	print("printing samplestring first")
	#print(m82)This ONLY GRABS the first position which is 0 for switch and endswitch
	#when I loop thru this in the peartree dictionary I will put the current pair into 
	#switch_location[0] and endswitch_location[0]
	######################################################
	print("WHAT ..... is in these two lists position 0 swith and endswitch")
	#print("it sees in y",y, "well how does it look")
	####################################
	print("passing the params for switch and endswion and endswitchlcoation")
	del switch_location[:] #these were passed as params that govern grabbing the right string
	switch_location.append(zebra)
	print(switch_location[0])
	del endswitch_location[:] 
	endswitch_location.append(cow)
	print(endswitch_location[0])
	#print("switch_location[0]",switch_location[0]) #10
	#print("endswitch_location[0]",endswitch_location[0]) #20
	#print("what it sees in switchlocation0 and endloaction0")
	print("===========================================")
	# LOOP thru string
	###=================
	fridge[0]='' #empty this sucker just in case oct 5th 2021
	#print("list_of_switch_range[1]",list_of_switch_range[1]) #10
	#print("list_of_switch_range[2]",list_of_switch_range[2]) #20
	for line in m82.splitlines(): #determine if "endswitch" is in line
		#this by default starts copying the string once line greater than 2
		#this says if counter between 10 and 20 including start number and finish number		
		#############################################
		#if "switch" in line and "endswitch" not in line: #this shows just switch
		#	print("switch in this line",counter)
		#if "endswitch" in line:
		#	print("endswitch in this line",counter)
		##############################################	
		#right here if counter is between min line number and max line number
		alpha = int(switch_location[0])
		beta  = int(endswitch_location[0])   
		#this loops thru string and copies lines to buildstring
		if counter >= alpha and counter <= beta: #if counter between(within) alpha and beta:
			buildstring += line + "\n" #I need to start at the 10th line
			counter += 1	
			continue
		else:
			counter += 1 #wasn't adding to counter
			continue #really
	print("the new creation concatted should be buildstring=")
	fridge[0]=buildstring  #here buildstring is stored in firdge[0]
	print("what is in the fridge[0] the nested switch copied")
	#print(fridge[0]) #the copied nested string is in here  fridge[0]
	#############################################
	#newstring='';cool_string = fridge[0]
	print("#method take_out_x_tabs_from_front_of_line()")
	#calls method take_out_x_tabs_from_front_of_line
	#it was cool_string which is now m82  was (2,cool_string)
	newstring=take_out_x_tabs_from_front_of_line(m82) #this is running #takes off 2 leading tabs
	fridge[0] = newstring
	
	#print("final outcome Tron")
	#print(fridge[0]) #this results in the nested switch string with  2 tabs taken off front of each line
	################################################
	# July 21st, 2021 4:16 pm Gilroy Starbucks
	#this copies the string just copied and put it into nest_string
	#its added to nest_string right here 
	#####################################################
	# the copied switch body string goes into fridge[0]
	# and then is added to nest_string list
	######################################################
	nest_string.append(fridge[0]) ##<<<===== right here the nested string is added to nest_string
	#this is filling nest_string with the contents of each nested string
	#then fridge[0] is added to the list nest_string
	print("nest_string length=", len(nest_string))
	#print("line 4315 nest_string here has this in it",nest_string)
	#print("trying to loop thru nest_string to figure this out")
	print("pumpkin pie")
	#for item in nest_string:
	#	print(item)
	#	print("==========")
	
	#need to delete teh first three tabs
	fridge[0] ='' #this empties fridge[0]
	print('trying to empty nest string here on line 4330 see what happens ')
	#del nest_string[:] 
	print("length of nest_string at this juncture is now",len(nest_string))
	#################################################
	print("copy a nested string and output it") #august 5th, 2021
	#print(nest_string)
	
print("====TESTING COPYING A NESTED STRING ======1 2 3 A  B C===....")	
print("====STAR TREK ENTERPRISE ===....")	
print("this is where I call the function to copy JUST ONE nested switch")
# july 18th I would need to add another paramter here like 2, for second nested switch 
#copy_one_nested_switch_string(samplestring) #reads sample string here 
#output into fridge[0]

#this should just call one nested string
# I will put the loop to go thru peartree dictionary
#and call copy_one_nested_switch_string(samplestring)
#and have it added to a list


# I will need to append it 


#this calls in order these methods
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [10,20], # I can make these now 
  "2": [28,38],
}
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========




smart_switch_numbers=[]
#the purpose of this is the switch ID number is it's initial line number
#NOTE: no spaces inbetween switch(exp){ otherwise replace doesn't work right 
#testing adding the comment and line number for switches

###=====================what I need to do =====================
# important sept 30th
# all I gotta do is make each nested switch like
# the main switch template and take out inner switch bodies
# then using the line number put in the generated method in it's place
# be sure that I add the line number as a comment I have that code
# and then make sure I get that switch line number to
# make the nested method to replace it
#####================================================================
#this one is all new and not tested september 30th musing
#testing adding the comment and line number for switches
#this is new not currently used or tested 

testcode='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''
#I am testing with this string the inner swithc is at 3 tabs, first switch at one tab.
#this was teststring6 also added 0 to end
teststring60='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


#so I will know what switch body I am dealing with so I can juggle them and manage them					
#when I get a string that I have copied I just need the switch at the top
##====================================
##  get_switch_number()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
def get_switch_number(stringname): #this might be for when
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	for line in stringname.splitlines():
		print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			print("switch number is==>>>>>",y) 
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;

#skip 16 thu 38
print('this is testing october 12th to get the inner switch line number as a comment ')
weasel=get_switch_number(teststring60) #so this figures out what switch is in a list slot
print("number of this switch string(should be 66 ..",weasel) 
print("ending program here....")



	#testing here 
axis=get_second_switch_number(teststring4)
print("you can always try..")
print("should be 31 ... ",axis)
# get second switch numbers check if many
#experimental new october 14th, thursday, 8:06pm 


print("get second MASH switch number (the comment number after teh inner switch")
print("testing to see if it correctly retrieves the number 66 in the nested switch")
weasel=get_second_switch_number(teststring60)
print("should return 66")
print("weaseL=",weasel)		


weasel=get_second_switch_number(teststring3)
print("should return 23")
print("weaseL=",weasel)		

weasel=get_second_switch_number(teststring2)
print("should return 15")
print("weaseL=",weasel)		



			
#keep line #15 del til = #38
################# creation of loopstring list to hold string that will hold the nested switch string

loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
loopstring[0]=waffles #was red_robin #   what it was previously ==samplestring #see if this works  #this is the mai nested string
print('big test here ')
print("loopstring[0]=",loopstring)
doves=[]
'''
#########################################
## loop thru pears dictionary
## and calls copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])
## to copy one nested switch at a time
    #it might just have to go thru once to fill pears
    # going thru a dictionary I need to designate which pair 
   
    ##########################################
    ## this loops thru the dictionary pears
    ##########################################
    print("about to loop thru pear values")
    #looping through dictionary pears 
      #say_something(cool) #this way the switch and endswitch locations are passed into the function
        ##########################################################
        ## this calls COPY ONE NESTED SWITCH STRING()
        ##########################################################
        print("about to start copy_one_nested_switch_string()")
'''






#https://www.youtube.com/watch?v=qtpxiNvGCp4
#########################################
##   copy_one_nested_switch_case_body()
#########################################
def copy_one_nested_switch_case_body(): #uses pears.values()
    print("======copy one nested switch case body () ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    counter = 1
    #using blueberries dictionary and not pears 
    #just changed this oct 6th wednesday 10am 2021 morgan hill starbucks
    
    # pears is a dictionary with values of start switch and end switch
    ## LOOP ######## this loops thru pears dictionary
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        #print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #great where does this copy of the string put into??
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
   
        

###=== this goes thru pears dictionary  and copies the nested switch strings
print("=== GODZILLA Time  ===")
#uses pears dictionary
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently
}
'''

print("here we go ... copy_one_nested_switch_case_body_blueberries():")
##====================================================
## copy_one_nested_switch_case_body_blueberries()
##================================================
#########################################
#this is using the string red_robin for testing purposes. 
  # pears is a dictionary with values of start switch and end switch
    #this goes thru the blueberries dictionary set of switch end switch pairs ===========
    ##===================================================================================
    ## LOOP ######## this loops thru pears dictionary
    #del nest_string[:] #empty this list
    #this is the blueberry dictionary 
    #it loops thru blueberries to copy a string
    #looping thru blueberries dictionary here 
    


    
loopstring[0]=waffles #red_robin #testing on oct 5th Tuesday
def copy_one_nested_switch_case_body_blueberries(): #uses pears.values()
    print("======copy_one_nested_switch_case_body_blueberries() ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    print("I think that at this point nest_string whould be empty")
    print("len(nest_string=",len(nest_string))
    #nest_string=[] #this reinitializes it 
    counter = 1
  
    #right here nov 6 2021 saturday change this to the list of sublists (time to ditch the dictionary
    print("showing contents of blueberries dictionary values the strings here.")
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #this copied string is added to nest_string list
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
##=============oct 5th musing how to maket his puppy work 
#I need to have switch numbers by line number
# associated with it's pair start stop
#===================   
print("testing blueberries dictionary list to get the string bodies printed out")
####################
#print("NEST_STRING line TAHOE CABIN Bears ione 4651 what is in nest_string at this point")
#print(nest_string)
counter =1  #so the nest_string would have the switch body strings in it
for item in nest_string:  #going thru nest_string of inputs I think
    print("counter=",counter)
    print(item)
    print("end of this switch string body")
    counter += 1
    print("======....=====")
    
    
del nest_string[:] #new just now putting this hear
print("is this thing turned on right now?")
print("the autumn leaves are falling now.")
print("let us see what red_robin looks like")
for line in waffles.splitlines(): #was red_robin
    print(line)
print("done printing out red_robin input to compare it with")
print("  this is the autumn LEAVES  test ==")
print("======after having added line numbers as comments to each switch ===========")
add_comment_and_line_number_to_all_switches(waffles) #red_robin
print("=======now do the next one=======")
print("=======now do the next one=======")
print("=======now do the next one=======")
#add_comment_and_line_number_to_all_switches(autumnleaf) ##testing this right here oh yea

#put it into a list which holds the new string with switch lines added as comments
#here I add line numbers to switches
#inputstring[0] #input string will be in here
copy_one_nested_switch_case_body_blueberries() #which is uses red_robin
print("finishing blueberries")

print("let see this puppy work ..... great america babes ignored me ...")
#copy_one_nested_switch_case_body() # this calls the loop

#print("pears dictionary",pears)
print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
print("pears now",pears)




#this is the resulting output of copying the string embedded in the main switch

holdthis=[]
holdthis.append(0) #creates the space to store it


teststring_brace='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''

#this swaps endswitch with }
# I need to count the "}" in the string, there should only be one, actually none
# if there is one it needs to be in the right place.
# I will have to loop thru the list to look if there is a brace in it already.
######################################
## take_out_endswitch(stringname)  #replaces endswitch with }
######################################
list_of_line_numbers_of_endswitches=[]
holdthis=[]
holdthis.append(0)
#the issue is that I need it to only do the bottom one 
def take_out_endswitch(stringname):
	print("==========take_out_endswitch()and put brace in called=======")
	x='';x=stringname.count("endswitch") #should be 1
	print(x)
	counter = 0
	for line in stringname.splitlines():
		if "endswitch" in line:
			list_of_line_numbers_of_endswitches.append(counter)
			counter += 1
			continue
		else:
			counter +=1
		continue
	print("list of line number of endswitches=",list_of_line_numbers_of_endswitches)
	coffee =list_of_line_numbers_of_endswitches[-1] #last one
	print("the last endswitch =",coffee)
	print(stringname) #this takes out endswitch and replaces it with }
	stringname=stringname.replace("endswitch","}")
	for line in stringname.splitlines():
		print(line)
	holdthis[0] = stringname#now galaxy gets what is in holdthis[0]
	print(holdthis[0])#return stringname #and this is returned
	
print("testing take out endswitch from string and replace it with a } ")
take_out_endswitch(teststring_brace)
#outpout to holdthis[0]
#for line in holdthis[0].splitlines():#
#	print(line)
	



###===================================================
##   show_list_of_nested_strings_separated()
###===================================================
## july 21st 2021 349pm gilroy starbucks
#oct 5th this is a list of thes copied switch ends witch stings in nest_string
###=== this shows the nest_string list of nested switches
#this just loops thru nest_string which has the seperated nested strings
def show_list_of_nested_strings_separated():
    print("======show list of nested strings separated=====")
    print(" == StayPuff Marshmellow Man ==")
    counter=1
    for item in nest_string: #this has the nest strings in it ALREADY nov 6, 2021
        print("counter=",counter)
        print(item)
        counter += 1
    print('end of first simple test ')   
    #===========================    
    counter =0
    print("loops thru nest_string that we filled up in copy_one_nested_switch_string(m82,zebra,cow)")
    #this requires nest_string which is looped thru
    print("length of nest_string=",len(nest_string))
    # loop thru nest_string list     to take out endswitch
    #for item in nest_string: #nest_string must have refined main switch with nest methods numbered already
    #    if "endswitch" in item: #swap endswitch with '}'
    #        print("== endswitch detected ==") #should be 2 of them
    #        print(counter) #takes out endswitch from this current string here
    #        holdthis[0]=take_out_endswitch(nest_string[counter])#takes out endswitch from each string
    #        nest_string[counter] = holdthis[0] #voodoo magic
    #        counter += 1
    #    else:
    #        print("oh good") #absolutely nothing happens here
    #        counter += 1
                
    print("see if it fixed it here")
    print("this is showing what's in nest_string list")
    #this loops thru nest_string to show after the changes were made
    print('this should be it right here the seperated nest strings')
    print("remember that the main switch string is totally different ")
    print(" this is the CRUCAL TEST OUTCOME RIGHT HERE TO SEE IF IT WORKED")
    print("what this does is print out the lists indiviudally after separating them")
    print("printing out the nest_string list right here play baseball Yankees")
    print("copied strings one by one")
    print("YANKEES need to show each copied switch body string")
    print("wow that worked")#da = blueberries.get("2")
    #print("getting data in blueberries")
    #print(da)
    mycounter =1
    nest_string_size= len(nest_string)
    print("length of blueberries =",len(blueberries))
    ###############
    #this makes sure that the nest_string is equal in size to blueberries
    # to counter a bug of overflow junk that I will figure out later
    # oct 5, 2021
    print("blueberries",blueberries)
    print("")
    #this deletes excess data that is appended to nest_string inexplicably
    #this simple fix was solved on oct 5th tuesday at 11:30pm 2021=======
    #temporary getting excess from nest_string
    #so 
    while len(nest_string) > len(blueberries):
        del nest_string[-1] #last element in list is deleted
    print("all done")
    print("length of nest_string=", len(nest_string))
    print("yes finally works NASA is born")
    #get length of blueberries
    #then reduce size of nest_string to that number (figure it out later) weird bug
    print("nest_string size = ",len(nest_string))
    for item in nest_string:  #nest_string
            da = blueberries.get(str(mycounter))#gets string at this position
            print("getting data in blueberries",da)
            print("counter=",mycounter)
            print(item)
            mycounter += 1
            
            print("==========-----------seperated nest strings -----------------")
    print("==========")
    #now delete extra slots in nest_string
    
    
print("===============================================================")
print("middle ground filler here to separate the change just made. fish 2 ")
print("===============================================================")
show_list_of_nested_strings_separated()
#now replace teh third string(the main string)
# this is to simulate cutting out the inner switches
## july 22nd, 2021 




####===========================================================###
####===========================================================###
####===========================================================###
print("july 22nd 2021 additions...====")
###============== this is working correctly now ==========
## more_testing()
##========================================================================

#sprint("checking number of nested switches at three tabs")
#stringname=testingstring1
#get_second_switch_numbers_check_if_many(stringname)


######################
##  more_testing()
######################
def more_testing():
    print("=== more_testing() == charisma ===method testing ")
    #this is adding samplestring with main to nest_string[2] to see what it will look like when working
    print("let's see what is already in nest_string ===> SpaceX pretest ")
    print("to see what is in nest_string")
    for item in nest_string:
        print(item)
    print("so slow 3 which is nest_string[2] has the main string in it")
    #let'see how it looks"
    print("==== after simple test of contents of nest_string")
    print("========")
    print("here we replace it with what will be after I modify it. this is dummy data testing")
    print("finished main string with nested methods added put into nest_string[2]")
    nest_string[2] = samplestring_main # the third one - putting in a different string premade
    #this is what is different right here in the line above
    
    #testing what the stages need to look like
    #to test what it should look like but doesn't yet
    print(" now we will try it again and see how it looks ")
    print(" after changing main string boo boo ")
    #loop thru nest_string
    for item in nest_string:
        print(item)
        print("===========///======oct 5 tuesday 2021 testing  ========")
        
        
###==================================== oct 5 thinking how to do this. 
#for each switch number I need to know what ranges of it's inner switches are
#I need the range of the inner switch numbers start and stop
#so inner switch ranges for switches by switch line number

#more_testing()

####===========================================================###
####===========================================================###
####===========================================================###


### this works this takes the copied nested switch
### and sets the proper indentation for it
#so it takes out 2 really but we have to say 3
## july 17th 10:12am 2021 starbucks

#the eye opening= make a list of the methods sequence
#tuesday, August 10th, 2021 ====,,,,,,,,,,,==========




loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
loopstring[0]=samplestring #see if this works  #this is the mai nested string
print('big test here ')
print("loopstring[0]=",loopstring)
doves=[]
copy_one_nested_switch_case_body() # this calls the loop

print("pears dictionary",pears)
print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
print("pears now",pears)

show_list_of_nested_strings_separated()
more_testing()


###==========================================================

#def tab_swap(x,y):
#    replace(x,y)

########==============
#wilderness=
#def set_front_tabs(x):
#    wildness=''
#    for line in nest_string.splitlines():
#        wildness += line.tab_swap(3,1) #strips one right
#        wildness += "\n"
#    print("after minor surgery see if this works")
 #   print(wildness)






# copy line by line stripping all tabs
# and then based on if starts wwith swtich 1 tab
# if case 2 tabs
# if not switch and not case three tabs
# if endswitch one tab
# if default two tabs


#unless I make a new string _so I want to remove teh first 2 tabs only
alpha_string=''
str1=''
#for line in nest_string.splitlines(): 
#    #put line into list, del first three tabs then conver to string
#   aline = line.split() 
#    print(aline) 
#    str1 += str1.join(aline) + "\n"
#    #print(str1)
#    
#print("string now is...")
#for item in str1:
#    print(item)


 



#########################################==============
## === skipping_some_lines() ========   July 5th, 2021 ===============
#########################################
#this works for one nested switch right now
#this goes thru a nested switch and takes out the nested single switch.

### solution found for dealing with deeply nested switches
#I think that I can use this if I take out the innermost switch
## first and then it should work  
# so the plan of attack is to change(yes change) the inner most
# depth switch first
#and work back to the next level till I am at the first level of depth.


#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========

skip_range=[]
#skip_range.append(0);   
#skip_range.append(0) 
#july 5th, 2021
#so I still need to get the start and finish lines  switch and endswitch for input 
del ibm[:] #empties it
#print(ibm[0])
ibm.append(samplestring) #so in  ibm[0] this is putting samplestring into ibm[0]
print(ibm[0])
#===================print testing on july 24th saturday  2021 at 9:36am =================
print("at this point we have this in ibm[0] after taking out the first nested switch")
#del skip_range[:]
print("LOOP TEST THRU RANGE LIST Goofy dog")
range_list=[]
skip_range.append(0) #slot [0]
skip_range.append(0) #slot[1]


#string,start,finish
#first it will just detect one nested switch , soon it will detect many

#this loops thru a string and makes a copy of the string
# but skips over a range example lines 10 thru 20
toosmart=[]
toosmart.append(0)
flag_test=[]
flag_test.append(False) #flag_test[0] set to False right here 
baton=[] #this is used to hold the concatted string that is changed on each pass 
baton.append(0)
baton[0]= "nada" #to start with to test this monstrocity


rose=[]
rose.append(9)  #testing purposes 
rose.append(19)
test_code_now='''
					switch(exp){ 
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){   #9 
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch  #19
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''








#this is testing with dummy data above in test_code_now
#taking out the inner switch body
print("halloween is coming snoopy and woodstock test")

print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1

#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
print("===========rose test==== testing taking out inner switch body ===")
#the pair would go here 
input1 = rose[0]
input2 = rose[1]
print(input1)
print(input2)
print("take out 10 thru 20")
x = test_code_now
start = rose[0]+1 #10 #TO PRESERVE INNER SWITCH TO REMAIN THERE
finish= rose[1]+1 #20 #TO GO ONE BEYOND ENDSWITCH WORD
skipping_some_lines(x,start,finish)
print(toosmart[0])
print("=====end end end of show end of this dumb test==testing rose flowers ===")
# october 1st this will have to be a prescan first pass to get the locations 
# this will look for an inner switch after first line and get it's line number
# and find it's 'endswitch' or '}'
# and put the switch line number and endswitch line number into a pair
# and then append it and keep going and that way it figures out the location on it's own
coffee_switches=[]
end_coffee_switches=[]

combinedlist=[]
switchtabs=[]
endswitchtabs=[]

#this is not working right 
### mr coffee smart skipping lines 
## mr_coffee_smart_find_innerswitches bodies and skip them except for inner switch word


##======================================================
##  mr_coffee_smart_skipping_lines(inputstring):
##======================================================
def mr_coffee_smart_skipping_lines(inputstring):
	print("======= mr coffee smart skipping lines ..this =======")
	print(" makes pairs to find locations of switches and endswitches.")
	print(inputstring)
	counter =0
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			tabdepth= line.count("\t")
			coffee_switches.append(counter)
			switchtabs.append(tabdepth)
			
			counter += 1
		else:
			
			counter += 1
	del coffee_switches[0] #deletes the first switch which is at the top 
	###=================================
	count =0
	#this looks for endswitch locations
	for line in inputstring.splitlines():
		if "endswitch" in line or "}"  in line:
			tabdepth= line.count("\t")
			end_coffee_switches.append(counter)
			endswitchtabs.append(tabdepth)
			counter += 1
		else:
			counter += 1
	#=====================================
	counter =0
	for item in coffee_switches:
		combinedlist.append("[" + str(coffee_switches[counter]) + "," + str(end_coffee_switches[counter]) + "]")
		counter += 1

	print("zzzz the result list =",combinedlist)
	print("switch tabs=",switchtabs)
	print("endswitchtabs =",endswitchtabs)
	

print("testing this using string red_robin to see if it works")
print("this is only returning the range list of the switch endswitch pairs")	
print("GO GO GO what that dog go")
#mr_coffee_smart_skipping_lines(red_robin2)
## it's chopping off this from the bottom
'''
fallthru
		
		default:
			print('the end')
}
'''
print("TESTING SKIPPING LINES 16 THRU 38 IN RED ROBIN")
print("testing skipping nested switch in red robin")
print("today is thursday sept 30th...")
print("testing...... sept 30 skipping 16 thru 38")

#So loop thru string and 
#get line number with # and 15 put into start
#and get line number with
 # and #38 and put into finish
print("watching videos of starship. video time...")
print('length of nest_string',len(nest_string))
print("nest_string[1]) see if it works..") 
print(nest_string[0])
print("===============")
print(nest_string[1])
print("===============")
print(nest_string[2])
print("===============")
print(nest_string[3])
print("===============")
print(nest_string[4])
print("===============")
#print(nest_string[5])
#print("===============")

#print("bottom after examining nest_string jazz")
#start = 15
#finish = 38
#skipping_some_lines(red_robin,start,finish)
#see if the string is in ibm[0]
#print('go for it 1')
#this is the lower section of the main switch now
#print("and now we start phase 2 -====")
#start  = 53-23 #subtract number after first cutting out skipping
#finish = 65-23

#skipping_some_lines(ibm[0],start,finish)
print("======= I have all of the code I need to make this miracle happen")
print("=====practicing cutting out inner switch guts leaving inner switch word==")

#now the string we have is missing the numbers above it 
#print(nest_string[2])
#start  = 10 #subtract number after first cutting out skipping
#finish = 19
#skipping_some_lines(nest_string[2],start,finish)

#print(toosmart[0])
#this changes the contents of nest_string[2] #see if this puppy works
#nest_string[2] = toosmart[0]
#print("what does this string look like right now this instant")
#print(nest_string[2])


#53 -65
print('go for it 2')
##########################################################################################
print("TESTING skipping_some_lines(ibm[0],skip_range[0],skip_range[1]")
print("10 thru 20 but keeping the first line on 10 which is switch")
print("then 28 thru 38 keeping first line on 28 which is switch")
print("well, how did it go ")
print(" skip skip skip skip skip skip skip skip skip skip skip skip skip skip skip skip ")
print("=====")
print("==========")
print("================")
print("======================")

#this would be done separately and is filling the range_list with the switch to endswitch params
#this will be a separate method for range input for the switch endswitches
#here the sublists of the param of each nested switch are added to range_list
#this is hard coded here filling the nested switch numbers 


#range_list=[[10,20],28,38]]  #that's right I do this backwards from bottom up!!!

'''
this goes thru the main switch string and makes a copy
of the main string in stages copying the whole thing
except for the range for each nested switch.
'''
## this means delete nested switches bodies except leave inner switch word only
##===================================================
#  REDUCE MAIN NESTED SWITCHES TO JUST SWITCH WORD
# debugged on august 5th 2021 gilroy starbucks
##===================================================
## this makes teh final main switch with the inner switch bodies stripped out
## just leaving the switch word where the nested switch was.
#range_list.append([10,20]) #these are added in order and then reversed
 # so that the nested switches are erased bottom up
addthis=[]
addthis.append([10,20])
addthis.append([28,38])
##========================
## add_to_range_list()
##========================
def add_to_range_list(): #uses addthis list 
    print("add_to_range_list() this is necessary to work")
    for item in addthis:
        range_list.append(item) #adding to range list
        
    print("length of range list =",len(range_list))
 
 
 
 #i will need to add data to range list still 
##======================
##  feed_range_list()
##======================
def feed_range_list():
    print("=========feed_range_list() called=====>>>")
    print("=========feed_range_list() called=====>>>")
    range_list.append([11,24]) 
    range_list.append([26,38])
    print('range_list=',range_list)
    #the list has to be REVERSED to do the changes bottom up so the line numbers work correctly
    range_list.reverse()#reverses it NOTICE WE REVERS THE LIST TO CHANGE IT BOTTOM UP
    #this is so the bottom is done first 
    print("length of range list =",len(range_list))


    
#Yes I am reversing the range_list to do the changes bottom up so they don't lose their place
print('printing the range_list')
print(range_list) #should be [28,38],[10,20] to do from the bottom up

#this takes out the inner switches except for the switch word
#so what this means is it removes the body of the nested switch but leaves just switch word.
### this uses range_list!!!!!!!!!!!!!!!!!
#between 11 and 47
#if first switch detected keep going so use switch counter
#it needs to only include the switch word of tab depth 3 switches
#before doing any changes it looks like this 
REAL_STRING='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep  (( 5 tabs ))depth 3 detector       Level 2    
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################==== this one should be deleted 
			switch(exp){ #23  #third level deep  (( 7 tabs ))   Level 3    =====
				case 'tahoe':=========
			print("do something")=======
			print("yep")
			fallthru
				case 'fallen leaf lake':
			print("nice")
			break
				default:
			print("we are done here")
			endswitch #33
			#############
			break
		default:
			print("we are done here")
			endswitch #38==========
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #47
			exp = 3  #note that this switch is stacked below the bottom stack at 3 tabs
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''
'''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep          Level 2    
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					break
				default:
					print("we are done here")
			} #38
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	
#after changes it should look like this after getting rid of inner switch body one indentation

#this is what the end result should be
endresultshouldbe='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			switch(exp){ # 15  #second level deep          Level 2    
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	

#I think that I need to go thru tab length3 first 
#then go thru tab length 5 
#then go thru tab length 7
#this is the input for the reduce_main_nested_switches_to_just_switch_word(

oldschool='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown nn')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					#################### del after line with '#' and  '15' in it till 38 in it
					switch(exp){ #15
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			exp = 3  
			switch(exp){ #26
				case 'burger':
					print("do something")
					####################
					switch(exp){ #30
					print("gosh")
					fallthru
				case 'porsche':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
} #51
'''
#the output should be
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #====
			exp = 3  
			switch(exp){ #====
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''


starbucks_code_main_test ='''
	switch(exp) { #main 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown 8888')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					break
				case 'please work':
					print('nice')
					fallthru
			endswitch	 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#The change that I need to make here is to cut out switches greater than 3 tabs  tabdepth > 3
##======================================================
##   reduce_main_nested_switches_to_just_switch_word():  #I think that this does all switches no matter their depth
##=======================================================
def reduce_main_nested_switches_to_just_switch_word(astring): #11 - 23 and 25-37
    print("starting this method to see what is in the string")
    #for line in astring.splitlines():
    #    print(line)
    print("===reduce_main_nested_switches_to_just_switch_word()== Tron approaches")
    print("C3Po")
    print("=====reduce_main_nested_switches_to_just_switch_word()====0000000000000==>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("what is in astring the input param")
    print(astring)
    print("end of the input string to see what is going into the function")
    print("reduce main nested switches to just switch word()")
    
    #feeding range list()
    #add_to_range_list() #this is new to put switch and endswitch lines into range_list
    feed_range_list() #added on wednesday, September 15th, 2021
    flag_test[0]== False #this flag is new this is the default setting for this flag
    print("flag_test[0]=",flag_test[0])
    #when flag_test[0] = True that means it's doing 2nd and subsequent loops (changes) and use baton[0] for concatting string
    print("==reduce_main_nested_switches_to_just_switch_word(astring)==")
    print("= R2D2 ==## $$ ## == reduce main nested switches to just switch word()==========")
    print("this cuts out the nested switches bodies leaving just the word switch")
    print("starting ibm[0] with samplestring")
    print("what we are starting with for input in ibm[0]")
    #print(ibm[0])  #the key is the range_list
    print('range_list=',range_list)  ### this is the dependency the range_list necessary for this to work
    #loop thru range_list
    print("we loop thru the range_list here")
    print("let's see what RADAR is in the range_list",range_list) #see if it's reversed or not
    #loops thru range_list with pairs of switch end and endswitch
    print("length of range_list of pairs=",len(range_list))
    print("range_list=",range_list)
    counter=0
    # loop thru range_list
    print("before starting let's look into the range_list",range_list)
    print("============")
    print("perhaps I need to go thru the 7th tab first, then 5th tab, then 3rd tab")
    print("thinking outloud how to do this.")
    print("range_list=",range_list) #just added this sept 30 2021 testing cafe borrone
    
    for item in range_list: ##range_list=[[10,20],28,38]] ==========================
        print("**",item, item[0],item[1])
        print("inside of loop thru range_list :: COUNTER HERE=",counter)
        skip_range[0]= item[0]; 
        skip_range[1]= item[1]
        #item[0]='',item[1]=''
       # print(item[0],item[1])
        print("skip_range=",skip_range)
        #this builds a new string by skipping the nested switch sections
        #but leaves the inner switch (switch(x) word intact
        # skipping_some_lines() called here 
        # ibm[0] has the samplestring in it from above
        toosmart[0]=astring #this might work
        #this is called before skipping some lines
        #the problem is that on the secondpass it's not taking in the changed toosmart[0]
        #====================================
        #SKIPPING SOME LINES()===============
        #====================================
        #this is governed by flag_test[0] which is set to default False above the loop
        skipping_some_lines(astring,skip_range[0],skip_range[1]) #this makes a new string skipping guts of inner switch
        counter += 1
        
        #skip_range[0]='';skip_range[1] ='' #just added this to see if it helps
        #del skip_range[:] #this clear it out afterwords to wipe the slate clean
    print("this is the final output of the transformation halloween approaches")
    print("output of = R2D2 == taking inner nested switches body out and putting just keeping swithc word")
    print("the star destroyer was moving fast")
    print("should be only two nested switches and only switch word remaining NOT 3")
    print("end of this picture show")
    #print(ibm[0]) #this prints out the result 
    print("=====================")
##======================================================

#here we go  
print("the goofy dog test")  
print('we start with this string')

#print(ibm[0])
print("OLYMPICS BLAZING... gold medal time")
print("=====calling reduce main nested switches to just switch word(========)")
print("HERE NOW...this should be the sample string with the nested switches")
print(" cut out leaving just switch word")
print("we are ==== STARTING ==== with this dam string legal eagle")
#bypass here on thursday sept 30 testing at cafe borrone
#print("September 30th testing at cafe borrone")
#ibm[0] = red_robin
print(ibm[0])
inputnowstring= ibm[0]
print("starting input before doing changes")
print(inputnowstring)
print("about to reduce main nested swithces to just switch word which work previously without incident")
print("line numbe 4162")
print(" FIRE BREATHING DRAGON NOW ")
#flag_test[0]== False #see if this works 
# I am right here today  LOOK RIGHT HERE OCTOBER 1ST 2021 
## this is the key method here ====

reduce_main_nested_switches_to_just_switch_word(oldschool) # I didn't notice this way down here
print("red alert test 2 reduce main nestd swith to switch word test 2 ...")


print("good times saturday night live test ")
del range_list[:]
reduce_main_nested_switches_to_just_switch_word(starbucks_code_main_test)
print("look above frosty snowman here")
print("output from taking out nested switches in string inputnowstring")
print("output of removing both nested switches")
print("RIGHT HERE ====== OCTOBEr 1st what does this look like below this line")
print(ibm[0])
print("does it loop thru two times for that is how many times it should")
print("==============")
#exit()



print("this is what the main switch looks like after having taken out the inner switch bodies")
print("which means that we should only have the inner switch words remaining and nothing else")
print('super super major major critical test 4129 line number ')
print("this shoudl be the main switch with only remaining switch(exp){ and no inner switch bodies")
print("here we should have the two nested switches remaining with no bodies")
print("mocha at starbucks")
#print(ibm[0])
# print this skips the nested switch body and creates a different version of the main switch
# and takes out the nested switches but leaves the switch word
print('after the olympics end...')
print("stopping it here because it should have worked...")
print("remember that I am using and EXIT() here to stop the code running past what I am concentrating on")

#exit()  






#print(ibm[0])
print(" starting anew here doing it the old way")
ibm.append(samplestring) #in ibm[0]
print(ibm[0])
print("that's all lemon tree software ==")
print("about to exit the program after seeing the nested switches taken out of main string")
#exit()
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/ ghostly  /=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("this is the SECOND ATTEMPT")
#skip_range.append(0)
#skip_range.append(0)
print("does this work yet") #these are farther down  so I needto do them first 
skip_range[0] =11
skip_range[1] =24
print("=============")
print("skip_range=",skip_range)
print("=============")
print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
print("what string is in ibm[0]=",ibm[0])
ibm[0]=oldschool
for line in ibm[0].splitlines():
    print(line)
skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 28,38 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
print("now swap out the top inner switch hopefully")
print("ibm[0]=",ibm[0])
skip_range[0] =10
skip_range[1] =20
print("=============")
print("skip_range=",skip_range)
print("=============")

skipping_some_lines(ibm[0],skip_range[0],skip_range[1])

#exit()

'''
skip_range[0] =10
skip_range[1] =20
print("=============")
print("skip_range=",skip_range)
print("=============")
skipping_some_lines(ibm[0],skip_range[0],skip_range[1]) 
'''

#print(ibm[0])
#fuse=[]
#fuse.append(0)

#del skip_range[:]

#skip_range.append(10)
#skip_range.append(20)

#I guess I can put the ranges into a list and then reverse it and 
#loop thru it.
print('at this juncture what is in ibm[0]')
print(ibm[0])
print("starting out we have this before stripping out the nested switches")
#ibm[0] = fuse[0] #to preserve changes made 
print("input values on 2nd pass =")
skip_range[0] =10
skip_range[1] =20
print(ibm[0])
print(skip_range[0])
print(skip_range[1])
print("========")
print("skip_range=",skip_range)
print("=========")

print('==== make it dam happen == ')
skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 10,20 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
print(ibm[0])
print(" where is it now lemonade stand ???")
del skip_range[:] #this has to be cleared out. 
#skip range needs to be cleared out for the next nest parameters here
##===============================
print("==== the end===both nested switches should only have the switch word reminaing ===")



print("===end of copying a string and skipping lines 10 thru 20===")   
print("in ibm[0] we have",ibm[0])
print("===== this is after running skipping_some_lines(smaplestring,10,20)")
print("===========")

smart_number=[]
smart_number.append('starter')
smart_number.append(0)
smart_number.append(0)
smart_number[1] = '1'
smart_number[2] = '2'
#switch is on line 10 need to change it this is looking for the switch

#this is changing ALL OCCURENCES of switch at the 
#same time just just the one I want it to change.
# I need to localize is it to one line number.

#have it change one and then break starting on the line above


#The problem I have is if I replace each switch with the nested numbers
#then the other code won't work so perhaps I need to add a comment
#the issue is making the main strings which should only have the first level inner switches
#which is governed by tab depth of 5 representing the second level
# since tab level 3 is the first main switch.
# I could do number 1 thru n for each level initally and then change them
# or I came up with the number top down 1 thru n but level list solves the problem 
#That was my genius

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#in terms of faster programming it's about communication and control
# the lollipop is the what level but above that are higher abstraction levels
# where yet more speed can be achieved and sustained
##$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========
#I think I will do the one nest level for now and add the other nest levels afterwords
#decision made august 22nd, 2021 9:08 am

# I have the main module which has nested methods
# I can use this for making nested switches with nested switch methods too
# but right now I want to get the nested feature working before implimenting it
#######3==================================
#Actually I can do the main and the nested that have inner switch words not changed yet
#And then apply the conversion to numbered switches
##=====================
''' from above just pasted it here to keep track of its contents
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,86], # I can make these now 
  "2": [11,47],
  "3": [15,38],
  "4": [23,33],
  "5": [49,73],
  "6": [53,64]
 #no comma after last data piece apparently
}
'''

danumber=''

#testing this here to make sure that it's right 
ibm[0] = '' #this should delete it
print("ibm length=",len(ibm))
stringname =teststring60
print('starting stage of string to manipulate')
for line in teststring60.splitlines():
    print(line)
danumber= 66

print("star wars begins now.")
##============================================
# swap_switch_for_nest_method_new(danumber)
#// inner switch(just the words) is swapped for nested method number")
#=============================================
#for this to work correctly I need to ahve already taken out the inner switch bodies that I copied
print("about to do OPTIMUS PRIME === GO BABY GO ===")
def swap_switch_for_nest_method_new(stringname,danumber): # I will add more values later perhaps 3 or 4 for coordinates
	print("#### ========= swap switch for nest method new  ========####")
	print(" =======OPTIMUS Prime======")
	global abovenestedswitch
	#stringname=ibm[0]
	#stringname=ibm[0] #loading from ibm[0] good
	print("called swap_switch_for_nest_method(n)")
	print("it is using this number in use_number[0]",use_number[0])
	acounter=0
	for line in stringname.splitlines(): #determine if "endswitch" is in line
		tabdepth = line.count("\t")
		print("the current tab depth in THIS line is",tabdepth)
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 check to make sure that switch and the comment line number in this line
		#this way it can ONLY make changes to switches at tab depth 3
		if tabdepth == 3: #this way it can ONLY access changing the string at 3 depth once
			#this way only if the tab depth is 3 can it manipulate the string
			if  "switch" in line and str(danumber) in line: #line with switch in it  
				print(line)  #doing counter > 1 so it doesn't do the first line
				#this is where the string is changed
				stringname = stringname.replace("switch(exp){","nested_switch_" +str(danumber)  + "(n)")
				break
			else:
				acounter += 1
				continue
		else:
			acounter += 1
			continue
			
	print("the final outcome of the chagne is here:")
	for line in stringname.splitlines():
		print(line)
	

# this takes in what is in ibm[0] and the outputs it to ibm[0] also, quite clever.   
print("let the judge state this is truth") 
number_to_add=66 
swap_switch_for_nest_method_new(teststring60,number_to_add) 
ibm[0] = stringname
print(ibm[0]) 

#where is th eone that grabs teh number automatically though

da='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
        
'''

data1='''
	switch(exp){ # 15
		case "1":
			print('hi')
			#isn't this special
			print('is this happening')
			print("what do we have here")
			break
'''

data2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

#the innerswitch must be at 3 tabs and the first top switch must be at 1 tab.
data3='''
	switch(exp) #62
		case 'burger':
			print("do something")
			####################
			switch(exp) #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


jazz6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #63  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #89  
			#############
			break
		case 'what':
			print("nice")
			####################
			switch(exp){ #455  
			#############
			break
			
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

jazz7='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
#replace_the_last_endswitch_with_brace
print("I found the code I need - I think - we shall see - if it is the right code indeed")

print("about to do thorough testing of chnage_switch_to_method_solved()")
#solved october 29th, 2021  NEXT get the number after comment just in time
'''
this builds a string called newstring replacing switches
at 3 tabs depth with nested_switch
with the comment id after # tacked onto
 the end of the nested_switch_22(exp) like so.
'''

   ##################################################            
       # if "}" in inputstring:  #have to cut "}" out of string      
       #     print("CONFIRMED there is a right brace in string")
       #     for line in templine.splitlines():
       #         if "}" in line:
       #             
       #              templine2 += line.replace("}","")
       #              templine2  +="\n" 
       #        else:
       #             templine2 += line +"\n"
       #    inputstring = templine2
       #     print("======testing if } taken out of string======")
       #    for line in inputstring.splitlines():
       #        print(line)
       #     print("======testing if } taken out of string======")
         #end if   
       # do nothing
       ######================================
       
''' ##################################################            
        if "}" in inputstring:  #have to cut "}" out of string      
            print("CONFIRMED there is a right brace in string")
            for line in templine.splitlines():
                if "}" in line:
                     templine2 += line.replace("}","") #this is where I was taking } out
                     templine2  +="\n"
                else:
                     templine2 += line +"\n"
            inputstring = templine2
            print("======testing if } taken out of string======")
            for line in inputstring.splitlines():
               print(line)
            print("======testing if } taken out of string======")
         #end if 
'''
        ########################################


innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
    print('this now takes out the { brace after switch if it is there')
    innerswitch=''
    print("this is what it sees when it starts change_switch_to_method_solved()")
    for line in inputstring.splitlines():
        print(line)
    print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
        print("=======testing if { taken out of string=======")
        for line in inputstring.splitlines():
            print(line)
        print("=======testing if { taken out of string=======")
       #check if } in this string an if so take it out
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
                print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            print("=====no { in string  ======")
            #end if
        print("=======testing if { taken out of string=======")
        for line in inputstring.splitlines():
            print(line)
        print("=======testing if { taken out of string=======")
        #check if } in this string an if so take it out #I have deactivated this since it's not needed
        
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
print("where is my mocha brainfreeze test october 30th...")




print("==========testing string da===================")
print("=============================")
inputstring=''
inputstring = da         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
print("end of red alert change switch to method solved end of test 5..")    
print("=============================")
print("======= testing string data1======================")
 
print("testing goldfish which is NOT indented yet")
#testing a second method in chain right now for expiermentinting==
#the input string MUST BE indented and look like this LOOK LIKE THIS 
somedata2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''


gofigureit='''
	switch(exp){ #77
		case 'burger':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is chnaged to brace later
'''



#just check if switch at 3 tabs to determine if nested switch
#monday dec 6th thinking 
####$#$$##############========================


            
            
check_if_nested_switch_inside_this_switch(somedata2)
print("inner switch in switch=",table[0] )
print("=======")
print("=========")

check_if_nested_switch_inside_this_switch(gofigureit)
print("inner switch in switch=",table[0] )
#exit()


print("wasn't that fun")
######======================================
# november 20th saturday just after 10am Morgan Hill 2021
inputstring=''
inputstring = goldfish    
    
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
   
print("see if this worked with goldfish accurately")
#exit()
    
inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data1         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
    
print("=============================")
print("========testing string data2=====================")


inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data2     
#what I am doing here is returning the concatted string to the string fizz variable.    
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

##==================
print("about to test data3 and I can't have anything after the #22 after switch")
inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data3         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

print("massive mammoth test here to see if mocha is ready")
print("does many changes from switch to nested switch with number ==testing jazz SIXAROO now jazz6 ")
inputstring = jazz6
print("testing jazz6")
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)



print("massive mammoth test here to see if mocha is ready")
print("does many changes from switch to nested switch with number ==testing jazz SIXAROO now jazz6 ")
inputstring = jazz7
print("testing jazz7")
print("calling method  change_switch_to_method_solved")
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

#exit()


###================== cold brew linus and snoopy ================== saturday morning software  november 20th, 2021 ====
#this is testing adding the nested switch 
linus_and_snoopy=[]
##==================================
##   add_nested_switch_methods():
##==================================
def add_nested_switch_methods():
    print("add nested_switch_methods() in catching_first_change list")
    for item in catching_first_change: #<== list with strings after taking out inner switch bodies
        #print(item)
        #here calling method chaning_switch_to_method_solved swaps switch for nested_method_numbered
        fizz =change_switch_to_method_solved(item)#this is applying the method to add nested_switch method
        print("===== oh yeah =====")
        linus_and_snoopy.append(fizz) #this is adding the changed string to linus_and_snoopy list
        
        #for line in fizz.splitlines():
        #    print(line)



##================================================
##print_out_result_of_adding_nested_switch() to each switch string:
##================================================
def print_out_result_of_adding_nested_switch():
    counter =1
    print('we made it to the top of the Donnor Summit ')
    for item in linus_and_snoopy:
        print("counter=",counter)
        for line in item.splitlines():
            print(line)
        counter +=1

print("here we go... let her rip")       
add_nested_switch_methods()
print_out_result_of_adding_nested_switch()
print('end of the show time movie trailer')



#test with one string and do piping

#cut_out_inner_switch_body_leaving_switch_word(teststring)
##===========================================================================
##  cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
#    print('this one is sooo critical')
#    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
#    skipping_some_lines(stringname,start,finish)
#    #this means that the output string should be placed into never_defeated[0]
#    for line in never_defeated[0].splitlines():
#        print(line)

inputlist=[]
inputlist.append(0)
outputlist=[]
outputlist.append(0)
 
print("this is a super critical test of piping two chain methods in sequence")
print("SUPER CRITICAL PIPING METHODS CHAINING TEST ===")
           
#put x in front so it's not used
#it must be indented properly to work daaaaa
xskitahoe ='''
		switch(exp){   #1 === line 10 beginning of single nested switch ======      
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				switch(exp) #7
					case 'funny':
						print('fun')
					case "da":
						print('yeah')
					default:
						print('bye')
				endswitch #14
				print("nicely")
				break
			default:
				print("we are done here")
		endswitch #this is key here =============line 20 end of nested switch ====
'''	


#testing 
print("testing printing out joy string")
joy='''
	switch(exp) #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp) #23
			#############
			break
		default:
			print("we are done here")
	endswitch #38
'''

hotmocha='''
	switch(exp) #3
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #11
			exp = 32
			switch(exp){ #62
			#############
			break
		default:
			print("we are done here")
	endswitch #86
'''

for line in joy.splitlines():
    print(line)



#testing doing 2 methods back to back piping output from first to input to second
#first method   
###==================
##  do_the_pipe()
###==================    
def do_the_pipe():
    print("do the pipe() called pipe pipe PIPE PIPE PIPE")
    print("outputlist[0]=",outputlist[0])
    inputlist[0] = outputlist[0]
    print("now put it into inputlist[0]")
    print("inputlist[0]=",inputlist[0])
    
    

print('doing some pipe testing today')

#######################################
#######################################
#######################################
###====== saturday morning codeing ==november 20th, 2021 testing this puppy ====
## SHIFT NEST STRING TO LEFT INDENT THE PUPPY
print("this is doing shift nest string to left() ======")
print("=====================================================")

shift_nest_string_to_left(xskitahoe)   
resultis =fishbowl[0] 
print("this is after shifting input string to the left to be one tab in front")
print("of the top switch") 
for line in resultis.splitlines():
    print(line)
    
 #this is technically the output which we will now put into inputlist
inputlist[0] = fishbowl[0]   
print("this is testing cutting out switch body from a string")
stringname=xskitahoe; start=7; finish = 14; #this sucker was moving...
print("let us see what is in skitahoe string first")
for line in xskitahoe.splitlines():
    print(line)
print("done with input string to see the starting point")
################################################
#################################################
##  CUT OUT INNER SWITCH BODY LEAVING SWITH WORD
#this one does not work (november 28th this is the hold one)so don't worrya bout it it works elsewhere got it working
# skipping rope yesterday.


cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
outputstring=string_after_cutting_out_inner_switch_body[0]
print('after stage 1 first method call in chain we have this result')
for line in outputstring.splitlines():
    print(line)
print("end of first change to string")
outputlist[0] = outputstring
print("right here this is  after taking out th einner switch body")
#MUST INDENT LEFT 
do_the_pipe()
#print("do the pipe() called")
#item = inputlist[0]

#second method
print("experimenting with joy string simple convert to removing inner switch")
print("and adding a nested method nubered")
print("calling first method")
#this is what I am testing Sunday november 28th, 2021 3:51pm take 101 north instead next time

print("testing a method on change switch to numberedmethod with joy")
print("testing  change_switch_to_method_solved()")
print('================ this is the one ===============go for the gold now==================')
print('==================that I need to work now ===============================')
print('===== this changes an inner switch by itself into a nested_switch numbered============================================')
print('=======using the commented number next to it==================')
print(" === I am at starbucks next to frosty the snowman")
fizz =change_switch_to_method_solved(joy)#

print("========the result of 1 chain method using piping=======")
for line in fizz.splitlines():
    print(line)
outputlist[0] = fizz #just for testing here 

print("testing hotmocha now changing two nested switches into nested methods")
fizz =change_switch_to_method_solved(hotmocha)# testing 2 switches to change

print("========the result of 1 chain method using piping=======")
for line in fizz.splitlines():
    print(line)
outputlist[0] = fizz #j
print("end of the show, turn out the exit lights")
#exit()
print("line 11259")

do_the_pipe()
#list strings are mutable changeable. 
inputlist[0]=inputlist[0].replace("nested","mocha")
print("see if it sticks")
print("just called the pipe()")
print("now it whould be input[0]")
for line in inputlist[0].splitlines():
    print(line)
#`exit()

print("testing taking out endswitch at bottom of function and swapping it with a brace like in C")
## I am doing this because this is how the parser works so it conforms with JavaScript and C style.
print("TESTING it is already November taking out endswitch and putting in a brace at bottom of function")
#focus=take_out_endswitch(fizz)
#for line in focus.splitlines():#
#	print(line)
###=====================================================================================

#next need to swap endswitch to } (right brace)

#exit()


#playing with this
makeitso= '''
switch(exp) #62
		case 'burger':
			print("do something")
			####################
			nested_switch_66(exp) #66
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #86   
'''

newattempt='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
'''

##============================================
## get_top_switch_number_from_this_string(x)
##============================================
twinlist=[]
#testing with string directly above this line
def get_top_switch_number_from_this_string(inputstring):
    print("get_top_switch_number_from_this_string")
    print("there is NO REASON to send humans to Mars")
    counter=0
    x= y =''
    for line in inputstring.splitlines(): #it will be the first switch 06
        if "switch" in line and "#" in line and "nested" not in line  and counter < 2: 
            print("confirmed switchh in line ")
            #this is new getting the switch id number after # on-the-fly
            #get string to right of #, get right side,remove spaces
            x = line.split("#"); y = x[1];y = y.strip();
            print("no drama this is what we have..")
            print("y=",y)
            print("now adding y to twinlist below")
            twinlist.append(y)
            break
        else:
            if counter > 3: #time to bail =too deep can't exist after first line actually
                break
            else:
                continue
                counter += 1
#grab first id number aftger switch 

inputstring =makeitso
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)

inputstring =newattempt
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)









print(" ")
print("====end of show here turn the lights out====")
#exit()  #<<<<<<=================== this is where our exit is.


print("== end of show ==== ")
#exit()
string_egg='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60 
'''


string_egg2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #33 
			#############
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''


pumpkins='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			switch(exp){ #34
			print("nice")
			switch(exp){ #45
			break
		default:
			switch(exp){ #66
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			####################
			switch(exp){ #35
			#############
			print("yep")
			fallthru
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew1='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

#add ability to get the comment number 15 and put that in automatically 
##=======================
##  funtime(y,x)
##=======================
# this is replacing the switch that is nested into 
# a method with the switch number

#building blocks are legos that are small behaviors inside
#of a function that can be assembled and connected in different
#configurations to make new functions without coding
#so interactively combined with a gui
#so chained methods really




#=====================================
# get inner switch number ()  only at the 3 tabs level depth though
#======================================
#so do this multiple times I would have to go thru a loop with the length of the count of switches at three tabs in a string
add_to_list=[]#and call this method get_inner_switch_number(stringname) #and change the counter number
thisline=[] #this also implies only getting one inner switch
def get_inner_switch_number(stringname): #implies at 3 tabs depth
	print("======get inner switch number called=======")
	counter=0
	x=''
	#what this does is get the commented inner switch number after the # in switch
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tabdepth=line.count("\t")      #this is getting tabdepth for this line
		if "switch" in line and "end" not in line and tabdepth== 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			x = line.split("#")  #this manipulates the current line
			y = x[1];
			print("switch number is...",y) 
			add_to_list.append(y)
			counter += 1
			print(stringname)
			#break  #after the if condition above it stops 
		else:
			counter += 1
	print("List add_to_list=",add_to_list)
	#del add_to_list[0] #should delete first one
	print('now we have ',add_to_list)
	#return y;


##===================================
##  funtime(stringname)
## this calls the method get_inner_switch_number()
##===================================
## this replaces the inners switch at 3 tabs with a netsed method name with the id comment number
#this right now only deals with one but I can modify it so that
#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
print("I just don't believe I coded this back on oct 22nd")
print("morgan hill starbucks frosty74")
#===========================================================================
#  convert_inner_switches_into_nested_methods_numbered(stringname): 
#============================================================================
# it will access a list using a loop and they will be put in in sequential order top down
def convert_inner_switches_into_nested_methods_numbered(stringname): #this is feeding in the number looking for
	print("======convert_inner_switches_into_nested_methods_numbered=====")
	x='';concatthis='';counter =0
	# using method get_inner_switch_number(string)#which is grabbed from 3 tab depth only
	for line in stringname.splitlines():
		print(line)
	#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if  tabdepth == 3  and "switch" in line:
		# I just moved what was in a method into the loop where the action happens
			x = line.split("#")  
			y = x[1];       #it was str(ournumber)
			y = y.replace(" ",'')
			filler ="nested_switch_" + str(y) +"(exp)" #has to be a string
			#### this is new december 5th #######
			print("inside of function convert_inner_switches_into_nested_methods_numbered")
			print("###====line 11729 ===========##")
			print("filler=",filler)
			if ":" in filler:
			    filler=filler.replace(":","")
			#end if
			print("after fix  -- filler=",filler)
			print("###===============##")
			######################################
			line = line.replace("switch(exp){",filler) #notice replace using var 
			concatthis += line + "\n"
			counter += 1
			continue
		else:
			concatthis += line  + "\n"
			counter += 1
			continue
	################	
	for line in concatthis.splitlines():
		print(line)	
		

print("testing this")
print("convert inner switches without bodies inot nested methods numbered")
convert_inner_switches_into_nested_methods_numbered(brew) #line number of inner switch is in thisline[0]
#exit()

#def plan_c(inputstring):


#so we wouldn't need to enter the 5 we an glean that
#and we don't need to know the 15 number either it will grab it
print('======= end of funtime code ==============')
print("now testing with 2 inner switches to change")
print("oasis in the desert -----")
#this is the one that we are playing with
print('=====those headlights are awefully bright - rude and dumb=====')
convert_inner_switches_into_nested_methods_numbered(string_egg2)
print('pumpkin express')
convert_inner_switches_into_nested_methods_numbered(pumpkins)

#try none and try one
convert_inner_switches_into_nested_methods_numbered(brew)
	
convert_inner_switches_into_nested_methods_numbered(brew1)

#exit()
# I think that I will go through a string and 
# return a list of the locations of switches 
# (skipping the first switch)
# switch and endswitch line numbers
# was just thinking that it's obviously a switch otherwise
# we wouldn't be here so NO NUMBER for main switch (brilliant)
#it still matters but it's obvious that it is there. It's actually
# the main switch and the frame for nested switches. 

#ibm[0]=tuna #input of string into ibm[0]
list_of_nested_switches=[]
list_of_nested_switches.append(12) #these are just the line numbers here 12 and 32 
list_of_nested_switches.append(32)

#here I am using a list which has the line numbers of the inner switches locations
print(list_of_nested_switches)  #so it would look like this 
#this goes through the input main switch and changes nested "switch" into a nested_switch numbered

#this is used for managing the nested switches by getting their location to know
#where to copy them when extracting them from a main switch
# today is july 17th, 2021 9:33 am

print('testing this to make list of all switch locations and all endswitch locations')
#print(tuna)
switch_location=[]
endswitch_location=[]
print("beginning === put location of switch and endswitch into lists")
print("====---------------------- saturday coding ----------===")

ourcounter=0
#for line in abovenestedswitch.splitlines(): 
'''
for line in tuna.splitlines():
    
    if line.startswith("switch"):
        print("this lines starts with switch")
        switch_location.append(ourcounter)
    
    
    if line.startswith("endswitch"):
        print("this line starts with endswitch")
        endswitch_location.append(ourcounter)
        
    ourcounter += 1
    '''        
print("====OUTPUT TO DETERMINE location of each switch and endswitch====")
print("")
print("switch_location=",switch_location)
print("endswitch_location=",endswitch_location)
print("")
print("===make your dreams reality===")
        



# july 24th, 2021 
#the input for this MUST be the already reduced main switch which
# has just the switch word in place where each nested switch thru endswitch was.


###  Thursday, August 19th, 2021 time 9:07 am
# I think that I just need to not worry about the other nested switches
# and just do the first level of nested switch since the others will just be in the other switches
# so let' say I have two nested switches deep
# I only have to have (for the main switch) the first level nestedswitch
# so then the situation becomes the numbering because in this first level of nested switches
# they would be numbered in sequence 1, 2, 3 etc  
# if say there are two nested in teh first main swith then sub1
# but for the inner levels (the next tab level) I would have to do 4,5,6 I suppose
# so continuing sequence or 1.1 and so forth
# I need to come up with a simple numbering system maybe Alpha first level Alph
###
#what if I have pairs, simple numbering but 
##===========================================	
## number_nested_switches_in_sequence()
##===========================================
#put the input I just created into ibm[0]
#this would be the main string after the nested switches are taken out  leaving switch word
forcedinputstring='''
	switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown kkk')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     #  this would be 10  for line number      
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 18 but it said previously 28      
			fallthru
		
		default:
			print('the end')
}
'''
#this is input for add counter to switches
trouble=[]
trouble.append(forcedinputstring)


#this is using preset nested switch starting locations 11 and 29 for this test
# this is for making the nested switch numbered method 



#this swaps switch with nested_switch_" n
##########################################
## number_nested_switches_in_sequence():  #this is using hardcoded input for testing
##########################################
def number_nested_switches_in_sequence(): # list_of_nested_switches[11,29]
	print("=R2D2= NUMBER_nested_switches_in_sequence()  ====== ajax =====")
	newcount=1  #number of nested switches starts from 1
	## wait do I loopthru it get the position of the inner switches now why not
	## modification on july 24th 
	print("to see what it sees first")
	#this is string above called forcedinputstring
	print(trouble[0])  #it was ibm[0] which I will change it back to later
	mystring=''
	mystring = trouble[0] #putting the string into trouble[0]
	newcounter=0
	foundone=[]
	# this gets the inner switch locations after the inner switch bodies have been stripped out (deleted)
	##===============================
	for line in mystring.splitlines():  #this fills list foundone with switch line numbers
		if "switch(exp)" in line:
			print("true we found switch")
			foundone.append(newcounter) #this fills the foundone list of line numbers with switch in it
			newcounter += 1
			continue
		else:
			newcounter += 1
			continue
	#=== end loop ========================
	print("we are done looking for the inner switch locations")
	print("====================")
	print("thefoundone llist has",foundone)
	print("the length is", len(foundone))
	print("========........======")
	print(" ") #below we delete the first switch which is on line 1
	del foundone[0] #this should delete the first switch we don't need 
	print("now we have for foundone list",foundone)
	## end getting inner switch lcoations
	##======================================
	
	#shiney= ibm[0] #so it will skip the first few lines skipping the first switch 
	thecounter = 0 #tracking lines in the string   oh it's using preset numbers
	print('the list of nested switches starting line',foundone)
	switchcount=0
	magic_string=''
	seagull='' #WAS shiney.splitlines()
	for line in trouble[0].splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 #IT HAS TO BE AFTER THE FIRST 2 LINES TO SKIP THE FIRST SWITCH
		#if  switchcount > 0  and thecounter in foundone:
		# if thecounter in founderone
		if  thecounter in foundone:  #this must be line numbers of inner switches
		#this line of code is absolutely beautiful and elegant 
			print("thecounter=",thecounter)
			print("switchcount=",switchcount)
			########We know the line numbers do it on one pass perhaps
			# it should only go to the lines in the list of nested switches
			gettabcount=line.count("\t")
			line = line.replace("switch(exp){","nested_switch_"  + str(newcount) +  "  " +str(gettabcount) + " tabs " +"(n)")
			magic_string += line + "\n"
			#NEW line above
			newcount += 1  #break #because we are only doing it once to replace only ONE switch #start  = thecounter #this resets the range n to skip what it just did.
			thecounter += 1 #this adds to the neste switch counter
			continue    
		else:
			magic_string += line + "\n"
			# new ling e
			thecounter += 1
			continue
	print("=====-----======-----======------=====----====----====---")
	print("magic_string=")
	print(magic_string)
	print("========")
	for line in magic_string.splitlines():
		print(line)
		
	print("were the changes made - this is kind of important at this stage RED ALERT")
	trouble[0] = magic_string #here it's fed into trouble[0] so it's in a list now
	print("did I rip out the nested switches or are they still intact???")
	print("trouble[0]=",trouble[0])	
	#ibm[0] = shiney
			
####================================			
print('about to call number-nested_switches_in_sequence() to test it extendo bus just passed')
number_nested_switches_in_sequence()
print("it should have ran already testing bugs bunny here ")
print("the nested switch words should be nested numbered methods now")
print("just ran this function number_nested_switches_in_sequence()")
print("original mac computer")
			
#exit()

print("we are at line 4434 now and after finishing doing number_nested_switches_in_sequence() ==>>")
print("this is where the exit() was.......1..2...3..4....5..555..666...777..8.8..9999.10 10==")













#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





			
###============== Sunday July 25th, 2021  10:19 am Cafe Borrone ===============
# the idea is to put the information for each nested switch case
# into the dictionary in terms of it's exact information
# so to fill the data into the nested switch dictionary I will need
# to loop thru the switch string and gather the data for each switch location
# and it's particulars and add it to the dictionary (this should be done first')
# the idea occurred to me since each nested switch has a specific location
# and juggling them can get quite confusing so this way I know which is which
# and where it is.
#=======================================================================
####################
## DICTIONARY HERE 
####################
#putting a named list inside of known dictionary
nest_data=[]
# I probably won't need this.
nested_switch_data =	{  #for pear tree in backyard (2 of them)
#key [level tab depth,number case,  line number, series number
"1": [3,2,23,1], # I can make these now 
"2": [3,3,43,2],
}

print(nested_switch_data)

result=[]
result.append(0)

###############################################################
## RAM LIST TO HOLD TEMPORARY DATA FROM LIST WITHIN DICTIONARY
###############################################################
ram_list=[]
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)

########################
## get_nest_data(key)
########################
def get_nest_data(x): #puts it temporarily into result[0]
	print("get nest data called",x)
	#this grabs the value from the key and puts it into result[0]
	#these are teh parameters for tehe signature for this nested switch
	result[0]=nested_switch_data.get(x)
	#s- there would be a list within result[0]
	#why not instead populate a list
	print("this is what is in result[0]")
	print(result[0])
	for item in result[0]:
	    ram_list.append(item) #see if this fills it or not
	print('ram_list=',ram_list)
#############################		

  #test data input
############################
##  add_to_nest_data(x,y)
############################
cool_list=[]

# what is missing is the meaning of the code and the beahvior that it creates
# when it's running and knowledge
# how it works and what it does at levels

x = cool_list
def add_to_nest_data(x,y):
	print("====add to nest data() called with ", x  ,"and",y)
	nested_switch_data["my_list_" + str(x) ] = y

#print("my_list_1[0]",my_list_1[0])
#print("gosh")
######====================================
########
print("working on access a dictionary in a precise positiion in a list")
print("that is in the dictionary")
my_dict={}
#add a dictionary #this might be just what I need actually 
my_dict["my_list"] =[3,1,4,1]
print('terrible')
print('trying mydict[0] see if it works')
print(my_dict["my_list"][0]) #the key
print(my_dict["my_list"][1]) #the key
print(my_dict["my_list"][2]) #the key
print(my_dict["my_list"][3]) #the key
alpha = my_dict["my_list"][0]
print("alpha sees =",alpha)
#check in the list


# 

my_list_1=[]
my_list_2=[]
my_list_3=[]
#####======================================
y = [1,2,3,4,5]
add_to_nest_data(1,y)

y = [23,26,34,42,52]
add_to_nest_data(2,y)

y = [63,66,64,72,72]
add_to_nest_data(3,y)
print("=================")
print(my_list_1)
print(my_list_2)
print(my_list_3)

#print(my_list_2)
#alpha = mylist_1[0] #should be 1
print("is this even working....",alpha)

print(" == looping through nested_switch_data to see the contents == ")
print("TESTING ship wreck the contents of the dictionary now,,,")
for key,value  in nested_switch_data.items():
	print(key,value)
	













################################
##  NESTED_SWITCH_INFO
###############################	
def nested_switch_info(x):
	get_nest_data(x)
	#this will get the info from the dictionary		
			
			
			
switch_location=[]
endswitch_location=[]
#  WE ARE HERE THIS IS WHERE THE BIG TEST BEGINS TO REPLACE INNER SWITCHES WITH METHODS ON THE FLY
##=================
#if we already have the numbers it should work, later I will have it find the locations first
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG ===BIG TEST here in the switch with 2 nested switches")
print("========")
print("this does the bottom half the bottom nested switch first ")
print("this is becuase it's governed by the corect line numbers")
print("and if I take out the top switch code then the numbers for the lower switch will be wrong")
print("I just realized that") #this is the purpose of experimentation
#ibm[0] = tuna  #I am force feeding it into ibm[0]

# I have to tell it what number to use to number the nested method using
# use_number[0]= 2 example








################
# the skipping is done by the main switch when I cam copying it and taking out the 
# nested switches below but keeping the switch word that I then convert to a method nested numbered
#################
### TESTING 
#NUMBERING OF NESTED SWITCH HAS TO BE DONE BOTTOM UP SINCE WE ARE RIPPING OUT THE NESTED SWITCH AFTER THE SWITCH WORD
#oh I will have to do this bottom up so the line numbers are correct.
#first show what is in ibm[0]
print("====== testing main switch template ======tue sep 14, 2021 ================")
print("WE MADE IT HERE line 4691 it's tuesday today")
print("TUESDAY TERRIBLE TEST of main nested switch and adding methods for switches swapped out") 
print(ibm[0])
print("I am taking out the lower switch first (later I will copy it first)")
print("it does it upside down going bottom up to do this.")
'''
skipping_some_lines(ibm[0],28,38) #changes 2nd nested switch
use_number[0]=2
swap_switch_for_nest_method_new(21) #second number has the switch in it 
#the first number is the number for the nested_switch
print("this now does the top nested switch")
print("here I am taking out the first nested switch later I will copy it first")
skipping_some_lines(ibm[0],10,20) #changes first nested switch in the sequence
use_number[0]=1
swap_switch_for_nest_method_new(11) #second number has the line number with switch   #needs to be 1 not 2
print("this is the end of Godzill and King Kong testing")
'''






#this should be called only once and 
print("====++++now testing running number_nested_switches_in_sequence()")
#number_nested_switches_in_sequence()
print("we have just completed the first nesteed switch skipping and putting a nested method 1 in ")
print("ibm[0] should show the main switch with 2 methods where the inner switches were previously")
print("this is the output of the string ibm[0]")
print(ibm[0])
print("I am going to loop thru the switch and change the lines with nested_switch")
print("============= Godzilla =============")
print("END OF GODZILLA AND RODAN AND MOTHRA")


#go thru a number the switches numerically top down

























hawaii ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown nnnmnn')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#######
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					######
					switch(exp){          
						case 'blable':
							print("do something")
							print("yep")
							fallthru
						case 'more':
							print("nice")
							break
						default:
							print("we are done here")
						endswitch 
						######
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			######
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			#######
			switch(exp){          
				case 'fish':
					print("do something")
					print("yep")
					fallthru
				case 'trout':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			#######
			fallthru
		
		default:
			print('the end')
}
'''	
get_switch_and_endswitch_locations(hawaii)
print("this would have just gotton the switch and endswitch line number locations above...")
print("I found it, I was looking for this code")
#empty_switch_and_endswitch_list_locations()

#get_switch_and_endswitch_locations(tuna)
###======================================================
#july 19th 2021 testing this feature now morgan hill starbucks
########################################################
#empty_switch_and_endswitch_list_locations()
#print("the one below this line should produce 2 switches and one with 10,20")
#print("why is this wrong")
#get_switch_and_endswitch_locations(samplestring) #samplestring 
#get switch and endswitch lcoations for one nest
#it's off by one says 11,21
#input is 10 and 20 and yet this says the line number is 11 and 21 for nested switch

empty_switch_and_endswitch_list_locations()
print("the one below this line should produce 2 switches and one with 10,20")
print("why is this wrong")
print("get result of get switch and endswitch locations from samplestring")
print("earth is over level ======")
print("earth is over level ======")
print("=== tea time =============")
get_switch_and_endswitch_locations(samplestring) # sammplestring


###  july 14th wednesday 2021 working on this
#real number is count endswitches and add 1 for total switches

#endswitches number is how many nested switches

# this empties the lists storing the switch and end switch locations

#del switch_location[:]
#del endswitch_location[:]

#get_switch_and_endswitch_locations(hawaii)

print("this is the string with two nested switches")
print("here we go wednesday coding - the bicycle gloves are great")
print("first clearing out the lists that hold the locations of the switch and endswitches")
print("this clears out the swith and endswitch locations in the list so it starts empty")

#I was deleting the crucial lists so the code down below couldn't behave correctly

#del switch_location[:]
#del endswitch_location[:]
#feed the string into the method to get the switch and endswitch locations
# but delete the first switch details which isn't important at this point.

#get_switch_and_endswitch_locations(tuna)
#this creates a list that can be of any size and then I can subtract the first switch
#and then divide the number by 2 to get teh number of switches or just count teh switches
'''
nest1=[]
nest1.append(switch_location[0])
nest1.append(endswitch_location[0])
nest2=[]
nest2.append(switch_location[1])
nest2.append(endswitch_location[1])
#wait a  second with each pass the output will be teh same unless I have 
#a list of say ten spaces tol hold locations to be proactive.
#####################################################
print("nest1=",nest1)
print("the two values in nest1 are",nest1[0],nest1[1])
print("nest2=",nest2)
print("the two values in nest2 are",nest2[0],nest2[1])
'''


#++++++++++=========================================================
### july 7th 2021 experimenting 
### testing cutting out two nested switches one at a time
### and replacing the switch location with the nested method with a number
# I need to do these separately first to make that they work
##===========================================
##===========================================
#skipping_some_lines(tuna,nest1[0],nest1[1])
#swap_switch_for_nest_method_new(1)

#and I need to make sure that the resulting string to modify the second phase is correct
#skipping_some_lines(tuna,nest2[0],nest2[1])
#swap_switch_for_nest_method_new(2)
##============================================
##============================================
# what I will attempt it going thru the double nested switch with two nests
# and delete the two nests and put nest methods in the location of the inner switches.
# and then after that is figured out I will first copy each inner switch
# Based on the nested switch locations I find I can determine how many nested switches
# espcially with teh endswitch count 



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========


















def end_program():
    print("ending program")
    return

## method chaining nov 13th, 2021 &:45 am
print("======= chaining methods =======")

'''
I was going to do method call
Loop thru all slots in list
====================
Then do next method call to all items in list
Chaining input to output is input fir next method
Then realized if i chained
Sequence of methods only go thru loop once (genius)
'''


# 48-C battery volvo 2002 s60
# 1 800 222 4357
# 
# 1041 Cochrane road, morgan hill starbucks

## chain methods code  chain methods chain methods CHAIN METHODS 



#A method that calls a series of methods really utilizing output from previous method

#these might have been created above but I am doing them again here just in case.
input=[]
input.append(0)

output=[]
output.append(0)


##=====================
##   get_final_finished_string()
##=====================
def get_final_finished_string():
    print("===get_final_finished_string():===")
    print("output[0]=",output[0])
    print("=== result is in output[0] ===")
    
# passing the baton in the relay race 
##=====================
##   so_pipe()   #this feeds output[0] into input[0] to be used with next method
##=====================
def do_pipe():
    print("==== do_pipe() ====")
    #put output[0] into input[0]
    input[0] = output[0] 


##=====================
##   initialize_lists()
##=====================
def initialize_lists():
    print("====initialize_lists(): ====")
    input[0] =''
    output[0]=''
   


old_string_test='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown ppp')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
endswitch
'''

  
holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			print("detected } in line")
			#location = line.index("#")    #gets location from left where position of #
			#line = line[:location] 
			print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			print("after left shift it is ",line)
			#line[0] = first #this is new to slice off right of brace
			line = line[0]#first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():
	#    print(line)
	    
	##===========today sunday coding
	
	#then look for this } and reposition it
	'''
	testingthis=''
	for line in holdthis[0].splitlines():
	    
	    if "}" in line:
	        line= line.lstrip()
	        testingthis += line
	    else:
	        testingthis += line
	holdthis[0] =testingthis
	print("now testing if this change worked shifting } to far left")
	for line in holdthis[0].splitlines():
	    print(line)
	'''       
	#this is what I need to modify.
	#so the whole modified string after ripping out endswitch is now in holdthis[0]
	
	print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
	
print("testing taking out endswitch and putting in brace")
#take_out_endswitch(old_string_test)
print(holdthis[0])


    
##======================================================================================
#the result of each of these methods will put their result in output[0]
#swap_feed_data then puts what is currently in output[0] into input[0] so it's a handoff of the baton
#each of these methods takes in input[0] as input with the result going into output[0]
#after each method we call do_pipe() which puts output[0] into input[0]
# string --> m1(input) => m2(input) => m3(input) => m4(input) => m5(input) 

##====================================================
##  first_method : manipulate_string  (left indent)
##====================================================
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    print("manipulate_string left margin indent ===first message called..")
    #shifts string left to indent it properly
    astring=manipulate_string(astring) #I think that this does left shift indentation
    return astring

##==========================================
##  second method : take_out_switch_body  from inner switches
##=========================================    
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    print("take_out_switch_body ...seconed method called...")
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #<== key this is new to see if it works=========
    #astring += " water"
    return astring


##=================================================
##  third method : change_switch_to_method_solved
##=================================================
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("change_switch_to_method_solved  swapto neested_switch method third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    return finalresult

##======================================
##  fourth method  : take_out_endswitch
##======================================
#take_out_endswitch(stringname)
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("take_out_endswitch  put in brace instead third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring)
    #astring += " bright"
    return finalresult
    
    
##=======================================================================================
#using descriptive names not true method names yet
# what this is doing is modifying a string in stages in a sequence 
# code name waterfall
output=[]
output.append(0) #so we can use output[0] below
##========================================
##  chain_methods()   this just does a sequence of methods piped  
##                    together so each method passes its output as input for next method
##=====================================
def chain_methods(item):
    print("==OFFICIAL== chain_methods called ====")
    firstresult  = first_method(item)         # manipulate_string(string)
    secondresult = second_method(firstresult) # take_out_switch_body(string)
    thirdresult  = third_method(secondresult) # change_switch_to_method_solved(string)
    fourthresult = fourth_method(thirdresult) # take_out_endswitch(string)
    output[0]    = fourthresult #this puts the result into output[0]
    print("now we are looking in the frac output of fourth method")
    for line in output[0].splitlines():
        print(line)
    #the resulting string is put into output[0]
    
    
    # I still need to rename the actual methods and put them above this section 
    #add comment number to all switches at the very beginning of initial switch string(not here)
    #add_comment_with_number_to_top_switch(input[0]);do_pipe();  #switch # 22 <-- line number added
    #shift_string_to_left_by_reducing_tabs(input[0]);do_pipe();  #subtract tabs # works nov 19th
    #cut_out_switch_bodies_at_3_tabs_depth(input[0]);do_pipe();  #reduce switch body to just switch word
    #swap_switch_with_nested_switch_number(input[0]);do_pipe();  #change switch to nested_switch_22(exp)
    #replace_the_last_endswitch_with_brace(input[0])             # endswitch becomes  }
    #get_final_finished_string() #in output[0] prints it out nest_list to see it




##=================================
## change_slot_string(counter)    this changes content of each slot in nest_list
##=================================
def change_this_slot_string(counter): #requires output[0] finished string
    print("==== change_this_slot_string(counter) ====")
    counter = int( counter)
    nest_list[counter] = output[0] #I really need to test this one and see if it works 
    #this means that needs to have finished chained_methods put into output[0]
    
##============================
## transform_string()    uses nest_list with strings in it of switch case bodies
##============================
def transform_string():  #this calls chain_method(item) # separate switch string input
    print("==== transform_string() ====")
    counter =0  #loop
    for item in nest_list:  #loop thru nest_list and each loop does the chain_methods
        chain_methods(item) # takes in string and does sequence methods puts into output[0]
        change_this_slot_string(counter) #changes slot string from output[0]
        counter +=1


##==================================================
## loop_thru_finished_list_of_prepped_strings():
##==================================================
def loop_thru_finished_list_of_prepped_strings():
    print("==== loop_thru_finished_list_of_prepped_strings() ====")
    counter =0  #loop
    for item in nest_list:
        print(item)
        print("counter=",counter)
        print("===========")
        


# loop_thru_finished_list_of_prepped_strings() took this out
# this hasn't been tested yet. Today is Sunday, November 14th, 2021 10:58 am Pacific Standard Time
# this goes thru nest_list and modifies all of the switch strings
# and fixed the indentation, and adds nested methods and a comment after each switch 
# with the number after it and cuts out the switch bodies at three tabs depth
# and it uses chain methods in a sequence on each string so the loop only goes ONCE !!!!!
##====================================================
##  prep_nest_list_of_switch_strings_for_bypass205()   STAINED GLASS WINDOW SECTION
##====================================================
## ATTENTION: I have the code for this working but the names are new and I need to 
# put the first two methods lists below in these names. This is SOOO COOL NOW 
#dec 5th sunday I don't think that this is called yet.not tested yet then.
def prep_nest_list_of_switch_strings_for_bypass205():
    print("====prep_nest_list_of_switch_strings_for_bypass205() ====")
    go_thru_input_major_switch_string_and_make_list_of_pairs_switch_and_endswitches() # made above
    using_pair_list_make_seperate_switch_strings_and_put_into_nest_list()             # made above
    transform_string() #DOES CHAIN METHODS  loops thru  nest_list modifies each separated string
    loop_thru_finished_list_of_prepped_strings() #thru FINISHED nest_list
    #the end result will be in nest_list with the strings ready to feed into bypass205
    



holdingpattern=[]
holdingpattern.append(0)
##=========================================
## fixes_dots_in_nested_string(inputstring)
##=========================================
def fixes_dots_in_nested_string(inputstring):
    print('testing very_clever')
    #    print(item)
    newline =''   
    for line in inputstring.splitlines():
        if "nested_switch" in line:
            newline += line.replace(":","") + "\n"
        else:
            newline += line + "\n"
    print("this is the result of modifying and taking out : after nested_switch")        
    for line in newline.splitlines():
        print(line)
    holdingpattern[0] =newline
     #I still need to change the slot in the string though 







input=[]
output=[]
output.append(0)

mystring = "smile "

def get_one(astring):
    astring += " a"
    return astring
    
def get_two(astring):
    astring += " water"
    return astring

def get_three(astring):
    astring += " bright"
    return astring

fizz  = get_one(mystring)
fizzy = get_two(fizz)
fuzzy = get_three(fizzy)

print("fuzzy after my simulated piping =",fuzzy)
print("")
print("")
print("final test before sending it to bypass205()")
print("this should take in a string")
print("indent it to the left margine")
print("take out switch bodies")
print("swap switch with nested_switch numbered")
print("============== here we go rudolph ======")
print(" . ")
print('...................,.,.,.,.,.,.,.,.,.,.,.')



#for testing purposes of transforming an input string this one is teststring3
mystring = teststring3  #right here change it 
for line in mystring.splitlines():
    print(line)
   
   
   
    
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    print("=====first method started..")
    #shifts string left to indent it properly
    #LEAVE THIS DON"T MEDDLE THIS WORKS
    # MODERN TAB SHIFTER TO LEFT IS PURE GOLD
    modern_tab_shifter_to_left(astring) #I think that this does left shift indentation
    astring= goldtime[0] #output from modern_tab_shifter_to_left
    #removes garbage on right side of switch strings (still testing)
    ########################
    print("check right here frosty")
    #print("newstring[0]=",newstring[0])
    
  
    
    ##################################
    #print("calling: fixes_dots_in_nested_string() method")
    #fixes_dots_in_nested_string(astring) #when it is nested_switch_22:(exp) removes :
    #astring=holdingpattern[0]
    for line in astring.splitlines():
        print(line)
    
    #return astring
 ######################################   
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    print("=======seconed method started.take_out_switch_body..")
    #astring =newstring[0] #from first method above outoput
    #TAKE OUT SWITCH BODY METHOD
    #print("see what we are passing does it have something in it")
    print(astring)
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #this is new to see if it works=========
    
    
    print("==output from second method take out switch body==")
    for line in astring.splitlines():
        print(line)
        
    print("================")
    #astring += " water"
    return astring




 #converts inner switch into a nested_switch method numbered
############################################
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("=======third method started...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    #converts inner switch into a nested_switch method numbered
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    print("===third method output==")
    print("outoput from change switch to method solved")
    #for line in finalresult.splitlines():
    #    print(line)
    
    print("what does it say right here")
    for line in finalresult.splitlines():
        print(line)
        
    return finalresult    
    
    
    
############################################

#take_out_endswitch(stringname)  #this would do all of them regardless of number
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("third method startedc...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring) #replaces it with }
    #astring += " bright"
    return finalresult
    
hollister_list=[]
#take_out_endswitch(stringname)
##=========================================
##  simulated_chain_methods():  this is called for each switch string
#this is doing one string at a time. 
##===================================
def simulated_chain_methods(mystring): #starting point 
    print("SIMULATED CHAIN METHODS () Rudolph the red nosed reindeer")
    first_method(mystring)
    fizz=goldtime[0] #output from first_method()
    print("stage1 fizz =",fizz)
    
    print("FIZZ TESTING CRITICAL 1ST METHOD output of first_method() ")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fizz.splitlines():
        print(line)
    
    ##############################==================
    fizzy = second_method(fizz)  #missing 66
    print("stage 2 fizzy=",fizz)
    
    print("FIZZ  TESTING CRITICAL 2ND METHOD to see what's in frac")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fizz.splitlines():
        print(line)
    
    #return   
    ##############################
    fuzzy = third_method(fizzy)
    print("stage 3 fruzzy=",fuzzy)
    
    print("FUZZY  TESTING CRITICAL 3RD METHOD to see what's in ")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fuzzy.splitlines():
        print(line)
        
        
    ############################
    frac  = fourth_method(fuzzy)
    print("strage 4 frac=",frac)
    #############################
    print("now we are looking in the frac output of fourth method")
    for line in frac.splitlines():
        print(line)
    print('above this line is the Rudolph the red nosed reindeer final first test')    
    print("line number 12502")
    #frac is the result
    #look at frac to see when  switch 31 and 66 are missing
    print("FRAC  TESTING CRITICAL 4TH METHOD n frac")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in frac.splitlines():
        print(line)
        
    hollister_list.append(frac) #new on november 30th Tuesday 
    
    
    
    
###==============
##   plan B 
##================  testing converting nest string testlist_of_strings
def planB():  #november 30th, tuesday 9:45 am morgan hill starbucks 
    print("never give up")
    print("PLAN B called using simulated_chain_methods on each switch string")
    print('===== welcome to planB ==== november 30th tuesday===')
    print("doing planB testing each nest_list doing chain_methods")
    counter=1
    for item in testlist_of_strings: #test string names numbered
        print("========================")
        simulated_chain_methods(item) #testing chain methods
        print("====== counter= ",counter)
        counter += 1
        
    print("the HOLLISTER LIST of modified switch strings that started out seperated")
    for item in hollister_list:
        print(item)
        print("==== middle ground between methods ===")


#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########


#making this sucker work no matter what 

#print("the big test begins")
#planB()
#print("now simply loop thru the finished changes in the list")

#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop

result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]

print("this is after the input stings have already been seperated")
###=====FIRST METHOD OF CHAIN METHODS ============
##======================
##  move_string_to_left_side()        first method modern tab shifter to left 
##======================
def move_string_to_left_side():
    print("=====APPLE== modern_tab_shifter_to_left()=====")
    counter = 1
    for item in testlist_of_strings:
        print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
        print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
    print("result of shifting input strings to left")
    print("=====APPLE==APPLE   APPLE   APPLE   APPLE   APPLE=====")
    for item in result_of_first_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    



###=====SECOND METHOD OF CHAIN METHODS ============
##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    print("=====PLUM == take_out_switch_body(item)====")
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
        print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
        print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    counter =1
    print("result of taking out inner switch bodies")
    for item in result_of_second_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    

#good_plum()



###=====THIRD METHOD OF CHAIN METHODS ============

##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    print("=====PEACH===change_switch_to_method_solved===")
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        print("===== counter =",counter)
        counter += 1
    #########################################
    counter =1
    print('result of 3rd method on string')
    for item in result_of_third_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    
    
 ###=====FOURTH METHOD OF CHAIN METHODS ============   
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
##=================================================================
def replace_endswitch_with_close_brace():
    print("=======ORANGE=take_out_myendswitch===")
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
        print("=======")
        fizz =  holdthis[0]
        print('orange fizz =',fizz)
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        print("===== counter =",counter)
        counter += 1
   #########################################
    print('result of 4th method on string')
    counter=1
    for item in result_of_fourth_method:
        print(item)
#Santa_Cruz_Python_Preprocessor/fourth_of_july2good.py /

 
 
   
#import official_switch_case_silver
#from official_switch_case_silver  import *  
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){
#first red robin here testing 


# output is to inputstring[0]

passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)
##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
#############################################################
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	print(" add_comment_and_line_number_to_all_switch()....this was just called .. ")
	print(" == directive 1 ==    ADD the stupid comment and line number after each switch relaly simple")
	awesome='';counter =0;newstring='';smart_switch_numbers=[];#clears it out Dec 11th
	print('baseline is red_robin starting appearance testing purposes')
	print(inputstring)
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
			#end if
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	print("=== jump off the cliff and fly in hang glider ==")
	for line in newstring.splitlines(): #was redrobin.splitlines()
		print(line)
	print("AFTER ADDING the line number as comments to the switches in red robin baby ")	
	print(newstring)   #it prints red_robin switch combo string with the line numbers added in comments
	print("smart_switch_numbers=",smart_switch_numbers)  #this is new here too 
	return newstring #this way I can capture the changed string





def too_swift():
    print("==========too_swift() called=======")
    print("dirt stimple test showing lines with switch, end switch and }")
    for line in waffles.splitlines():
        if "switch"in line:
            print(line)
        if "}" in line:
            print(line)
too_swift()

print('done for the exit sign')        


print("from the web trying this out")

quail=[]
# I am adding the quail list to practice filling it

print("testing add comment and line number after all switches")
add_comment_and_line_number_to_all_switches(waffles)#was red_robin
print("REd ALERT critical test first method  test first method ...")
#exit()


def empty_switch_and_endswitch_list_locations():
    print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter

switch_location=[]
endswitch_location=[]
together_pair=[]
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	return
	#return we START BUILDING
	print("thbis is what I am testing now now now")
	print("  get switch and endswitch locations###  called line 322 #####")
	print("######get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#wrong='''	
		#rechecking to see if this works 
		if "switch" in line and "end" not in line:
			print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		#if "endswitch" in line:
		#	print("look right here endswitch found",counter)
		#	endswitch_location.append(counter)
		#	counter += 1
		else:
			counter += 1 
	
	counter=0
	for line in z.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line:
			print(line)
			print("look right here endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1 
		#'''
	print("at this point this is what we have...after testing BIG YELLOW BIRD go bird")
	del switch_location[0] #takes out first number not needed
	print("switch_location=",switch_location)
	print("endswitch_location=",endswitch_location)
	#test_string1exit()
	print("this over writes the contents of these two lists ")		
	#hard coding it in here why 
	#switch_location    =[1,11,15,23,31,62,66]
	#endswitch_location =[100,60,51,46,41,86,77]	#might hav eto resverse these 	
	
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	#del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	print(z)                #now I remember that is the first switch which doesn't matter
	print("I deleted the first switch since I'm not bothering with it")
	print("switchlocations=",switch_location)
	print("on line 180 endswitchlocation=",endswitch_location)
	
	print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	print("this is how many nested switches are here")
	print("now we should have this many nested switches to contend with",answer)
	print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	#if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
	#	print("endswitch locations =",endswitch_location)
	#	print("out of curiosity print the number of endswitches", len(endswitch_location))
	#else:
	#	pass
	print("I need to test that this part still works here in fourth of july 2 .py")	
	print("this might be simpler to test and use actually======/////???????//////===")
	print("======================================")
	print(" ===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === ")
	print("I need to delete teh first swithc location")
	
	#working on this on Saturday, October23, 2021 to get this stage done 
	#del switch_location[0] #ALREADY DELETING FIRST SWITCH ABOVE BECAUSE IT'S NOT NEEDED NOT NESTED
	print("does this look right testing on Sunday gloomy rainy day")
	print('switch_location=',switch_location)
	print('endswitch_location=',endswitch_location)
	#the input is above
	
	
	print("....")
	print("the input for filling the blueberries dictionary are the lists switch_location and endswitch_location")
	print("==================")
	#print("the enchanting world of making blueberry pie")
	
	
	
	
	##################################################################################
	############## working on this on saturday, october 23rd, 2021 ###################
	##################################################################################
	print(" rain fall status ")
	counter=0
	#working on creating input list for blueberries dictionary: can't believe I didnt do this yet
	print("what the hell is going on here")
	#print("switch_location=",switch_location)
	#for item in switch_location:
	#	print(item)
	#print("so how did that go...")
	
	print("endswitch_location=",endswitch_location)
	#for item in endswitch_location:
	#	print(item)
	print("so how did that go...")
	
	
	counter=0
	print("starting at counter =0")
	
	print("=============== starbucks morgan hill =====")
	print(switch_location)
	print(endswitch_location)
	print("emptying together pair here")
	del together_pair[:] #delete it just in case to start with clear chalkboard
	print("=======") #THIS FILLS THE TOGETHER_PAIR LIST OF SWITCH,ENDSWITCH 
	print("this loop fills the together_pair list of switch,endswitch numbers")
	print("this is so much dam fun oh yeah")
	total1 = len(switch_location)
	total2 = len(endswitch_location)
	print("total1 =",total1)
	print("todal2=",total2)
	print("this is where we START BUILDING the ===TOGETHER PAIR =====")
	for item in switch_location:
		solution = "[" + str(switch_location[counter]) + "," + str(endswitch_location[counter]) + "]" 
		print("solution=",solution) #to see what it looks like 
		together_pair.append(solution)
		print("counter=",counter)
		counter += 1
		
		#this should prevent stack overflow of the list range added november 9th 
		if counter >= len(switch_location):
			print("stack overflow called since counter > = len(switch_location)")
			break
		else:
			continue
			
	print("now we will loop thru the together_pair to see that the pairs are in there")
	del endswitch_location[-1] #should delete 100
	print("this is what is in TOGETHER_PAIR at line 254")
	for item in together_pair:
		print(item)
		apple = item.split(",")
		print("======")
		print(apple[0])
		sweet1 = apple[0].replace("[",'')
		#print(sweet1)
		print(apple[1])
		sweet2 = apple[1].replace("]",'')
		print(sweet1,sweet2)
		print("where's the party")
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	##################### end of method #################################3
#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]  	
	
	

print("what are they actually")
print("starbucks coding NEXT TO RED ROBIN===== big storm coming...")
#Sget_switch_and_endswitch_locations(red_robin) #yeah it's calling red robin!!!
print("result of switch and endswitch locations in red robin")
print("examine the contents of the lists switch_location and endswitch_location")
print('switch_location=',switch_location)
print('endswitch_location=',endswitch_location)
print("RIGHT HERE DANGER WILL ROBINSON=====")
#print('switch_location=',switch_location)
#print('endswitch_location=',endswitch_location)
print("next I will fill the blueberries dictionary not yet on oct 23rd, 2021 saturday")
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location

string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
print(string)

print("end of test from the web")
print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced
old_coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown eee')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
}
'''
coffee_now='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
	
#this is coolstring with the nested switches already taken out for all levels+
coolstring='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown jj')
			switch(exp){
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){   #here        representings stripped out inner nest
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			switch(exp){     #heret 
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			fallthru
			
		case 16 to 20:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){ 
			switch(exp){
			switch(exp){
			fallthru
		default:
			print('the end')
}
'''

#working on this July 15th, 2021 10:16am Starbucks
#get_switch_and_endswitch_locations(coolstring)
#output to these lists
#switch_location #skips the first main switch not included
#endswitch_location (if any)
#get_switch_and_endswitch_locations(coolstring)
print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#this accesses coolstring august 5th, 2021
#this is to set the inner switch positions in the main switch input strings
#after the bodies of the nested switches have been stripped out

##########################################
##  put_switch_locations_into_switch_list()  #this is making the nested_switch_ number  
##########################################
def put_switch_locations_into_switch_list(inputstring): #just added param
    print("##2### put_switch_locations_into_switch_list ###")
    print("##2## put switch locations into switch list ###")
    print("put switch locations into switch list")
    #### get swith and endswitch locations called here 
    get_switch_and_endswitch_locations(inputstring) #it's right here 
    for item in switch_location: #this is only going thru switch_location
        switch_list.append(int(item))  #was -1 on here #off by one in the string for some reason
    # print(" ");print("switch_list=")
    #print(switch_list)

#######################################
##  swap_switch_to_nested_method()  #this is making the nested_switch_ number  
#######################################
def swap_switch_to_nested_method(stringname,linenumber,series_num):
	print("============== swap_switch_to_nested_method() ==========")
	#print("input: linenumber", linenumber)
	#print("input: series_num", series_num)
	
	#print("##4## swap switch to nested method - numbered ###")
	#print("##4## swap switch to nested method - numbered ###")
	#print(" THIS IS BEING CALLED TO DO THE MAGICswap switch to nested method called....")
	str_list = stringname.split('\n')
	#print('changing line',linenumber)
	#series_num = number_series[0] 
	str_list[linenumber] = "\t\t\tnested_switch_" + str(series_num) + "(n)"
	stringname = "\n".join(str_list)
	genius[0]=stringname   #strings are immutable but lists are mutable(changeable)

######################################	

#this is the control center main that runs this operation
#this numbers the nested switch methods top down
#genius[0]=coolstring  #assignment here <<<==================


#######################################
##  loop_thru_switch_locations():
#######################################
def loop_thru_switch_locations(regularstring):  #looping thru  switch_list[10,18]
    print("##1##loop thru switch locations ## line number 276 ####")
    print("##1##loop thru switch locations ######")
    #trick put_switch_locations_into_switch_list
    #method called
    put_switch_locations_into_switch_list(regularstring) #method
    print('this filles switch_list of switch line numbers')
    #print(genius[0])
    print("what is the order of the switch_list I think it's reversed to do bottom up")
    print(switch_list)
    print("------------")
    print("switch_list=",switch_list)
    le_number=1 #default numbering nested string 
    for item in switch_list: #loops thru switch_list WITH SWITCH LOCATIONS (LINE NUMBERS)
        print("item in switch_list",item)
        #string,switch,line number
        # swap_switch_to_nested_method here 
        #method this one is the holy grail that actually works
        ###############################
        swap_switch_to_nested_method(genius[0],item,le_number) 
        coolstring =genius[0]
        le_number += 1  #adding to the nested number here
    print("#### end of loop thru switch locations() ####")
    print('the EXIT sign is green')
#######################################



print("STAR TREK TEST FULL PHOTON LASERS add numberednested method McCoy looks good now beam me up ")
print("starting with this input main string with nested switch bodies cut out")
print("tahoe dream")
##==========================================================|
## swap_nested_switches_with_methods_in_main_switch_string
##==========================================================|
def swap_nested_switches_with_methods_in_main_switch_string(inputstring):
    print("===swap_nested_switches_with_methods_in_main_switch_string()== line number 309=") 
    loop_thru_switch_locations(inputstring) 
    print("this is the output string of the transformation from input string")
    ## this is after loop thruw switch locations method is completed
    print("this is the main input switch string after adding nested methods")
    print("the output of this transformation of swapping switch for nested_method")
    #this is the input string transformed 

#this calls it
genius[0]=coffee_now  #assignment here <<<==================
print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
swap_nested_switches_with_methods_in_main_switch_string(coffee_now)
print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
print(genius[0])

#this calls above
print("=== begin tron test ==line 323 =TESTING september 1st here we go=-=== to see if this sucker works === august 27th ==== please work ==")
print("this is testing the main switch string module changing nested switches")
print("that already had their bodies cut out and swaping in a nested method")
genius[0]=coolstring  #assignment here <<<==================
print("about to call swap_nested_switches_with_methods_in_main_switch_string(coolstring)")
swap_nested_switches_with_methods_in_main_switch_string(coolstring)
print("fter testing tron getting closer=== 1 ...2.....3  out the EXIT")
print(genius[0])
print('end of test of swap nesetd switches with methods in main switch string ')
print(" oh that's what this does...da ")
print("====line 332 ==end of this tron test september 1st=====")
print("======end of this tron test september 1st=====")
#exit()  #stop it here
	#string_change =coolstring
#stringname=coolstring
print("now change the inner switches to the nested method numbered")
#swap_switch_to_nested_method(coolstring,10,1)	  #####======

print("after first change ====>>>>>>>")
#coolstring =genius[0]                            #########==========

#series_num = number_series[0] 
#swap_switch_to_nested_method(coolstring,18,2)	  ########=========
print("after the 2nd change ...")
#coolstring =genius[0]
##print(genius[0])                                ################============
print("done with this test of the new method")
  #building the method to make this magic happen automatically


#-------------------  july 10th, 2021   11:03 pm  -------starbucks coding-------
#I am hard coding the location of the switch words. I need to have it search on it's own
# but I recall I have code that does that elsewhere
#now I need to find the code that makes the correct nested switch list locations

#they are being harded coded in here I should be getting them from above

#switch_list.append(11) #was 10,18,31
#switch_list.append(19)
#switch_list.append(32)## added a third switch to test it more thoroughly 

##============================================================================
print("here put switch_locations into switch_list")
## this is new added Thursday july 15th 2021 prevents off by one error
## it takes input of nested switch line number locations from switch_location
## and puts them into switch_list (but again not the first main switch)   

#this one just commented out
#put_switch_locations_into_switch_list()
print("about to test it with the loop thru switch method ====")
print("today is july 22nd, 2021 thursday refining the algorithms and methods")
## calling LOOP THRU SWITCH LOCATIONS (INNER)

######======================
#loop_thru_switch_locations() #where to find the inner switches to replace with a nest method
######======================


print("did it work=============MMMMMMMMMM----======MMMMMMMMM==========")
print("we called loop_thru_switch_locations() which calls swap_switch_to_nested_method()")
print("we should have successfully swapped out the inner switches with nested_method numbered")
print("today is july 15th, 2021 at Starbucks connecting the functions")
print(genius[0])    	
print("olympic gold medal to make it this far.")
print("==IT SHOULD BE ABOVE THIS LINE WITH THE NESTED NUMBERS METHODS INNER SWITCHES==")
print("now I need to work on copying the nested strings to a list")
print("and then taking out the nested strings from the main switch string except for switch")
    
#this one works just need to test it as a method above 
#str_list = coolstring.split('\n')
#print('changing line 11')
#str_list[10] = "\t\t\tnested_switch_1(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)

#print(string_change)
#stringname = string_change
#############
#str_list = coolstring.split('\n')
#str_list[18] = "\t\t\tnested_switch_2(n)"
#coolstring = "\n".join(str_list)
#print(coolstring)


#what if I go thru a list to make teh changes
#=====================================================
#z = 'test4'

#choose to 'Update Now'
# when the newest MacOS Mojave 10.14. 6 Supplemental Update

#say we add it to first case 2nd line after case just bump down whatever
#is on that line. copy that line just for saftey and add it to the tail
#with \n at beginning and end of that line


### look for nested switch called    switch_nest()  
# get case number which case is it, first, second, third for this test
#then get line number of case section determine what line it's on.
#(the nested switch method)

output_string_test='''
 switch(x) #main switch    #<<====== switch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "one":
            print("this is the first case in the main switch")
            #switch_nest() #force feeding it for testing switch case function actually 
            ######################
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word')   
                     
        if case == "two":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
            print("tahoe[0]=",tahoe[0]) #result of innerswitch running
            #what output is there from inner_switch?? use a list to capture it
            fallthru('word') 
            
        if case == "three":
            print("this is the first case in the main switch")
            print("out of from innerswitch1 below")
           
            
'''

######## testing 2nd and 3d level deep nested switch cases july 29th, 2021


# will mess around with this later. 

triple_nested_switchtest ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown iiii')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	



cicelyalaska ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown iiii')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ooo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	



snowman='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown pppppp')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									#################### this one is new 
									switch(exp){  #fourth level deep   Level 4    
										case 'obama':
											print("do something")
											print("good")
											fallthru
										case 'ufos are real':
											print("better")
											break
										default:
											print("nice job")
									endswitch 
							#############
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== interesting test here for just 3 here ==')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
		case 1 thru 3:
			print("where\'s this will be one match for 3, 5!")
			print('first prize')
			switch(exp){  #second level deep          Level 2    
				case 'sierra':
					print("do something")
					print("yep")
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
						default:
							print("welcome to the party") 
						endswitch
					fallthru
				case 'snow lake':
					print("nice")
				default:
					print("welcome to the party") 
			endswitch
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'music':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'sierra':
							print("do something")
							print("yep")
							fallthru
						case 'snow lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'coolish':
									print("do something")
									print("yep")
									fallthru
								case 'auburn':
									print("nice")
									####################
									switch(exp){  #fourth level deep   Level 4    
										case 'coolish':
											print("do something")
											print("yep")
											fallthru
										case 'auburn':
											print("nice")
											#######################
											switch(exp){  #fifth level deep   Level 5    
												case 'coolish':
													print("do something")
													print("yep")
													fallthru
												case 'auburn':
													print("nice")
													break
												default:
													print("we are done here")
											endswitch 
											break
										default:
											print("we are done here")
									endswitch 
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		
		default:
			print('the end')
}
'''	

'''
loop thru string
get switch locations and tabs coount
then make list of numbers of switches inside tab 3 switch
only thing that I cna think of.
make list with sublists
'''

answer=triple_nested_switchtest.count("endswitch")
print('counting the nested switches to see how it goes ====Boo ')
print("the number of nested switches based on endswitch=",answer)
for line in triple_nested_switchtest.splitlines():
    print(line)
print("=== the end ====")
print("================")

#answer we seek is case section 2, line 2
################===============================
#33 june 28th, 2021 9:26 pm now 

#where I detect the nested switch  location and starting and ending point
# I copy the nested switch and delete it from the main switch
# I add a method where thes switch word is.
# My compromises to get it working faster are the nested switch
# must end with endswitch  and not a curly brace
# this makes it easier to get working and aids readability

#the switch main switch is chopped off at the begining of the inner switch
#the bottom after the nested switch ends with endswitch is copied
#to the top half but only after the nested method is added to th eline
#where the nested switch was 



# when code is running there is nothing to see.
# If we have moving behavior (which is invisible)
# that is what matters -but like what Fred Brooks says
# software is invisible. So I need to make it tangible and visable.

#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========



# starting testing here to see if I can reduce the code to make sense

 ####### august 10th 2021 testing commences.
 
find_nested_switch_game ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown mmm')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	

gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

print("what we are starting with the switch with a nested switch")
print(find_nested_switch_game)
print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
print("this gets the line number of the line that the case starts")
print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
    print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
    print("case line numbers",pacman)    
    #print(pacman[2])  
    print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========


#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            print(item)
            print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
            print("we have a match")
            print(line)
            #linecounter += 1 if it's endswitch don't add one
            print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    print("the end of this nested switchis",endnestedswitchline[0])
    print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    print("x=",start_and_finish[1])
    print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function

print("will do red robin string with the sets of pairs individually to verify it's right")
print("testing Sunday, NOvember 7th, just got 3rd booster shot ----")
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')
print('=======copy_a_nested_switch() called=====)=====')

columbia_river=[]
gold_list=[]
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    print("= copy_a_nested_switch() called== just now 10;43 am ====")
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
print("=======begin Sunday Morning Brew Testing=======")

# uses methods:
# add_comment_and_line_number_to_all_switches
# inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
# copy_a_nested_switch(water)
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]] 
gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]       
##=============================================================
##  split_up_big_string_into_nested_switches(myinputstring)
#  dependency requires gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]  
##=============================================================
# I am adding comment with line number to all switches wonderful news.
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print("===boom boom boomsplit up big string into nested switches()===")
    water =add_comment_and_line_number_to_all_switches(myinputstring) #stringname goes here
    print("need to see that the comment and line number added after each switch")
    for line in water.splitlines():
        print(line)
    print("that is how we shall know")
    del columbia_river[:] #empties columbia_river; the inputstring name is now called water 
    #gold_list is prefilled here 
     #before the input string is modified  but after comment numbers added ; this is the original input string which is used for the main later
    print("gold_list=",gold_list)
    columbia_river.append(water) #this adds the mega initial string first for the main string
    print('at this point the length of columbia_river should be 1 and it is',len(columbia_river))
    for item in gold_list: #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) #get input string from goldlist
        copy_a_nested_switch(water)  #copy string based on switch,endswitch pair 
        print("====================")#puts resulting string into makeitwork[0] and output
        output = makeitwork[0]       #put nested string into columbia_river list
        columbia_river.append(output)
    print("length of columbia river =",len(columbia_river))
    counter =1
    #adding here the initial string which will be used to make the main switch
      #it is added just before looping thru i
    print("now loop thru columbia river to see the switch bodies seperated")
    for item in columbia_river:
        print("counter=",counter)
        print(item);print("===========");counter += 1
##================================================================        


     
print("okay from this point forwards I have access to the columbia_river with the strings in it") 
     
     
     
     
     
     
     
     
     
     
     
     
     
     
#######======================================== ## find_nested_switch_game
#the input is the whole string afgter having added comment of swithc line number in loopstring[0]
#x =11; y = 60;
##=======================================
##  testing_code_copying_string_adding_it_to_list()
##========================================
def testing_code_copying_string_adding_it_to_list(x,y):
    inputs_pair_to_copy_a_string(x,y)
    #water is the modified string with line number (but need to only add the line numbers once as comment
    copy_a_nested_switch(water) #this takes in switchstring with switch numbers added as comment
#######=========================================
    output = makeitwork[0]        #this would have to be after the call to copy a nested switch
    columbia_river.append(output)

#testing_code_copying_string_adding_it_to_list(11,60)


print("now printing out columbia river")
print("length of columbia river =",len(columbia_river))
for item in columbia_river:
    print(item)
    
#exit()
 





start  = 7  #hard coded beginning of nested switch
finish = 14  #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################
start_and_finish=[]
start_and_finish.append(0) #position [0] #ignore
start_and_finish.append(start) #position [1]
start_and_finish.append(finish) #position [2]
#so we have
start_and_finish[1] = 7
start_and_finish[2] = 14
#############################
r=gameday
#linecounter=0
makeitwork=[]
makeitwork.append(0)
print('======SECOND ATTEMPT======')
#######========================================
copy_a_nested_switch(r) #this gets put into r as a parameter
#######=========================================



#lines 1 thru 9 
 #this looks for the line number of endswitch for the nested switch
print("testing getting a COPY TOP HAT OF MAIN SWITCH")
print('this also grabs and displays the inner switch first line')
#the inner switch needs to be the last line of this string
##================================================
start = 1 #starting from 11 not 10
finish = 10
#linecounter=0
abovenestedswitch=''
print("this was put into a function on July 15th, 2021 ===")
####################################
## copy_top_hat_of_main_switch(): #this grabs the string of the main switch above 
# the first nested switch in this case there is only on 
####################################
terriblysmart=''
def copy_top_hat_of_main_switch(): #this is grabbing the top of 
    #the switch case just above the first nested switch 
    print("======copy top hat of main switch()====")
    global abovenestedswitch
    linecounter=0 #string name find_nested_switch_game
    for line in find_nested_switch_game.splitlines():
         # between >= 1 and <= 10
        if linecounter >= int(start) and linecounter <= int(finish):
            abovenestedswitch += line + "\n"
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    print(":the result copy above  first nested switch case ")        
    print(abovenestedswitch)
    terriblysmart = abovenestedswitch

#copy_top_hat_of_main_switch()  #not called yet

print("end of copying top half above nested switch ")  
print("it should end with switch which we will edit")

mystringtest='''
	switch() #7
		case 'funny':
			print('fun')
		case "da":
			print('yeah')
		default:
			print('bye')
	endswitch #14
'''					
					

####################
#replace switch

#linecounter= 0
newlist=[]
newlist.append(0)
#newlist[0]
# I just put this into a function to have control over it 
#COPY COATTAILS BOTTOM OF BIG SWITCH AFTER NESTED SWITCH END
################################################################
## copy_coattails_bottom_of_big_switch_after_nested_switch_end():
################################################################
def copy_coattails_bottom_of_big_switch_after_nested_switch_end():
    print("copy_coattails_bottom_of_big_switch_after_nested_switch_end()")
    linecounter=0
    start = 21 #INPUT PARAMS TO GRB need to put these in a list for efficiency
    finish = 32
    outerswitch=''
    for line in find_nested_switch_game.splitlines(): #string looping thru
        #   IF BETWEEN line numbers 21 and 32 
        if linecounter >= int(start) and linecounter <= int(finish):
            outerswitch += line + "\n"
            linecounter += 1
        else:
            linecounter += 1
            continue   
        
    print("testing getting a COPY COATAILS BOTTOM OF BIG SWITCH")
    print(outerswitch)
    newlist[0]=outerswitch
##===================================================





#this is turning code into a function on july 15th, 2021
#######======
#copy_coattails_bottom_of_big_switch_after_nested_switch_end()
#######=======





#here is where i make this temporary list that I will put the
#input strings of the main switch and the one nested switch for testing

inputstringswitches=[]

###################
##    swap(a,b)
###################
def swap(a,b,c): #c = starbucks[1]
    cooler =c.replace(a,b)
    return cooler #starbucks[1] =string with changes made
    
    
  
#this puts the nest_method on the line selected in the tophalf of the string
#################################
## swap_switch_for_nest_method(n)
################################# 
def swap_switch_for_nest_method(n): # I will add more values later perhaps 3 or 4 for coordinates
    global abovenestedswitch
    abovenestedswitch=terriblysmart
    print("called swap_switch_for_nest_method(n)",n)
    abovenestedswitch = abovenestedswitch.replace("switch(exp){","nested_switch_" + str(n) + "(n)")
    print(abovenestedswitch)
    print("===================")

#june 29th, 2021


def scan_input_string_for_number_of_switches():
    print('work on this')#I have this figured out now elsewhere
    
    
#commented this out on august 3rd testing making big method 
   
#this needs to be put into a method and called below actually
def fishfood(): #necessary testing that's all
    print('about to try new swap method')    
    swap_switch_for_nest_method(2) #feeds it the number 2 for testing
    outerswitch=newlist[0]
    outerswitch= makeitwork[0]
    maybe=abovenestedswitch + outerswitch
    print('we have stripped the nested switch from the main switch')
    print("and inserted a method for now")
    print(maybe)
    ######### put first main switch into inputstringswitches
    print("adding main switch and nested switch taken out into list")
    print("the next step will be to run it thru the silve_module")
    print(" to create teh strings output in python")
    inputstringswitches.append(maybe) #should be position 0

    print("and the nested switch is here before it's converted")
    print(makeitwork[0]) #roadrunner
    #roadrunner = roadrunner.replace("endswitch","}")
    ######### put nested switch into inputstringswitches
    inputstringswitches.append(makeitwork[0]) #should be position 1
    print("====== go for the gold =======")
    print("this shows the resulting strings accessed thru the list that")
    print("they were put into so I can access them now for running silve module")
    print("==--------------==")
    print("here is the result now")
    print(inputstringswitches[0])
    print("now the nested switch")
    #print(inputstringswitches[1])
    galaxy=''
    galaxy = inputstringswitches[1]
    print(galaxy)
    print("Now I replace endswitch with }")### replace endswitch with }
    inputstringswitches[1] = galaxy.replace("endswitch","}")
    print("now looking into inputstringswitches[1] endswitch should be gone")
    print(inputstringswitches[1])
    print("==== end of first major step ==in process of transformation ==")

#################===========
#fishfood()
#################===========




#############################
##  get_inner_switch_line()
#############################
def get_inner_switch_line():
    print("can we get serious here I mean really")       
    bronze=0     
    linecounter=0
    secondswitchline=0  
    for line in find_nested_switch_game.splitlines():
        if "switch" in line: 
            print(line) 
            linecounter += 1 
            print("switch line number = ",linecounter)
            secondswitchline = linecounter
            break
        else:
            linecounter += 1  
            continue
    print("line with inner switch =",secondswitchline)
    print("==================")
#the inner nested switch will obviously end within the same case it starts in.

###########==============
#get_inner_switch_line()  
###########===============


                
###########################################################
print("")
print("====")
print("")
print("get line number of each switch")
print("each number after first switch is a nested switch")
print("get the line number of each switch")
switcharoo=[]
switcharoo.append(0)

linecounter=0





#######################################
##  get_number_of_nested_switches():
#######################################
def get_number_of_nested_switches():
    print("get_number_of_nested_switches()")
    linecounter=0
    #this looks for the line number of 2nd switch for now more later  
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "switch(" in line:  #grabs first line
            print(line)
            switcharoo.append(linecounter)
            
            linecounter += 1
            continue  
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
              
            #if "switch_nest()" in line:
            #   print(line)
    print("line number of switches",switcharoo)  
    print(switcharoo[2])                

casecounter=0
case_count=0

##########========================
#get_number_of_nested_switches()
##########========================
###############################################################
################ testing call of these methods at once
###========== august 3rd test Tuesday nice air conditioning ====
def nested_switch_trapeze_tricks():
    print("==== nested_switch_TRAPEZE_tricks() called=====")
    loop_thru_switch_locations()
    get_case_line_numbers(find_nested_switch_game)
    get_larger_number_less_than_case()
    get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
    copy_a_nested_switch(find_nested_switch_game)
    copy_coattails_bottom_of_big_switch_after_nested_switch_end() 
    fishfood()
    get_inner_switch_line() #not sure if I need this one
    switcharoo=[];switcharoo.append(0);linecounter=0
    print("the nubmer of nested switches=")
    get_number_of_nested_switches()  # here it is 

#this calls it right here 
#nested_switch_trapeze_tricks()
#print("end of running nested_switch_trapeze_tricks() Gee what does it do")

####=============================== end of the line here==========



################################
## get line number of cases()
################################
def get_line_number_of_cases():
    print("get_line_number_of_cases()")
    for line in find_nested_switch_game.splitlines():
    #get each case number 
    #check if switch in it
        if "case" in line:  #grabs first line
            case_count += 1
            print("case_count=",case_count)
            print(line)
        
            casecounter += 1
            linecounter += 1
            print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
     
#answer 2nd case section    
#nested switch on line 10        
 #answer line 2 inside of case
 #case section 2 starts on line 8
''' OUTPUT
 get line number of each case section
		case 1 thru 3:
1
		case 4 to 7:
2
			case blable:
3
			case more:
4
		case 8 to 10:
5
case line numbers [0, 2, 8, 11, 14, 23]
Line 8 is case second section
We therefeore know that if switch is on line 10
then switch is on the 2nd line after the case section starts
====
get line number of each switch
each number after first switch is a nested switch
get the line number of each switch
	switch(exp) {  
			switch(exp){
line number of switches [0, 1, 10] <<<=== line 10 nested switch
'''
'''
 print('kangaroo hop hop!')
			switch(exp){
			case blable:
			   print("do something")
			   print("yep")
			case more:
			   print("nice")
			default:
			   print("we are done here")
			}'''  
    
    
    
#Monday june 28th, 2021 thinking
#get switch line number and case it's in and line number inside of case
#and what line the switch ends with }
#which I need to know to copy it. I can set the loop to start
#on a particular line and to concat a string and stop
#after coping a set number of lines. 
#Based on line count between switch and } which I can do first
#if line.startswith("switch") do until line startswith("}")




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






   
#def fantastic(): #we would know case number and therefore line number
#   newcounter=0
#  for line in output_string_test.splitlines():
#       if "case" in line:
 #          line_number.append(newcounter) 
       
       #and
       
       #I think that for the parser thats analyzing the input string
       #but the outoput python is quite different.
       #the nested method will be one line
       #so it's really  just adding the one line string
       #to a set of say 5 lines and moving the existing lines down 1 line
       
   #say second line after case 
   #test if something on that line
   #inner_switch_1('test7')
print("what can I do with lists")
print("the night is still young. competing with harvard and stanford")
red=[]
orange=[]
blue=[]
pink=[]
pink.append("\tempty")
red.append("\tone")
orange.append("\tdam")
blue.append('\ttuna')

super = pink[0]  + '\n'  +red[0] + '\n' + orange[0] + '\n' + blue[0] +'\n'
print(super)
red[0] = "\tnestedswitchmethod" 
pink[0]= "\tfunny"
super = pink[0]  + '\n' + red[0] + '\n' + orange[0] + '\n' + blue[0] +'\n'
print(super)

print("========")
line_1=[]
line_2=[]
line_3=[]
line_4=[]
line_5=[]
line_6=[]
line_7=[]
extra_line_1=[]
extra_line_2=[]
extra_line_1.append(0)
extra_line_2.append(0)
football =[]
football.append(0) #method name 
football[0]="\tinner_switch_1('test4')"

line_1.append(0)
line_2.append(0)
line_3.append(0)  #for example nested switch is line 3
line_4.append(0)
line_5.append(0)
#line_6.append(0)

#line_7.append(0)
 #say it's 4 line case 
line_1[0]="\tprint satement line 1"
line_2[0]="\tprint satement line 2"
########################################
line_3[0]="\tprint satement line 3"
line_4[0]="\tprint satement line 4"
print("================")
#if it's on line 3 we take top off to separate it 
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
# new
print("beginning state")
extra_line_1[0]=line_3[0]
extra_line_2[0]=line_4[0]

print("copying that will be don")
print(extra_line_1[0])
print(extra_line_2[0])

print("====bit flipping==== ")
print("putting nested switch in position 3 which is line 3")
line_3[0]=football[0] #designated line for nested switch 
line_4[0]=extra_line_1[0] #this is a novel approach restarting from 1
line_5[0]=extra_line_2[0]

print("after adding the switch nested method in position 3")
print('we then have this:')
print(line_1[0])
print(line_2[0])
print(line_3[0])
print(line_4[0])
print(line_5[0])
print("=========== now adding teh strings to magic concatting them ")
magic=''
magic = line_1[0] +"\n" +line_2[0] +"\n" + line_3[0] +"\n"+ line_4[0] +"\n" + line_5[0]
print(magic)  
print("=====================")  
print("let teh games begin")    
print("done")
#line_5[0]="line 5"
#line_6[0]="line 6"
#line_7[0]="line 7"
#line_8[0]="line 7"
mylist=[]
mylist= ["starter","one","two","three","four","five"]




def sosmart():
    mylist.insert(0,"starter")
    mylist.insert(1,"one")
    mylist.insert(2,"two")
    mylist.insert(3,"three")
    mylist.insert(4,"four")
    mylist.insert(5,"five")
    
    
def put_nested_switch_into_line(x):
    mylist.insert(x,"nested_switch") #it replaces the whole line
    print(mylist)
    
def reset_list():
    for item in mylist:
        del item
    
    print(mylist)

print("333333333333======333===================")
print("new attempt here  Friday June 25th -0--")
fruits = ['apple', 'banana', 'cherry']
fruits.insert(1, "orange")

print("======= water tower see how well this works=======")
print(mylist)
put_nested_switch_into_line(2)
sosmart() #resets it
put_nested_switch_into_line(1)
sosmart() #resets it
put_nested_switch_into_line(3)
sosmart()
print("===000000000000100000000000======")

# I ahve to split it in half somewhere and we have top above nested switch line
#and then we have the nestline
#and we have the bottom 

#so if we have lists for each line number of case section up to say up to 10 lines for now
#say switch will go on line 3 of 6 lines for an exmaple
#line 1 and line 2 are top
#line 3 is nest_switch_method
#line 4 to n is the bottom




     
case_guts='''
\tprint("aaaaaa in the main switch")
\tprint("bbbbbb below")
\tprint("ccccc#result of innerswitch running
\t#what ddddddd?? use a list to capture it
\tfallthr eeeeeeeu('word'
'''
    
    #method inner switch withnumber (input will likely be from a list later)
add_this="\tinner_switch_1('test4')\n"
nested_method_name=[]
nested_method_name.append(add_this)
crystal=[]
crystal.append(0)# [0]


#get input string of case section
#
# I need to get the line number where the switch is supposed to go
# based on the input C style location of the nested switch
# based on which case it is in (the sequence starts from 1)
# then detect the line number in order within that case where the switch starts
#
#
  
#exmaple, we need to add nested switchmethod to line 2
#so we copy line1

top=[]
middle=[]
bottom=[] 
put_in_here=[]

#### fudge ########    
def fudge():
    #def copy_one_line_inside_case(x)
    astring=''
    soupstring=''
    line_counter =0
    print(case_guts)  
    
    print("===========STAGE 1=========")  
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == 1:  #grabs first line
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print('first line string=',astring)
    #################
    newstring=''
    coolstring=''
    line_counter =0
# copy from the line where we want to insert (line 2) 
# thru to last line in case section
    print("============STAGE 2===========")
    #this copies 2nd string to string n (the rest)
    
    for line in case_guts.splitlines():
        if line_counter >= 2:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
        
    print(newstring) #this copies all of the lines into newstring
    put_in_here.append(newstring)
    #this is the switch method string on top of rest of case body lines
    #copy from targetline insertion line thur last line
    # we then add the nested switch method to the rest of the case 
    ##########################################
    #this will be a new helper method
    
    #def add switchline to rest of case body()
    #this is necessary BEFORE adding first line
    print("=================STAGE 3=================")
    egg=[]
    nested_switch_method_name=[]
    fossil=[]
    #fossil.append(0)
    #fossil[0] = nested_switch_method_name[0] + put_in_here[0]
    coolstring = add_this + newstring#how so I insert to front of a string
    #higher =nested_method_name[0] + put_in_here[0]
    egg.append(coolstring) #egg[0]
    
    #middle.append(coolstring)
    print(coolstring)
    glory=''
    #this adds the first string followed by coolstring
    #########################
    #this adds the line(s) above the insertion line 
    #put first string ontop of rest of lines of 
    #this adds the first line which was skipped to the new switch line
    #with the rest of the case body
    
    
    #def add_top_above_lines_above_switch_line(a,b)
    #a = string with the switch_method name
    #b = rest of the lines
    print("==========STAGE 4==========")
    nested_switch_method_name.append(astring)
    glory = astring + coolstring#[0] #now it's a list
    print("glory shows")
    print(glory)
                #method name in list     #nested method name + rest of lines in case
    egg[0] = nested_switch_method_name[0] + egg[0] #coolstring
    print('from list now') #string add_this
    print(egg[0])
    #bottom.append(glory)
    #print("now printing from the list bottom[0]")
    #print(bottom[0])
#   def add

#then replace first line with new line methodnested name
#    then add paste first line to new beginning of string
print('copy string from line 2 bbs')
fudge()
#now I can insert in line 2

print("========= result of fudge  ============ ")
print("========= Fudge Happy Potter Hogwarts ========")

#convertList = ' '.join(map(str,list1)) 















###################################
## copy one line inside of case (x)
####################################
def copy_one_line_inside_case(x):
    print("copy one line inside case()")
    astring=''
    soupstring=''
    line_counter =0
    #print(case_guts)    
    #this copies just the first line to astring
    for line in case_guts.splitlines():
        if line_counter == x:
            astring += line +'\n'
            line_counter += 1
            break
        else:
            line_counter +=1
            continue
    print(' line',x,' string=',astring)
 ####################   
 #copy just the line entered within the case body
copy_one_line_inside_case(1) 
copy_one_line_inside_case(2)
copy_one_line_inside_case(3)
copy_one_line_inside_case(4)
copy_one_line_inside_case(5)






#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========








################################################
##  get_below_after_method_insertion()
################################################
def get_below_after_method_insertion(y):
    newstring=''
    coolstring=''
    line_counter =0
    #this copies 2nd string to string n (the rest)
    for line in case_guts.splitlines():
        if line_counter >= y:
            newstring += line +'\n'
            line_counter += 1
        else:
            line_counter +=1
            continue
    print('below after method insertion',y)   
    print(newstring) #this copies all of the lines into newstring
    #this is the switchm

#this grabs lines within the case after the input line number to the end
get_below_after_method_insertion(2)
get_below_after_method_insertion(3)
get_below_after_method_insertion(4)
get_below_after_method_insertion(5)
 
egg=[]
#def stage_three(a,newstring):#("====STAGE 3====")
#    print('stage_three called')
#    coolstring = add_this + newstring#how so I insert to front of a string
#    egg.append(coolstring) #egg[0]


#stage_three(add_this,newstring)

### stage four ########
#def stage_four():
#    print('stage-four called') #method name in list     #nested method name + rest of lines in case
#    egg[0] = nested_switch_method_name[0] + egg[0] #coolstring
#    print('from list now') #string add_this
#    print(egg[0])  
    
#stage_four()    
#it's going to be in the code gen phase actually where I add the
#one line (so much easier) to the particular case that it's in
#and on the line number within that case below a particular line
#But I the main switch is generated so it should have a marker
#like nested_switch_1_3('test4')
#case number in series and line number within that case

# 
# 
# x=1
# def paste_inner_switch_method_into_string(x):
#      print("===================")#this goes thru the string and detects a nested switch
#      case_counter =0
#      for line in output_string_test.splitlines():    #and copies it and puts it into 
#         case_counter += 1    #acgtaully it gets the start and stop location line numbers
#         if "case" in line:
#             print("case detected in line")
#             case_counter += 1
#             if case_counter == x:
#                 print("this should be our match")
#                 print("this is case number ",case_counter,"and x=",x)
#                 print("therefore we do the MAGIC SHIT HERE")
#                 fantastic()
#                 break
#         else:
#             continue
# 
# list1=[]
# list1.append(0)
# def test_this():
#  #put it into a list
#     list1[0]="inner_switch_1('test7')"
#     say it's line 
# 
# #possibly have it scan thru the output python generated
# I might need a marker  #comment where to put it based on
# just the case. I can finangle where in a case I add it 
# since it's just a method and after I get it placed
# then I can change where in the case it is since it's
# within the case body so I have latitude and the body case 
# will be isolated so there should be some leeway. 





happydays='''
line =""
varholder=[]
varholder.append('0')
###############################============
	
# ===== inswitch ========
def inswitch(n):
	if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
		n = str(n)
	global case
	case = n.lower() 
#=====================
# for infallthru    
def infallthru(n):
	eval("inswitch('" + n + "')")
global x
x = "one" #it was "one"     
tahoe=[]
tahoe.append(0)
victory=[]
victory.append(0)
#######################
### inner switch_1(n):
#######################
def inner_switch_1(n): #test2 is the test
	print("=======inner_switch called==1==",n)
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break   
###================
inner_switch_1(zoo[1]) #this calls it with zoo[1]
'''
##========================
##  darkness()
##========================
def darkness():
    print("darkness() =========")
    print(happydays)
    touble=''
    print("darkness called=====>>>>>>>>>=====>>>>")
    print("happy days analyze the pattern for the tabs and how many ")
    counter =0
    print("===================")#this goes thru the string and detects a nested switch
    for line in happydays.splitlines():    #and copies it and puts it into 
        counter += 1    #acgtaully it gets the start and stop location line numbers
        if "\t" in line:
            print("tab detected in line")
            trouble =line.count("\t")
            print(line)
            print("tabs=",trouble," ",counter)
            trouble=''
        else:
            continue
            
darkness()
  
  
  
  
  
  
           
print("HERCULES TEST RIPPING OUT TABS FROM FRONT")   
'''
to set adding tabs i realized there are two modes
regular switch and nested switch
and to subtract a tab i need to cancel nuke tabs in a line then add the desired number
to get what i want
'''  
import re
myString = "\t\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
print(myString)
print("now rip out the tabs")
myString = re.sub(r"[\t]*", "", myString) #was * where I have 2
print(myString)   
print("now add a tab")

myString = "\t" + myString
print(myString)    
myString = "\t" + myString #add second tab
print(myString)              
            




#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========






##### this makes the input for zoo[1] lowercase
###############################
## make_input_lower_case() ####
###############################
def make_input_lower_case():
    answer = zoo[1]
    answer = answer.lower()
    zoo[1] = answer    

# what i doing here is putting the dynamic built inners switch python code into a list.
# this is just beautiful and brilliant.

fiddle=[]
fiddle.append(0)
fiddle.append(happydays) #appends the string and puts it into fiddle[1] and exec()
#print(fudge[1])
print("TESTING BLADE RUNNER SERIES =what does an innerswitch by itself need")
print('it is all in one big string about to execute it')
#THIS IS CRITICAL INPUT IN   zoo[1]
zoo[1] = 'test3'# testing (user input lower or upper)
make_input_lower_case() #this converts the input for nested
#see if it works
print(fiddle[1])

exec(fiddle[1]) #this is executing the nested switch method above




sewage = ''
#for item in fiddle[1]:
#    sewage += item
#print("sewage=",sewage)
#print("=====")   
#x =sewage.replace("\t","\t*") #this is so I can see the tabs



#right here 

## add this to it:  
#def inner_switch_3(n): # 
samplecode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
	inswitch(n) #3 
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			infallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print ("switch case behavior works in Python now!")
			print("")
			infallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			infallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested switch ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner switch 1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''

#modified on november 12th 2021 friday to get this sucker working 
##====================================
##  get_switch_number_in_comment()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
#this looks ofr the first switch at 3 tabs need to modify it to 1 tab depth. aha 
def get_switch_number_in_comment_in_output_python_code_string(stringname): #this might be for when
	print("get_switch_number_in_comment_in_output_python_code_string(stringname)")
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number_in_comment_in_output_python_code_string() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	for line in stringname.splitlines():
		print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0 #this looks for inswitch at 1 tab depth length 
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "inswitch" in line and "end" not in line and tablength == 1:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number ",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;



flynow=[]
###============================================================================
##  put_output_python_nested_switch_code_into_def_inner_switch_numbered(string):
##==============================================================================
#try this november 12th struggling here 
#I want to see this
'''
def inner_switch_3(n): 
    print("=======inner_switch called==3==",n)
    casetest1 = ['test5','test6']
    #this is switch inside of inner_switch
    inswitch(n)                           #<<====== inswitch() method is here
    while True:                  #<==== infinite loop used for fall thru method
        if   case  == "test1":
'''

def put_output_python_nested_switch_code_into_def_inner_switch_numbered(stringname):
	print('===== TESTING RED ALERT ======')
	print("put outpout python nested switch code into def inner switch numbered")
	#this calls a method to get this switch number to use to number this nested switch
	thenumber= get_switch_number_in_comment_in_output_python_code_string(stringname) #use other code similar to this
	#print("the number it returned is",thenumber) #thenumber=22 #for testing
	string_to_add= "def inner_switch_" +thenumber.strip() +"_(n):\n"
	concatstring = string_to_add + stringname;
	#print("lets see if it actually worked or not and concatted it correctly")
	##################################
	for line in concatstring.splitlines():
		print(line)
	flynow.append(concatstring) #so the resulting string modified exists.
	#########################

#thenumber=22
#string_to_add= "def inner_switch_" + str(thenumber) + "(n):" 
put_output_python_nested_switch_code_into_def_inner_switch_numbered(samplecode)
#makeitso = string_to_add + samplecode;

def testit():
    print("testit called to see if I put def nested method at top of string")
    print("doing samplecode first in virgin form")
    for line in samplecode.splitlines(): #unchanged original output string
	    print(line)
    print(":")
    print("end of test run....")
    print(":")
    print("and now after putting def nestd switch numbere at top")
    print("did this sucker work....please...")
    #for line in makeitso.splitlines():
	#    print(line)
#testit() 
    
dumbstringcode ='''
	caselist1= ['test1']
	caselist2= ['test2']
	caselist3= ['test3']
	caselist4= ['test4']
	caselist5= ['google', 'fishfood', 'probability']
	caselist6= ['test6']
			
	switch(n)
	while True:
		if case in caselist1: #['test1']
			print("dam did it work?")
			print("yes it's test == one")
			tahoe[0]="victory" #puts victory into tahoe[0]
			print("")
			fallthru('test2')
		elif case in caselist2: #['test2']
			print("this is inside of inners switch test2")
			print (" case behavior works in Python now!")
			print("")
			fallthru('test3')         
		elif case in caselist3: #['test3']    
			print ("go reindeer")
			print("")
			fallthru('test4')
		elif case in caselist4: #['test4']
			print ("testi  first nested  ol...")
			tahoe[0]="sublime" #puts victory into tahoe[0]
			#######################
			#inner_switch_2('test7') #commented out
			#######################
			print("out of inner  1")
			print("")
			break
		elif case in caselist5: #['google', 'fishfood', 'probability'] 
			print("successful test in casetest2")   
			print("solving the last few probs now") 
			print("oh my god it worked")     
			print("========= coolness ====")
			print('wow this is really sweet coding genius')
			break
		elif case in caselist6: #['test6']
			print ("gui design massive coolness test Starbucks")
			break
		#default:
		else:
			print('None')
			break
'''


fridge=[]
fridge.append(0)


print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
#================================================
x =dumbstringcode.replace("switch","inswitch")
dumbstringcode=x
y = dumbstringcode.replace("fallthru","infallthru")
supergood = y
#=================================================
####### this fixes a bug of the inner switch getting an extra in and it's taken out
#######3=======
print("--------000000000000---testing changing switch and fallthru ====")
print("-------=0000000000000  into inswitch and infallthru ------")
print("testing conversion of a python string of a nested switch")
print("to tranform it into inswitch(), infallthru()")
print("this should be the working version of ")
print("have changing switch to inswitch and fallthru into infallthru")
print(supergood)
print("did it finally work or not===========>>>>>")
z = supergood  #this fixes a bug where the nested switch method is wrong
y = supergood.replace("inner_inswitch","inner_switch")
print("and this should fix the bug of accidentally namming inner_switch")
exam = y
print(exam)
print("===== end of good working code ==============")

#for line in dumbstringcode.splitlines(): #switch case in JS
 #   #print("smartcounter =",smartcounter)
 #   
 #   if "\t\t\tswitch" in line:
 #        umbrella += "inswitch(n)\n"
 #   if "fallthru" in line:
 #       umbrella += "infallthru(
 #       
 #              
       #this is the range I want to print



#this is where the swo string is I was looking for.

print("july 3rd test 2021 6:53 pm")
print("testing nested switch string BETA TESTING ====0")
#find_nested_switch_game ='''
#clever('4')
swo ='''
	switch(exp) { #first true test 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brownpppp')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     # inner s w i t c h      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#this one has two nested switches that I will try next. 
swo_next ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown bbv')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # inner s w i t c h     =============  
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #=========================
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 28    ===============   
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch   #38===================================
			fallthru
		
		default:
			print('the end')
}
'''	
# I seem to recall a bug usin

#this is testing sensing a multiline switch with more than one switch
####===============
#testing moved here for safety
# CHECK FOR THE NUMBER OF SWITCHES WITHIN THE INPUT STRING
nested_switch=[]
nested_switch.append(0)
nested_switch[0]= False # by default
################################################################################
#determines if a string input is a nested switch with at least one inner switch
################################################################################

###################
##  jumanji(y)       tests if string input has at least one nested switch
###################  sets nested_switch[0] = True
def jumanji(y):  #instead of this I just do a count for endswitch which is just one line of code. 
	print("--------------------------")
	print(" --- J U M A N J I -------")
	print("--------------------------")
	print("this determines if it's a nested switch with a nested switch or more in it")
	print("testing jumanji() counting switches and endswitches")
	#just some sample ifs to read what's the input look like 
	print("this is looking into the string below")
	#print(swo)
	print("--- end of string that we will analyze ---")
	print("")
	print("get count of lines startingwith switch in the string")
	#this counts switch number in the string
	switchcounter=0
	for line in y.splitlines(): #determine if switch is in line
	#this looks for switch in the line but endswitch can't be in this line
		if "switch" in line and "end" not in line:
			switchcounter += 1  ## SWITCH COUNTER
			#print("switchcounter=",switchcounter)
			print("yea this starts with switch")
			continue
		else:
			continue
	print("total switches =",switchcounter)
	
	##============================
	#this counts endswitch number in the string
	print("get count of lines startingwith endswitch in the string")
	endswitchcounter=0		
	for line in y.splitlines(): #determine if "endswitch" is in line
		if "endswitch" in line: 
			endswitchcounter += 1  #END SWITCH COUNTER
			#print("endswitchcounter=",endswitchcounter)
			print("yea this starts with endswitch")
			continue
		else:
			continue
	print("TOTAL endswitches =",endswitchcounter) #endswitchcounter
	print("end of this checker ===========")
	print(" total switches",switchcounter, "and total endswitches",endswitchcounter)
	
	#this sets the flag in nested_switch[0] if at least one nested switch
	#===============================================
	#if one or more switch and one or more endswitches
	if switchcounter > 1 and endswitchcounter >=1: #actually if endswitchcounter 1 it's True
		nested_switch[0] = True
	else:
		nested_switch[0] = False
	
	print("the result of this test for if this has nested switch(es)") 
	print("this is the list with the critical nested_switch[0] value")
	print("WHAT DOES THIS SAY --  it should be True")   
	print("nested_switch[0] = ",nested_switch[0])
	print("=================")
	print("=================")
	print("this  below this is dog breath that doesn't work")
	print("====== end of this initial switch counter filter that will eventually")
	print("=== trigger bypass205 to do multiple switches ====")
	
	
#end jumanji()  ===================||	
	
jumanji(swo)  #called here to test it
print("just called jumani with swo and if nested switches below will be True")
print(nested_switch[0])
#this should be the output the nested switch copied








#this is still using endswitch they aren't swopped out yet

## July 5th, 2021  testing Monday July 5th line number 1593
# July 18 added a second nested swithch to test on lines 28 to 38
samplestring ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ooooo')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======28       
				case 'autumn':
					print("falling leaves")
					print("sunlight from the sky")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much creativity")
			endswitch  #======== ============38
			fallthru
		
		default:
			print('the end')
}
'''	


samplestringzoo1 ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown rere')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){  # ===== 10 ===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch  #========== 20  ==========notice this for it is key 
			print('taught me how to write code')
			fallthru
			print('hello world')
			switch(exp){  # ===== 24===== 3 tabs, 2nd case , line 2 in this case, 1 in series
				case 'rats':
					print("do autumns")
					print("yep")
					fallthru
				case 'more':
					print("badness")
					break
				default:
					print("we tesla done here")
			endswitch  #========== 34  ==========notice this for it is key 
	
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new ======39       
				case 'autumn':
					print("falling leaves")
					print("a night on the town ")
					fallthru
				case 'winter':
					print("snow time")
					break
				default:
					print("so much cranberries")
			endswitch  #======== ============49
			fallthru
		
		default:
			print('the end')
}
'''	


#######################
#### testing ######
### samplestring with switches taken out ####
#### and nested methods replacing it ########
######## july 22 ###testing #####
##### this represents the accurate main switch with proper indentation
samplestring_main ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown bbbbb')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			nested_switch_1(n)
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			nested_switch_2(n)   #this is new 28       
			fallthru
		
		default:
			print('the end')
}
'''	


#nested_switch_2(n)
#july 21st 2021 get teh number of lines in the string
# count endsswitches to get number of nested switches
# do the main switch last which erases(skips) the nested switches
#here I count the number of lines in the string to get last line 
# the tricky part was figuring out when to grab the main switch but I couuld actually
#do it first it doesn't matterand make a copy of it and modify the copy


#so I would add a third record to the pears dictionary 1, 44
######=== total lines in the string for the main switch =========
#using the whole string I know that the nested switches will be on the first line
thecounter=0
for line in samplestring.splitlines():
    print(line)
    thecounter += 1
    
print("the total lines =",thecounter)
print("================ wile e coyote =======")





tuna ='''
	exp = '4'
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown ----0')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			switch(exp){  #this one has input here         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			exp = 'fish' #and we have input here too. 
			switch(exp){          
				case 'fish':
					print("do something")
					print("yep")
					fallthru
				case 'trout':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			fallthru
		default:
			print('the end')
}
'''




# ibm list is used for holding switch strings 
ibm=[]
ibm.append(0)

use_number=[]
use_number.append(0) #[0]

#def between(x,condition,y):
    
#experimentatl copy the nested switch ignore the rest and only Do one.


#this only copies one nested switch within the main switch
#this i pased on knowing the input 
#these are hard coded here

#just put this here to see if it works correctly
# saturday july 17th, 10:11 am starbucks
print("STARBUCKS CRUCIAL testing saturday morning")
'''
this is first emptyhing the switch and endswitch locations lists
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





print("the one below this line should produce 2 switches and one with 10,20")
#this find the location one one pair of a nested switch and end switch

#this gets the start and end from samplestring
#empty_switch_and_endswitch_list_locations()



#this has the output of filling these lists
#switch_location
#endswitch_location

print("stopping this now to see what it looks like with the switch list and endswitch list")
#return  # to stop the program
''' THIS IS THE OUTPUT OF RUNNING THE FUNCTION ABOVE
===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === 
I need to delete teh first swithc location
switch_location= [10, 28]
endswitch_location= [20, 38]
'''

print("=== shazam level about to try fancy stuff ====")

#loop
#pairlist is actually a list 
pairlist=[];theforce=[]
#this would just add the switch location
alpha='';beta ='';counter =0;jedi='';
#this reads in data from switch_location
#               and from endswitch_location
#======================================================
# fill_pairlist_with_switch_and_endswitch_pairs(yy):
#======================================================
def fill_pairlist_with_switch_and_endswitch_pairs(yy):
    print("====fill pairlist with switch and endswitch pairs()=====")
    print(" godzilla ruled over rodan ")
    get_switch_and_endswitch_locations(yy) #===== using sample stringh 
    print("this is grabbing the switch locations which are dynamically added to a dictionary for pairlist")
    print("the length of switch location =",len(switch_location))
    print("the length of end switch locatoin =",len(endswitch_location))
    print("==============...............============")
    # loop thru list switch_location ==============================
    counter =0;allpha='';beta='';           #so this is one small set switch and endswitch line numbers
    for item in switch_location: #this loops thru the list switch_location          
        alpha = switch_location[counter]
        beta  = endswitch_location[counter] #they should be the same length 
        #here the positions are appended to pairlist dictionary
        pairlist.append([alpha,beta])       #always in sets of 2 #adds alpha and beta as list into pairlist  list
        print("pairlist=",pairlist)
        counter += 1
    print("======================")
    newcounter=0
    print("the length of the pairs =",len(pairlist));print('let me see what is in pairlist')
    print("pairlist=",pairlist)
    for item in pairlist:  #this is the combined pairlist
        print(item)
        sosmart = pairlist[newcounter] #here I access first and second numbers in pairlist
        print(sosmart[0]);print(sosmart[1]) 
        print("====== JEDI TEST ========")#not to be confused with jumanji above 
        #this takes in data from switch_location list and endswitch_location
        # and glues them together into a new pair list into 
        # list called theforce
        #this is constructing filling the data in the dictionary pair values
        jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
        print('jedi=',jedi) #like this [12,16]
        
        #put pairs into list into jedi and append to theforce
        theforce.append(jedi) #the pair is added  to theforce list
        turbo  =theforce[newcounter]
        newcounter += 1
    print("theforce=",theforce)
    print("the length of theforce list =",len(theforce))
    print("did we make it this far... in a galaxy")
    #adding loop here to test this
    print("doing a newest test  christmas tree of the pairs in list theforce")
    acounter=0
    print("====magic brew time=====")
    print("== the filled list with pairs of switch endswitch is called theforce ===")
    for item in theforce:
        print(item)
        print("=======")
        cool =item
        print("cool=",cool)
       
        print("acounter=",acounter)
        x=''
        x = cool.split(",")  # see if this trick works
        print(x[0], x[1]) # see if this trick works
        print("end game")
        acounter += 1
        continue
    print("end of printing each item in theforce")
###=====





thisdict ={}


def cleanse(x):
    x = eval(x)
    return x;
    
#modified this method on august 11th wednesday, 1:11pm
############################################
##     adding data list to dictionary
############################################
def adding_data_list_to_dictionary(dictname,key,newdata_list):
    print("LOOK AT THOS at input params see if they are right first")
    print(dictname)
    print(key)
    print(newdata_list)
    return #temporarily halts this from running
    
    print("called adding data list to dictionary")
    #tryit =eval("" + dictname + "[" + key + "]" + "= " + newdata_list +"")
    #tryit =eval("" + 
    angel =dictname
    thekey= key
    newdata_list
    print(angel)
    print(thekey)
    print(newdata_list)
    print("====>>>====>>>end of games...")
    #print(tryit) #to see what it sees
    
    #thisdict["4"] = "[12,22]" #adding data list as string to dictionary
    
    #eventually I will add 1 to dictionary length
    
    ##########################################
    #dictname + key + [12,22] input format 
    ##########################################
    #dictionary name should be known
    print(thisdict)
    for item in thisdict.values():
        print(item)
    print("testing getting value in dictionary by key")
    x = thisdict["4"]
    
    #x = thisdict.get("4") #this should work also
    print(x) #together
    x = eval(x)#just dreamed this up and it worked
    print("this represents getting the x and y for a nested switch locations")
    print("first number",x[0])#seperate
    print("second number",x[1]) #separate
    
    
        
#OUTPUT
'''
called adding data list to dictionary
{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, '4': '[12,22]'}
Ford
Mustang
1964
[12,22]
testing getting value in dictionary by key
[12,22]
first number 12
second number 22
'''
print("fast wile e coyote test  adding data list to a dictionary")
print("==========")
print("==========")

# october 28th, 2021 thirstday
# I need to go thru combined pair list three + five + seven and feed it into a dictionary

## its really get index pair in struct
#### get_number_in_struct(x)   THIS WORKS!!!!!!!!!!! oct 26th



pair_returned=[]

##======================================
##  get_number_in_struct(x):
##==================================
def get_number_in_struct(x):
    print("get_number_in_struct(x) called")
    print("the input was x",x)
    print("get_number_in_struct(x) called too cool")
    print("get ",x)
    #using eval() to do thisdict.get(x)===###################
    apple_pie=eval('thisdict.get(x)')
    print("=====///get number in struck(x) called---------///")
    print("get number ", str(x), " in struct with x called")
    print("apple-pie=",apple_pie)
    super = apple_pie
    if apple_pie == None:
        print("it is None")
    else:
        print("why not",super[0],super[1])
        print("now splitting it into the two numbers within the pair of switch endswitch")
        print(super[0])
        print(super[1])
        #doing this to have common lists for passing on to other functions later
        pair_returned.append(super[0])
        pair_returned.append(super[1])
        print("pair_returned at this point has",pair_returned)
#=============================================


    
#adding_data_list_to_dictionary(thisdict,'5','[12,22]')
print("washing machine time add this '5','[12,22]')")
print("thisdict",thisdict)
numb = '6'

thisdict[numb] = [23,47] #this worked
print("pretty autumn testing")
goaway=''
goaway = thisdict['6']
print("fishfood =",goaway)
print('dirt simple test')
'''
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now 
  "2": [11,60],
  "3": [15,51],
  "4": [23,46],
  "5": [31,41],
  "6": [62,86],
  "7": [66,77]
 #no comma after last data piece apparently
}
'''

#=======================
#add data to struct
#======================

print("no time for pumpkin carving")
#numb = number and aset = [start,stop]
aset=''
numb=''
# this method works on oct 26th 2021
##==============================================
## add_data_to_struct(thisdict,numb,aset)
##====================================================================
def add_data_to_struct(thisdict,numb,aset):
    return #abandoning this too confusing going with just a list of lists
    print("add data to struct")
    print("numb=",numb)
    print("aset=",aset)
    #numb='12' #the number will keep a rolling total and added automaticaly
    thisdict[numb] = aset  #this just seems too simple.
    print(thisdict) 
    
#add_data_to_struct(thisdict,numb,aset)
##============================

gooddata=[]
##==========================================
## get value in dict (name ofdict,x)
##==========================================
def get_value_in_dict(name_of_dict,x): # we will know the dict it won't change
    return #abandonning this for being too confusing and unworkable at this time
    print("plumtree=",plumtree)
    print(thisdict)
    print("get value in dict",x)
    nn = plumtree.get(str(x))
    print("================")
    print("using key",x,"it retrieved from the plumtree dictionary",nn)
    print("================")
    # I was assuming (wrongly) that all keys input would be in dictionary; unknown
    if x in thisdict: #it can't be this simple
        y=eval("plumtree[x]")
        print(y)
        del gooddata[:] #clears it out 
        print(y[0],y[1])
        gooddata.append(y[0])  #this returns with the index[0][1]
        gooddata.append(y[1])
    else:
        print('x',x,'is not in dictionary plumtree')
    
#this builds a new record
#numb='2'
#aset =[11,47]
#thisdict[numb] = data1
#print('input of 2 for [11,47]')
print("==tuesday testing ==add data to dictionary and then access it")
#add_data_to_struct(thisdict,numb,aset)
'''
if '2' in thisdict:
    print('yes 2 is in thisdict')
else:
    print("nope no 2 in thisdict")
#get_value_in_dict(thisdict,'1')
'''
##==========================

print('testing right here === bingo time === adding data to a struct')
#aset =[10,30]
#numb='2'
print('before adding the numbers pairs')
#add_data_to_struct(thisdict,numb,aset)
###=================================


#print(thisdict)
print("should have 2 and 11,47 added to it above")
print("==== boo ==========")
print("cool little test here getting data from dictionary struct")

# GET NUMBER IN STRUCT
#get_number_in_struct('2') #should be [11,47] #it really gets the pair data
#what exactly does this return
#print("output is this ========> ",pair_returned[0],pair_returned[1])
#print("should be  11 and 47")
##===========================
print("cafe borrone coding time")
#aset=[21,37]
#numb='12'
#dictname=thisdict
#add_data_to_struct(dictname,numb,aset) ###====================
#apple_pie=thisdict.get('12')
#apple_pie = aset
#print("should be 21, 37",apple_pie)
#aa = apple_pie[0]
#bb = apple_pie[1]

#print(aa)
#print(bb)
print("====")
print("get thisdict 9")
print("========= happy coding time ====")
#get_number_in_struct('9')
#get_number_in_struct('12') 
#print('should return [21,37]')
print("====== mocha ice drink ====")
#this retrieves the data based on 9
print('porsche time...........')



#apple_pie=thisdict.get('12')
#print("apple pie =",apple_pie)
print("where are we now")


print("stanford football test...")

#print(thisdict)
#print("======values======")
#for x in thisdict.values():
#    print(x)
#print("==========")
#print("=======items=====")
#for y in thisdict.items():
#    print(y)

#x='2' 
#get_number_in_struct(x)
#x='6' 
#get_number_in_struct(x) 
#x='9' 
#get_number_in_struct(x)
#x='12' 
#get_number_in_struct(x)       
#print("======= gameover ======")
#I will need to loop thru the dictionary blueberries
# so now I am on my way of loading the dictionary which will
#just happen once after the pairs are created.

#print(apple_pie) #should be [22,44]
#print("=====")


#x='9' 
#get_number_in_struct(x)   
#print("should return [22,44]")
#thisdict["GTI"] = [75,85]
#print(thisdict) #should include Cherry=[23,47]
#apple_pie=''
#print("below this it should be 23,47")

#x='6' 
#get_number_in_struct(x)   #should return [23,47]
#print(apple_pie[0])# = 23
#print(apple_pie[1]) # = 47
#apple_pie=thisdict.get('GTI') #should return [23,47]
#print(apple_pie)


#creating a dictionary with initial values (brilliant)
#this is new for oct 7 thursday, 2021 morgan hill starbucks
#data =dict() #create empty dictionary
#data =dict(a=1,b=2,c=3)   #short and sweet fill with initial values
#print(data)

#change a value in a dictionary
#thisdict["year"] = 2018

#if "model" in thisdict:
#    print("yes model is one of the keys in thisdict")
#    
#    #add item to dictionary
#    thisdict["color"] = "red"
#    
#update command
#thisdict.update({"color":"red"})


'''
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now 
  "2": [11,60],
  "3": [15,51],
  "4": [23,46],
  "5": [31,41],
  "6": [62,86],
  "7": [66,77]
 #no comma after last data piece apparently
}
'''
plumtree={} #new dictionary
####=======================================================
#feed list of pairs into dictionary (such as blueberries)
print("testing looping thru list")
#this represents a list of sublists of the switch,endswitch pairs
#I need to make testlist
testlist=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]

returnlist=[]
returnlist.append(0)
#I can make my own custom methods to get from list
#the list is actually referenced starting from 1 where I start the counter
##==============================================
##  get_pair_from_testlist(x):
##==============================================
def get_pair_from_testlist(x):
    print("=========get_pair_from_testlist=========")
    print("testing get_pair_from_testlist",x)
    counter = 1
    print("inside the loop we see for x this ",x)
    for item in testlist: #it doesn't really loop, it's a one pass loop
        #if number entered bigger then length of list warn then break    
        if x > len(testlist): #error detection bypass worked 
            print("ERROR went beyond number length in list")
            print("please enter a number less than ",len(testlist))
            break
        #if number entered less than 1 warn then break
        if x < 1: 
            print("ERROR number must be 1 or higher")
            break
        if counter == x: #it matched with a doable number
            print(item)
            alpha = item[0]
            beta  = item[1]
            print(alpha,beta)
            returnlist[0] = [alpha,beta]
            print("returnlist[0] =",returnlist[0])
            break
        else:
            break
##==============================================================

            
get_pair_from_testlist(1)
get_pair_from_testlist(1)
print("the pair is ",returnlist[0][0],"really cool",returnlist[0][1])
get_pair_from_testlist(-1)
get_pair_from_testlist(0)
get_pair_from_testlist(2)
get_pair_from_testlist(3)
get_pair_from_testlist(4)
get_pair_from_testlist(5)
get_pair_from_testlist(6)
get_pair_from_testlist(7)
get_pair_from_testlist(22)

#Okay. I need to fill the testlist from the threetabs, five tabs seven tabs nine tabs



#the list with the pairs is in testlist

#this dictionary is being abandoned for over complexity and confusion
# november 3ed 10:03 am morgan hill

#this reprents looping thru the testlist and filling data into the dictionary and populating it
##====================================================
##  fill_the_struct_dictionary_with_the_list()
##====================================================
def fill_the_struct_dictionary_with_the_list():
    return
    print('fill the struct dictionary with the list')
    counter=1
    # loop
    for item in testlist:
        print(item)
        aset=[item[0],item[1]]#this creats teh apirs 
        numb=str(counter) #making it a string here . clever
        thisdict=plumtree
        #add_data_to_struct()
        add_data_to_struct(thisdict,numb,aset) ###==============
        print("=======")
        counter += 1

        print("plumtree DICTIONARY now looks like this")    
        print(plumtree)
        print("here we go time to see it work===looping thru plumtree struct=====")
        for x in plumtree.values():
            print(x)
    
        print("===========")    
        for k, v in plumtree.items():
            print(k, v)
#what I am working on his dynmcially loading the 
#from the list to filling the blueberries dictionary
#this returns the index[0][1]
#THIS IS THE METHOD TO FILL A STRUCT RECORD HOLDER FROM A LIST 
#print("I need to empty plumtree dictionary first")
#plumtree.clear()
#print("just emptied plumtree dictionary")
#fill_the_struct_dictionary_with_the_list()




### MORE TESTING HERE ACCESSING THE DICTIOANRY PLUMTREE TO GET THE PAIRS DATA

#print("testing if this will actually work or it's an illusion")
#get_value_in_dict(plumtree,'1')


#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])
#print("====... did it work terrible =")



#get_value_in_dict(plumtree,'2')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'3')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'4')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'5')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'6')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])

#get_value_in_dict(plumtree,'7')
#print("gooddata[0]=",gooddata[0],"gooddata[1] =",gooddata[1])


#print('testing getting pair based on number in plumtree')
#apple_pie=plumtree.get('2') #notice it's not a string
#print("it is for '2' this",apple_pie)

#apple_pie=plumtree.get('1') #notice it's not a string
#print("it is for '1' this",apple_pie)

#apple_pie=plumtree.get('2') #notice it's not a string
#print("it is for '2' this",apple_pie)

#apple_pie=plumtree.get('3') #notice it's not a string
#print("it is for '3' this",apple_pie)

#apple_pie=plumtree.get('4') #notice it's not a string
#print("it is for '4' this",apple_pie)

#apple_pie=plumtree.get('5') #notice it's not a string
#print("it is for '5' this",apple_pie)


def testing_pair_list():
    return #not testing this right now
    print("length of theforce=",len(theforce))
    print("together_pair=",together_pair)
    print("======testing pair list() == fireworks time in tahoe ====")
    print("theforce[0]=",together_pair[0]) #first pair coordinates start stop
    print("theforce[1]=",together_pair[1]) # second pair coordinates start stop
    print("===starting loop thru list theforce =======")
    newcounter=0
    print("dog breath test")
    for item in together_pair:
        print(item)
        #this only works for two numbers 2 number long currently
        dog = together_pair[newcounter] #here I access first and second numbers in pairlist
        x = dog.split(",")  # see if this trick works
        print(x[0])
        print("doing surgery cutting off first character")
        charlie=''
        charlie = x[0]
        super=x[1]
        print("super=",super)
        print("=====")
        charlie = charlie[1:]
        print("charlie =",charlie)
       
        super =super[:-1]
        print("super=",super)
        print("===...=.=.=.=.=.=.=.=.=.=.")
        print("===...=.=.=.=.=.=.=.=.=.=.")
        charlie=''
        charlie = x[0]
        charlie = charlie[4:]
        print("charlie =",charlie)
        #print(x[1])
        print("==========")
        newcounter += 1 #python doesn't have ++
        
    print("=== end of looping thru list =======")
    
    
print("MAJOR TEST august 7th, 2021 morgan hill starbucks mocha time")    
print("testing this dam code again...")    

#=======================================================
## this makes the pair list for locations of nested switches august 7th, 2021 
print("DOING TEST of PAIRS of switch and endswitch necessary to do copy and skip comamnds")
print("===================== big test today wednesday =========")
print("what this entails is the mechanics of switch and endswitch locations")
print("which need to be dead on to work correctly for separating the nested strings")
print(" ---- THIS MUST WORK DEAD ON --- for the show of separating teh strings")
print("  --- so this creates the information needed to correctly separate the strings")
print(" === puff the magic dragon time here august 11th ===")
fill_pairlist_with_switch_and_endswitch_pairs(samplestring)
testing_pair_list() #this shows the outpout of grabbing the switch
# and endswitch pairs (sets)



#this way I can use the pair list to copy the nested switches
#========================================================

#print("oh wow does this actually PEAR TREE SHAKE  work pairlist below")
#print("number of pairs =",len(pairlist)) #this is beautiful!!!

#print("oh wow look at this pairlist I made=== starbucks mocha===...")
#print("the length of pairlist =", len(pairlist))
#print('after first attempt')
#sosmart =pairlist[0] #first position
#print("wow will this work >> that would be so cool")
#print(sosmart[0])
#print(sosmart[1])




#print("====== JEDI TEST ========")
#this is constructing filling the data in the dictionary pair values
#jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
#this is building a pair [4, 8]   #an example 

#print("celebration time it almost works completely fireworks")
#print('jedi=',jedi)
#theforce.append(jedi)


#print("I simply add the jedi string which is a list (brilliant)
#print("to theforce list sooo nice")
#make a method here 

#fill jedi with one set 
#print("=======NEXt JEDI TEST ======")
#sosmart =pairlist[1] #second position meaning second nested switch 


#print("wow will this work >> that would be so cool")
#print(sosmart[0])
#print(sosmart[1])
#x = 10
#y = 20
#jedi = "[" + str(sosmart[0]) + "," + str(sosmart[1]) + "]" 
#print("celebration time it almost works completely fireworks")
#print('jedi=',jedi)

# feed jedi set of 2 numbers into the forcelist with an append
#was theforce
#theforce.append(jedi)

#print("theforce=",theforce)
#print("the length of theforce list =",len(theforce))

########################
#print("the =========== force here ========force shows",theforce)
#print("theforce[0]=",theforce[0]) #set one of pair of a switch start and endswitch
#print("theforce[1]=",theforce[1]) # set second pair of a switch and endswitch locations

# so this is building the pears lists of switch endswitch so then I would add the pearslist
#to a dictionary now I think. 

############













#this would just add the switch location


#I can createa  new list to make the pairs first
#go thru grabbing the first number first
#then on the second loop add the second the endswitch

#fill the pears dictionary now
#exit()


#print("switch_location=",switch_location)
#print("endswitch_location=",endswitch_location)

#what is the output???
print("snow man here ")
print("I need to have it flow into the range below lists")
#these are hard coded in here 
print("the output from get swtich and endswitchlocatin for samplestring")
print("right below this line")
print(" RODAN FLYING......")

#for some strange reason the get swithc and endswitch locations are off by 1

#switch_location[0] -=  1
#endswitch_location[0] -=  1
#print("what type is it switch_location[0]",type(switch_location[0]))
#test =switch_location[0] 
#test=test-1
#switch_location[0] = test
#print("switch_location now",switch_location)

#test =endswitch_location[0] 
#test=test-1
#endswitch_location[0] = test
#print("endswitch_location now",endswitch_location)

##============================================================
#these are in switch_location and in endswitch_location


######################################################
list_of_switch_range=[]
list_of_switch_range.append(0)
list_of_switch_range.append(0) #was 10 hard coded 
list_of_switch_range.append(0) #was 20 hard coded

#list_of_switch_range[1] = switch_location
#list_of_switch_range[2] = endswitch_location
##############################################################
## july 17th, 2021 11:12 am
print("IS THIS WORKING OR NOT ==========")
#here we feed the input switch and endswitch into range lists
#THIS WORKS FOR JUST ONE INNER NESTED SWITCH 

anest_string='''
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''
print("wild wild west test...")

###########################################============
#experimenting on nov 4th thursday 
get_first_switch_test='''
			switch(exp){ #21         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
'''

get_first_switch_da='''
			switch(exp){ #  54         
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					switch(exp) # 98
					break
				default:
					print("we are done here")
			endswitch 
'''

# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)
got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname):
##====================================================
def get_switch_number_at_top_of_string(stringname):
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		print(line)
		print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;


# here I would add the strings in quail after they have been separated
# and they are in the list mytestlist. I then apply a method to each
# string to get teh switch number at the top and append it 
# to the list got_the_number
 # I will need to loop thru the quail list of the seperated switch strings
 # and append the strings within to mytestlist
 #so actually I would loop thru quail list and call get switch number

mytestlist=[]
mytestlist.append(get_first_switch_test)
mytestlist.append(get_first_switch_da)
del got_the_number[:] #clear out this list at the beginning

#loop thru list with thes trings
#feed the strings into method get switch number at top first switch
##=====================================================
## get_first_switch_number_from_all_strings()  fly jets
##=====================================================
def get_first_switch_number_from_all_strings():
    print("get_first_switch_number_from_all_strings()")
    for item in mytestlist: #this will be quail list before parser
        get_switch_number_at_top_of_string(item)


get_first_switch_number_from_all_strings()
print("really got_the_number=",got_the_number)
# this will be my so-called twin list
# that I will use 
# for the python outoput strings in the stanford list
# to use to make the nested_method names for the defs


#exit();

#
'''
 this transfers the line location of switch and endswitch
 to list of switch range 1 and 2 from 
 switch_location and endswitch_location
'''
#28,38 for second string
# I am skipping using this now NOT using this method 
##################################################
##  get_one_nested_switch_start_and_finish()
##################################################
def get_one_nested_switch_start_and_finish():  # this gets the input from switch_location[0]
    print("get_one_nested_switch_start_and_finish()")
# and from  endswitch_location[0]

## this takes in the two lists of list_of_switch_range[1] and list_of_switch_range[2]
    print("=== ||=== get one nested switch start and finish line numbers")
    #force feeding it the second nested switch location input data 
    #these are hard coded for testing 
    #switch_location[0]    = 28  #july 18th testing 2nd nested switch
    #endswitch_location[0] = 38  #july 18th testing 2nd nested switch 
    list_of_switch_range[1] =switch_location[0] #force it in here
    list_of_switch_range[2] =endswitch_location[0]
    #list_of_switch_range[0]=0
    #list_of_switch_range[1]=10
    print(list_of_switch_range[1])
    print(list_of_switch_range[2])
    #list_of_switch_range[2]=20


the_nest_string= fridge[0] 



print("real string test from columbia river")

counter1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown  8888')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
			exp = 3
			switch(exp){ #49
				case 'burger':
					print("do something")
					####################
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''


#===========
counter2='''
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
'''
#===========
counter3='''
			switch(exp){ #49
				case 'burger':
					print("do something")
					####################
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''

#===========
counter4='''
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
'''

#===========
counter5='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
'''
#===========
counter6='''
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
'''

testing_string_list=[]
testing_string_list.append(counter1)
testing_string_list.append(counter2)
testing_string_list.append(counter3)
testing_string_list.append(counter4)
testing_string_list.append(counter5)
testing_string_list.append(counter6)
#this is what has the string_with_nested_switches in it
# THIS TAKES TABS OUT OF THE ENTIRE NESTED SWITCH 

###===================================================
#abvoe this line are the test input strings for switches






teststringgonow='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''
funky='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch 
'''

###=================================================================
passthis=[]
passthis.append(0)
##
#this gets the tabdepth in front of top switch word
##==================================================
##  starter_engine(the_nest_string):   nov 30th tested working accurately
##==================================================
def starter_engine(the_nest_string):
	print("======starter engine called======")
	tabdepth='';n=''
	for line in the_nest_string.splitlines(): #nest_string
		if "switch" in line and "end" not in line: #had "not"
			tabdepth = line.count("\t")
			n= tabdepth;n = n-1  #need to have one tab in front
			break
	passthis[0]= n;
	print("n =",n)











goldtime=[]
goldtime.append(0)
##===================================================================
##  modern_tab_shifter_to_left(the_nest_string):  nov 30th tested working
##  methods: starter_engine()
###==================================================================
def modern_tab_shifter_to_left(the_nest_string):
    print("====modern tab shifter to left=======")
    starter_engine(the_nest_string)  #method call to get tabdepth on first switch line
    buildstring='';n = passthis[0] #filled from starter_engine method number of tabs in front of switch
    ### n is number of tabs in front of switch BEFORE CHANGING IT
    if n == 0: #means one(1) tab in front of switch do nothing
        buildstring =the_nest_string #no changes to indentation
    if n > 1: #more than one tab in front of switch so cut some tabs out
        for line in the_nest_string.splitlines():
            buildstring += line[n:] +'\n' #this cuts out n tabs from the front of this line
    goldtime[0] = buildstring
    print("output of concatted string in goldtime[0]")
    print("I wanna see it")
    for line in buildstring.splitlines():
        print(line)
  




print("testing indenting all 7 strings using modern tab shifter to left()")
for item in testing_string_list:
    modern_tab_shifter_to_left(item)
    print("==== line =====")
print("let them play in the snow")    
#exit()
print("================================")
print("================================")
print("============go baby work ====================")
print("================================")
catching_first_change=[]
print("testing going thru loop and calling one method to start ")
print("TEST MODE NOW...")
for item in testing_string_list:
    print(item)

#=================================== friday nov 19th =============================
# this is where I am applying a method to each item in input switch strings list
###===============================================================================
## THIS IS GOING THRU LIST AND CALLING METHOD modern_tab_shift_to_left(item) to each string
## and then putting modified switch string into list catching_first_change
counter=1  #FILLING CHATCHING_FIRST_CHANGE LIST FROM TESTING_STRING_LIST
for item in testing_string_list: #just filled this above
    #print(item)
    #method shift string to left
    modern_tab_shifter_to_left(item) #now put it into a new list
    #result put into goldtime[0])
    #add modified string to list catching_first_change
    #result of method effects on string goes into goldtime[0]
    #which is then appended to new list
    catching_first_change.append(goldtime[0])
    print("counter =",counter)
    print("=========================")
    
print("the exit sign is GREEN ....")  
print("the output change in list now..")
#print here we empty the original list and then refill it with inbetween list
del testing_string_list[:]   
print("this is filling the list testing_string_list from list catching_first_change")
for item in catching_first_change:
    print(item)
    testing_string_list.append(item)
print("================================")
print("=======strings modified in origional list testing_string_list ============")
##== here we see what's in the list

print("now blue orion looking thru original strings in list after being modified")
for item in testing_string_list:
    print(item)
 
  
#exit()










##########################################
##  take_out_x_tabs_from_front_of_line(n):
##########################################
def take_out_x_tabs_from_front_of_line(the_nest_string):
	starter_engine(the_nest_string);n=passthis[0]
	print("take out ",n," tabs from front of line - of string")
	print("take_out_x_tabs_from_front_of_line(n)") #make this is into a method 
	print("n=",n)
	#get tab count in line with switch and counter =1
	#should be governed by the first line with switch 
	
				
	wildness=''
	print('half way down n =',n)
	for line in the_nest_string.splitlines(): #nest_string
		
		newline = line[1:]
		print(newline)
		
		if n == 4:
			wildness += line.replace("\t\t\t\t","\t") 
		if n == 3:
			wildness += line.replace("\t\t\t","\t") #strips one right
		if n == 2: #this leaves 1 tab in front of each line
			wildness += line.replace("\t\t","\t") #strips one right
		if n == 1: # we only one one tab in front of the switch word as the guidepost
			pass #do nothingwildness += line.replace("\t\t","\t") #strips one right
		wildness += "\n"
	print("after minor surgery see if this works")
	print(wildness)
	fridge[0] = wildness
	return wildness # this worked

#3 take out 2
the_string='''
				switch(exp){ #  54
					case 'blable':
						print("do something")
						print("yep")
						fallthru
					case 'more':
						print("nice")
						switch(exp) # 98
						break
					default:
						print("we are done here")
				endswitch 
'''

#2 take out 1
the_second_string='''
		switch(exp){ #  54
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				print("nice")
				switch(exp) # 98
				break
			default:
				print("we are done here")
		endswitch 
'''


toocool=the_string.replace("\t","",1)
for line in toocool.splitlines():
    print(line)
trythis=toocool    
print("after first reduction")    
gonow=trythis.replace("\t","",1)
for line in gonow.splitlines():
    print(line)
    
print("did it twice")    
        
print("go away")
take_out_x_tabs_from_front_of_line(the_string)
print("road block here")
take_out_x_tabs_from_front_of_line(the_second_string)
print("hiking up Loma Road")
#exit()

#store in a dictionary each pair of switch and end switch params
# then I loop thru it with the numbers

####============ july 19th 2021  Monday ===================
# I already have the code to build a list of all switches and endswitches
# but I need to put them into a dictionary when I do that search to capture them as pairs

##================================

'''
swtich endswitch location
for trackcing hwer eto grab each nested switch
list with nestd swithc method name with number loop thru it
alist=[]
so = "10,20"
alist.append(so)
thisdict={
"brand":"Ford",
"2":alist[0],
"year":1964
}
#grab content by number
x = thisdict.get("2")
print(x)
# macro between
# put n thru m in a list
# then just this
# if x in list_of_numbers
'''

print("testing dictionary to hold switch endswitch pairs (pear tree)")
print(" ==== testing using a dictionary now ==== mayflower ship===")
alist=[]
alist.append(0)
alist.append(10)
alist.append(20)
alist.append(30)
alist.append(40)

color_table={
    "brand":"mocha",
    "Red": [10,20],
    "3": [30,40]
}

coffee = color_table["Red"][0]
print(coffee)
coffee = color_table["Red"][1]
print(coffee)
#grab content by number
#coffee = thisdict.get("2")
#print(coffee) #it should print 10,20
#print("now another one")
#coffee = thisdict.get("3")
#print(coffee) #it should print 10,20


friend1=[]
friend2=[]

thisdict =	{
  "1": [4,7],
  "2": [10,20],
  "3": [21,30]
}
for x in thisdict.values():
  print(x)
  cool = x
  print(cool[0])
  print(cool[1])
  friend1.append(cool[0])
  friend1.append(cool[1])
  print("good times")
  print(friend1)
  





### successful test for between macro ################### july 19th, 2021 ########## 

print("testing between macro and how it will work")
mylist=[]

mylist.append(3)
mylist.append(4)
mylist.append(5)
mylist.append(6)

testlist =[]
testlist=[1,2,3,4,5,6,7,8,9,10]
#####################
##  between test()
#####################
def between_test(): #between macro 
#it would have to be like this
#if a between(x,y)
    print("BETWEEN TEST HERE ----")
    print("bla bla bla")
    print("between test")
    #x = 7
    print("the final outcome..")
    # if x >= switchline and x <= end switchline  #meaning  from start number thru endnumber
    #if x is between switchnumber and endswitch number
    #the list would contain the start number thru the stop mumber 
    # if x is between startnumber and endnumber:
    counter=0 #the logic is to be between x and y it's inclusive of x and y also
    for item in testlist: #so we look for a narrow range within the large input range
        if item in mylist:
            print("yes",item)
            counter += 1
            
        else:
            print("nope",item)
            counter += 1

print("=====do test of between macro proof of concept=====")
between_test() #this tests if we have a list of numbers 1 to 6

print("testing this with between")
zoo = 4
#if zoo between 1 and 6:
alist=[]
alist=[1,2,3,4,5,6]
print("======= BEtWEEN TESt ========")
print("testing the replacement for using betwen")
print("if zoo(4) is between 1 and 6")
if zoo  in alist:
    print("yes it's between 1 and 6",zoo)
else:
    print("nope",zoo)


###=========================
##   between() macro
##==========================
def between(x,y,z):
    print("between called for if x in list between y and z")
    if x in alist: #1 thru 6
        print("True yes ",x, "between ", y, " and ",z)
    else:
        print("False,",x," is not between ",y," and ",z)



print("doing between macro tests....")
between(4,1,6)
between(10,1,6)
between(0,10,25)


#also next add
##==================
##  after macro
##  before macro
##================

############## testing using  a dictinary to store
############## pears of switch and endswitch pairs

#this will be generated. but I think that
# I might have the dictionary pears already existing.

###====================== dictionary storage area =================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================
###====================== dictionary storage area ================================

#dictionary called pears
peartree = {}  


#given name peartree of dictionary
def get_value_of_key_original(x): #peartree hardcoded in
    car=eval("peartree.get('" + str(x) +"')")
    print(car)
    return car #so if it is a list it should return a list right?z

#given name peartree of dictionary
def get_value_of_key(dict,x):
    car=eval("" + dict +".get('" + str(x) +"')") #maybe
    print(car)
    return car #so if it is a list it should return a list right?z


########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists
####################################################################||
### PRACTICING ADDING DATA TO A DICTIONARY CALLED PEARTREE  
#####################
## do this baby 

#what I need to do is add to a dictionary dynamically 
#####################
def do_this_baby():
    print("do this baby caled")
    print("===do this baby() adding data to peartree dictionary called ......====")
    print("practicing ADDING data to see if it works (this will be done dynamically later")
    peartree['1'] = [10,20]
    peartree['2'] = [28,38]  #uses small anonymous list for data
    print(peartree)
    x = peartree.get("1")
    print("x=",x)
    
    
def add_data_to_peartree(x,z):
    answer =''
    answer = "peartree['" + str(x) +"'] = z " #[10,20]
    print("just before exec add data to peartree")
    print(answer)
    exec(answer)
    
fool_on_hill= '[10,20]'
print("TESTING adding data to a dictionary")
add_data_to_peartree(1,fool_on_hill)
print("peartree has in its contents=")
print(peartree) 







#testing adding data record to dictionary dynamically.
#Declare a dictionary (empty) 
print("dynamiclaly add data to dictionary = DRIVE THRU ")
print("testing dynanmically adding data to a dictionary Drive Thru")
data = {'a': 1, 'b': 2, 'c': 3}
print(data)
data.update({'d':3,'e':4})  # Updates 'c' and adds 'd'
print("====after adding d and e dictioanry data======")
print(data)

fun={} #dictionary called fun
print("first the fun dictionary is empty")
print(fun)
#input values to dynamically add data for teh switch endswitch to dictionary

print("adding data to drivethru dictionary ")
print(" RED WHITE AND BLUE ")
drivethru={}
#drivethru.update('1': '[10,20]')
#drivethru.update('2': '[30,40]')
#3drivethru.update('3': '[50,60]')
#drivethru.update('4': '[70,80]')
#print(drivethru)

#zerohour=get_value_of_key(3)
#print("zerohour=",zerohour)

cherish=[10,20]
skyblue =[28,38]

def get_dictionary_size(x): #length
    shit= len(x)
    print("size of this dictionary",x," is",shit)
    print("so the result is ",shit)
    return shit;
    


print("This is doing an update here --->")
fun.update({'1':cherish,'2':skyblue})
print("hard coded here printing out the dictionary fun")
print(fun)
print("========")
num1='3'
num2='4'
silver =[42,46]
gold =[50,52]

#put these into a list also
crystal=[]
crystal.append(0)
crystal.append(num1)
crystal.append(num2)

dust=[]
dust.append(0)
dust.append(silver)
dust.append(gold)



#=
##==============================
def dynamically_add_data_to_dictionary(a,x,y):
    print("testing... dynmically add data to dictionary a, x, y")
    print("Tesitng using lists now which are changeable on the fly")
    a.update({crystal[1]:dust[1],crystal[2]:dust[2]}) #totally dynamic attempt here
    print(a)
print('did this work adding to dictionary')
##################################################################
print("here dynamic attempt --boo scoopy doo van does this work----->>")
dynamically_add_data_to_dictionary(fun,gold,silver)
print("3  =[42,46]")
print("4  =[50,52]")

print('after updating fun dictionary dynamically  strawberry fields===')
print(fun)
print(fun.get("1"))
rat=fun.get("1")
print("below should be 10 and 20 for the result")
print(rat[0])
print(rat[1])

print(fun.get("3"))
rat=fun.get("3")
print("below should be 42 and 46 for the result")
print(rat[0])
print(rat[1])

print(fun.get("4"))
rat=fun.get("4")
print("below should be 50 and 52 for the result")
print(rat[0])
print(rat[1])

print("==== end of adding to data to dictionary dynamically ===")
for k,v in fun.items():
    print(k, v)
    print(v[0],v[1])
    print("----------")

#modidfy this get value to use dictoinary name as parameter  
print("here we are testing get_value_of_key(dictname,keynumber)  (fun,3)")  
#note dictionary name as param MUST BE A STRING in quotes 
love=get_value_of_key('fun',3) #dictionary name and key number

print('the value of key  in fun =',love)
print("should return 42, 46")
print(love[0]) #42
print(love[1]) #46

print("testing getting the length of the fun dictionary")
golddust=''
golddust =get_dictionary_size(fun) #so I would call this before adding to it so
print("so now we can get the number for number of items in a dictionary")
print("we have ", golddust," as the length for dictionary fun")
#that I can add just the new data list [3,4] example and not think about key number
# basedon the length I just add 1 to it
print("above this line should be the size of the dictionary fun pumpkins")
######################################################################
print("now to empty dictionary called fun")
fun.clear() #empties dictionary
print(fun)
    
##===============================
## get_size_of_dictionary  (name of dictionary)
##===============================
def get_size_of_dictionary(zoo):  #this is so I know what next record should be
    print("get_size_of_dictionary")
    answer = len(zoo)
    print("get size of dictionary zoo",answer)
    #how do I loop thru a dictionary
    print(":this is printing out peartree ")
    for x in peartree:
        print(x)
    print("====")
    print("")
    print("this loops thru dictionary thisdict")
    for x in thisdict.values():
        print(x)
    print("")   
    print("===loop thru dictionary== this.dict ==")
    for x, y in thisdict.items():
        print(x, y)




car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

def playing_with_dictionary_structs():
    print("playing with dictionary access...")
    x = car.get("model")
    print("testing getting car model")
    print(x)

playing_with_dictionary_structs()

   
#but I just thought I can have a running total in a list too
def do_something():
    print("Muppets Animal")
    result=''
    do_this_baby() # I think that the list peartree was empty when I was testing it
    print(peartree)
    print("get size of dictionary ... a test")
    #how do I determine if a list is empty
    if len(peartree) > 0:
        result= len(peartree)
        print("length of peartree =",result)
    else:
        print("peartree is empty and equal to 0")
        print(len(peartree))
    print(result)
    return result
######################################
do_something()

    


print("doing simple test here to get value of key number in peartree dictionary")
print("====Domino's Pizza= dominios pizza dominios pizza=")
firstone=get_value_of_key_original(1) #its using peartree
print('the value of key 1 in peartree =',firstone)
print("does this work or not???")
print(firstone[0])
print(firstone[1])

print("===== pizza hut ===has terrible pizza =")
secondone=get_value_of_key_original(2)
print('the value of key 1 in peartree =',secondone)
print("peartree[2][0] =",secondone[0])
#print(type(secondone[0]))
#print(str(secondone[0]))
#print(type(secondone[0]))
super = secondone[0]
#this force it into becoming a string actually 
#print(eval('secondone[0] == ' + str(super)))
print(super)
print("where is it")
print("type=",type(super))
if secondone[0] == 28: #int actually
    print("this tests :  if secondone[0] == 28:")
    print('too funny no chance in hell====it will never work ')
else:
    print("no way will it work")
    
print("peartree[2][1]=",secondone[1])
foolish = secondone[1]
foolish = str(foolish)
print(type(foolish))
print("now it's a string")
print("end of htis test")
 #peartree['1'] = [10,20]
 #peartree['2'] = [28,38] 
    

#example getting the size of dictionary peartree    
get_size_of_dictionary(peartree)




###############################################
## dnanmically add one record to dictionary
###############################################
def dynamically_add_one_record_to_dictionary():#will need some params
    print("starbucks morgan hill checking this out")
    print("dynamically add one record to dictionary ()") #what about input param
    #first pass go thru dictionary to determine it's current length put that into a list
    super=''
    super=get_size_of_dictionary(peartree)
    #so to add 1 to super for next record
    testtheory='[42,60]' #this is hardcoded here but testing at this stage so it's ok
    #super += 1
    #combine = firsthalf + secondhalf 
    #print(combine)
    #eval(combine)
    #print(combine) 
    #hard coded adding data to dictionary here obviously
    
    peartree['3'] = [42,60] #there would have to be 4 slots already to work
    print(peartree)
    get_size_of_dictionary(peartree)
    print("now yellow BIG BIRD test =========")
    ### look here this is correct below that owrks 
    fish =  "peartree['4'] = [66,80]"
    exec(fish)
    print("experimenting here adding new item to dictionary peartree for testing")
    ##======================================
    thenumber = 5; 
    y1 = 82; 
    y2 = 94
    salmon =  "peartree['" + str(thenumber) + "'] = [" + str(y1) +","+ str(y2) + "]" 
    #this would be blueberries 
    print("salmon=",salmon)
    #salmon= "peartree['5'] = [82,94]"
    #salmon= peartree['5'] = [82,94] #this one is correct
    exec(salmon)
    
    #and I can use 'peartree' as a var and connect it will try that next. 
    #what I built up above needs to look like this string 
    
    ###==========================
    #I need a database for each function that is searchable
    #with a tag of what it does - behavior
    #I could do it in javascript with my switch case
    ###=============================
    
    
    get_size_of_dictionary(peartree)
    print("is peartree 4 here with 66,80")
    print("looping thru dictionary peartree here on oct 23rd")
    for x, y in peartree.items():
        print(x, y)
    #output
    #output='''   
    #    1 [10, 20]
    #    2 [28, 38]
    #3 [42, 60]
    #4 [66, 80]
    #5 [82, 94]
    ##########################
    num = 5
    numb1 = 200
    numb2 = 280
    firsthalf  = "peartree['" + str(num) + "'] ="
    secondhalf = "[" + str(numb1) + "," + str(numb2) + "]"
    print('look here very carefully....')
    print('secondhalf=',secondhalf)
    together = firsthalf + secondhalf
    print("look at below this line does it look right GROUCH")
    print(together)
    exec(together)
    
    
    
    get_size_of_dictionary(peartree)
    #print(peartree['5'])
    print("get value of 5",peartree.get('5'))
    ###########################
    '''
    loop thru peartree:
        print(item)
    '''
    for item in peartree:
        print(item)
        
    for x in peartree.values():
        print(x)
        
    print("chocolate somores. ")
    sweet =get_value_of_key_original(1)
    print("sweet key 1 =",sweet)
    
    get_value_of_key_original(2)
    get_value_of_key_original(3)
    get_value_of_key_original(4)   
    get_value_of_key_original(5)
   

#this will be used to take in a set of two numbers switch endswitch
#to add to the pears dictionary
#### makes [24,34] from ab and returns it
#### make list with two pieces of data (ab)
def make_list_with_two_pieces_of_data(a,b):
    jedi=''
    jedi = "[" + str(x) + "," + str(y) + "],"  #notice it adds the comma on the tail
    return jedi
    
#making peartree['1'] is not tough

#what about this
#dynamically build it [10,20]
x = 10
y = 20
jedi = "[" + str(x) + "," + str(y) + "],"  #notice it adds the comma on the tail

print("")
print(" lightning round")
print("testing dynamically creating a two slot list to add to a dictionary")
x = 22
y = 33
raz=make_list_with_two_pieces_of_data(x,y)
#this does this
#  jedi = "[" + str(x) + "," + str(y) + "]," 
print("should return [22,33]")
print(raz)



print("celebration time it almost works completely fireworks")
print('jedi=',jedi) #creates [10,20],

print("interesting test to dynamically add a record to peartree dictionary")
print("KERMIT THE FROG test riding a bicycle")
run=get_size_of_dictionary(peartree)
print("size of dictionary before adding to it ",run)
dynamically_add_one_record_to_dictionary()
run=get_size_of_dictionary(peartree)
print("size of dictionary now is ",run)
#######################################################
do_this_baby()
print("did this work or not")
print("july 20th, 2021 wow time flies")
print(peartree)
###################################################################||

#######################
peartree = {}   #this will always exist and needs to exist to work.
buton=[]   #this is the passing of the buton in track and field relays
buton.append(0) #two positions here in this inner list
buton.append(0)
########
## I need to fill the pear tree data values from after 
## I generate teh switch_location and endswitch_location lists

### PRACTICING ADDING DATA TO A DICTIONARY CALLED PEARTREE  


# test input
# this adds a datum to peartree
# this is the method to add a 
# new switch pair to dictionary peartree

#it was add_this <<=========
# now it's this
#####################################
## add_data_to_pears()
#####################################
### the dictionary name is hardcoded as peartree
# peartree is a dictionary
# buton is a list with two slots 

def add_data_to_pears(x,apple):
    print("add_data_to_pears()",x,apple)
    peartree[x]=apple  #this is where the list is added
    print(peartree)

#adding data to dictionary pears here 
 #july 21st 
 #simple var with data is a list anonymous which is what I will construct
apple = [10,20] #<<====== right here I need to produce this from the switch output
x = '1'    
add_data_to_pears(x,apple)  #feeding a new switch pair into peartree

##======
apple = [28,38]
x = '2'  #here I have to provide the number, now I can figure out what 
#it needs to be by getting the length of the dictionary and adding 1 to it.
#for th enext input of data to add to the dictionary. 
add_data_to_pears(x,apple)
##======

print('tahoe test')
print("testing getting a list out of the dictionary in terms of whats in it")
cd=get_value_of_key_original(2) #see if it returns [28,38]
print(cd)

################################################
###### TESTING FILLING A DICTIONARY ############
###############################################@

# I will nede a loop
# july 21st, 2021
#this looks into peartree for a key to return a value
# the values it put into buton[0]and buton[1]
 
# this is accessing the peartree
##############################
##  ACCESS_SWITCH_1_N
##############################
def access_switch_1_n(t):
  print("access_switch_1_n() called")
  print(peartree.get(t)) #was '1'
  one=peartree.get(t)
  print(one[0])
  print(one[1])
  #################
  # added July 21st
  buton[0]= one[0]
  buton[1]= one[1]
  print("this is looking into buton list")
  print("================//================")
  print("buton[0]=",buton[0])
  print("buton[1]=",buton[1])
  print("================//================")
  ##################
  print("I can now grab")
  print("the nest switch params")
  print("from the pear tree")
  print("to feed  copy nest method")
  print("first",one[0],"second",one[1])

#this is accessing the pears dictionary to get the data by the key
### this calls the method above   
t='1' 
access_switch_1_n(t) #accesses key 1


t='2' 
access_switch_1_n(t) #accesses key 2


###############################

# output 
'''
add_this called
{'1': [10, 20]}
add_this called
{'1': [10, 20], '2': [28, 38]}
access switch called
[10, 20]
10
20
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 10 second 20
access switch called
[28, 38]
28
38
I can now grab
the nest switch params
from the pear tree
to feed  copy nest method
first 28 second 38
'''
#<href="https://discover.cs.ucsb.edu/commonerrors/pythonerrors.html"> python common errors UC Santa Barabara</a>

########
b=''
##############################################
## ACCESSING DATA IN PEARTREE DICTIONARY #####
##############################################
def accessing_data_in_peartree_dictionary():
    print("====accessing data in peartree dictionary ==")
    print("====Accessing data  from peartree dictionary()....====")
    print("accessing keys in the peartree  which I would do with a loop later.")
    #print now accessing the dictionary that has been filled with data
    #x = peartree("1")
    print(peartree)
    x =peartree['1']  #adding data to a dictionary
    print(x)
    print(x[0],x[1])
    print("============")
    #x = peartree("2")
    x=peartree['2']  #adding data to a dictionary 
    print(x)
    print(x[0],x[1])
    print("how did it go Hogwarts after flying the car over London")
    
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    ########$$$$$$$$$$$$$$$$###################
    
    #this is where I access the dictionary
    # and call the code to get the nested swith
    # based on the switch and endswitch location params
    
    print("==== now trying a LOOP thru peartree =====")
    counter =1  #starting from 1
    for item in peartree: #looks in peartree in this example and splits pair set to display
        x = str(counter)
        b = peartree[x] #this was "1"
        print(b[0],b[1]) #these will always be the same 
        counter += 1
## output is correct
'''
==== now trying a LOOP thru peartree =====
10 20
28 38
'''
#this is for the numbering and access to the nested switches
# and governing them and number the nested_switches and managing it all perfectly.
#================ thursday, august 19th, 2021 solution =============================
#so with this approach number is simple 1 to n for each tab level
#only thing that I change is level depth of indentation
#so if we have main switch and then 3tab depth then 5tab depth
#level0, level1, level2
#level stands for nested switch depth
#so I can use the numbering 1 thru n for each switch
#and use the numbering system and just add the level[0] in a list
#level[0] is main 1, 2, 3, 4, 5 #nested numbering
#level[1] tab depth 5 is first level nested switch if nested within 1, 2, 3
#level[2] tab depth 7 is second level nested with , 1, 2, 3
#level[3] tab depth 9 is third level 
#def loop thru pears dictionary and call  nested switch
#==================================================================

#this calls the method above:        
accessing_data_in_peartree_dictionary()

### this would be after filling this with switch_location and endswitch_location method

print("practicing with this hardcoded input data for switch and endswitch to prove it works")
print("down at pears tree here hard coded ")
# this represents a dictionary called pears already loadded with data
#=================================================
########################
##  PEARS DICTIONARY
########################
#pears =	{  #for pear tree in backyard (2 of them)
#  "1": [10,20], # I can make these now 
#  "2": [28,38],
#  "3": [1,44]
#}

#testing with this new data multiple nested switches

#this hardcoded I put this in here. it's not automated yet
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently

}

#for red_robin
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,100], # I can make these now  1 tab level start and stop
  "2": [11,60], #3 tabs
  "3": [15,51], #5 tabs
  "4": [23,46], #7 tabs # yes it is a stacked at 3 tab level already 
  "5": [31,41], #9 tabs
  "6": [62,86], #3 tabs
  "7": [66,77]  #5 tabs
 #no comma after last data piece apparently
}


#nest_string has pears
#and then blueberries added. 
#solved it.
 
#da = blueberries.get("2")
#print("getting data in blueberries")
#print(da)

'''
11 is in 1
62 is in 1
15 is in 11
23 is in 15
31 is in 23
66 is in 62
'''


def lametest():
    print("doing lametest()")
    if 11 in range(1,86):
        print("true")
    else:
        print("false")
    
lametest()

#new pears

#creates this

#this string already has numbered switches with comments 
#note that the numbering of the switches isn't starting from 1 down.
#testing this sep 30  #switch11 is the main switch
foolish='''
			switch(exp){  #11  first level deep                   Level 1... 3tabs
				case 'blable':
					print("do something") #formula is switch number + 1 thru second number
					#################### cut out 16 thru 38
					switch(exp){ # 15  #second level deep          Level 2    5 tabs=================
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23  #third level deep   Level 3   7 tabs  
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33 === 7 tabs 
							#############
							break
						default:
							print("we are done here")
					endswitch #38   # 5 tabs========================
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
			exp = 3  #note that this switch is stacked below the bottom stack at 3 tabs
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  # 53second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #64
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''
#end result will be .......
##=======================
''' main string is 11 thru 73
        pair   tab count
  "1": [11,47],[3] # I can make these now #but it has two starting points SECTIONS
  "2": [49,73],[3]
  
  "3": [15,38],[5] 
  "4": [53,64],[5]
  
  "5": [23,33] [7]
#main 1  to 3 tab depth level 1 ONE
only switches at 3 tabs 
#it should be 
###########
mainswitch number followed by it's nested switches which will be methods
====switch numbers two columns===
first position [0] is first switch id line number for that string
second list can have more than one number represents the switchnest numbers
now figure out how I calculate this and fill it as a listwith sublists
[1] [11,49]
[11][15]
[49][53]
[15][23]
[23][0]
'''
# what this does is add ..  # 66  the line number after each switch(exp){

print("TWIN LIST let's take a look and see what's in it")
#print("let's look inside of twinlist",twinlist)
#they have to be in the same order as the actual switch cases

'''
##================
======1:3==========                   switch1 > switch11 and switch49  =========
switch1
     switch11 method 3 tabs first number from pair 11,47
     switch49 method 3 tabs first number from pair 49.73
end73
#==============================       switch11 > switch15  =======
only switch at 5 tabs between 11 and 47
#minor 3 tab to 5 tabs  Copy 11 thru 47 TWO
switch 11  3 tabs
     switch 15#method  5 tabs   must be between 11 and 47
switchend47
#=============================         switch49 > switch53    ======
#minor 3 tab to 5 tab   THREE
only switch at 5 tabs between 49 and 73
switch 49
     switch 53 method must be between 
endswitch73
##====================  FOUR           switch15  > 23 =======
#minor  5 to 7 tabs   
only swith at 7 tabs between 15 and 38
switch 15
     switch 23 method
##====================  FIVE           switch23  none ======== by itself
#minor none 7 tabs not nested because no 9 tabs its an end tail
switch 23      
$$$$$$$===================================================$$$$$$$$
# I need to be able to generate the pattern
if tab depth == 3 then
first number of pair[0] is nested switch 11 and 49
     switch11 method  first number from pair 11,47
     switch49 method 
     
=======3:5
if tab depth == 5 then
first number of pair[0] 15 goes inside minor 
three tabs to five tabs
switch 11
     switch 15#method   must be between 11 and 47
switchend47
===== 3:5
[49,73],[3]=== [53,64],[5] if secondpair[0] > firstpair[0] and 
switch 49
     switch 53 method must be between 
endswitch73
#testing this
combinedtabs=[]
combined_tabs = threetabs + fivetabs + seventabs
#threetabs= [11, 47, 49, 73] done 
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]
'''
print("testing merry christmas code")
print("obviously this is a thinking and engineering problem")
threetabs = [[1, 2],[3, 4]] 
fivetabs  = [[5, 6],[7, 8]]
seventabs = [[9, 10]]
#testing this
fuel=[threetabs,fivetabs,seventabs]
combinedtabs_jazz=[]
combine=''
fulllist=["threetabs","fivetabs","seventabs","ninetabs","eleventabs","thirteentabs","fifteentabs"]

#def grab_these_tabs(x):
    


upto7 = "threetabs + fivetabs + seventabs"
combined_tabs_jazz = eval(upto7)
print("combined_tabs_jazz=",combined_tabs_jazz)
for item in combined_tabs_jazz:
    print(item)
    

#laketahoe
combined_tabs=[]
##========================================================
threetabs= [[11, 47],[49, 73]] 
fivetabs = [[15, 38],[53, 64]]
seventabs= [[23, 33]]
#this combines the theetabs, fivetabs and seventabs
combined_tabs = threetabs + fivetabs + seventabs

counter=1 #looping thru combined_tabs list
for item in combined_tabs:
    alpha = item[0];beta  = item[1]
    print("pair=",item," "," counter=",counter,", first=",alpha,", second= ",beta)
    print("=========================")
    counter += 1
print("did she work")

for item in combined_tabs:
    print(item)
    
#output
'''
pair= [11, 47]    counter= 1 , first= 11 , second=  47
=========================
pair= [49, 73]    counter= 2 , first= 49 , second=  73
=========================
pair= [15, 38]    counter= 3 , first= 15 , second=  38
=========================
pair= [53, 64]    counter= 4 , first= 53 , second=  64
=========================
pair= [23, 33]    counter= 5 , first= 23 , second=  33
=========================
did she work
'''
    
#this is what is in combined_tabs now
print("showing off combined tabs list")
for item in combined_tabs:
    print(item)
print("===================")    
#see if this works
#=================================================


table=[]
table.append(0)
#============================================================
## check_if_nested_switch_inside_this_switch(astring): 
## returns table[0] = False or True
# coded on dec 6th monday 12:== noon ish

#==========================================================
def check_if_nested_switch_inside_this_switch(astring):
    print("check if nested switch inside this switch")
    counter=0
    table[0] = False
    for line in astring.splitlines():
        tabcount=line.count("\t")
        if tabcount == 3  and "switch" in line and "end" not in line:
            table[0] = True
            print(line) #proof is in the pudding - how good is it
            break
            
            
            
            
            
##### this does absolutely nothing 
# I need to make a method to add main switch to string list
def add_main_switch_params_to_dictionary():
    print("how it will work")
    #methods count end switches
    #Take answer add 1
    #loop thru input switch string get total number of lines
    #"3" : [1,44],  #is the result
    #call method to add it to dictionary


#pears['3'] = [4,7] #example
# 38-15+ 1=24  formula end number - first number = x then x + 1
#first number keep, skip out to 23 lines (length of string of nested switch)

print("====dictionary pears====")
print(pears)
print("==========")
print("====dictionary peartree====")
print(peartree)

print("==== practicing with dictionary called pears ========")
#access the dictionary one key in particular to get the value
#print('pears[3] which is the key number')
#x = pears["3"]
#print("x = ",x) #this should be 4,7
#print("============")
 
 
def say_something(x):
    print("say something test here")
    print('cool[0]=',x[0], "cool[1]=",x[1])
     


print("PRACTICING LOOP THRU THE PEAR DICTIONARY WITH HARD CODED DATA FOR TESTING")
print("============")
print("== PEARS  dictionary now LOOPING THRU IT===")
print("listening to teh Beach Boys to see if it works ----")
#looping thru dictionary called thisdict
'''
for x in pears.values(): #looping thru pears dictionary holding switch and end switch pairs locations
    
    print(x)
    cool = x
    #print(cool[0])
    #print(cool[1])
    print(cool[0],cool[1])
    #say_something(cool)
    copy_one_nested_switch_string(m82)
    print("========================")
       
''' 
#this will be a method but of course
'''
for line in inputstring.splitlines(): #	
		#this will be the second loop======
		# if counter is between start and finish #just after start and less than = to finish
		if counter > start and counter <= finish: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
	print("===output from skipping some lines====")
	print('it created this string')
	print(concatthis)
'''	
	


#######=========================================
#
##==============================================
def do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring):
	print("do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up")
	#this 
	genius[0] = inputstring
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	
	


#testing
spilled_coffee ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 ==========
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 ===============
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #26 ==============
			
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



skitahoe ='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #14
			print("nicely")
		case 'more1':
			switch(exp) 16
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #23
			print('party time')
			switch(exp) #25
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #32
		case 'more2':
			print('more parties')
			switch(exp) #34
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #41
			print('are we there yet')
			switch(exp) #43
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
					print('bye')
			endswitch #50
			print('how many this week')
			switch(exp) #52
				case 'funny':
					print('fun')
				case "da":
					print('yeah')
				default:
				print('bye')
			endswitch #59
			print('what the..')
			break
		default:
			print("we are done here")
	endswitch #this is key here =============line 20 end of nested switch ====
'''	



flag_test=[]  
toosmart=[]
toosmart.append(0)
baton=[]
baton.append(0)
 
flag_test.append(False) #set flag_test by default to False
#flag_test[0]
# x is the name of the string to be modified
switch_list=[]
endswitch_list=[]
thenewpairs=[]

##============================
##  buildpairlist()  created nov 21st, sunday to manage doing the main switch 
##============================  and cutting out switches at three tabs for main switch 
def build_pair_list(stringname):
	print("====== build_pair_list called ======")
	counter =0
	#flush lists
	switch_list=[]
	endswitch_list=[] #should reset them both 
	#thenewpairs=[]
	#del endswitch_list[:]
	#this fills up the switch_list line
	#===================================
	# LOOP FILLS UP SWITCH_LIST 
	#===================================
	#loop thru stringname and fill up switch list
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line:
			switch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	counter =0
	#loop thru stringname and fill up endswitch list
	#this fills up the switch_list line
	# =======================================
	# LOOP FILLS ENDSWITCH LIST 
	#========================================
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if "endswitch" in line :
			endswitch_list.append(counter)
			counter += 1
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	del switch_list[0]     #delete first switch number which is on line 1
	del endswitch_list[-1] #delete last number endswitch which is end of entire string
	print("after deleting first and last switch we have..")
	print("switch_list=",switch_list);print("endswitch_list=",endswitch_list)
	counter=0 #build the pairs and put them into sweet; then append sweet to thenewpairs list
	#===================================================================================
	# LOOP FILLS THENEWPAIRS LIST WITH SWEET WHICH HAS SWITCH,ENDSWITCH LINE NUMBERS
	#===================================================================================
	for item in switch_list:
		sweet=[switch_list[counter],endswitch_list[counter]]
		thenewpairs.append(sweet)
		counter += 1
	print("this is what we want to see at starbucks")
	print("thenewpairs=",thenewpairs)
	#==================================
	# LOOP PRINTS OUT THE NEWPAIRS LIST
	#==================================
	for item in thenewpairs:
		print(item)
		print('stop here for now')
		#exit()
	#REVERSE THE NEWPAIRS LIST BECAUSE IT HAS TO BE DONE BOTTOM UP TO THE STRING 
	thenewpairs.reverse() #they have to be skipped bottom up to work properly
	print("thenewpairs=",thenewpairs)	
	print("resulting list of thenewpairs =",thenewpairs)



pinkpanther=''
##===========================================
##  skipping_some_lines() #this works
##===========================================
def skipping_some_lines(thestring,start,finish):#input string, switch number then endswitch line number  ....start line nest switch and finish  endswitch
	return
	print("METHOD  skipping_some_lines() called==========")
	print("======= skipping_some_lines() ================called",start,finish)
	# if I have a flag that it's been triggered then afterewards 
	# print("this is the input string used stating skipping_some_lines")
	# for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0]) =============================
	#if flag_test[0] == False: #meaning first pass  and what it's set to by DEFAULT
	smart=thestring;
	baton[0]=thestring #this is new
		#change it to True now
	flag_test[0] = True #this should now be tru e========================
	#else: #meaning TRUE this is run after first run of skipping_some_lines()======
		#what this does is use the new concatted changed string changed on the fly with each pass
		#for second and all subsequent passes it uses baton[0]
	thestring = baton[0]#====================
	#print('what is in baton[0]',baton[0])
	##==========================================================
	# the issue is that on the second pass it is using the original string
	# and it needs to be using the modified string
	# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
	# because the numbering system of the string starts from 1 too.
	### look that we have the counter here set to 1 by default 
	counter=1; concatthis =''; #finish = finish + 1 
	print("start=",start,"finish=",finish) #I took out x = 
	#smart=x;
	print("inside of skipping lines before going thru the loop this is the value of")
	print("the input string it will mess around with")
	#print(smart)
	print("=== ah now I get it these are the lines that it MUST SKIP and we want what is before and after this range to create the modified string =")
	print("it sees in start",start)   #this is a number
	print("it sees in finish",finish) #this is a number too
	##=================
	#so I would build pair list of inner switches at 3 tabs and then loop thru them to skip them
	#this is new on sunday november 21st 2021
	#what I want to skip on the fly without range data
	
	#------------------------------------------------
	#from switch at 3 tabs until endswitch at 3 tabs
	#skip the lines inbetween leaving switch word
	##----------------------------------------------
	
	
	##=============== this is a new addition to automate the grabbing of inner switches ====
	# this creates pairs of the switch, endswitch pairs 
	#if start == 1 and finish == 1: #meaning figure out pairs on the fly
	
		
	#exit()
	counter=0
	#for item in thenewpairs:
	#	start  = item[0]; print("start=",start)
	#	finish = item[1]; print("finish=",finish)
	#check thype
	print("checking tyhpe of thestring")
	print(type(thestring))
	print(thestring)  #it shows 0
	print("what is it?")
	print("starting baton[0] has teh initital input string in it")
	for line in thestring.splitlines(): #smart = x
			#this preserves the switch word and skips the rest of nested switch body including endswitch
			# if counter is between start and finish #just after start and less than = to finish
			#just added start +1 and finish + 1
			#tabdepth= line.count("\t")
			#if tabdepth == 3 and "switch" in line and "end" not in line:
			#		start = counter
			# use while loop of course
			#so it's upside down and backwards to create the same meaning.
			# probably need to do a prescan but maybe i can do it without doing prescan
			#get location of switch and endswitch at 3 tabs
			#while "endswitch" not in line:
			#####################==================
		if counter > start+1 and counter <= finish +1: #if only between start and finish skip these lines
			#skip  #so greater than start(switch) and less than finish  we are cutting out these lines of code
			counter += 1
			continue	
		else: #this builds the string by concatting it
			concatthis += line + "\n" #notice we add a new line at the end
			counter += 1
			#ibm[0] = concatthis
			continue	
		##=======================================
	baton[0]=concatthis;
	print("===output from skipping some lines====")
	#print('it created this string')
	#print(concatthis)
	print("how does it look===>>> by lettuce field")
	del ibm[:] #this should empty it
	print("this is the output result of skipping some lines")
	#print(concatthis)
	#what I am doing here is putting what has been concatted in the string into toosmart[0]
	#this has red_robin hardwired into the code 
	#just commented out line below november 10th, 2021 to see wehat happens 
	#toosmart[0]= red_robin #it did say toosmart[0] = red_robin
	#just commented these out thanksgiving
	#baton[0] = concatthis  #here the concatthis has been put into baton[0]=======
	#pinkpanther=concatthis==============
	##==========================================================
	### mocha test ### this is new November 10th, 2021  ########
	never_defeated[0]= baton[0]  #just added this line 
	###########################################################
	##==========================================================
	concatthis='' #this resets concatthis to empty-
	print('in baton here we have')
	#print(baton[0])
	print('==============')
	print("now the result is here....!!!!@@@@@$$$$$")
	print(never_defeated[0])
	#ibm[0] = concatthis	  #this has the switch string with the nested switch cut out
	#putting concatthis into ibm[0] here 
	ibm.append(toosmart[0])
	print("at the bottom of the skipping some lines to take out inner switch")
	print(" it sees this in ibm[0]")
	#exit()	
	#print(ibm[0])
		#just moved this over one tab	
#exit()
#end skipping_some_lines  ========================================================
print("Levels TEST on wonderful Monday winter wonderland ")
print("this will take out the inner switch between") 
never_defeated=[]
never_defeated.append(0)

#for line in skitahoe.splitlines():
#   print(line)




#it was previously this
def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
    return
    print('this one is sooo critical')
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    skipping_some_lines(stringname,start,finish)
    #this means that the output string should be placed into never_defeated[0]
    for line in never_defeated[0].splitlines(): #prints it after takening out. 
        print(line)
        

##===========================================================================
##  modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#this was redesigned and modified on sunday november 21st at 8:30am to 
# work with skipping some lines with no known locations of inner switches at 3 tabs
# and it calls method build_pair_list to find them and reverse them for input for skipping_some_lines
# and I have to subtract 1 from start and finsh
#this one is used to get the main switch and take out switches at 3 tab depth

# and loops thru list feeding start and finish  params and calling skipping_some_lines()
# #  the input for start and finish will be 1 by default but they will be overwritten
# #  by the build pair list on-the-fly.
print('this one is sooo critical')
def modified2_cut_out_inner_switch_body_leaving_switch_word(stringname):
    #it is modified so it can change more than one inner switch into a switch, infinite
    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
    ###======= this is ingenius=========
    #METHOD BUILD_PAIR_LIST(STRINGNAME) 
    if len(thenewpairs) > 0:
        print("==TRUE thenewpairs >0 it is ===== ",len(thenewpairs))
        del thenewpairs[:] #delete contents of thenewpairs list if it's not empty yet
    #end if
    #if len(never_defeated[0]) > 0:
    never_defeated[0]='' #deletes it
    build_pair_list(stringname)           # goes thru thenewpairs list and
    for item in thenewpairs:              # fills start and finish into skipping_some_lines params
        start  = item[0];
        finish = item[1]; # print("start,finish=",start," ",finish)
        skipping_some_lines(stringname,start-1,finish-1)#so close now 
        #the result of the concatting goes into never_defeated[0]
    #this means that the output string should be placed into never_defeated[0]
    print("let us see what we have jazz blues line 6166 ....")
    #so it's output is in  never_defeated[0]
    thisstring = never_defeated[0]
    return thisstring; #see if this works  it is important that we return the string
    print("let's see what it has in it and if it converts the inner switch bodies to switch word...")
    for line in thisstring.splitlines(): #prints it after takening out. 
        print(line)
    cat_scales[0]= never_defeated[0]
    print("now loop thru pinkpanther")
  
        
#manipulate_string(item) #shifts it to the left

# this is the one that is new as of november 21st and it does the main switch with
# inner switches at 3 tabs that it takes out leaving just the switch word.
#============ original============ modified2
output_list=[]
output_list.append(0)
# testing spilled_coffee string 
stringname=spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print("input string is spilled_coffee  =========")
print("doing first attempt of converting inner switch bodies to just the switch word")
mybaby =''
mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)
print("did this sucker work tuesday november 23?")
print("now loop thru the output if it generated it")
print("this is the resulting output processed by the modified2_cut_out... function")
for line in mybaby.splitlines():
    print(line)
    #print("======") 
print("end of first string test for reducing switch bodies to switch word") 
print("=== made it to this point after first attempt completed ===")  
print("now a SECOND ATTEMPT AT CALLING THIS METHOD NOW. WEIRD AT LEAST FIRST PASS WORKS ==")
## testing skitahoe string
#stringname=skitahoe;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print("just testing 2nd one with skitahoe string to see if it works ==input sstring is spilled_coffee")
mybaby =''
#worked by itself
print("doing skithaoe string now=============")
stringname=skitahoe
mybaby = modified2_cut_out_inner_switch_body_leaving_switch_word(stringname)

for line in mybaby.splitlines():
    print(line)
#exit()   
    
print("===end of show on thanksgiving==attempt 2 =")    
#exit()


#exit()

print("catscales=",cat_scales[0])
print("=====rats======")
print("never_defeated[0]",never_defeated[0])

goldring = never_defeated[0]
print("is this going to finally work or not")
output_list.append(goldring)
print("WHAT IS BELOW THIS DAM LINE")
print(output_list[0])
print("now loop thru goldring s")
for line in goldring.splitlines():
    print(line)

print("seeing if this works")
for line in never_defeated[0].splitlines():
    print(line)
    
#ram = never_defeated[0].replace("switch","rocks")
#never_defeated[0]= ram
#for line in never_defeated[0].splitlines():
#    print(line)
#exit()
#==================================
print("end of deifnitely working modifies2 cut out inner switch body.()")


#stringname=skitahoe; start=7; finish = 14; #this sucker was moving....    
#cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
print("let us see what we have.")

#need to indent it I think.
#produces this output it is NOT indented yet 
goldfish='''
	switch(exp){   #1 === line 10 beginning of single nested switch ======      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7
			print("nicely")
			break
		default:
			print("we are done here")
	endswitch 
'''
			
			
			

print(" RED RED RED cut out switch body leave only switch word baby")
print(" red alert testing cut out switch body leaving switch word tesitng 4 ..")    
#exit()

#this is testing with dummy data above in test_code_now
#taking out the inner switch body
print("halloween is coming snoopy and woodstock test")

#print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1
print("take out 10 thru 20") #but actually keep 10 and takeout including20
#x = test_code_now
#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
print("rose test")








#modified so it doesn't matter where the inner switch is 
# they will all be at 3 tabs
#the first switch must be at 1 tab and inner switches need to be at 3 tabs one depth in
#THIS IS NEW CODE WEDNESDAY CODING...november 10th ........
##########################################################################################
#####################################################################################
 #creates first slot in list for string
	#print("actually this builds lists of switch and endswitch locations and makes pairs")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print("===========smart_cut_out_inner_switch_bodies_at_three_tabs=========")
	#print(" checking to see if more than ONE inner switch at three tabs and ")
	#print("if so then put them into a list")
	#print("the first loop determines how many inner switches at 3 tabs")
	#print("the second loop will go thru a list of the pairs - ah yes but ")
	#print("not implimented yet ")
	
	#print("it sees in finish",finish) #this is a number too
	

# "actually this builds lists of switch and endswitch locations and makes pairs")
# what it does: creates pairs set of start, finish after getting list of switch and endswitch lines
# then it will loop thru pairs set in reverse order and cut out switch bodies bottom up 


## new november 10th 2021 !!:37am
#JUST TRY IT


#this requires this function below to be called first though
#  smart_cut_out_inner_switch_bodies_at_three_tabs(samplestring)
pairset=[]
genius=[]
genius.append(0)

never_defeated=[]
never_defeated.append(0)
list_of_inner_switches_at_three_tabs=[]
list_of_inner_endswitches_at_three_tabs=[]




##========================================================
## loop_thru_pair_set_and_call_skiplines(samplestring)
##=========================================================
def loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring):
	print("len(never_defeated) =",len(never_defeated))
	#never_defeated[0] = thestring #this takes the initial string put into never_defeated[0]
	never_defeated.append(thestring) #maybe this is what I need to do to fix this bug
	print(never_defeated[0]) 
	counter =0
	#loop thru pairset of sets of switch,endswitch (already reversed to go bottom up)
	for item in pairset: #the pairset list was filled in smart_cut_out_inner_switch_bodies_at_three_tabs
		alpha = item[0];beta  = item[1];print("alpha=",alpha, "beta=",beta)
		start = alpha; finish = beta
		#METHOD skipping_some_lines()============= uses never_defeated[0] stirng in list
		skipping_some_lines(thestring,start-1,finish-1) #added -1 on Mon Nov 22nd 2021 9:00 AM
		#doing this to see if it cut out the inner switch body 
		print("this is showing the changes reducing switches in never_defeated[0]")
		mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
		print("this is what the switch string looks like after taking out a switch body")
		counter += 1
	








##====================================================================
##  make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring)
##====================================================================
def make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):
	print("METHOD make_Pair_set_of #### called  ... make_pair_set_of_inner_switches_at_three_tabs_depth(inputstring):")
	counter =0
	print('let us look at this string to see what it sees')
	print("========//////////==========///////==============")
	for line in inputstring.splitlines():
		print(line)
	print("========//////////==========///////==============")
	for line in inputstring.splitlines(): #smart = x
		#this preserves the switch word and skips the rest of nested switch body including endswitch
		#for this line get tab_depth
		#print("this is where I add the switch line number to list of inner switches at three tabs")
		tab_depth= line.count("\t") #but this presumes just one inner switch there could be more
		#if 3 tabs True AND switch in line and end not in line and counter > 1 
		if tab_depth == 3 and "switch" in line and "end" not in line and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_switches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)		
	#second new loop but looks for endswitch locations at 3 tabs 
	counter =0
	for line in inputstring.splitlines(): #smart = x
		print(line)		
		tab_depth= line.count("\t")
		#print("this is where I add the endswitch line number to list of inner switches at three tabs")
		if tab_depth == 3 and "endswitch" in line  and counter > 1: #proceed
			#this puts the current line number into the list below
			list_of_inner_endswitches_at_three_tabs.append(counter)
			counter += 1
		else:
			counter += 1
	print("==================")
	print("list_of_inner_switches_at_three_tabs=",list_of_inner_switches_at_three_tabs)	
	print("list_of_inner_endswitches_at_three_tabs=",list_of_inner_endswitches_at_three_tabs)		
	print("===================")
	print("===== end of phase 1 =====")
	##======================================================================================
	print('doing Friday debugging oh what fun it is to ride in a one horse open sleigh')
	if len(list_of_inner_switches_at_three_tabs) == 1:
		print("this means only ONE dam pair")
	else:
		print("the length is =",len(list_of_inner_switches_at_three_tabs))
		cat = len(list_of_inner_switches_at_three_tabs)
		print("the length of inner switches at three tabs is ",cat)
	###=================================================================	
	print("now I need to make pairs")
	get_number = len(list_of_inner_endswitches_at_three_tabs)
	
	if get_number == 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	##3=======================================================================		
	if get_number > 1: #it's only doing it if the gen_number > 1 daaaaaa
		#create pairs   THIS IS CONSTRUCTING THE PAIRSET LIST OF SWITCH ENDSWITCH LINE NUMBERS
		counter=0
		for item in list_of_inner_switches_at_three_tabs:
			pairs = [ (list_of_inner_switches_at_three_tabs[counter]) , list_of_inner_endswitches_at_three_tabs[counter] ]
			print(pairs)
			pairset.append(pairs)
			counter += 1
	else:
		pass #print("there is only one switch endswitch so do regular mode just one inner switch at 3 tabs ")
	if get_number > 1:
		pairset.reverse()  # REVERSE PAIRSET SO THAT I CAN CHANGE THE INNER SWITCHES BOTTOM UP
	
	print(pairset)
	print("loop thru pairset") #to go thru input string and reduce inner switches to just switch word bottom up
	for item in pairset:
		alpha = item[0];
		beta  = item[1];
		print("alpha=",alpha, "beta=",beta)
	##======================================
	print("method to go thru pairset and call skipping_some_lines(start,finish)")
	do_fancy_walk_thru_pairset_list_cutting_out_switch_bodes_bottom_up(inputstring)
	#########====================================
		#skipping_some_lines(genius[0],start,finish)
	#it goes thru the string and makes list of switch,endswitches
	
	#skipper needs to cut out from bottom up 
	#skipping_some_lines(x,start,finish):
	#it will call a method

#this must be called after one switch string has had it's inner switches reduced to switch word
#def reset_to_initial_conditions(): #brainchild on NOv 11th, Thursday morning#
#	print(" ====reset_to_initial_conditions()======"#)
#	never_defeated[0] =""
#	list_of_inner_switches_at_three_tabs=[]
#	list_of_inner_endswitches_at_three_tabs=[]
#	pairset=[]
#	baton[0]= "" #should clear it out
    

#def show_output_string_after_changes():
#    mouse = never_defeated[0] #the result of skipping some lines goes into never_defeated[0]
#		print("this is what the switch string looks like after taking out a switch body")
#		print('resulting string change is for counter',counter)
#		for line in mouse.splitlines():
#			print(line)    
#this makes pairset list of switch and endswitch 
#this is only run ONCE
fullhouse=[]
##============================================================================
##  take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word
##----------------------------------------------------------------------------
##  Methods: make_pair_set_of_inner_switches_at_three_tabs_depth(thestring) oh wow genius here
##  Methods: loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
##  Methods: skipping_some_lines(x,start,finish)
##  Methods: determine_if_inner_switch_inside_of_this_switch_string(weasel)
##  result of modified string put into  fullhouse.append(never_defeated[0])
##============================================================================
def take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring):
	return
	print("THIS NEEDS TO WORK NOW==")
	print(" take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(thestring)")
	baton[0]=thestring
	print("called ....take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestring)") 
	make_pair_set_of_inner_switches_at_three_tabs_depth(thestring)
	print("this is scenario where if one inner switch it's not filling the pairset")
	print("pairset=",pairset)
	loop_thru_pair_set_to_cut_out_inner_switch_bodies(thestring)
	print("list_of_inner_switches_at_three_tabs=", list_of_inner_switches_at_three_tabs)
	print("list_of_inner_endswitches_at_three_tabs=", list_of_inner_endswitches_at_three_tabs)
	print("pairset=",pairset)
	print("this should be the result of the switch with inner switches cut to just switch word, bodies gone")
	for line in never_defeated[0].splitlines():
	    print(line)
	##################################################
	## adding resultof output of methods of taking out inner switches into never_defeated[0]
	## which is put into list fullhouse using append
	### this is where the result of the change string put into never_defeated[0]
	### is appended to list fullhouse
	fullhouse.append(never_defeated[0]) #needs to be here obviously
	#-------------------------------------
	#if it is here then it's called ONLY after the first one has completed and thereafter
	#==================================================
	## this resets super important lists utilized 
	never_defeated[0]=''
	list_of_inner_switches_at_three_tabs.clear()
	list_of_inner_endswitches_at_three_tabs.clear()
	pairset.clear()
	baton[0]= ""
	



print("====STARTING ATTEMPT 1====== charlie brown music is the best jazz ====")


take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(spilled_coffee)


#exit() 
print("this is after the first string and taking out inner switch bodies...")
#print("====STARTING ATTEMPT 2====== charlie brown music is the best jazz ====")
#reset_to_initial_conditions()
	##==========================

##=======================
#take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(samplestringzoo1)


#reset_to_initial_conditions() #this must be done after each transformation
print("the final OUTPUT is here ...")
print("length of fullhouse should be 2 is now",len(fullhouse))


#for item in fullhouse:
#    print(item)

####################################################
#print("size of FULLHOUSE is..",len(fullhouse))
#for item in fullhouse:
#    print(item)

print("time to go sledding")
#exit()


print("now I will try to do a few stings with it.") 
print("end of this initial test of ")
result_of_check_if_inner_switch=[]
result_of_check_if_inner_switch.append(0)

#coded on november 19th friday at 10:48 am morgan hill starbucks
##====================================================================
## determine_if_inner_switch_inside_of_this_switch_string(weasel):
##====================================================================
def determine_if_inner_switch_inside_of_this_switch_string(weasel):
    print("determine_if_inner_switch_inside_of_this_switch_string(weasel):")
    ## START INNER LOOP ======= devised on nov 19th friday 10L30 am ===========
    innerswitch= False #this must be set to False before each call below 
    result_of_check_if_inner_switch[0] = False
    for line in weasel.splitlines(): #this looks for an inner switch at 3 tabs depth
        tabdepth = line.count("\t")
        if tabdepth == 3 and "switch" in line:
            print("where's the party THIS string has an inner switch ")
            innerswitch = True
            result_of_check_if_inner_switch[0] = True
            break
        else:
            continue
        print("....")
    print('this has to be called after the loop is done')
    print("result_of_check_if_inner_switch[0]=",result_of_check_if_inner_switch[0])
    #end loop ===================


funtestlist=[]

print("big bird for prez")
print("testing in my mind wed november 10th test ..going thru list and calling take out switch bodies.")
funtestlist=[samplestring,samplestringzoo1] #samplestringzoo1
#use the list I made earlier catching_first_change

# what this does is loop thru the seperated switch strings and 
# applies a method take out nested switch bodies leaving switch word


#ratmaze_list=[]
#=====================
#  try_the_mocha()
#=====================
# method determine_if_inner_switch_inside_of_this_switch_string(stringname)
# method take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
#=====================
def try_the_mocha(): #this has the separated strings in it (that's helpful)
    print("try the mocha() testing.......... running the rat maze and learning it...")
    fullhouse.clear()
    print("let us see the SEPARATED strings in this list")
    for item in catching_first_change:
        print(item)
    print("===== okay is this it ===")
    
    print("length of catching first change should be 6",len(catching_first_change))
    counter=0  #this is running the method for second stage of chain_methods
    for item in catching_first_change: #funtestlist: #strings in funtest list
        weasel = item
        ## determines if there is an inner switch in THIS string ==========
        determine_if_inner_switch_inside_of_this_switch_string(weasel)
        innerswitch= result_of_check_if_inner_switch[0]
        print('innerswitch if true or false it is .. =',innerswitch)
        if innerswitch == True:  #if there is an inner switch then apply the method below  
            ######## this method  cuts out all inner switch bodies ######################
            take_out_nested_switch_bodies_at_three_tabs_depth_leaving_switch_word(item)
            #fullhouse.append(never_defeated[0]) this line is at bottom of method take_out_nested..
            #never_defeated[0] #this string is the result of the method above in never_defeated[0]
            #############################################################################
        else:
            fullhouse.append(weasel) #so the original string unchanged is added to fullhouse llist
            #this means no innerswitch in this switch string 
            #it's False no inner switch
        counter += 1
        
        ###=========================================================
    print(" end of double loop ")
    print("after going thru catching first change list it should be 6 for counter")
    print("counter =",counter)
    print("len(fullhouse)=",len(fullhouse))
    print("let us look in here if switch stirngs with no inner switches okay and exist at least")
    for item in fullhouse:
        print(item)
    del catching_first_change[:]
    #this fills the output list into catching_first_change list 
    for item in fullhouse:
        catching_first_change.append(item)
        
    print("now big test of second chain method #taking out switch bodies")
    print("this should print out 6 stritngs")
    counter=1
    for item in catching_first_change:
        print("counter=",counter)
        print(item)
        print('=========')
        counter += 1
        
    

print("this is for all of the marbles out of style")
try_the_mocha()    
print('did it work razzle dazzle pumpkins')



#exit()





#modified to get nested switch #so after the first switch in the string 
#so it gets the switch that is nested.
###============================
## get second switch number
##=============================
def get_second_switch_number(stringname): #this might be for when
# I create copies of the switch body strings
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		if "switch" in line and "end" not in line and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y) 
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;
	
	
#input1 = rose[0]
#input2 = rose[1]
#print(input1)
#print(input2)
bigstringtest='''
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
    										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch #tail
							
									break
								default:
									print("we are done here")
							endswitch #46  2
'''

print('output should be it shoud return this string')
'''
							switch(exp){ #23
      								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2
							'''
							
print('october 12th testing doing actually test taking out inner switch')

bigstringtest1='''
	switch(exp){ #1
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #9
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch #tail
							
			break
		case 'tahoe bound':
				print('fun time now')
				exp ='fishy'
				switch(exp){ #25
					case 'fishy':
						print("do something")
						print("yep")
						fallthru
					case 'where now':
						print("nice")
						break
					default:
					print("we very done")
				endswitch #tail
				print('end of the game time')	
		default:
			print("we are done here")
	endswitch #46  2
'''

start = 10 #rose[0]+1
finish=20 #rose[1]+1
total = finish -start; #gives us 10
x= bigstringtest  #string name to cut out the range from 10 to 20 
skipping_some_lines(x,start,finish)
print(toosmart[0])
print('leaving this November 10th test now for skipping lines in string')
#exit()







peachtree=[]
several_three_tab_switches_list=[]
## get second switch numbers check if many #returns list of inner switch id numbers
##########################################################
## get_second_switch_numbers_check_if_many(stringname):
############################################################
def get_second_switch_numbers_check_if_many(stringname): #this might be for when
	print("get_second_switch_numbers_check_if_many(stringname): Grinch stole christmas")
	print(" ..get_switch_number.. ")
	awesome=''
	counter =0  #say it's 3
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter=0
	targetswitch =0
	for line in stringname.splitlines():
		tablength = line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:
			targetswitch += 1 
			counter += 1
		else:
			counter += 1
	#end loop
	print("this should return 2")
	print("number of switches at 3 tabs meaning first level =",targetswitch)
	
	#first check if tab length == 3
	counter=0
	smart=False #default setting
	for line in stringname.splitlines():
		tablength=line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3 and counter > 1 and "#" in line:
			x = line.split("#")  
			y = x[1];print(y)
			if ":" in y:
				y=y.replace(":","")
			print(y)
			several_three_tab_switches_list.append(y)
			peachtree.append(several_three_tab_switches_list)
			smart= True
			counter += 1
			continue
		else:
			counter += 1
			continue
		#print if the list is empty put a 0 in it
		print("special case test")
	if smart != True:	
		several_three_tab_switches_list.append(0)
		peachtree.append(several_three_tab_switches_list)
	#end loop
	print("this is key its NOT LOOKING FOR DEEPLY nested but only at 3 tabs >>")
	print("we are here now after filling switch list with inner switches at level 3 tabs")
	#print("several_three_tab_switches_list=",several_three_tab_switches_list)
	#print("this should return a list whith these two numbers in it 11 62")
	#for item in several_three_tab_switches_list:
	#    weasel=get_switch_number(testcode)
	#   


##==========================================================
# the issue is that on the second pass it is using the original string
# and it needs to be using the modified string
# changed it to start counter from 1 instead of 0 on Oct 5th, 2021
# because the numbering system of the string starts from 1 too.
	
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1	
##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
baton=[]
baton.append(0) #this creates the first slot 0
start=''
finish=''
string_name=''
switch_tab_depth=''
stringname=bigstringtest1
#this gets the endswitch line number that we need
#then I will call skip rope to finish the cutting out of the inner switch case


input_to_get_inner_switch=[]
string_after_cutting_out_inner_switch_body=[]
string_after_cutting_out_inner_switch_body.append(0)

hp=[]
hp.append(0)
lightning=[]
lightning.append(0)
#global concatthis;
	#this just might work 
	#this is a flag to pass the existing concatted string to be used fresh for next switch
	#this list is preset at False 
	#so this starts out false and passes thru it and then the list which used to have
	#FAlse in it has a string in it thereafter and the modified string from first pass
	#and subsequent passes is the new string to modify on the fly
	
#this requires the string name and start and finish to work
#this takes one nested switch with start and finish locations
#this method must be given start and finish in the params
#this prints out the new string after cutting out the nested switch except for the switch word
##========================================================================
## skip_rope_skipping_some_lines()  this cuts out ONE inner switch body
##========================================================================
def skip_rope_skipping_some_lines(string_name,start,finish):#start line nest switch and finish  endswitch
	print("start= ",start,"finish= ",finish)
	if string_after_cutting_out_inner_switch_body[0] == False: #starting
		print("it is False it is  empty ")
	else: 
		string_name = string_after_cutting_out_inner_switch_body[0]
		print('it is NOT False and therefore we fill the string from the list[0]')
	concatthis=''
	print("===skip_rope_skipping_some_lines(string_name,start,finish)====")
	#string_after_cutting_out_inner_switch_body[0]
	print(string_name)
	counter=0; #concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	print("string_name=",string_name,"start=",start,"finish=",finish)
	for line in string_name.splitlines(): 
		if counter > start  and counter <= finish: 
			#print(line) #it won't print the switch word since it's skipping it
			counter += 1; continue
		else: 
			concatthis += line + "\n"; counter += 1; continue
	#print('it created this SILLY STRING === multi colored silly string=')
	#print(concatthis)
	#print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
	weasel=string_after_cutting_out_inner_switch_body[0]
	#for line in weasel.splitlines():
	#	print(line)
	#return weasel  #I need to return from each for the piping to work correctly
	lightning[0] = concatthis
	#for line in lightning[0].splitlines():
	#    print(line)


##=====================================================
##  modern_take_out_endswitch(string):
##======================================================
def modern_take_out_endswitch(inputstring):
	print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			print("detected } in line")
			location = line.index("#")    #gets location from left where position of #
			line = line[:location] 
			print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			print("after left shift it is ",line)
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():




test_string1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown  1')
			fallthru	
		case 4 to 7:
			print('kangaroo hop hop!')#
			#############1
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################5
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default
											print("we very done") 
									endswitch 
							#############k
									break
								default
									print("we are done here")
							endswitch #46  
							#############k
							break
						default
							print("we are done here")
					endswitch #51   
					#############)
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #60  
			exp = 32
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default
					print("we are done here") 
			endswitch #86   
			##############)
			print('taught me how to write code')
			fallthru	
			 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		default
			print('the end')
	endswitch #100  
'''
test_string2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #23
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #31
								case 'fishy':
									print("do something")
									print("yep")
									fallthru
								case 'where now':
									print("nice")
									break
								default:
									print("we very done")
							endswitch 
					#############
							break
						default:
							print("we are done here")
					endswitch #46  2.......
					#############
					break
				default:
					print("we are done here")
			endswitch #51   3 ...
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''

test_string3='''
	switch(exp){ #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #23
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					####################
					switch(exp){ #31
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'where now':
							print("nice")
							break
						default:
							print("we very done")
					endswitch 
			#############
					break
				default:
					print("we are done here")
			endswitch #46  2.......
			#############
			break
		default:
			print("we are done here")
	endswitch #51   3 ...
'''

test_string4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  .
'''

test_string5='''
	switch(exp){ #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'where now':
			print("nice")
			break
		default:
			print("we very done")
	endswitch #41
'''

test_string6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'snow fire':
					print("nice")
					#############
					break
				default:
					print("we are done here")
			endswitch #77 5 .....
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86
'''

test_string7='''
	switch(exp){ #66
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'snow fire':
			print("nice")
			#############
			break
		default:
			print("we are done here")
	endswitch #77 5 .....
'''
# instead what if I feel a list of switches at 3 tabs and endswitches at 3 tabs
# and make pairs and then use the skip robe which already works and that way 
# I will reuse working code and based on the length of the switch list I just
# look in both lists at the same location position 0 and then 1 etc.
print("big test....starbucks morgan hill ========")

switch_list=[]
endswitch_list=[]
total_switches_at_3tabs_depth=[]

#delete helper lists first
def delete_helper_lists_first():
	del total_switches_at_3tabs_depth[:]
	del switch_list[:]
	del endswitch_list[:]
	
#this gets the important switch and endswitch at 3 tabs length which is critical.
def get_switch_and_endswitch_locations_in_string(string_name):
	print("====||||  get switch and endswitch locations in string  ||||======")
	delete_helper_lists_first()
	#count how many switches at tab depth 3
	####=================
	switchcount=0
	counter = 0
	for line in string_name.splitlines():
	    tabdepth = line.count("\t")
	    if "switch" in line and "end" not in line and tabdepth == 3:
	        switchcount += 1 #doesn't have ++
	        total_switches_at_3tabs_depth.append(counter)
	        counter += 1
	        continue
	    else:
	        counter += 1
	        continue
	####===================
	print("total switch at 3 tabs in this string",len(total_switches_at_3tabs_depth))
	print("they start on these lines",total_switches_at_3tabs_depth)
	#count_switches_at_threetabs= string_name.count("
	counter=0; concatthis =''; #finish = finish + 1 
	print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'switch' in line and "end" not in line and tabdepth == 3: 
			switch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("phase 2 here ====")
	counter=0; concatthis =''; #finish = finish + 1 
	#print("string_name=",string_name)
	#this looks for switch at 3 tabs depth and adds line number of switch
	for line in string_name.splitlines():
		tabdepth = line.count("\t")
		if 'endswitch' in line and tabdepth == 3: 
			endswitch_list.append(counter)
			counter += 1
			continue
		else:
			counter += 1
			continue
	print("switch_list=",switch_list)
	print("endswitch_list=",endswitch_list)
	print("end of line...")
	########################======
	
	########################==========
print("calling get switch and endswitch locations (only one set) in string ")
#this needs to be done first ===== before calling the function

print("should be 1 for this test")
#del switch_list[:]
#del endswitch_list[:]
print('real test now i really need this puppy to work')





#del total_switches_at_3tabs_depth[:] #empty it first 
#del switch_list[:]
#del endswitch_list[:]
#print('real test now in string with more than one inner switch at 3 tabs should be 2')
get_switch_and_endswitch_locations_in_string(test_string1)
#mylist=[]
#mylist.append(5)
print("did it even work or not?!---00000000000000000 mocha")
#exit()

'''
print("======experimenting with test_string1========")
if total_switches_at_3tabs_depth[0] > 1:
    number_to_loop = total_switches_at_3tabs_depth[0]
    print("number to loop=",number_to_loop)
else:
    print("nope only one inner switch at 3 tabs")   
if number_to_loop == 2:
    print("True that number to loop = 2")
    print("1st loop == ")
    x = 0
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
    print("2nd loop === ")
    x=1
    start  = switch_list[x]
    finish = endswitch_list[x] 
    print("start=",start)
    print("finish=",finish)
#end if
'''      
#mylist.append(17)
print("doing test_string6")

print("halloween is nearly here test======..........")
print("switchlist =",switch_list)
print("endswitchlist =",endswitch_list)
print("==============")
#start  = switch_list[0]
#finish = endswitch_list[0]
#currently skip rope method only does one switch to endswitch set so I would use a loop
#and put skip rope in it to do multiple ones


# input 62, look in dictionary to get the 86
# input 11, look in dicitonary get the 60 
print('testing test_string2 ...')
#start = 5
#finish = 41
#this needs to be called first 
print('testing test_string2')
###====-=====================================================
print("this has to be done fifrst need to get switch and endswith lcoations")
print("=======")
#delete_helper_lists_first() #trying this out

print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string

print('we have switch_list=',switch_list)
print("endswitch_list=",endswitch_list)
print('........... what do the lists say above ....')
start  = switch_list[0]  #5
finish = endswitch_list[0]  #41   #below this means that it's empty, False to set flag
string_after_cutting_out_inner_switch_body[0]= False #set this to False first
print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
print("======testing string2======")
skip_rope_skipping_some_lines(test_string2,start,finish)
###=======================================================
#exit()
###======================================================================
print("=======testing test_string6======")
#this is only designed to cut out ONE inner switch 
print("calling skip rope skipping some lines with inputs ",start,"and ",finish)
skip_rope_skipping_some_lines(test_string6,start,finish)

print('now string1 with 2 nested switches=== star trek time====')
print("testing 1..")
#need to find the switches locations and work from the bottom up so do second inner switch first
#that's how the macros work bottom up that way I can use the numbering input correctly. 


### here it has to do the cutting out in reverse since more than one inner switch to cut out
### I learned this trick from my macros solution
#### relooking at this on oct 22nd friday, at 10:46 am 2021
###=========================================================================
#this will be a special method for dealing with reducing down 2 or more inner switches to switch word
print("PUFF THE MAGIC DRAGON === THIS SHOULD ALREADY WORK== ")

# need to make this into a method that has some fuzzy logic
print("TESTING WITH 62 AND 86 SKIPPING ROPE")
#this needs to be put into a method 
#this needs to be set to False to work correctly.
#first we set it to False


#what this does is go thru a list that is in reverse order to cut out thru skipping
# a string to take out inner switches at 3 tab level.  it actually works.
# I need to have a modified one if only one list 

#we will have a loop ::; put this together on Friday, October 22nd, 2021 at 11 am
#string_after_cutting_out_inner_switch_body[0]= False 
#if len(inputlist) == 1:  good if only one list and reverse calls it does nothin
#what this does is loop thru a list of switch endswitch at 3 tabs and does more than one


###========================================================================
## convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
###=========================================================================
def convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):
    print(" ====convert_switch_with_more_than_one_inner_switch_at_3_tabs(stringname):==== ")
    string_after_cutting_out_inner_switch_body[0]= False        #necessary default flag 
    counter=0 #where am I filling inputlist?
    for item in inputlist: #this grabs the params from item     #list of switches pairs start stop at 3 tabs depth
        start = item[0];
        finish = item[1];
        print('start=',start,'','finish=',finish)                       #62; finish=86 
        skip_rope_skipping_some_lines(stringname,start,finish)  #this copies the string skipping the range designated
        counter +=1
        print("counter=>>",counter)
        print("=====================")
    print("at bottom of converts  with more than one inner switch at 3 tabs")
    print("testing if weasel is returnable at the end of the function")
     #this is after it's done
    #for line in weasel.splitlines():
    #    print(line)
    #return weasel 

	
print("I am fillilng the inputlist right here manually force feeding it.")
#this calls it but right now I want to know where I fill th einputlist
inputlist =[]
inputlist.append([11,60])
inputlist.append([62,86])
print(inputlist)
inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

print("after reversing the list we now have===")
print(inputlist)
print("convert switch with more than one inner switch at 3 tabs(stringname)==== string1")
#get_switch_and_endswitch_locations_in_string(test_string1) #presumes one inner switch 
print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
print("THIS IS THE BIG CHRISTMAS TEST =====*******=====")
print("====real deal here ===GET SWITCH AND ENDSWITCH LOCATIONS========")
print("this needs to be called first get_switch_and_endswitch_locations_in_string()")
#get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
#print('we have switch_list=',switch_list)
#print("endswitch_list=",endswitch_list)
#it needs to make these [[11, 60], [62, 86]]
###testing nov 27th at 10:46am starbucks
print('important testing on Saturday morning')
trialinputlist=[]
inputlist =[]

#made nov 27th, satgurday 4:15pm morgan hill starbucks 
##===========================
## build_trail_inputlist()
##===========================
def build_trial_inputlist(): #this combines switch and endswitch into pair into trialinputlist
	del inputlist[:] #this empties the input list discarding previous data in it
	del trialinputlist[:]
	print("build_trail_inputlist()..")
	counter=0;
	for item in switch_list:
		pair=[switch_list[counter],endswitch_list[counter]]
		trialinputlist.append(pair)
		counter += 1
		
	print("look for the ball on the green")
	print("trialinputlist=",trialinputlist)
	for item in trialinputlist:
		inputlist.append(item)
	print("inputlist=",inputlist)
	for item in inputlist:
		print(item)
	inputlist.reverse() #is this needed here or not 

	
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
print('end of the show sunday morning blues coding')
print("Super silly string 1 PHASE 1 taking out two nested switches at 3 tabs location bottom one first")
print('end of the show sunday morning blues turkey day 2')
print('doing the same string a 2nd time to see if it works')
print("............................................")
print("now trying test_string2")
#del switch_list[:]
#del endswitch_list[:]
print("do you see what I see??")
#inputstring=test_string1
outputstring=[]
outputstring.append(0)
snowboarding=[]


##=================================
## take_out_switch_body(astring):  #def foxnews(astring):
##================================
def take_out_switch_body(astring): #this was foxnews
	nestedswitch= False
	print("take_out_switch_body(string)      today is november 28th sunday  4:29 pm ")
	#right here look if a switch at 3 tabs if not skip below
	####=== new as of monday december 6th, 2021 =========================
	#determine if 
	for line in astring.splitlines():
		tabcount =line.count("\t")
		if "switch" in line and tabcount == 3:
			print("yes switch at 3 tabs in line")
			print("frosty says switch at 3 tabs confirmed")
			nestedswitch= True
			break
	print("frosty the snow man light test for nested switch")
	print("nestedswitch=",nestedswitch)
	print("==================================")
	if nestedswitch == False: #what this does is put the input string into output
		#add input into output  this means no changes were done to the switch string
		print("this switch string DOES NOT have an inner switch")
		lightning[0]=astring 
	else:
	##======= this is down here now ========december 6th 2022 =========
		get_switch_and_endswitch_locations_in_string(astring) #for this switch string
		build_trial_inputlist()	 #this is new 
		convert_switch_with_more_than_one_inner_switch_at_3_tabs(astring)
	#end if
	##########================================================================
	print("frosty snowboarding")
	#december 6th looking where I am not adding31 and 66 
	
	print("this is new code now today is Monday november 29th now Dec 6th.")
	print("what is in lightning[0] now")
	#print(lightning[0])
	
	print("resulting final output of take_out_switch_body:") 
	snowboarding.append(lightning[0])  #this is new dec 6th monday
	for line in lightning[0].splitlines():
		print(line)


print("testing this 2nd method")
print("testing take_out_switch_body now") 
print("========TAKE OUT SWITCH BODY()========")
take_out_switch_body(test_string1) #the first one has more than one inner switch it takes out
take_out_switch_body(test_string2)
take_out_switch_body(test_string3)
take_out_switch_body(test_string4)
take_out_switch_body(test_string5)
take_out_switch_body(test_string6)
take_out_switch_body(test_string7)

#gotta take out } in switches 
print("big test if it works right or not")
print("printing out snowboarding list") 
#this should print out just the final product
print("SNOWBOARDING LIST OUTPUT")
counter=1
for item in snowboarding:
    print("counter=",counter)
    print(item)
    print("========")
    counter +=1
    
    

#exit()
   
#def finally_reduce_inner_switches_at_three_tabs_into_switch_word(inputstring):
print("where is the christmas tree test===== doing test_string  1 ===========")
get_switch_and_endswitch_locations_in_string(test_string1) #for this switch string
build_trial_inputlist()	 #this is new 
print("right here what is in inputlist=",inputlist) #needs to be reversed
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string1)
print("end of christmas tree test test string 1 with 2 nested switches at 3 tabs")
#exit()

print("where is the christmas tree test===== doing test_string   2 ===========")
get_switch_and_endswitch_locations_in_string(test_string2) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string2)
print("anotehr one 3")
print("where is the christmas tree test===== doing test_string  3 ===========")
get_switch_and_endswitch_locations_in_string(test_string3) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)


print("where is the christmas tree test===== doing test_string  4 ===========")
get_switch_and_endswitch_locations_in_string(test_string4) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)


print("testing another one now===== doing test_string  6 ==========")
get_switch_and_endswitch_locations_in_string(test_string6) #for this switch string
build_trial_inputlist()	 #this is new 
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)

#exit()

# method chaining
# getone.getteo.getthree()

#=======
#Bottom of chain methods result if methods goes into
#output[0]

#Where is transform_string() called

#https://www.google.com/amp/s/nypost.com/2021/11/11/ufos-buzzing-us-warships-may-be-aliens-top-spy-chief/amp/

#Good stuff

#https://m.youtube.com/watch?v=azZ4XAZuVk4




print(inputlist)
#inputlist.reverse() #reversing the list since the cutting out must be done bottom up to work properly

print("after reversing the list we now have===")
#print(inputlist)
#get_switch_and_endswitch_locations_in_string(test_string2)
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string2)
print('pizza for dinner maybe')
#exit()

#inputlist =[]
#inputlist.append([10,36])


#get_switch_and_endswitch_locations_in_string(test_string3)
print('end of the show sunday morning blues turkey day 3')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string3)

#rint('end of the show sunday morning blues turkey day 4')
#convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string4)
inputlist =[]
inputlist.append([5,16])
print('end of the show sunday morning blues turkey day 6')
convert_switch_with_more_than_one_inner_switch_at_3_tabs(test_string6)
print("wow wow")


#string_after_cutting_out_inner_switch_body[0]= False  #just filler but a flag meaning empty

#exit()
#print("testing input 62, 86 skipping rope")
#start=62; finish=86  #[62,86] #input values fed into it 
#skip_rope_skipping_some_lines(test_string1,start,finish)#62,86

#start=11; finish=60  #[11,60]
#skip_rope_skipping_some_lines(test_string1,start,finish)#11,60

print(" super silly string 2 PHASE 2 taking out 2nd nested switch (the higher first one done second) at 3 tabs")
print("TESTING WITH 11 AND 60 SKIPPING ROPE")
print("testing 11,60 inputs for skip rope skipping some lines ")
print("testing 2...") 







print("after doing this which needs to be made into a function with a loop")
print("it will need input of [[11,60],[62,86]] that I reverse if more than one in it")
#listname.reverse()
#so I can use teh same string to do both cuts out of inner switches 
#first     62,86
#second is 11,60

#exit()
#skip_rope_skipping_some_lines(string_name,start,finish)
#critical_list= [[11, 62], [15], [23], [31], [0], [66], [0]]
#end of show

# tuesday, october 19th, 2021  time 9:52 morgan hill starbucks
#==================================
# cut_out_switch_body_no_params   october 19th tuesday
#==================================
#abandoned this appraoch 
# objective is to go through string and take out switch bodies without inputs
'''
def cut_out_switch_body_no_params(string_name):
	print("cut out switch body no params===")
	counter=1; concatthis =''; #finish = finish + 1 
	#switch is the start line though we are skipping after it and keeping it
	#the start line is the switch which will be preserved but skipping when cutting out
	#start  = input_to_get_inner_switch[0]
	#finish = input_to_get_inner_switch[1]
	
	#what about a quick search for locations of switch and endswitch
	for line in string_name.splitlines(): 
		if "switch" not in line and "endswitch"  not in line and tabdepth != 3:
			print(line)
		#notice start +1 based on line number 
		tabdepth = line.count("\t")
		if "switch" in line and "end" not in line and tabdepth == 3:
		#actaully I don't want 
			concatthis += line + "\n"; counter += 1; continue
			print(line) #it won't print the switch word since it's skipping it
			
		 else: 
			 counter += 1; continue
		if "endswitch" in line and tabdepth == 3:
			print(line)#get current line then break
			concatthis += line + "\n"; counter += 1; continue
			#break
	print("===output from skipping some lines====")
	print('it created this SILLY STRING === multi colored silly string=')
	print(concatthis)
	for line in concatthis.splitlines():
		print(line)
	print("=======")
	print("I would put this into a list to store for later")
	string_after_cutting_out_inner_switch_body[0] = concatthis
##========== new version 
	print("here we have the halloween special START SKIPPING ROPE...")
	print("the output string looks like this")
	weasel=string_after_cutting_out_inner_switch_body[0]
	for line in weasel.splitlines():
	    print(line)
'''	
	
	
print("testing cutting out the inner switch bodies to see if it works")	
#cut_out_switch_body_no_params(test_string6)
### this is now working correctly taking into account
# that lines start from 0 not 1 and I need to skip and include the switch word


#next go thru list of stirngs and take out inner switches bodies


#Never theorize before you have data.Invariably you end up twisting facts to suit theories instead of theories to suit facts. -Sherlock holmes.
#There is nothing more deceptive than an obvious fact


##================================= testing at starbucks gilroy christmas tree
#####transform_string() #12379






##========================================================================
##  def next_metamorphosis_take_out_inner_switch(stringname,switch_number):
##=========================================================================
def next_metamorphosis_take_out_inner_switch(string_name,switch_number):
	print("==next_metamorphosis_take_out_inner_switch)====")
	print("==next_metamorphosis_take_out_inner_switch)====")
	switch_tab_depth=''
	counter=1 #look we are starting to count from 1
	startcount =0
	endswitchline=0
	end_switch_tab_depth=''
	#get inner switch location all we know is the switch line number 31 in this case 
	#get switch_tab_depth
	print("the switch_number=",str(switch_number))
	for line in stringname.splitlines():   #switchnumber 31
		if "switch" in line and  "end" not in line and "#" in line and str(switch_number) in line:
			print("31 in line and switch in line and end not in line and # in line ALL TRUE")
			switch_tab_depth = line.count("\t") #gets tab depth
			startcount= counter
			end_switch_tab_depth=switch_tab_depth #see if this works now
			break
		else:
			counter += 1
			continue
	#get endswitch location
	print("startcount =",startcount) #targer switch line number 
	print("target switch_tab_depth =",switch_tab_depth)
	print("END OF PHASE 1 ...")
	
	#get endswitch tab depth
	print("============================")
	counter = 1 #get endswitch tab depth
	for line in string_name.splitlines():
		this_line_tabs= line.count("\t")
		if "endswitch" in line and counter > startcount:
			this_tab_depth = line.count("\t")
			if counter > startcount and this_tab_depth == switch_tab_depth: #this means endswitch must be AFTER switch
				endswitchline = counter
				#the tab depth MUST be the same as the target switch tab depth 
				break
			else:
				counter +=1
		else:
			counter += 1
			continue
			
	print("end_switch_tab_depth=",end_switch_tab_depth)
	print("the end switch line=",endswitchline)
	print("=============================")
	print("END of PHASE 2...")
	counter =1
	for line in string_name.splitlines():
		if "endswitch" in line and counter == endswitchline:
				endcount = counter
				break		
		else:
			counter += 1
	
	startcount = startcount-1 #because we skip switch and keep it. 	
	print("output of next_metamorphosis()")
	print("startcount=",startcount) #oh this is brilliant
	start = startcount
	print("the endswitch line =",endswitchline)
	finish = endswitchline
	print('start=',start)
	print('finish=',finish)
	input_to_get_inner_switch.append(start)  #[0]
	input_to_get_inner_switch.append(finish) #[1]
	print("start=",input_to_get_inner_switch[0])
	print("finish=",input_to_get_inner_switch[1])
	print("switch_tab_depth=",switch_tab_depth)
	#now I can run the skip lines code that requires the start and finish range numbers
	print(" END of PHASE 3 ...")
	print("again this doesn't modify the switch string it just gets input data")
	print("for the next phase which is skipping rope")
	
#notice start +1 based on line number 
#		#because numbers are off by 1 since starting at 0 not 1 in counting
#		#if counter > start +1 and counter <= finish: 
#		if "endswitch" not in line and this_tab_depth == switch_tab_depth: 
#			print(line) #it won't print the switch word since it's skipping it
#			counter += 1; continue
#		else: 
#			concatthis += line + "\n"; counter += 1; continue
#	print("===output from skipping some lines====")
#	print('it created this SILLY STRING ====')
#	print(concatthis)
	
#for the first pass flag_test[0]= False and then it's flipped to True
	#print("flag_test[0]=",flag_test[0])
	#if flag_test[0] == False or flag_test[0] == None: #meaning first pass  and what it's set to by DEFAULT
	#    smart=x;
	#    #change it to True now
	#    flag_test[0] = True #this should now be tru e
	#else: #meaning TRUE this is run after first run of skipping_some_lines()
	#    x = baton[0]
	### look that we have the counter here set to 1 by default 
	



#===========================
print("HERE WE START METAMORPHOSIS ENTERING THE MATRIX...")
#this one has to be called first since it creates the start and finish lines for this string
#based on what the switch number is in the comment which it will look for
#and the inner switch line numbers will be known beforehand
#because they are automatically added 

#def take_out_inner_switch_bodies(thestring):
#first I need to get the nested switch number (assuming one at this point)
## I need to make this into a method witht he two functions below
#working on this october 14th, 2021 gilroy 6:55pm

#I need to get the inner commented switch number 
###=====================================================
print("three, two,one, blast off===>>>")
string_name= bigstringtest # <=== string is in here 
#I need to put the method here that gets the switch comment number
#switch_number=31 #I need to get this number automatically
#this will be different if there are more than one inner switch at 3 tabs length
#I still need to clean up the copied switches so the first switch is at 1 tab
#and the next next level switches start at 3 tabs
#for this first attempt we will limit the inner switches to just one
axis=get_second_switch_number(bigstringtest) #returns 31
#should be 31 
print("axis should be 31",axis)
switch_number = axis #finally getting closer to victory
####===============================
#I have code that get the inner switch number if only one
#and I have code that can find all inner switches at 3 tab level depth 
#what this does is rip out the nested switch body leaving the switch
# word in the nest_list after separating the switch bodies
#this is an important step and I just figured out how to
# detect if more than one inner switch at the three tab level depth
## make this into a method now

# I also got the code to get the second switch in a string line number  in the comment
#which will invariably be different from the true line number, but that's okay.
#=================================================
#=================================================
#=================================================
#=================================================
##========== halloween darkness  oct 14th ===================


print("cinderella")

get_second_switch_numbers_check_if_many(foolish)
print("the result of the  if_many method is to put the inner switches numbers at 3 tabs")
print("into the list which is below")
print("several_three_tab_switches_list=",several_three_tab_switches_list)
print("")
print(" back to the future should be above for stirng foolish")

print("testing bigstringtest1")
print("let us see if this works...")
print("the dark knight is here")
del several_three_tab_switches_list[:]
print('here we go')
get_second_switch_numbers_check_if_many(bigstringtest1) #using bigstringtest1 now
start=''
finish =''

print('end of this test of get second swithc numbers check if many')
print('waiting to get it working')


#I need to go thru each string and count the switches at 3 tabs
#do the loop jazz too.
##=========================================================
##  count_inner_switches_at_first_level(inputstring)
##=========================================================
def count_inner_switches_at_first_level(inputstring):
	print("=====count inner switches at first level=== so at 3 tabs ==")
	counter =0
	innerswitch = 0
	for line in inputstring.splitlines():
		tabdepth = line.count("\t") #added and "end" not in line to eliminate endswitch bug
		if "switch" in line and "end" not in line and tabdepth == 3:
			print("the line number is ",counter)
			linewithswitch =counter
			innerswitch += 1
			counter += 1
		else:
			counter += 1
			
	print("innerswitch count at 3 tabs in this string=",innerswitch)
	print("the line number of the sole inner switch is",linewithswitch)
	return innerswitch;

inputstring = bigstringtest1
#this counts inner switches at 3 tabs indentation in a switch string
total=count_inner_switches_at_first_level(inputstring) #calls the method above


print(" we are done here, of the number of inner switches at 3 tabs = ",total)
#where do I get the inner switch number??
print("=========.........")
print("=========....halloween pumpkins are coming.....")
print("=========.........")
 #this calculates the start and finish of one nested switch 
string_name=bigstringtest1 #I need to find the get switch number for inner switch
switch_number=several_three_tab_switches_list[0] #this presumes only one inner switch
switch_number = int(switch_number) #right here a miracle occurs==== 
print(type(switch_number)) #this gets the start and finish numbers for inner switch to cut out
next_metamorphosis_take_out_inner_switch(string_name,switch_number)
print("it should be 9 and 20 and it shows...")
#all this does is create the start and finish line numbers of one inner switch
print(input_to_get_inner_switch[0])  
print(input_to_get_inner_switch[1])
print("string_name=",string_name,"start=",start,"finish=",finish)

print("go for the gold medal===================")
string_name= bigstringtest1
#I am feedingit 9 and 20 to start with here 
#here the inner start and finish of an inner switch is inserted
start =input_to_get_inner_switch[0]#9  #=input_to_get_inner_switch[0]  #9 #1 after switch line number so it really does 10 compensating 
finish=input_to_get_inner_switch[1]#)20 # =input_to_get_inner_switch[1] #=20
print("SKIPPING ROPE NOW to modify the string and cut out inner switch")
skip_rope_skipping_some_lines(string_name,start,finish)
#skip rope takes out the inners switch leaving the inner switch word.
print("The GREEN EXIT SIGN NOW")
#exit()
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================
#=================================================

#skip_rope_skipping_some_lines(string_name,start,finish)
#it needs to return values to start and finish as input for 
#skip_rope_skipping_some_lines(string_name,start,finish)

#now I need to count switches in a string
#and as a backup safety count endswitches also.


#I can work on these separately actually 
################
teststring1='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the flying dog house!")
			print('first prize')
			print('you block head Charlie Brown 2')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!'); exp= 'blable'
			#############
			switch(exp){ #11
				case 'blable':
					print("do sw 11")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  
							#############
							break
						default:
							print("we are done here")
					endswitch #51   
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   
			exp = 3
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86   
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
	endswitch #100  
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [11, 60]
#counter= 2
teststring2='''
			switch(exp){ #11
				case 'blable':
					print("do something")
					####################
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #60   4..........endwitch 4  line 60 3 tabs 
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [15, 51]
#counter= 3  THIS IS 5 TABS IN FIRST LINE 
teststring3='''
					switch(exp){ #15
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									####################
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
							#############
									break
								default:
									print("we are done here")
							endswitch #46  2.......
							#############
							break
						default:
							print("we are done here")
					endswitch #51   3 ...
'''


#==========-----------seperated nest strings -----------------
#getting data in blueberries [23, 46]
#counter= 4 this one works 
#I have to reduce these downto first tab and then three tabs
teststring4='''
	switch(exp){ #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################
			switch(exp){ #31
				case 'fishy':
					print("do something")
					print("yep")
					fallthru
				case 'where now':
					print("nice")
					break
				default:
					print("we very done")
			endswitch 
			#############
			break
		default:
			print("we are done here")
	endswitch #46  2.......
'''
#==========-----------seperated nest strings -----------------
#getting data in blueberries [31, 41]
#counter= 5
teststring5='''
									switch(exp){ #31
										case 'fishy':
											print("do something")
											print("yep")
											fallthru
										case 'where now':
											print("nice")
											break
										default:
											print("we very done")
									endswitch 
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [62, 86]
#counter= 6
teststring6='''
			switch(exp){ #62
				case 'burger':
					print("do something")
					####################
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #86
'''

#==========-----------seperated nest strings -----------------
#getting data in blueberries [66, 77]
#counter= 7   THIS IS 5 tabs in first switch line 
teststring7='''
					switch(exp){ #66
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch #77 5 .....
'''

#==========-----------seperated nest strings -----------------
print("moving tabs out.")
print("testing moving extra tabs out of a string")
print("this is looping thru teststring3 ")
print("Grand Canyon test Friday")
print("I will take out 5 tabs from the front of each line")
for line in teststring3.splitlines():
    print(line)
print("end of test of printing out teststring3")
print(" ")
counter =0
switch_actual_tabs=[]
switch_actual_tabs.append(0)
import re
onetab="\t"  # here is onetab declared with one tab inside of it
fishbowl=[]
fishbowl.append(0)




#sunday confirmation number sundayoct 17th, 2021
holdon=[]
holdon.append(0)
holdthis=[]
holdthis.append(0)
galaxy=''
#this swaps endswitch with }
#what this does is replace endswitch with '}
###===================================
##  take_out_endswitch(stringname)
###===================================
def take_out_endswitch(stringname):
	print("take_out_endswitch()  called=====")
	answer=''
	galaxy = stringname
	print(galaxy)  #using replace endswitch with }
	#this replaces all endswitch(es) to }
	holdthis[0] = galaxy.replace("endswitch","}") #added here
	#bug what if there is already a curly brace but no endswitch
	print(holdthis[0])
	#move it to left
	answer = holdthis[0]
	newstring=''
	for line in holdthis[0].splitlines():
		if "}" in line and "\t" in line:
			line = line.lstrip()
			newstring += line
		else:
			newstring += line + "\n"
			
	holdthis[0] = newstring
	
	print(holdthis[0])
	for line in holdthis[0].splitlines():
		print(line)
		
	#return answer;
	
	#galaxy = holdthis[0]
	#holdon[0] =holdthis[0]
	#return galaxy
	
	
	
	
	

##==========================================
## shift_nest_string_to_left(stringname)   made on oct 15th, 2021 8:57 am
##==========================================
def shift_nest_string_to_left(stringname):   #cuts out tabs and adds new tabs automatically
    print("========= shift_nest_string_to_left(stringname ===... =====")
    for line in stringname.splitlines():
        print(line)
    #print("this is th einput string====")
    newline=''
    counter=0
    thismatters=''
    print("shift_nest_string_to_left() called")
    for line in stringname.splitlines():
        tabslength = line.count("\t") #this is set up for string3 initially. 
        print("tabslength=",tabslength)
        #counter +=1
        if counter == 1 and "switch" in line: #just added this oct 15th 
            #print(line)
            #print("we care about THIS ONE",tabslength)
            switch_actual_tabs[0] = tabslength
            #print("switch_actual_tabs[0]===",switch_actual_tabs[0])
        else:
            print("he well")
        print("=================>>>=======")
        #For teststring3  if 5 tabs in first line then tabslength-4  because it has 5
        ##==================================================================
        clever=0 #starting give it default value of 0 
        #this one works
        if switch_actual_tabs[0] == int(5): #5-4
            clever = 4
            #print("let's see if clever is an int here")
            #print(type(clever))  
            
        #for some reason this if below is not working right    
        if switch_actual_tabs[0] == int(3): #3 - 2 #reducing to 1 tab on first line
            clever = 1
            #print("let's see if clever is an int here")
            #print(type(clever))  
        #so if 5 -4 giving us 1
        #if 6 -5
        #if 7 -6 giving us 1
        #if 4 -3
        #if 3-2
        #if 1 do nothing
        #this is based on it having 5 tabs in line one and minus 4 tabs
        #if tabslength == 3:
        #    tabslength = 1; #which is -2
            
        #if tabslength == 5:
        #    tabslength = 1 #which is -4
        #I think what I need to do is determine indentation before first switch to gauge it    
        print(" switch_actual_tabs[0]=", switch_actual_tabs[0])
        #total_tabs_to_add=''
        ##########################################
        #if 5 tabs then -4
        #if 3 tabs then -2
        total_tabs_to_add=''   #this was 4 changed it to celver
        print("at this point what is the value of clever",clever)
        total_tabs_to_add =int(tabslength) - int(clever) # reducing it to 1 taking 4 tabs off  #right here 
        print("====")
        print("at this point what is the value of total tabs to add",total_tabs_to_add)
        #print("position 1 type test")
        #print(type(total_tabs_to_add))
       
        #this is what I took out above and replace with below 
        #total_tabs_to_add = ''
       # print("testing boolean condition here ....")
        print("tablength in first switch line =",tabslength)
        #====== if tablength = 5 -==========================
        if tabslength == 5:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 4 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
        #end if
        print("====")
        #number one rule code does exactly what you tell it to do. 
        #====== if tablength = 3 -==========================
        if tabslength == 3:
            #print("TRUE HERE flying horse to locate this ")
            total_tabs_to_add = tabslength - 2 #TO GET 1
            print("total tabs to add right here =",total_tabs_to_add)
            
        #print("position 2 type test")
        #print(type(total_tabs_to_add))
        
        #if tabslength == 3:
        #    total_tabs_to_add = tabslength - 2 
        #end if
        #print("=====")
        #print("position 3 type test")
        #print(type(total_tabs_to_add))
       
        #print("so this line will have this many tabs in front",total_tabs_to_add)
        total_tabs_to_add = total_tabs_to_add * onetab #times 1 tab #0 x 1 = 0
        print("RESULT= total_tabs_to_add to each line",total_tabs_to_add)
        myString = line
        output   = re.sub(r"[\t]*", "", myString)    #takes all tabs out of this line
        newline += total_tabs_to_add + output + "\n" #this puts the tabs in front of the stripped string line
        counter +=1
        continue
    #print('the result is..')
    print("this prints out the output what the changed indentation shift to left looks like")
    #return newline
    fishbowl[0] = newline  #the output of shifting to left 
    for line in newline.splitlines():
        print(line)
#print("drink coca-cola test")
#print("TESTING 3")    
#print("starbucks breakfast of friday testing..")
#print("testing indenting correclty teststring3")
#shift nest string to left
shift_nest_string_to_left(teststring3) #good 5 TABS DOWN TO 1
print("red alert test 3 shift nest stirng to left side ... test 3 ")
print("look carefully at this and make sure that it's right with just one tab at top")
print("testing with string skitahoe")
shift_nest_string_to_left(skitahoe) 
print('first we will do this simple test with no tabs see if it returns 0')
practicestring='''
switch(exp){
    case 1:
        print('hello')
'''
tabsinthisline =''
for line in practicestring.splitlines():
    if "switch" in line:
        tabsinthisline = line.count("\t")
        print("tabsinthisline=",tabsinthisline)
        break
        
print("TESTING string 7 now indenting it to the left")
shift_nest_string_to_left(teststring7) #good 5 TABS DOWN TO 1
print("red alert testing shift string to left")




	
	
	
#exit()

#exit()
print("end of testing of doing indentation shifting to string")
print("oct 26th nearly done with this.. line 6127 ")
#exit()

print("this is where I am indenting the switch strings already in a list")
print("I need to indent them to work on them further to prepare them for the parser")

gold_list_results=[]
newstring=[]
newstring.append(0)
##=================================
##  manipulate_string(addstring) #this appends the changed switch strings to gold_list_results
##=================================
print('testing taking out 2 ')
def manipulate_string(addstring):
    print("======manipulate_string() called line 8524=======")
     #the objective is to reduce tabs so only 1 tab in front of first switch in string
    cutout=''
    print("let us ORIGINLAL INPUT STRING HERE look at the starting input string before modifying it")
    for line in addstring.splitlines():
        print(line)

    print("== red white and blue ==============")
    print("=======pinpointing bug on november 30th =============================")
    print("getting tab count in front of first switch here")
    for line in addstring.splitlines():
        if "switch" in line and "end" not in line:
        #this determines the number of TABS in this line
            tabsinthisline = line.count("\t")
            print("tabsinthislines=",tabsinthisline)
            print("the tabs in front of first switch are",tabsinthisline)
            #the objective is to have only 1 tab in front of first switch
            # which then propogates down the length of the entire string
            if int(tabsinthisline) > 1:    #example
                cutout = tabsinthisline -1
                print("tabsinthisline =",tabsinthisline);
                print("cutout =",cutout)
                break
            if tabsinthisline == 1: #which means do nothing we want just 1 tab first
                cutout = -1; #this is using -1 as a flag
                break
            if tabsinthisline == 0:
                break
            # do nothing   193241613
     #take out just 2 tabs
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    print("now doing ===== SECOND PHASE ======of manipulate_string")
    super=''
    lastchar=''
    for line in addstring.splitlines():
        #if "switch" in line and "end" not in line:
        tabsinthisline = line.count("\t")
        #it does all lines of the string taking out the first 2 tabs which are chars
        if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
            sliced = line[cutout:] #this can be a variable
            print("sliced sees",sliced)
            #phase A ============================
            
            print("================================")
            print("======phase A sliced=",sliced)
            ### bug fix ##===========================
            #reput in on dec 5th sunday 
            print('this fixes the bug that was putting junk after each line')
            print('adding extra : ) u #')
            print('see if it works ... again')
            ###############################
            ###### testing bug fix dec 5th sunday ######################
            #this tests if last character is #,),u,:
            #print("the last char is sliced[-1]",sliced[-1])
            #tail = sliced[-1]
            #looklist=[]
            #looklist=["#",")","u",":"]
            #if tail in looklist: 
            #   print("yes last char is either #,),u,:")
            #   sliced=sliced[:-1]
            #else:
            #  print("none of the garbage characters are the last char")
            #   pass
            ################################
            ################################    
            ##========================================
            
            
            #if len(sliced) >0:
            #    lastchar=sliced[-1]
            #    #print("lastchar =",lastchar)
            #   # print("TRUE weird last character",lastchar)
            #    if lastchar == ":" or  ")" or  "u" or   "#":
            #        sliced=sliced[:-1]  
            #========================== bug fix on nov 30th Tuesday hollister starbucks===============================    
            #    sliced=sliced[:-1]
            #else:
            #    print("last char must be 0")
               # print("length of sliced =",len(sliced))
            #print("after teh change the line looks like ",sliced)
            #print("====did it work or not=============")
            
            
            ################################################################
            ## this takes out the last char at end of the line
            #get last character
            #=============================
            #sliced=sliced[:-1]
           # if any of these are True  :),u,#
            #print("====  testing if last character : ) u # ==== ")
            #if lastchar == ":" or  ")" or  "u" or   "#":
             #   print("TRUE weird last character",lastchar)
            #    sliced=sliced[:-1]
            #else:
            #    print('current last char is',lastchar)
                
               
                
            #if sliced[-1] == ":" or  sliced[-1] == ")": or sliced[1] == "u": #
            #    sliced=sliced[:-1]
            #end if
            #===============
            
            #sliced=sliced[:-1] #this is new but when does this occur and why?
            #this is new nov 30th, tuesday hollister starbucks
            
        else: #this means its equal to 0
            #scenario zero tabs in front of first switch starting
            if tabsinthisline == 0:#this handles if there are zero tabs in front of switch line
                sliced = "\t" + line; # add one tab if zero tabs.
                #phase B ============================
                
                print("================================")
                #print("=====phase B sliced=",sliced)
            else:
                #phase C ===================
                sliced =  line; #maning this has at least 1 tab already
                
                print("================================")
                #print("=====phase C sliced=",sliced)
        super += sliced + "\n" # this does all lines in the string
        #=== super 1 ==================
        #print("SUPER 1 =",super)
        #scenario if it's already perfect at 1 tab length in front of switch
        if cutout == -1:  #this means tabs in this line determined to be 1
            super += line 
            #super 2  =====================
            
            print("================================")
            #print("SUPER 2 sliced=",super)
        #end if
    print("================ taking out 2 tabs quickly and dirtily")    
    print("this is the output SUPER lines to see the result")
    print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
    for line in super.splitlines():
        print(line)
    return super #this should do it now this is what is returned a string called super
    
    
    newstring[0]= super #shift_nest_string_to_left(string)
    #this appends the super string to gold_list_results list 
    gold_list_results.append(super)
    #the string sare in gold_list_results
print('testing cutting out first two tabs from front of string')
print("===TESTING CUTTING OUT FIRST TWO TABS FROM FRONT OF EACH STRING OF CODE==")
print("moving everythign to left side for formatting this sucker see if gold nears")


print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
print("=====testing in theory method chaining ======")
#output=[]
#output.append(0)
#myinput=[]
#myinput.append(0)
print(" chain methods test with 3 methods that hand off output as input to next method")
print('testing 3 methods in a row november 23rd santa cruz avenue menlo park ')
print("==================================")
print("first let us see the string in the starting representation") 
#for line in teststring6.splitlines():
#    print(line)
#print
#output[0]='' #to shift string identation to the left
print(" **  method 1  **  indent to left   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
print(" **  method 1  **   testing manipulate_string(string)")
#del myinput[:]
#myinput.append(teststring6)
#input[0] = teststring6
############===============
#manipulate_string(myinput[0]) #indent to left  what is the outpout put into 
############==========
#output[0]=newstring[0] 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#razzle = output[0]
#myinput.append(razzle)
#3toosmart = razzle
#mystringname= toosmart #spilled_coffee;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
print(" **   method 2  ** cut out sitch bodies  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
print(" **   method 2  **  modified2_cut_out_inner_switch_body_leaving_switch_word ===")
#right here it can't read the stringname
print("==========starting point======================")
print("================================")
#print("stringname=",mystringname)
#for line in mystringname.splitlines():
#    print(line)
    
#print("checking cat scales list [0] now===========")
#for line in cat_scales[0].splitlines():
#    print(line)
    
#mycat = never_defeated[0]
###################==============
#stringname=mycat;  #this sucker was moving...pilots in ireland describing ufo zooming by.    
#start =1; finish=1; #this means start and finish unknown
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)

#print(never_defeated[0])
#start=1,finish=1;
#modified2_cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
###################==========
print("please work now did this sucker work tuesday november 23?") 
print('result of taking out inner switches ') 
#output[0]=cat_scales[0]    #outoput 
#for line in output[0].splitlines():
#    print(line)
#print("........")
#del myinput[:]
#myinput.append(output[0]) #does this one work  
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")
print(" **  method 3  ** testing take_out_endswitch()")

#################==========
#take_out_endswitch(input[0])
#################===========
#outoput in holdon[0]
#output[0] = holdon[0]
#print("result of taking out bottom endswitch ")
#for line in output[0].splitlines():
#    print(line)

print("above this line is the totally modified string from 3 chained methods ")


###============= test nov 24th wednesday 2021 target parking lot

test_string4='''
	switch(exp){ #44
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")
		####################1
			switch(exp){ #51
				case 'fishy':
					print("do something")
					print("yep")
					fallthru:
				case 'where now':
					print("nice")
					break
				default:
					print("we very done") 
			endswitch 
			#############k
			break
		default
			print("we are done here")
	endswitch #46  
'''

#You can use double or single quotes:
#testing on my iphone. last night. 
testingthis='''
	switch(exp) #23:
		case 'tahoe':)
			print("do something"))
			print("yep"):
		case 'fallen leaf lake':)
			print("nice")#
		####################1
			nested_switch_31:(exp) #31:
			#############k
			break:
		default:)
			print("we are done here").
} 
'''

moregarbage='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru	
			:
		case 4 to 7:)
			print('kangaroo hop hop!')
			#############
			nested_switch_22:(exp) #22
			exp = 32
			nested_switch_33:(exp) #33
			##############
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:)
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
} 
'''

trythisone='''
	switch(exp) #1:
		case 1 thru 3:)
			print("where's the dog house!"))
			print('first prize'))
			print('you block head Charlie Brown')u
			fallthru	
			:
		case 4 to 7:)
			print('kangaroo hop hop!')#
			#############1
			nested_switch_11:(exp) #11:
			exp = 32
			nested_switch_62:(exp) #62:
			##############)
			print('taught me how to write code')u
			fallthru	
			 
		 :
		case 8 to 10:)
			print('mocha blast'))
			print('== 31 flavors===')u
			fallthru	
		:
		default:)
			print('the end') 
} 
'''

##==============================
##  remove_garbage_on_right_margine(inputstring):    called after manipulate_string
##==============================
#removes garbage on right margine and takes out : in nested_switch if it exists
def remove_garbage_on_right_margine(inputstring): #this fixes garbage characters afterwords
	print('----------cherry on top called----------------------')
	cutout=''
	print("let us ORIGINAL INPUT STRING HERE look at the starting input string before modifying it")
	for line in inputstring.splitlines():
		print(line)
	return  ##  this stops the method cold 
	counter=0
	print('starting to enter cherry on top really serious need to get it working')
	adder='';last_char=''; result = False
	for line in inputstring.splitlines():
		print(line) #if "switch" in line and "end" not in line:
		#need test if last line is a number then don't chop it off
		
		print("length of line=",len(line))
		#if length of this line is more than zero
		if len(line) > 0:
			last_char = line[-1]; #returns a character or number or space whatever it is 
		#ourstring = "switch(exp){ #22"
		last_char_in_line_is_number = last_char.isdigit()
		#  checks if last char in line is a number
		#############################
		if last_char_in_line_is_number == True:
			print("last character is definitely a number")
			##########################################
			print("last_char a number is",last_char)
			#if anumber == True:
			print("SECOND SCENARIOthe last character is a NUMBER")
			adder += line + "\n"
			print("last_char=",last_char)
			continue
		
    #need to ahve it check for "))"
		################if line ends with junk ==========================
		if last_char == ":" or last_char == ")" or last_char == "u" or  last_char == "#": #maybe any character
			#need to check if last 2 are )) only cut off one, otherwise
			# if it's only ) and then don't cut it off
			
			print("FIRST SCENARIO :, ),u, #")
			adder += line[:-1] + "\n" #this deletes the last character from the line
			print("last_char=",last_char)
			
			
		########### if line ends with a space 	
		if last_char == "": #meaning it is an empty space
			print("THIRD SCENARIOlast char is a SPACE")
			adder += line + "\n"
			print("last_char=",last_char)
			
			
			######## this handles if the line ends with a number
			#elif last_char.isdigit():   
			#	print("SECOND SCENARIOthe last character is a NUMBER")
			#	adder += line + "\n"
			#	print("last_char=",last_char)
		print("counter=",counter)
		counter += 1
	###########################################################
	############################################################	
	#decided to get rid of : inside of nested_switch here
	#this fixes this bug  >>  nested_switch_11:(exp) #11:
	print("NOW remove dots inside of nested_switch line if they exist")
	
	verycool=''	
	
	
	for line in adder.splitlines():
		#check if nested switch in this switch string
		if "nested_switch" in adder:
			#print("TRUE nested_switch in line")
		
			if "nested_switch" in line and ":" in line:
				#print("nested switch is True")
				verycool += line.replace(":","") + "\n"
			else:
				verycool += line + "\n"
			
		else:
			verycool += line + "\n"
			#print("no nested_switch in this switch string")
			pass	
	print("FINAL OUTPUT FOR THIS STRING======>>>>>")
	for line in verycool.splitlines():
		print(line)    
	print('afterwards not working yet just trying to get last char of each line')	
	print('resulting fixed removed garbage looks like this.....')
	
	
		#it does all lines of the string taking out the first 2 tabs which are chars
		#if cutout != 0  or cutout > 0:#this handles if cutout = 0 meaning None
	newstring[0]=verycool #bug was right here.	
	inputstring=''
 ################################ 
	#print("THIS IS THE RESULTING STRING below this line in manipulate_string function...")
	#for line in super.splitlines():
	#	print(line)
	#newstring[0]= super 
	#print('the final output with cleaned up garbage should be here')
	#print("outpout of cherry on top ==== attempt 1 ")
	#for line in newstring[0].splitlines():
	#	print(line)
	
print("STARTING test 1")
print("take care of garbage on right margine and remove : in inner nested_switch")
#remove_garbage_on_right_margine(moregarbage)
#for line in newstring[0].splitlines():
#    print(line)
#exit()    
    
#print("next one")
#print("STARTING test 2")
#remove_garbage_on_right_margine(trythisone)
#for line in newstring[0].splitlines():
#    print(line)

print('what about this one')
print("STARTING test 3")
#remove_garbage_on_right_margine(test_string4)
#for line in newstring[0].splitlines():
#    print(line)
#print("STARTING DONed")
#exit()









print("Hello")



def method1(inputstring):
     return;
     concat =''
     print("==method1==")
     concat += inputstring
     concat += " fish"
     print(concat)
     return concat

def method2(output1):
     return;
     concat =''
     print("==method2==")
     concat += output1
     concat += " mice "
     print(concat)
     return concat

def method3(output2):
     return;
     concat =''
     print('==method3==')
     concat += output2
     concat += " \nrain fall heavy"
     return concat

print("above the rocket launch")


####===========================================================
def try_these_chain_methods(inputstring):
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("=====try_these_chain_methods=====")
    print("looping through inputstring to see the starting state")
    for line in inputstring.splitlines():
        print(line)
    ##==========    
    print("==trying these three methods and see if it works or not==")
    output1 = manipulate_string(inputstring) #shift string to left
    print("reached after first method called")
    print("mOnday morning Blues testing of manipulate_string method")
    #print(newstring[0])
    
    #takes out extraneous :, ),#,u on right side AND removes : inside of nested_switch word
    remove_garbage_on_right_margine(output1) #this should work now Takes out garbage on far right
    output1 = newstring[0] #extranious #: ) empty lines have : u
    for line in output1.splitlines():
        print(line)
        
    #return    #stoppinghere 
    ##=========
    start =1; finish=1;
    output2 = modified2_cut_out_inner_switch_body_leaving_switch_word(output1,start,finish,)
    print("reached after second method called")
    ##=========
    output3 = take_out_endswitch(output2)
    print("reached after third method called")
    print("this is the final output string from the three chain methods",output3)
    ##=========
    for line in output3.splitlines():
        print(line)
print("serious three raptor engine test launch")        
inputstring= teststring6        
#try_these_chain_methods(inputstring)
print("finishing calling test chain methods")
print(" end of today's test ")
#exit()    
#starting teststring6
#take the string to test it
#shift_nest_string_to_left(string)
#manipulate_string(item) 







	


	
##=====================================
## swap_endswitch_with_curlybrace() this uses the method take_out_endswitch()
##======================================
##=presumes that quail list already filled up with seperated strings
devious_list=[]
peachtree=[]
#so this function loops thru quail list and checks if endswitch in a string in quail
def swap_endswitch_with_curlybrace(): #using testlist_of_strings
    print("=== swap_endswitch_with_curlybrace() ===========")
    print("this requires that quail list must already be filled with switch strings")
    counter=0
    #assert len(quail) > 0 #it did say quail list 
    if len(gold_list_results) > 0: #meaning there is something in quail list
        #looping thru quail list
        for item in gold_list_results:  #notice that this works by looping thru quail list and changing strings with endswitch
            if "endswitch" in item:
                print("yes endswitch is in this string")
                #it happens here TAKE OUT ENDSWITCH(ITEM)
                take_out_endswitch(item) #calling take_out_endswitch saved to holdon[0]
                #print(holdon[0])
                print("its appended to devious_list here via holdon[0]")
                devious_list.append(holdon[0])#this line just might not be working correctly need to look at it further
               # testlist_of_strings[counter] = holdon[0] #this puts it back into testlist slot
                holdon[0]=''
                counter += 1
                continue
            else:
                print("nope no endswitches")
                counter += 1
                continue
    else:
        print("testlist_of_strings list is empty so can't do swap endswitch with curylbrace")
    print("let's see if this works or not does this thing actually work")
    print('strawberrie fields are forever')
    # see if it takes endswitch out and puts } in its place
#end function



#three test in a row here of method calls 



print("===== hard code filling testlist_of_strings   ====")
testlist_of_strings=[]
testlist_of_strings.append(teststring1)
testlist_of_strings.append(teststring2)
testlist_of_strings.append(teststring3)
testlist_of_strings.append(teststring4)
testlist_of_strings.append(teststring5)
testlist_of_strings.append(teststring6)
testlist_of_strings.append(teststring7)

print("===== testing this using a loop =====")
print("this left shifts and indents each switch string to prepare for going thru bypass205()")
counter=0  #this shifts (indents) the whole switch string to the left with 1 tab in front of switch
print("this prints out the switch strings after left Red Shift== to one tab")
cow_hide=[]
fuel=''
##==============================================
##  starting_what_switch_strings_look_like():
##==============================================
def starting_what_switch_strings_look_like():
    print("starting we have...")
    for item in testlist_of_strings:
        print(item)

##==============================================
##  left_shift_all_switch_strings():
##==============================================    
def left_shift_all_switch_strings(): #this goes thru testlist_of_strings
    print("now we will shift the switch to the left margine")
    counter=0
    for item in testlist_of_strings:
        print("counter =",counter)
        manipulate_string(item) #this calls manipulate_string(item) to shift the switch string to the left
        #adds change to axis put into newloop appended 
        counter += 1
#output is in gold_list_results list
print("   ")
print(" this is AFTER the switch strings have been seperated and put into a list")
print(" called testlist_of_strings  ")
print(" testing  ==left shift jazz== ")
starting_what_switch_strings_look_like()
left_shift_all_switch_strings()



print("DID IT WORK OR NOT the changes stick is it still === LEFT SHIFTED=====")

print('we are here now nov 23rd tuesday morning morgan hill.')




#for item in devious_list:
 #   print(item)
critical_list=[]
print('plum tree test') #hours spent getting this tow ork oct 17th, 2021 9;52pm
def goodtimes():
    print("good times()")
    print("looping thru gold list results list")
    for item in gold_list_results:
        print(item)
        del several_three_tab_switches_list[:] #delete it first to erase the chalkboard
        stringname=item
        get_second_switch_numbers_check_if_many(stringname) #output here
        print("several_three_tab_switches_list=",several_three_tab_switches_list)
        print(several_three_tab_switches_list)
        why= several_three_tab_switches_list
        print("why=",why)
        print(type(why)) #gets the type of var why is.
        results=list(map(int,why)) #changing the string numbers into ints then it works
        #this adds to this list the inner switch numbers for each switch string
        print('results=',results)
        #some will have none, some will have 1, and some will have more than 1
        critical_list.append(results)
        print('critical_list=',critical_list)
        #print(peachtree)
goodtimes()    
print("end of show")    
print("resulting three tab inner switches in each of the switch strings")


def cool():
    print('==========cool function==== is this working yet====')
    for item in critical_list:
        print(item)

cool()

   
    
    
    #holdthis[0] = galaxy.replace("endswitch","}")
#I need to replace the inner switches with methods now
####========== sunday october 17th, 2021 



#what is below here isn't working right for some odd reason

print("about to call swap_endswitch_with_curlybrace() ===")
print("this replaces each endswitch with } to prepare for bypass205()")
#this one is designed to go thru quail list
print("here we take out the endswitch in each string and replace it with }")
swap_endswitch_with_curlybrace() #have it work with gold_list input already left justified
print('about to loop thru devious_list to see if it swapped endswitch with } or not')
for item in devious_list:
        print(item) 
#print("now we will loop thru the testlist_of_strings to see the endswitch is gone now")
#for item in testlist_of_strings:
#    print("counter =",counter)
#    print(item)
#    counter += 1
    


print("TESTING string 1 now=======>>")
manipulate_string(teststring1)   
#exit()
'''
print("TESTING string 2 now========")
manipulate_string(teststring2)   
print("TESTING string 3 now========")
manipulate_string(teststring3)   
print("TESTING string 4 now=========")
manipulate_string(teststring4)   
print("TESTING string 5 now========")
manipulate_string(teststring5)   
print("TESTING string 6 now=========")
manipulate_string(teststring6)   
print("TESTING string 7 now=========")
manipulate_string(teststring7) 
#shift_nest_string_to_left(teststring6)  #3 tabs  DOWN TO 1
#this one is not working 
'''
print("test 2")
print("testing indenting correclty teststring1")
#shift_nest_string_to_left(teststring1) 

print("test 1")
print("testing indenting correclty teststring2")
#shift_nest_string_to_left(teststring2) 

#this doesn't work yet
#now to a loop 
#listtest=[]
#listtest=[teststring1,teststring2,teststring3,teststring4,teststring5,teststring6,teststring7]
#print("testing going thru all strings and indenting them ")
#counter =0
#print("====starting looping thru each teststring=====")
#for item in listtest:
#    shift_nest_string_to_left(item)
#    print("========")
#    print("counter=",counter)
#    counter += 1
    
      
# ==================================================================================
# what to work on today thursday, october 14th, 2021 ,,,,,,,,,
# so I would feed in just a param to look for "#" AND "switch" AND "31" and get tabdepth
# I need to try calling and looking for switch in line and # and the number 31
# and loop thru to endswitch at same tab depth.
# get tab depth on switch   tab_depth1 = line.count("\t")
# and then the first line with "endswitch" in line and this_tab_depth == tab_depth1
# =================== thursday coding ================================================

#so the formula is whatever never it starts from subtract that
#so if it starts at line number 11 at beginning of string with switch
#so if we do 31 down to 41 we subtract 11 from first number and second number
#so it's really 20 down to 31
#or I could have it start #31 in line and switch in line
#loop until same tab depth and "endswitch" in line


 #add item to dictionary
#pears['3'] = [4,7] #example
print(pears)
 #access dictionary
#x = pears("1")
 
 #remove item from dictionary
#thisdict.pop("model")
 
 
#now when I loop thru switch and endswithc lines
#have it fill the dictionary with the data



#######================================================================#########==========

#######================================================================#########==========
rose=[]
rose.append(0)
rose.append(0)

#######================================================================#########==========

#input1 = rose[0]
#input2 = rose[1]
#23,46

#start = rose[0]+1
#finish= rose[1]+1

#skipping_some_lines(x,start,finish)
#print(toosmart[0])


#always do one nest. Just change the switch start and stop sooo simple


## MAIN TRIGGER FOR TESTING THIS CODE OF EXTRACTING NESTED SWITCH STRINGS 
###################################################
## #this means I need to feed in the one switch location and one endswitch location
## that need to have been already figured out



##  copy_one_nested_switch_string(m82)   <<=======     this is the main trigger for the test july 18th 
##  I will need to add another paramter to determine which nestd switch is grabbed 
def extra(): # does nothing
	print("did it work??")
	
	print("#method  get_switch_and_endswitch_locations()")
	######### just commented out line below july 19th 1:10 pm
	
	#get_switch_and_endswitch_locations(m82) # presumes only one nested switch inside param would be passed here to to pass thru this is new  method call
	######## I will need to take out this method above out of this function
	######## this currenlty only takes in the first switch by design 
	#this builds a list of switch_location and endswitch_location all of them
	# but this function conpy one nested stirng ONLY USES the first switch and first endswitch
	###################################################################
	#this gets switch_location[0] and endswitch_location[0]
	print("copy one nested switch string ()")
	print("get start of nested switch and end of nested switch")
	print("#method get_one_nested_switch_start_and_finish()()")
	#get_one_nested_switch_start_and_finish() # method call 
	#this just copies the locations of switch and endswitch into 
	
	
	
nest_string=[]	
######################################################
##  def copy_one_nested_switch_string(m82,zebra,cow)
######################################################
#this fills nest_string list with copies of the switch body strings
#and takes out front two tabs from string
def copy_one_nested_switch_string(m82,zebra,cow): #so I would add a param to determine which nest to grab july 18th 
	print("==== copy_one_nested_switch_string() =====")
	print("===========.................==============")
	#print("let's look at the input")
	#print(m82)   #main string name
	print(zebra) #switch    location
	print(cow)   #endswitch location
	
	print("========COPY ONE NESTED SWITCH STRING()== called=====")
	#input_string[0]=samplestring
	counter=0		
	buildstring=''
	print("printing samplestring first")
	#print(m82)This ONLY GRABS the first position which is 0 for switch and endswitch
	#when I loop thru this in the peartree dictionary I will put the current pair into 
	#switch_location[0] and endswitch_location[0]
	######################################################
	print("WHAT ..... is in these two lists position 0 swith and endswitch")
	#print("it sees in y",y, "well how does it look")
	####################################
	print("passing the params for switch and endswion and endswitchlcoation")
	del switch_location[:] #these were passed as params that govern grabbing the right string
	switch_location.append(zebra)
	print(switch_location[0])
	del endswitch_location[:] 
	endswitch_location.append(cow)
	print(endswitch_location[0])
	#print("switch_location[0]",switch_location[0]) #10
	#print("endswitch_location[0]",endswitch_location[0]) #20
	#print("what it sees in switchlocation0 and endloaction0")
	print("===========================================")
	# LOOP thru string
	###=================
	fridge[0]='' #empty this sucker just in case oct 5th 2021
	#print("list_of_switch_range[1]",list_of_switch_range[1]) #10
	#print("list_of_switch_range[2]",list_of_switch_range[2]) #20
	for line in m82.splitlines(): #determine if "endswitch" is in line
		#this by default starts copying the string once line greater than 2
		#this says if counter between 10 and 20 including start number and finish number		
		#############################################
		#if "switch" in line and "endswitch" not in line: #this shows just switch
		#	print("switch in this line",counter)
		#if "endswitch" in line:
		#	print("endswitch in this line",counter)
		##############################################	
		#right here if counter is between min line number and max line number
		alpha = int(switch_location[0])
		beta  = int(endswitch_location[0])   
		#this loops thru string and copies lines to buildstring
		if counter >= alpha and counter <= beta: #if counter between(within) alpha and beta:
			buildstring += line + "\n" #I need to start at the 10th line
			counter += 1	
			continue
		else:
			counter += 1 #wasn't adding to counter
			continue #really
	print("the new creation concatted should be buildstring=")
	fridge[0]=buildstring  #here buildstring is stored in firdge[0]
	print("what is in the fridge[0] the nested switch copied")
	#print(fridge[0]) #the copied nested string is in here  fridge[0]
	#############################################
	#newstring='';cool_string = fridge[0]
	print("#method take_out_x_tabs_from_front_of_line()")
	#calls method take_out_x_tabs_from_front_of_line
	#it was cool_string which is now m82  was (2,cool_string)
	newstring=take_out_x_tabs_from_front_of_line(m82) #this is running #takes off 2 leading tabs
	fridge[0] = newstring
	
	#print("final outcome Tron")
	#print(fridge[0]) #this results in the nested switch string with  2 tabs taken off front of each line
	################################################
	# July 21st, 2021 4:16 pm Gilroy Starbucks
	#this copies the string just copied and put it into nest_string
	#its added to nest_string right here 
	#####################################################
	# the copied switch body string goes into fridge[0]
	# and then is added to nest_string list
	######################################################
	nest_string.append(fridge[0]) ##<<<===== right here the nested string is added to nest_string
	#this is filling nest_string with the contents of each nested string
	#then fridge[0] is added to the list nest_string
	print("nest_string length=", len(nest_string))
	#print("line 4315 nest_string here has this in it",nest_string)
	#print("trying to loop thru nest_string to figure this out")
	print("pumpkin pie")
	#for item in nest_string:
	#	print(item)
	#	print("==========")
	
	#need to delete teh first three tabs
	fridge[0] ='' #this empties fridge[0]
	print('trying to empty nest string here on line 4330 see what happens ')
	#del nest_string[:] 
	print("length of nest_string at this juncture is now",len(nest_string))
	#################################################
	print("copy a nested string and output it") #august 5th, 2021
	#print(nest_string)
	
print("====TESTING COPYING A NESTED STRING ======1 2 3 A  B C===....")	
print("====STAR TREK ENTERPRISE ===....")	
print("this is where I call the function to copy JUST ONE nested switch")
# july 18th I would need to add another paramter here like 2, for second nested switch 
#copy_one_nested_switch_string(samplestring) #reads sample string here 
#output into fridge[0]

#this should just call one nested string
# I will put the loop to go thru peartree dictionary
#and call copy_one_nested_switch_string(samplestring)
#and have it added to a list


# I will need to append it 


#this calls in order these methods
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [10,20], # I can make these now 
  "2": [28,38],
}
'''



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========




smart_switch_numbers=[]
#the purpose of this is the switch ID number is it's initial line number
#NOTE: no spaces inbetween switch(exp){ otherwise replace doesn't work right 
#testing adding the comment and line number for switches

###=====================what I need to do =====================
# important sept 30th
# all I gotta do is make each nested switch like
# the main switch template and take out inner switch bodies
# then using the line number put in the generated method in it's place
# be sure that I add the line number as a comment I have that code
# and then make sure I get that switch line number to
# make the nested method to replace it
#####================================================================
#this one is all new and not tested september 30th musing
#testing adding the comment and line number for switches
#this is new not currently used or tested 

testcode='''
					switch(exp){ #53
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''
#I am testing with this string the inner swithc is at 3 tabs, first switch at one tab.
#this was teststring6 also added 0 to end
teststring60='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


#so I will know what switch body I am dealing with so I can juggle them and manage them					
#when I get a string that I have copied I just need the switch at the top
##====================================
##  get_switch_number()  it gets the switch number from FIRST LINE OF STRING then bails
##====================================
def get_switch_number(stringname): #this might be for when
	print("indian braves dancing for rain")
	# I create copies of the switch body strings
	print("get_switch_number() called it's getting the first inner swithc at 3 tabs length ")
	awesome=''
	y = ''
	counter =0  #say it's 3
	print("this is what the string we are manipulating looks like")
	for line in stringname.splitlines():
		print(line)
	print("================-------===")
	#we would be looking in the main string for this
	#not changing line just getting line number from it since it's the ID for the switch
	#do I need to give it the line number as an input
	counter =0
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tablength= line.count("\t")
		if "switch" in line and "end" not in line and tablength == 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			print("switch number is==>>>>>",y) 
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;

#skip 16 thu 38
print('this is testing october 12th to get the inner switch line number as a comment ')
weasel=get_switch_number(teststring60) #so this figures out what switch is in a list slot
print("number of this switch string(should be 66 ..",weasel) 
print("ending program here....")



	#testing here 
axis=get_second_switch_number(teststring4)
print("you can always try..")
print("should be 31 ... ",axis)
# get second switch numbers check if many
#experimental new october 14th, thursday, 8:06pm 


print("get second MASH switch number (the comment number after teh inner switch")
print("testing to see if it correctly retrieves the number 66 in the nested switch")
weasel=get_second_switch_number(teststring60)
print("should return 66")
print("weaseL=",weasel)		


weasel=get_second_switch_number(teststring3)
print("should return 23")
print("weaseL=",weasel)		

weasel=get_second_switch_number(teststring2)
print("should return 15")
print("weaseL=",weasel)		



			
#keep line #15 del til = #38
################# creation of loopstring list to hold string that will hold the nested switch string

loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
#loopstring[0]=red_robin #   what it was previously ==samplestring #see if this works  #this is the mai nested string
#print('big test here ')
#print("loopstring[0]=",loopstring)
doves=[]
'''
#########################################
## loop thru pears dictionary
## and calls copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])
## to copy one nested switch at a time
    #it might just have to go thru once to fill pears
    # going thru a dictionary I need to designate which pair 
   
    ##########################################
    ## this loops thru the dictionary pears
    ##########################################
    print("about to loop thru pear values")
    #looping through dictionary pears 
      #say_something(cool) #this way the switch and endswitch locations are passed into the function
        ##########################################################
        ## this calls COPY ONE NESTED SWITCH STRING()
        ##########################################################
        print("about to start copy_one_nested_switch_string()")
'''






#https://www.youtube.com/watch?v=qtpxiNvGCp4
#########################################
##   copy_one_nested_switch_case_body()
#########################################
def copy_one_nested_switch_case_body(): #uses pears.values()
    print("======copy one nested switch case body () ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    counter = 1
    #using blueberries dictionary and not pears 
    #just changed this oct 6th wednesday 10am 2021 morgan hill starbucks
    
    # pears is a dictionary with values of start switch and end switch
    ## LOOP ######## this loops thru pears dictionary
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        #print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #great where does this copy of the string put into??
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
   
        

###=== this goes thru pears dictionary  and copies the nested switch strings
print("=== GODZILLA Time  ===")
#uses pears dictionary
'''
pears =	{  #for pear tree in backyard (2 of them)
  "1": [11,47], # I can make these now 
  "2": [49,73],
  "3": [15,38],
  "4": [53,64],
  "5": [23,33] #no comma after last data piece apparently
}
'''

print("here we go ... copy_one_nested_switch_case_body_blueberries():")
##====================================================
## copy_one_nested_switch_case_body_blueberries()
##================================================
#########################################
#this is using the string red_robin for testing purposes. 
  # pears is a dictionary with values of start switch and end switch
    #this goes thru the blueberries dictionary set of switch end switch pairs ===========
    ##===================================================================================
    ## LOOP ######## this loops thru pears dictionary
    #del nest_string[:] #empty this list
    #this is the blueberry dictionary 
    #it loops thru blueberries to copy a string
    #looping thru blueberries dictionary here 
    


    
#loopstring[0]=red_robin #testing on oct 5th Tuesday
def copy_one_nested_switch_case_body_blueberries(): #uses pears.values()
    return
    print("======copy_one_nested_switch_case_body_blueberries() ....=====.")
    print("make the impossible into reality VIKING SHIP  fish 1 ")
    print("show what is in ")
    print(blueberries) #what is pears have in in it
    print("I think that at this point nest_string whould be empty")
    print("len(nest_string=",len(nest_string))
    #nest_string=[] #this reinitializes it 
    counter = 1
  
    #right here nov 6 2021 saturday change this to the list of sublists (time to ditch the dictionary
    print("showing contents of blueberries dictionary values the strings here.")
    for x in blueberries.values(): #looping thru pears dictionary holding  switch pairs locations in an anonymous list
        print('this is number',counter)
        print(x)
        cool = x #(which is a pair thus only two values)
        print("cool=",cool)
        print(cool[0],cool[1]) #this is switch and endswitch line numbers 
        print("copy one nested switch string")
        #this uses the pair location start switch and end switch numbers
        #the string is in loopstring[0] <<----------------
        copy_one_nested_switch_string(loopstring[0],cool[0],cool[1])  #first is 1 second is 2 
        #this copied string is added to nest_string list
        #switch_location[0]=''
        cool='' #this resets it
        counter += 1
        print("========================")
    #end loop
##=============oct 5th musing how to maket his puppy work 
#I need to have switch numbers by line number
# associated with it's pair start stop
#===================   
print("testing blueberries dictionary list to get the string bodies printed out")
####################
#print("NEST_STRING line TAHOE CABIN Bears ione 4651 what is in nest_string at this point")
#print(nest_string)
counter =1  #so the nest_string would have the switch body strings in it
for item in nest_string:  #going thru nest_string of inputs I think
    print("counter=",counter)
    print(item)
    print("end of this switch string body")
    counter += 1
    print("======....=====")
    
    
del nest_string[:] #new just now putting this hear
print("is this thing turned on right now?")
print("the autumn leaves are falling now.")
print("let us see what red_robin looks like")
#for line in red_robin.splitlines():
#    print(line)
print("done printing out red_robin input to compare it with")
print("  this is the autumn LEAVES  test ==")
print("======after having added line numbers as comments to each switch ===========")
#add_comment_and_line_number_to_all_switches(red_robin)
print("=======now do the next one=======")
print("=======now do the next one=======")
print("=======now do the next one=======")
#add_comment_and_line_number_to_all_switches(autumnleaf) ##testing this right here oh yea

#put it into a list which holds the new string with switch lines added as comments
#here I add line numbers to switches
#inputstring[0] #input string will be in here
#copy_one_nested_switch_case_body_blueberries() #which is uses red_robin
print("finishing blueberries")

print("let see this puppy work ..... great america babes ignored me ...")
#copy_one_nested_switch_case_body() # this calls the loop

#print("pears dictionary",pears)
print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
print("pears now",pears)




#this is the resulting output of copying the string embedded in the main switch

holdthis=[]
holdthis.append(0) #creates the space to store it


teststring_brace='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  this is what it will actually look like 
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''

#this swaps endswitch with }
# I need to count the "}" in the string, there should only be one, actually none
# if there is one it needs to be in the right place.
# I will have to loop thru the list to look if there is a brace in it already.
######################################
## take_out_endswitch(stringname)  #replaces endswitch with }
######################################
list_of_line_numbers_of_endswitches=[]
holdthis=[]
holdthis.append(0)
#the issue is that I need it to only do the bottom one 
def take_out_endswitch(stringname):
	print("==========take_out_endswitch()and put brace in called=======")
	x='';x=stringname.count("endswitch") #should be 1
	print(x)
	counter = 0
	for line in stringname.splitlines():
		if "endswitch" in line:
			list_of_line_numbers_of_endswitches.append(counter)
			counter += 1
			continue
		else:
			counter +=1
		continue
	print("list of line number of endswitches=",list_of_line_numbers_of_endswitches)
	coffee =list_of_line_numbers_of_endswitches[-1] #last one
	print("the last endswitch =",coffee)
	print(stringname) #this takes out endswitch and replaces it with }
	stringname=stringname.replace("endswitch","}")
	for line in stringname.splitlines():
		print(line)
	holdthis[0] = stringname#now galaxy gets what is in holdthis[0]
	print(holdthis[0])#return stringname #and this is returned
	
print("testing take out endswitch from string and replace it with a } ")
take_out_endswitch(teststring_brace)
#outpout to holdthis[0]
#for line in holdthis[0].splitlines():#
#	print(line)
	



###===================================================
##   show_list_of_nested_strings_separated()
###===================================================
## july 21st 2021 349pm gilroy starbucks
#oct 5th this is a list of thes copied switch ends witch stings in nest_string
###=== this shows the nest_string list of nested switches
#this just loops thru nest_string which has the seperated nested strings
def show_list_of_nested_strings_separated():
    print("======show list of nested strings separated=====")
    print(" == StayPuff Marshmellow Man ==")
    counter=1
    for item in nest_string: #this has the nest strings in it ALREADY nov 6, 2021
        print("counter=",counter)
        print(item)
        counter += 1
    print('end of first simple test ')   
    #===========================    
    counter =0
    print("loops thru nest_string that we filled up in copy_one_nested_switch_string(m82,zebra,cow)")
    #this requires nest_string which is looped thru
    print("length of nest_string=",len(nest_string))
    # loop thru nest_string list     to take out endswitch
    #for item in nest_string: #nest_string must have refined main switch with nest methods numbered already
    #    if "endswitch" in item: #swap endswitch with '}'
    #        print("== endswitch detected ==") #should be 2 of them
    #        print(counter) #takes out endswitch from this current string here
    #        holdthis[0]=take_out_endswitch(nest_string[counter])#takes out endswitch from each string
    #        nest_string[counter] = holdthis[0] #voodoo magic
    #        counter += 1
    #    else:
    #        print("oh good") #absolutely nothing happens here
    #        counter += 1
                
    print("see if it fixed it here")
    print("this is showing what's in nest_string list")
    #this loops thru nest_string to show after the changes were made
    print('this should be it right here the seperated nest strings')
    print("remember that the main switch string is totally different ")
    print(" this is the CRUCAL TEST OUTCOME RIGHT HERE TO SEE IF IT WORKED")
    print("what this does is print out the lists indiviudally after separating them")
    print("printing out the nest_string list right here play baseball Yankees")
    print("copied strings one by one")
    print("YANKEES need to show each copied switch body string")
    print("wow that worked")#da = blueberries.get("2")
    #print("getting data in blueberries")
    #print(da)
    mycounter =1
    nest_string_size= len(nest_string)
    print("length of blueberries =",len(blueberries))
    ###############
    #this makes sure that the nest_string is equal in size to blueberries
    # to counter a bug of overflow junk that I will figure out later
    # oct 5, 2021
    print("blueberries",blueberries)
    print("")
    #this deletes excess data that is appended to nest_string inexplicably
    #this simple fix was solved on oct 5th tuesday at 11:30pm 2021=======
    #temporary getting excess from nest_string
    #so 
    while len(nest_string) > len(blueberries):
        del nest_string[-1] #last element in list is deleted
    print("all done")
    print("length of nest_string=", len(nest_string))
    print("yes finally works NASA is born")
    #get length of blueberries
    #then reduce size of nest_string to that number (figure it out later) weird bug
    print("nest_string size = ",len(nest_string))
    for item in nest_string:  #nest_string
            da = blueberries.get(str(mycounter))#gets string at this position
            print("getting data in blueberries",da)
            print("counter=",mycounter)
            print(item)
            mycounter += 1
            
            print("==========-----------seperated nest strings -----------------")
    print("==========")
    #now delete extra slots in nest_string
    
    
print("===============================================================")
print("middle ground filler here to separate the change just made. fish 2 ")
print("===============================================================")
show_list_of_nested_strings_separated()
#now replace teh third string(the main string)
# this is to simulate cutting out the inner switches
## july 22nd, 2021 




####===========================================================###
####===========================================================###
####===========================================================###
print("july 22nd 2021 additions...====")
###============== this is working correctly now ==========
## more_testing()
##========================================================================

#sprint("checking number of nested switches at three tabs")
#stringname=testingstring1
#get_second_switch_numbers_check_if_many(stringname)


######################
##  more_testing()
######################
def more_testing():
    print("=== more_testing() == charisma ===method testing ")
    #this is adding samplestring with main to nest_string[2] to see what it will look like when working
    print("let's see what is already in nest_string ===> SpaceX pretest ")
    print("to see what is in nest_string")
    for item in nest_string:
        print(item)
    print("so slow 3 which is nest_string[2] has the main string in it")
    #let'see how it looks"
    print("==== after simple test of contents of nest_string")
    print("========")
    print("here we replace it with what will be after I modify it. this is dummy data testing")
    print("finished main string with nested methods added put into nest_string[2]")
    nest_string[2] = samplestring_main # the third one - putting in a different string premade
    #this is what is different right here in the line above
    
    #testing what the stages need to look like
    #to test what it should look like but doesn't yet
    print(" now we will try it again and see how it looks ")
    print(" after changing main string boo boo ")
    #loop thru nest_string
    for item in nest_string:
        print(item)
        print("===========///======oct 5 tuesday 2021 testing  ========")
        
        
###==================================== oct 5 thinking how to do this. 
#for each switch number I need to know what ranges of it's inner switches are
#I need the range of the inner switch numbers start and stop
#so inner switch ranges for switches by switch line number

#more_testing()

####===========================================================###
####===========================================================###
####===========================================================###


### this works this takes the copied nested switch
### and sets the proper indentation for it
#so it takes out 2 really but we have to say 3
## july 17th 10:12am 2021 starbucks

#the eye opening= make a list of the methods sequence
#tuesday, August 10th, 2021 ====,,,,,,,,,,,==========




loopstring=[]
loopstring.append(0) #so we have loopstring[0] to fill now
loopstring[0]=samplestring #see if this works  #this is the mai nested string
print('big test here ')
print("loopstring[0]=",loopstring)
doves=[]
copy_one_nested_switch_case_body() # this calls the loop

print("pears dictionary",pears)
print("now empty pears dictionary")
#empty pears dictionary here works 
pears.clear() #this clear the pears dictionary 
print("pears now",pears)

show_list_of_nested_strings_separated()
more_testing()


###==========================================================

#def tab_swap(x,y):
#    replace(x,y)

########==============
#wilderness=
#def set_front_tabs(x):
#    wildness=''
#    for line in nest_string.splitlines():
#        wildness += line.tab_swap(3,1) #strips one right
#        wildness += "\n"
#    print("after minor surgery see if this works")
 #   print(wildness)






# copy line by line stripping all tabs
# and then based on if starts wwith swtich 1 tab
# if case 2 tabs
# if not switch and not case three tabs
# if endswitch one tab
# if default two tabs


#unless I make a new string _so I want to remove teh first 2 tabs only
alpha_string=''
str1=''
#for line in nest_string.splitlines(): 
#    #put line into list, del first three tabs then conver to string
#   aline = line.split() 
#    print(aline) 
#    str1 += str1.join(aline) + "\n"
#    #print(str1)
#    
#print("string now is...")
#for item in str1:
#    print(item)


 



#########################################==============
## === skipping_some_lines() ========   July 5th, 2021 ===============
#########################################
#this works for one nested switch right now
#this goes thru a nested switch and takes out the nested single switch.

### solution found for dealing with deeply nested switches
#I think that I can use this if I take out the innermost switch
## first and then it should work  
# so the plan of attack is to change(yes change) the inner most
# depth switch first
#and work back to the next level till I am at the first level of depth.


#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========

skip_range=[]
#skip_range.append(0);   
#skip_range.append(0) 
#july 5th, 2021
#so I still need to get the start and finish lines  switch and endswitch for input 
del ibm[:] #empties it
#print(ibm[0])
ibm.append(samplestring) #so in  ibm[0] this is putting samplestring into ibm[0]
print(ibm[0])
#===================print testing on july 24th saturday  2021 at 9:36am =================
print("at this point we have this in ibm[0] after taking out the first nested switch")
#del skip_range[:]
print("LOOP TEST THRU RANGE LIST Goofy dog")
range_list=[]
skip_range.append(0) #slot [0]
skip_range.append(0) #slot[1]


#string,start,finish
#first it will just detect one nested switch , soon it will detect many

#this loops thru a string and makes a copy of the string
# but skips over a range example lines 10 thru 20
toosmart=[]
toosmart.append(0)
flag_test=[]
flag_test.append(False) #flag_test[0] set to False right here 
baton=[] #this is used to hold the concatted string that is changed on each pass 
baton.append(0)
baton[0]= "nada" #to start with to test this monstrocity


rose=[]
rose.append(9)  #testing purposes 
rose.append(19)
test_code_now='''
					switch(exp){ 
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){   #9 
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch  #19
							#############
							break
						default:
							print("we are done here")
					endswitch 
'''








#this is testing with dummy data above in test_code_now
#taking out the inner switch body
print("halloween is coming snoopy and woodstock test")

print(test_code_now)
#the inner switch is at 9 (which we keep) so we start from +1 meaning 10
#and the endswitch is at 19 but we need to nuke that too so it's endswitch + 1

#the number system starts from 1 for the switch numbering
#because it starts counting from 0 and not 1 we need to subtract 1 from it
#so it was originally 10, 19

#if switch is #9 and endswitch is 19
#Add 1 to each number start and finish
print("===========rose test==== testing taking out inner switch body ===")
#the pair would go here 
input1 = rose[0]
input2 = rose[1]
print(input1)
print(input2)
print("take out 10 thru 20")
x = test_code_now
start = rose[0]+1 #10 #TO PRESERVE INNER SWITCH TO REMAIN THERE
finish= rose[1]+1 #20 #TO GO ONE BEYOND ENDSWITCH WORD
skipping_some_lines(x,start,finish)
print(toosmart[0])
print("=====end end end of show end of this dumb test==testing rose flowers ===")
# october 1st this will have to be a prescan first pass to get the locations 
# this will look for an inner switch after first line and get it's line number
# and find it's 'endswitch' or '}'
# and put the switch line number and endswitch line number into a pair
# and then append it and keep going and that way it figures out the location on it's own
coffee_switches=[]
end_coffee_switches=[]

combinedlist=[]
switchtabs=[]
endswitchtabs=[]

#this is not working right 
### mr coffee smart skipping lines 
## mr_coffee_smart_find_innerswitches bodies and skip them except for inner switch word


##======================================================
##  mr_coffee_smart_skipping_lines(inputstring):
##======================================================
def mr_coffee_smart_skipping_lines(inputstring):
	print("======= mr coffee smart skipping lines ..this =======")
	print(" makes pairs to find locations of switches and endswitches.")
	print(inputstring)
	counter =0
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			tabdepth= line.count("\t")
			coffee_switches.append(counter)
			switchtabs.append(tabdepth)
			
			counter += 1
		else:
			
			counter += 1
	del coffee_switches[0] #deletes the first switch which is at the top 
	###=================================
	count =0
	#this looks for endswitch locations
	for line in inputstring.splitlines():
		if "endswitch" in line or "}"  in line:
			tabdepth= line.count("\t")
			end_coffee_switches.append(counter)
			endswitchtabs.append(tabdepth)
			counter += 1
		else:
			counter += 1
	#=====================================
	counter =0
	for item in coffee_switches:
		combinedlist.append("[" + str(coffee_switches[counter]) + "," + str(end_coffee_switches[counter]) + "]")
		counter += 1

	print("zzzz the result list =",combinedlist)
	print("switch tabs=",switchtabs)
	print("endswitchtabs =",endswitchtabs)
	

print("testing this using string red_robin to see if it works")
print("this is only returning the range list of the switch endswitch pairs")	
print("GO GO GO what that dog go")
#mr_coffee_smart_skipping_lines(red_robin2)
## it's chopping off this from the bottom
'''
fallthru
		
		default:
			print('the end')
}
'''
print("TESTING SKIPPING LINES 16 THRU 38 IN RED ROBIN")
print("testing skipping nested switch in red robin")
print("today is thursday sept 30th...")
print("testing...... sept 30 skipping 16 thru 38")

#So loop thru string and 
#get line number with # and 15 put into start
#and get line number with
 # and #38 and put into finish
print("watching videos of starship. video time...")
print('length of nest_string',len(nest_string))
print("nest_string[1]) see if it works..") 
print(nest_string[0])
print("===============")
print(nest_string[1])
print("===============")
print(nest_string[2])
print("===============")
print(nest_string[3])
print("===============")
print(nest_string[4])
print("===============")
#print(nest_string[5])
#print("===============")

print("bottom after examining nest_string jazz")
start = 15
finish = 38
#skipping_some_lines(red_robin,start,finish)
#see if the string is in ibm[0]
print('go for it 1')
#this is the lower section of the main switch now
print("and now we start phase 2 -====")
start  = 53-23 #subtract number after first cutting out skipping
finish = 65-23

#skipping_some_lines(ibm[0],start,finish)
print("======= I have all of the code I need to make this miracle happen")
print("=====practicing cutting out inner switch guts leaving inner switch word==")
#
print('trying blueberries and nest_string')
print('trying blueberries and nest_string')
print('trying blueberries and nest_string')
print('trying blueberries and nest_string')
print('trying blueberries and nest_string')
#now the string we have is missing the numbers above it 
#print(nest_string[2])
start  = 10 #subtract number after first cutting out skipping
finish = 19
#skipping_some_lines(nest_string[2],start,finish)

#print(toosmart[0])
#this changes the contents of nest_string[2] #see if this puppy works
#nest_string[2] = toosmart[0]
print("what does this string look like right now this instant")
#print(nest_string[2])


#53 -65
print('go for it 2')
##########################################################################################
print("TESTING skipping_some_lines(ibm[0],skip_range[0],skip_range[1]")
print("10 thru 20 but keeping the first line on 10 which is switch")
print("then 28 thru 38 keeping first line on 28 which is switch")
print("well, how did it go ")
print(" skip skip skip skip skip skip skip skip skip skip skip skip skip skip skip skip ")
print("=====")
print("==========")
print("================")
print("======================")

#this would be done separately and is filling the range_list with the switch to endswitch params
#this will be a separate method for range input for the switch endswitches
#here the sublists of the param of each nested switch are added to range_list
#this is hard coded here filling the nested switch numbers 


#range_list=[[10,20],28,38]]  #that's right I do this backwards from bottom up!!!

'''
this goes thru the main switch string and makes a copy
of the main string in stages copying the whole thing
except for the range for each nested switch.
'''
## this means delete nested switches bodies except leave inner switch word only
##===================================================
#  REDUCE MAIN NESTED SWITCHES TO JUST SWITCH WORD
# debugged on august 5th 2021 gilroy starbucks
##===================================================
## this makes teh final main switch with the inner switch bodies stripped out
## just leaving the switch word where the nested switch was.
#range_list.append([10,20]) #these are added in order and then reversed
 # so that the nested switches are erased bottom up
addthis=[]
addthis.append([10,20])
addthis.append([28,38])
##========================
## add_to_range_list()
##========================
def add_to_range_list(): #uses addthis list 
    print("add_to_range_list() this is necessary to work")
    for item in addthis:
        range_list.append(item) #adding to range list
        
    print("length of range list =",len(range_list))
 
 
 
 #i will need to add data to range list still 
##======================
##  feed_range_list()
##======================
def feed_range_list():
    print("=========feed_range_list() called=====>>>")
    print("=========feed_range_list() called=====>>>")
    range_list.append([11,24]) 
    range_list.append([26,38])
    print('range_list=',range_list)
    #the list has to be REVERSED to do the changes bottom up so the line numbers work correctly
    range_list.reverse()#reverses it NOTICE WE REVERS THE LIST TO CHANGE IT BOTTOM UP
    #this is so the bottom is done first 
    print("length of range list =",len(range_list))


    
#Yes I am reversing the range_list to do the changes bottom up so they don't lose their place
print('printing the range_list')
print(range_list) #should be [28,38],[10,20] to do from the bottom up

#this takes out the inner switches except for the switch word
#so what this means is it removes the body of the nested switch but leaves just switch word.
### this uses range_list!!!!!!!!!!!!!!!!!
#between 11 and 47
#if first switch detected keep going so use switch counter
#it needs to only include the switch word of tab depth 3 switches
#before doing any changes it looks like this 
REAL_STRING='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep  (( 5 tabs ))depth 3 detector       Level 2    
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################==== this one should be deleted 
			switch(exp){ #23  #third level deep  (( 7 tabs ))   Level 3    =====
				case 'tahoe':=========
			print("do something")=======
			print("yep")
			fallthru
				case 'fallen leaf lake':
			print("nice")
			break
				default:
			print("we are done here")
			endswitch #33
			#############
			break
		default:
			print("we are done here")
			endswitch #38==========
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #47
			exp = 3  #note that this switch is stacked below the bottom stack at 3 tabs
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73
'''
'''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			####################
			switch(exp){ # 15  #second level deep          Level 2    
				case 'tahoe':
					print("do something")
					print("yep")
					fallthru
				case 'fallen leaf lake':
					print("nice")
					break
				default:
					print("we are done here")
			} #38
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	
#after changes it should look like this after getting rid of inner switch body one indentation

#this is what the end result should be
endresultshouldbe='''
	switch(exp){  #11  first level deep                   Level 1
		case 'blable':
			print("do something")
			switch(exp){ # 15  #second level deep          Level 2    
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #47
'''
	

#I think that I need to go thru tab length3 first 
#then go thru tab length 5 
#then go thru tab length 7
#this is the input for the reduce_main_nested_switches_to_just_switch_word(

oldschool='''
	switch(exp){ #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 3')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #11
				case 'blable':
					print("do something")
					#################### del after line with '#' and  '15' in it till 38 in it
					switch(exp){ #15
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			exp = 3  
			switch(exp){ #26
				case 'burger':
					print("do something")
					####################
					switch(exp){ #30
					print("gosh")
					fallthru
				case 'porsche':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
} #51
'''
#the output should be
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){ #====
			exp = 3  
			switch(exp){ #====
			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''


starbucks_code_main_test ='''
	switch(exp) { #main 
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown 4')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					switch(exp){  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch 
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			##############
			print('taught me how to write code')
			fallthru
			switch(exp){  #first level deep                   Level 1
				case 'blable':
					print("do something")
					####################
					break
				case 'please work':
					print('nice')
					fallthru
			endswitch	 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	


#The change that I need to make here is to cut out switches greater than 3 tabs  tabdepth > 3
##======================================================
##   reduce_main_nested_switches_to_just_switch_word():  #I think that this does all switches no matter their depth
##=======================================================
def reduce_main_nested_switches_to_just_switch_word(astring): #11 - 23 and 25-37
    print("starting this method to see what is in the string")
    #for line in astring.splitlines():
    #    print(line)
    print("===reduce_main_nested_switches_to_just_switch_word()== Tron approaches")
    print("C3Po")
    print("=====reduce_main_nested_switches_to_just_switch_word()====0000000000000==>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("=====reduce_main_nested_switches_to_just_switch_word()======>>")
    print("what is in astring the input param")
    print(astring)
    print("end of the input string to see what is going into the function")
    print("reduce main nested switches to just switch word()")
    
    #feeding range list()
    #add_to_range_list() #this is new to put switch and endswitch lines into range_list
    feed_range_list() #added on wednesday, September 15th, 2021
    flag_test[0]== False #this flag is new this is the default setting for this flag
    print("flag_test[0]=",flag_test[0])
    #when flag_test[0] = True that means it's doing 2nd and subsequent loops (changes) and use baton[0] for concatting string
    print("==reduce_main_nested_switches_to_just_switch_word(astring)==")
    print("= R2D2 ==## $$ ## == reduce main nested switches to just switch word()==========")
    print("this cuts out the nested switches bodies leaving just the word switch")
    print("starting ibm[0] with samplestring")
    print("what we are starting with for input in ibm[0]")
    #print(ibm[0])  #the key is the range_list
    print('range_list=',range_list)  ### this is the dependency the range_list necessary for this to work
    #loop thru range_list
    print("we loop thru the range_list here")
    print("let's see what RADAR is in the range_list",range_list) #see if it's reversed or not
    #loops thru range_list with pairs of switch end and endswitch
    print("length of range_list of pairs=",len(range_list))
    print("range_list=",range_list)
    counter=0
    # loop thru range_list
    print("before starting let's look into the range_list",range_list)
    print("============")
    print("perhaps I need to go thru the 7th tab first, then 5th tab, then 3rd tab")
    print("thinking outloud how to do this.")
    print("range_list=",range_list) #just added this sept 30 2021 testing cafe borrone
    
    for item in range_list: ##range_list=[[10,20],28,38]] ==========================
        print("**",item, item[0],item[1])
        print("inside of loop thru range_list :: COUNTER HERE=",counter)
        skip_range[0]= item[0]; 
        skip_range[1]= item[1]
        #item[0]='',item[1]=''
       # print(item[0],item[1])
        print("skip_range=",skip_range)
        #this builds a new string by skipping the nested switch sections
        #but leaves the inner switch (switch(x) word intact
        # skipping_some_lines() called here 
        # ibm[0] has the samplestring in it from above
        toosmart[0]=astring #this might work
        #this is called before skipping some lines
        #the problem is that on the secondpass it's not taking in the changed toosmart[0]
        #====================================
        #SKIPPING SOME LINES()===============
        #====================================
        #this is governed by flag_test[0] which is set to default False above the loop
        skipping_some_lines(astring,skip_range[0],skip_range[1]) #this makes a new string skipping guts of inner switch
        counter += 1
        
        #skip_range[0]='';skip_range[1] ='' #just added this to see if it helps
        #del skip_range[:] #this clear it out afterwords to wipe the slate clean
    print("this is the final output of the transformation halloween approaches")
    print("output of = R2D2 == taking inner nested switches body out and putting just keeping swithc word")
    print("the star destroyer was moving fast")
    print("should be only two nested switches and only switch word remaining NOT 3")
    print("end of this picture show")
    #print(ibm[0]) #this prints out the result 
    print("=====================")
##======================================================

#here we go  
print("the goofy dog test")  
print('we start with this string')

#print(ibm[0])
print("OLYMPICS BLAZING... gold medal time")
print("=====calling reduce main nested switches to just switch word(========)")
print("HERE NOW...this should be the sample string with the nested switches")
print(" cut out leaving just switch word")
print("we are ==== STARTING ==== with this dam string legal eagle")
#bypass here on thursday sept 30 testing at cafe borrone
#print("September 30th testing at cafe borrone")
#ibm[0] = red_robin
print(ibm[0])
inputnowstring= ibm[0]
print("starting input before doing changes")
print(inputnowstring)
print("about to reduce main nested swithces to just switch word which work previously without incident")
print("line numbe 4162")
print(" FIRE BREATHING DRAGON NOW ")
#flag_test[0]== False #see if this works 
# I am right here today  LOOK RIGHT HERE OCTOBER 1ST 2021 
## this is the key method here ====

reduce_main_nested_switches_to_just_switch_word(oldschool) # I didn't notice this way down here
print("red alert test 2 reduce main nestd swith to switch word test 2 ...")


print("good times saturday night live test ")
del range_list[:]
reduce_main_nested_switches_to_just_switch_word(starbucks_code_main_test)
print("look above frosty snowman here")
print("output from taking out nested switches in string inputnowstring")
print("output of removing both nested switches")
print("RIGHT HERE ====== OCTOBEr 1st what does this look like below this line")
print(ibm[0])
print("does it loop thru two times for that is how many times it should")
print("==============")
#exit()



print("this is what the main switch looks like after having taken out the inner switch bodies")
print("which means that we should only have the inner switch words remaining and nothing else")
print('super super major major critical test 4129 line number ')
print("this shoudl be the main switch with only remaining switch(exp){ and no inner switch bodies")
print("here we should have the two nested switches remaining with no bodies")
print("mocha at starbucks")
#print(ibm[0])
# print this skips the nested switch body and creates a different version of the main switch
# and takes out the nested switches but leaves the switch word
print('after the olympics end...')
print("stopping it here because it should have worked...")
print("remember that I am using and EXIT() here to stop the code running past what I am concentrating on")

#exit()  






#print(ibm[0])
print(" starting anew here doing it the old way")
ibm.append(samplestring) #in ibm[0]
print(ibm[0])
print("that's all lemon tree software ==")
print("about to exit the program after seeing the nested switches taken out of main string")
#exit()
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/ ghostly  /=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("===========///=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/======")
print("this is the SECOND ATTEMPT")
#skip_range.append(0)
#skip_range.append(0)
print("does this work yet") #these are farther down  so I needto do them first 
skip_range[0] =11
skip_range[1] =24
print("=============")
print("skip_range=",skip_range)
print("=============")
print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
print("====::::::::: after changing bottom nested switch to just switch word ::::::===")
print("what string is in ibm[0]=",ibm[0])
ibm[0]=oldschool
for line in ibm[0].splitlines():
    print(line)
skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 28,38 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
print("now swap out the top inner switch hopefully")
print("ibm[0]=",ibm[0])
skip_range[0] =10
skip_range[1] =20
print("=============")
print("skip_range=",skip_range)
print("=============")

skipping_some_lines(ibm[0],skip_range[0],skip_range[1])

#exit()

'''
skip_range[0] =10
skip_range[1] =20
print("=============")
print("skip_range=",skip_range)
print("=============")
skipping_some_lines(ibm[0],skip_range[0],skip_range[1]) 
'''

#print(ibm[0])
#fuse=[]
#fuse.append(0)

#del skip_range[:]

#skip_range.append(10)
#skip_range.append(20)

#I guess I can put the ranges into a list and then reverse it and 
#loop thru it.
print('at this juncture what is in ibm[0]')
print(ibm[0])
print("starting out we have this before stripping out the nested switches")
#ibm[0] = fuse[0] #to preserve changes made 
print("input values on 2nd pass =")
skip_range[0] =10
skip_range[1] =20
print(ibm[0])
print(skip_range[0])
print(skip_range[1])
print("========")
print("skip_range=",skip_range)
print("=========")

print('==== make it dam happen == ')
skipping_some_lines(ibm[0],skip_range[0],skip_range[1])  # 10,20 #so I could put those in a list
# this says go thru string and skip lines 10 thru 20-
print(ibm[0])
print(" where is it now lemonade stand ???")
del skip_range[:] #this has to be cleared out. 
#skip range needs to be cleared out for the next nest parameters here
##===============================
print("==== the end===both nested switches should only have the switch word reminaing ===")



print("===end of copying a string and skipping lines 10 thru 20===")   
print("in ibm[0] we have",ibm[0])
print("===== this is after running skipping_some_lines(smaplestring,10,20)")
print("===========")

smart_number=[]
smart_number.append('starter')
smart_number.append(0)
smart_number.append(0)
smart_number[1] = '1'
smart_number[2] = '2'
#switch is on line 10 need to change it this is looking for the switch

#this is changing ALL OCCURENCES of switch at the 
#same time just just the one I want it to change.
# I need to localize is it to one line number.

#have it change one and then break starting on the line above


#The problem I have is if I replace each switch with the nested numbers
#then the other code won't work so perhaps I need to add a comment
#the issue is making the main strings which should only have the first level inner switches
#which is governed by tab depth of 5 representing the second level
# since tab level 3 is the first main switch.
# I could do number 1 thru n for each level initally and then change them
# or I came up with the number top down 1 thru n but level list solves the problem 
#That was my genius

#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#in terms of faster programming it's about communication and control
# the lollipop is the what level but above that are higher abstraction levels
# where yet more speed can be achieved and sustained
##$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========
#I think I will do the one nest level for now and add the other nest levels afterwords
#decision made august 22nd, 2021 9:08 am

# I have the main module which has nested methods
# I can use this for making nested switches with nested switch methods too
# but right now I want to get the nested feature working before implimenting it
#######3==================================
#Actually I can do the main and the nested that have inner switch words not changed yet
#And then apply the conversion to numbered switches
##=====================
''' from above just pasted it here to keep track of its contents
blueberries =	{  #for pear tree in backyard (2 of them)
  "1": [1,86], # I can make these now 
  "2": [11,47],
  "3": [15,38],
  "4": [23,33],
  "5": [49,73],
  "6": [53,64]
 #no comma after last data piece apparently
}
'''

danumber=''

#testing this here to make sure that it's right 
ibm[0] = '' #this should delete it
print("ibm length=",len(ibm))
stringname =teststring60
print('starting stage of string to manipulate')
for line in teststring60.splitlines():
    print(line)
danumber= 66

print("star wars begins now.")
##============================================
# swap_switch_for_nest_method_new(danumber)
#// inner switch(just the words) is swapped for nested method number")
#=============================================
#for this to work correctly I need to ahve already taken out the inner switch bodies that I copied
print("about to do OPTIMUS PRIME === GO BABY GO ===")
def swap_switch_for_nest_method_new(stringname,danumber): # I will add more values later perhaps 3 or 4 for coordinates
	print("#### ========= swap switch for nest method new  ========####")
	print(" =======OPTIMUS Prime======")
	global abovenestedswitch
	#stringname=ibm[0]
	#stringname=ibm[0] #loading from ibm[0] good
	print("called swap_switch_for_nest_method(n)")
	print("it is using this number in use_number[0]",use_number[0])
	acounter=0
	for line in stringname.splitlines(): #determine if "endswitch" is in line
		tabdepth = line.count("\t")
		print("the current tab depth in THIS line is",tabdepth)
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 check to make sure that switch and the comment line number in this line
		#this way it can ONLY make changes to switches at tab depth 3
		if tabdepth == 3: #this way it can ONLY access changing the string at 3 depth once
			#this way only if the tab depth is 3 can it manipulate the string
			if  "switch" in line and str(danumber) in line: #line with switch in it  
				print(line)  #doing counter > 1 so it doesn't do the first line
				#this is where the string is changed
				stringname = stringname.replace("switch(exp){","nested_switch_" +str(danumber)  + "(n)")
				break
			else:
				acounter += 1
				continue
		else:
			acounter += 1
			continue
			
	print("the final outcome of the chagne is here:")
	for line in stringname.splitlines():
		print(line)
	

# this takes in what is in ibm[0] and the outputs it to ibm[0] also, quite clever.   
print("let the judge state this is truth") 
number_to_add=66 
swap_switch_for_nest_method_new(teststring60,number_to_add) 
ibm[0] = stringname
print(ibm[0]) 

#where is th eone that grabs teh number automatically though

da='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
        
'''

data1='''
	switch(exp){ # 15
		case "1":
			print('hi')
			#isn't this special
			print('is this happening')
			print("what do we have here")
			break
'''

data2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

#the innerswitch must be at 3 tabs and the first top switch must be at 1 tab.
data3='''
	switch(exp) #62
		case 'burger':
			print("do something")
			####################
			switch(exp) #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   
'''


jazz6='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #63  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #89  
			#############
			break
		case 'what':
			print("nice")
			####################
			switch(exp){ #455  
			#############
			break
			
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''

jazz7='''
	switch(exp){ #1      
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			switch(exp) #7 
			print("nicely")
			break
		case "trouble":
			print("in trouble now")
			switch(exp) #19 
		default:
			print("we are done here")
	endswitch #this is key here 
'''
#replace_the_last_endswitch_with_brace
print("I found the code I need - I think - we shall see - if it is the right code indeed")

print("about to do thorough testing of chnage_switch_to_method_solved()")
#solved october 29th, 2021  NEXT get the number after comment just in time
'''
this builds a string called newstring replacing switches
at 3 tabs depth with nested_switch
with the comment id after # tacked onto
 the end of the nested_switch_22(exp) like so.
'''

   ##################################################            
       # if "}" in inputstring:  #have to cut "}" out of string      
       #     print("CONFIRMED there is a right brace in string")
       #     for line in templine.splitlines():
       #         if "}" in line:
       #             
       #              templine2 += line.replace("}","")
       #              templine2  +="\n" 
       #        else:
       #             templine2 += line +"\n"
       #    inputstring = templine2
       #     print("======testing if } taken out of string======")
       #    for line in inputstring.splitlines():
       #        print(line)
       #     print("======testing if } taken out of string======")
         #end if   
       # do nothing
       ######================================
       
''' ##################################################            
        if "}" in inputstring:  #have to cut "}" out of string      
            print("CONFIRMED there is a right brace in string")
            for line in templine.splitlines():
                if "}" in line:
                     templine2 += line.replace("}","") #this is where I was taking } out
                     templine2  +="\n"
                else:
                     templine2 += line +"\n"
            inputstring = templine2
            print("======testing if } taken out of string======")
            for line in inputstring.splitlines():
               print(line)
            print("======testing if } taken out of string======")
         #end if 
'''
        ########################################


innerswitchstatus=[]
innerswitchstatus.append(0)

castle1=[]
castle1.append(0)
##===================================================
## change_switch_to_method_solved(inputstring):
##====================================================
print("make the coffee magic coding happen working on this today charlie brown") 
#solved and working on October 30th 2021 ====================================
def change_switch_to_method_solved(inputstring):
    innerswitchstatus[0]= False #by default
    print("====== change_switch_to_method_solved(inputstring)=== get the money now====")
    print('this now takes out the { brace after switch if it is there')
    innerswitch=''
    print("this is what it sees when it starts change_switch_to_method_solved()")
    for line in inputstring.splitlines():
        print(line)
    print("========testing if this input string has a nested switch ==")
    innerswitch= False #default setting
    counter=0;newstring='';y='';x='';tabdepth=''; switches_total=''
    #verify that there is at LEAST ONE nested switch in here
    for line in inputstring.splitlines(): # we only need to detect one inner switch
       tabdepth = line.count("\t") #gets tab count for this line
       if "switch" in line and "end" not in line and tabdepth == 3:  #it just needs to be true once
       #this means yes there is a nested switch in this string
            innerswitchstatus[0]= True #this is new 
            innerswitch = True
            break
       else:
            innerswitch = False
            continue
    if innerswitch == False:
        print("this switch string DOESN'T HAVE an inner switch")
    ##########################################
    print("innerswitch =",innerswitch)
    ##### modified on halloween  2021 to bypass if no inner switch ##########################################               
    templine=''
    templine2=''
    
    #### IF INNERSWITCH == TRUE:
    if innerswitch == True: #if a switch at 3 tabs depth  is True
    #check if { in this string if so take it out
        print('checking if left brace in string')
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine  +=   line.replace("{","") 
                    templine  +="\n"
                else:
                    templine += line +"\n"
            inputstring = templine
        #end if
        print("=======testing if { taken out of string=======")
        for line in inputstring.splitlines():
            print(line)
        print("=======testing if { taken out of string=======")
       #check if } in this string an if so take it out
      
        counter=0 #new counter for this loop different from upper for loop above
        for line in inputstring.splitlines():#      getting tab depth
            tabdepth = line.count("\t") #gets tab count for this line
            #skips first switch by counter MUST BE AFTER 2nd line
            #this is where we swap switch(exp) with nested_switch_(number)(exp)
            if "switch" in line and tabdepth == 3 and "end" not in line and counter > 2: 
                print("confirmed switchh in line and tabdepth3")
                #this is new getting the switch id number after # on-the-fly
                #get string to right of #, get right side,remove spaces
                x = line.split("#"); y = x[1];y = y.strip();
                # replace switch with nested_switch + id number harvested from comment above
                thisline = line.replace("switch(exp)", "nested_switch_" + str(y) + "(exp)")
                #this removes the extra spaces after #
                location = thisline.index("#")    #gets location from left where position of #
                thisline = thisline[:location]    #this slices off the right side from # position
                thisline = thisline + "#" + str(y) #this concats on the # and comment id number
                counter += 1; newstring += thisline + "\n"; continue
            else:
                newstring += line + "\n"; counter += 1; continue
        return newstring  
        ##################################################################
    else: #this MEANS NO INNER SWITCH IN THE INPUT STRING
        print("no inner switches in this string")
        if "{" in inputstring: #have to cut "{" out of string
            print("CONFIRMED there is a left brace in string")
            for line in inputstring.splitlines():
                if "{" in line:
                    templine += line.replace("{","") #taking out left brace here
                    templine  +="\n"
                else:
                    templine += line +"\n"           #otherwise it doesn't replace anything 
            inputstring = templine
        else:
            print("=====no { in string  ======")
            #end if
        print("=======testing if { taken out of string=======")
        for line in inputstring.splitlines():
            print(line)
        print("=======testing if { taken out of string=======")
        #check if } in this string an if so take it out #I have deactivated this since it's not needed
        
        #this is what we return the inputstring
        return inputstring; #no changes made 
        castle1[0] =inputstring 
        innerswitchstatus[0] = False
    ### end of function =======================================================
    
print("where is my mocha brainfreeze test october 30th...")




print("==========testing string da===================")
print("=============================")
inputstring=''
inputstring = da         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
print("end of red alert change switch to method solved end of test 5..")    
print("=============================")
print("======= testing string data1======================")
 
print("testing goldfish which is NOT indented yet")
#testing a second method in chain right now for expiermentinting==
#the input string MUST BE indented and look like this LOOK LIKE THIS 
somedata2='''
	switch(exp){ #62
		case 'burger':
			print("do something")
			####################
			switch(exp){ #66  
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is endswitch chnaged to brace later
'''


gofigureit='''
	switch(exp){ #77
		case 'burger':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #86   look this is chnaged to brace later
'''



#just check if switch at 3 tabs to determine if nested switch
#monday dec 6th thinking 
####$#$$##############========================


            
            
check_if_nested_switch_inside_this_switch(somedata2)
print("inner switch in switch=",table[0] )
print("=======")
print("=========")

check_if_nested_switch_inside_this_switch(gofigureit)
print("inner switch in switch=",table[0] )
#exit()


print("wasn't that fun")
######======================================
# november 20th saturday just after 10am Morgan Hill 2021
inputstring=''
inputstring = goldfish    
    
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
   
print("see if this worked with goldfish accurately")
#exit()
    
inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data1         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
    print(line)
    
print("=============================")
print("========testing string data2=====================")


inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data2     
#what I am doing here is returning the concatted string to the string fizz variable.    
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

##==================
print("about to test data3 and I can't have anything after the #22 after switch")
inputstring=''
print("====== second test but no inner switch here ===")
inputstring = data3         
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

print("massive mammoth test here to see if mocha is ready")
print("does many changes from switch to nested switch with number ==testing jazz SIXAROO now jazz6 ")
inputstring = jazz6
print("testing jazz6")
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)



print("massive mammoth test here to see if mocha is ready")
print("does many changes from switch to nested switch with number ==testing jazz SIXAROO now jazz6 ")
inputstring = jazz7
print("testing jazz7")
print("calling method  change_switch_to_method_solved")
fizz=change_switch_to_method_solved(inputstring)
print("===== oh yeah =====")
for line in fizz.splitlines():
   print(line)

#exit()


###================== cold brew linus and snoopy ================== saturday morning software  november 20th, 2021 ====
#this is testing adding the nested switch 
linus_and_snoopy=[]
##==================================
##   add_nested_switch_methods():
##==================================
def add_nested_switch_methods():
    print("add nested_switch_methods() in catching_first_change list")
    for item in catching_first_change: #<== list with strings after taking out inner switch bodies
        #print(item)
        #here calling method chaning_switch_to_method_solved swaps switch for nested_method_numbered
        fizz =change_switch_to_method_solved(item)#this is applying the method to add nested_switch method
        print("===== oh yeah =====")
        linus_and_snoopy.append(fizz) #this is adding the changed string to linus_and_snoopy list
        
        #for line in fizz.splitlines():
        #    print(line)



##================================================
##print_out_result_of_adding_nested_switch() to each switch string:
##================================================
def print_out_result_of_adding_nested_switch():
    counter =1
    print('we made it to the top of the Donnor Summit ')
    for item in linus_and_snoopy:
        print("counter=",counter)
        for line in item.splitlines():
            print(line)
        counter +=1

print("here we go... let her rip")       
add_nested_switch_methods()
print_out_result_of_adding_nested_switch()
print('end of the show time movie trailer')



#test with one string and do piping

#cut_out_inner_switch_body_leaving_switch_word(teststring)
##===========================================================================
##  cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
##===========================================================================
#def cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):
#    print('this one is sooo critical')
#    print("cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish):")
#    skipping_some_lines(stringname,start,finish)
#    #this means that the output string should be placed into never_defeated[0]
#    for line in never_defeated[0].splitlines():
#        print(line)

inputlist=[]
inputlist.append(0)
outputlist=[]
outputlist.append(0)
 
print("this is a super critical test of piping two chain methods in sequence")
print("SUPER CRITICAL PIPING METHODS CHAINING TEST ===")
           
#put x in front so it's not used
#it must be indented properly to work daaaaa
xskitahoe ='''
		switch(exp){   #1 === line 10 beginning of single nested switch ======      
			case 'blable':
				print("do something")
				print("yep")
				fallthru
			case 'more':
				switch(exp) #7
					case 'funny':
						print('fun')
					case "da":
						print('yeah')
					default:
						print('bye')
				endswitch #14
				print("nicely")
				break
			default:
				print("we are done here")
		endswitch #this is key here =============line 20 end of nested switch ====
'''	


#testing 
print("testing printing out joy string")
joy='''
	switch(exp) #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp) #23
			#############
			break
		default:
			print("we are done here")
	endswitch #38
'''

hotmocha='''
	switch(exp) #3
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			switch(exp){ #11
			exp = 32
			switch(exp){ #62
			#############
			break
		default:
			print("we are done here")
	endswitch #86
'''

for line in joy.splitlines():
    print(line)



#testing doing 2 methods back to back piping output from first to input to second
#first method   
###==================
##  do_the_pipe()
###==================    
def do_the_pipe():
    print("do the pipe() called pipe pipe PIPE PIPE PIPE")
    print("outputlist[0]=",outputlist[0])
    inputlist[0] = outputlist[0]
    print("now put it into inputlist[0]")
    print("inputlist[0]=",inputlist[0])
    
    

print('doing some pipe testing today')

#######################################
#######################################
#######################################
###====== saturday morning codeing ==november 20th, 2021 testing this puppy ====
## SHIFT NEST STRING TO LEFT INDENT THE PUPPY
print("this is doing shift nest string to left() ======")
print("=====================================================")

shift_nest_string_to_left(xskitahoe)   
resultis =fishbowl[0] 
print("this is after shifting input string to the left to be one tab in front")
print("of the top switch") 
for line in resultis.splitlines():
    print(line)
    
 #this is technically the output which we will now put into inputlist
inputlist[0] = fishbowl[0]   
print("this is testing cutting out switch body from a string")
stringname=xskitahoe; start=7; finish = 14; #this sucker was moving...
print("let us see what is in skitahoe string first")
for line in xskitahoe.splitlines():
    print(line)
print("done with input string to see the starting point")
################################################
#################################################
##  CUT OUT INNER SWITCH BODY LEAVING SWITH WORD
#this one does not work (november 28th this is the hold one)so don't worrya bout it it works elsewhere got it working
# skipping rope yesterday.


cut_out_inner_switch_body_leaving_switch_word(stringname,start,finish)
outputstring=string_after_cutting_out_inner_switch_body[0]
print('after stage 1 first method call in chain we have this result')
for line in outputstring.splitlines():
    print(line)
print("end of first change to string")
outputlist[0] = outputstring
print("right here this is  after taking out th einner switch body")
#MUST INDENT LEFT 
do_the_pipe()
#print("do the pipe() called")
#item = inputlist[0]

#second method
print("experimenting with joy string simple convert to removing inner switch")
print("and adding a nested method nubered")
print("calling first method")
#this is what I am testing Sunday november 28th, 2021 3:51pm take 101 north instead next time

print("testing a method on change switch to numberedmethod with joy")
print("testing  change_switch_to_method_solved()")
print('================ this is the one ===============go for the gold now==================')
print('==================that I need to work now ===============================')
print('===== this changes an inner switch by itself into a nested_switch numbered============================================')
print('=======using the commented number next to it==================')
print(" === I am at starbucks next to frosty the snowman")
fizz =change_switch_to_method_solved(joy)#

print("========the result of 1 chain method using piping=======")
for line in fizz.splitlines():
    print(line)
outputlist[0] = fizz #just for testing here 

print("testing hotmocha now changing two nested switches into nested methods")
fizz =change_switch_to_method_solved(hotmocha)# testing 2 switches to change

print("========the result of 1 chain method using piping=======")
for line in fizz.splitlines():
    print(line)
outputlist[0] = fizz #j
print("end of the show, turn out the exit lights")
#exit()
print("line 11259")

do_the_pipe()
#list strings are mutable changeable. 
inputlist[0]=inputlist[0].replace("nested","mocha")
print("see if it sticks")
print("just called the pipe()")
print("now it whould be input[0]")
for line in inputlist[0].splitlines():
    print(line)
#`exit()

print("testing taking out endswitch at bottom of function and swapping it with a brace like in C")
## I am doing this because this is how the parser works so it conforms with JavaScript and C style.
print("TESTING it is already November taking out endswitch and putting in a brace at bottom of function")
#focus=take_out_endswitch(fizz)
#for line in focus.splitlines():#
#	print(line)
###=====================================================================================

#next need to swap endswitch to } (right brace)

#exit()


#playing with this
makeitso= '''
switch(exp) #62
		case 'burger':
			print("do something")
			####################
			nested_switch_66(exp) #66
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	} #86   
'''

newattempt='''
	switch(exp){ # 15
		case "1":
			print('hi')
			switch(exp) #       22
			#isn't this special
			print('is this happening')
			switch(exp) #      36
			print("what do we have here")
'''

##============================================
## get_top_switch_number_from_this_string(x)
##============================================
twinlist=[]
#testing with string directly above this line
def get_top_switch_number_from_this_string(inputstring):
    print("get_top_switch_number_from_this_string")
    print("there is NO REASON to send humans to Mars")
    counter=0
    x= y =''
    for line in inputstring.splitlines(): #it will be the first switch 06
        if "switch" in line and "#" in line and "nested" not in line  and counter < 2: 
            print("confirmed switchh in line ")
            #this is new getting the switch id number after # on-the-fly
            #get string to right of #, get right side,remove spaces
            x = line.split("#"); y = x[1];y = y.strip();
            print("no drama this is what we have..")
            print("y=",y)
            print("now adding y to twinlist below")
            twinlist.append(y)
            break
        else:
            if counter > 3: #time to bail =too deep can't exist after first line actually
                break
            else:
                continue
                counter += 1
#grab first id number aftger switch 

inputstring =makeitso
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)

inputstring =newattempt
get_top_switch_number_from_this_string(inputstring)
print('in twinlist we have',twinlist)









print(" ")
print("====end of show here turn the lights out====")
#exit()  #<<<<<<=================== this is where our exit is.


print("== end of show ==== ")
#exit()
string_egg='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
	endswitch #60 
'''


string_egg2='''
	switch(exp){ #11
		case 'blable':
			print("do something")
			####################
			switch(exp){ #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			####################
			switch(exp){ #33 
			#############
			break
		default:
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''


pumpkins='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			switch(exp){ #34
			print("nice")
			switch(exp){ #45
			break
		default:
			switch(exp){ #66
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			switch(exp){ #25
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			####################
			switch(exp){ #35
			#############
			print("yep")
			fallthru
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

brew1='''
	switch(exp){ #22
		case 'blable':
			print("do something")
			####################
			
			#############
			print("yep")
			fallthru
		case 'more':
			
			print("nice")
			
			break
		default:
			
			print("we are done here")
	endswitch #60   4..........endwitch 4  line 60 3 tabs
'''

#add ability to get the comment number 15 and put that in automatically 
##=======================
##  funtime(y,x)
##=======================
# this is replacing the switch that is nested into 
# a method with the switch number

#building blocks are legos that are small behaviors inside
#of a function that can be assembled and connected in different
#configurations to make new functions without coding
#so interactively combined with a gui
#so chained methods really




#=====================================
# get inner switch number ()  only at the 3 tabs level depth though
#======================================
#so do this multiple times I would have to go thru a loop with the length of the count of switches at three tabs in a string
add_to_list=[]#and call this method get_inner_switch_number(stringname) #and change the counter number
thisline=[] #this also implies only getting one inner switch
def get_inner_switch_number(stringname): #implies at 3 tabs depth
	print("======get inner switch number called=======")
	counter=0
	x=''
	#what this does is get the commented inner switch number after the # in switch
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		tabdepth=line.count("\t")      #this is getting tabdepth for this line
		if "switch" in line and "end" not in line and tabdepth== 3:#and "#" in line and counter > 1: #just need to grab the first switch 
			x = line.split("#")  #this manipulates the current line
			y = x[1];
			print("switch number is...",y) 
			add_to_list.append(y)
			counter += 1
			print(stringname)
			#break  #after the if condition above it stops 
		else:
			counter += 1
	print("List add_to_list=",add_to_list)
	#del add_to_list[0] #should delete first one
	print('now we have ',add_to_list)
	#return y;


##===================================
##  funtime(stringname)
## this calls the method get_inner_switch_number()
##===================================
## this replaces the inners switch at 3 tabs with a netsed method name with the id comment number
#this right now only deals with one but I can modify it so that
#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
print("I just don't believe I coded this back on oct 22nd")
print("morgan hill starbucks frosty74")
#===========================================================================
#  convert_inner_switches_into_nested_methods_numbered(stringname): 
#============================================================================
# it will access a list using a loop and they will be put in in sequential order top down
def convert_inner_switches_into_nested_methods_numbered(stringname): #this is feeding in the number looking for
	print("======convert_inner_switches_into_nested_methods_numbered=====")
	x='';concatthis='';counter =0
	# using method get_inner_switch_number(string)#which is grabbed from 3 tab depth only
	for line in stringname.splitlines():
		print(line)
	#modified this and got it working correctly on friday, oct 22nd morgan hill 2021
	for line in stringname.splitlines():
		tabdepth = line.count("\t")
		if  tabdepth == 3  and "switch" in line:
		# I just moved what was in a method into the loop where the action happens
			x = line.split("#")  
			y = x[1];       #it was str(ournumber)
			y = y.replace(" ",'')
			filler ="nested_switch_" + str(y) +"(exp)" #has to be a string
			#### this is new december 5th #######
			print("inside of function convert_inner_switches_into_nested_methods_numbered")
			print("###====line 11729 ===========##")
			print("filler=",filler)
			if ":" in filler:
			    filler=filler.replace(":","")
			#end if
			print("after fix  -- filler=",filler)
			print("###===============##")
			######################################
			line = line.replace("switch(exp){",filler) #notice replace using var 
			concatthis += line + "\n"
			counter += 1
			continue
		else:
			concatthis += line  + "\n"
			counter += 1
			continue
	################	
	for line in concatthis.splitlines():
		print(line)	
		

print("testing this")
print("convert inner switches without bodies inot nested methods numbered")
convert_inner_switches_into_nested_methods_numbered(brew) #line number of inner switch is in thisline[0]
#exit()

#def plan_c(inputstring):


#so we wouldn't need to enter the 5 we an glean that
#and we don't need to know the 15 number either it will grab it
print('======= end of funtime code ==============')
print("now testing with 2 inner switches to change")
print("oasis in the desert -----")
#this is the one that we are playing with
print('=====those headlights are awefully bright - rude and dumb=====')
convert_inner_switches_into_nested_methods_numbered(string_egg2)
print('pumpkin express')
convert_inner_switches_into_nested_methods_numbered(pumpkins)

#try none and try one
convert_inner_switches_into_nested_methods_numbered(brew)
	
convert_inner_switches_into_nested_methods_numbered(brew1)

#exit()
# I think that I will go through a string and 
# return a list of the locations of switches 
# (skipping the first switch)
# switch and endswitch line numbers
# was just thinking that it's obviously a switch otherwise
# we wouldn't be here so NO NUMBER for main switch (brilliant)
#it still matters but it's obvious that it is there. It's actually
# the main switch and the frame for nested switches. 

ibm[0]=tuna #input of string into ibm[0]
list_of_nested_switches=[]
list_of_nested_switches.append(12) #these are just the line numbers here 12 and 32 
list_of_nested_switches.append(32)

#here I am using a list which has the line numbers of the inner switches locations
print(list_of_nested_switches)  #so it would look like this 
#this goes through the input main switch and changes nested "switch" into a nested_switch numbered

#this is used for managing the nested switches by getting their location to know
#where to copy them when extracting them from a main switch
# today is july 17th, 2021 9:33 am

print('testing this to make list of all switch locations and all endswitch locations')
print(tuna)
switch_location=[]
endswitch_location=[]
print("beginning === put location of switch and endswitch into lists")
print("====---------------------- saturday coding ----------===")

ourcounter=0
#for line in abovenestedswitch.splitlines(): 
for line in tuna.splitlines():
    
    if line.startswith("switch"):
        print("this lines starts with switch")
        switch_location.append(ourcounter)
    
    
    if line.startswith("endswitch"):
        print("this line starts with endswitch")
        endswitch_location.append(ourcounter)
        
    ourcounter += 1
        
print("====OUTPUT TO DETERMINE location of each switch and endswitch====")
print("")
print("switch_location=",switch_location)
print("endswitch_location=",endswitch_location)
print("")
print("===make your dreams reality===")
        



# july 24th, 2021 
#the input for this MUST be the already reduced main switch which
# has just the switch word in place where each nested switch thru endswitch was.


###  Thursday, August 19th, 2021 time 9:07 am
# I think that I just need to not worry about the other nested switches
# and just do the first level of nested switch since the others will just be in the other switches
# so let' say I have two nested switches deep
# I only have to have (for the main switch) the first level nestedswitch
# so then the situation becomes the numbering because in this first level of nested switches
# they would be numbered in sequence 1, 2, 3 etc  
# if say there are two nested in teh first main swith then sub1
# but for the inner levels (the next tab level) I would have to do 4,5,6 I suppose
# so continuing sequence or 1.1 and so forth
# I need to come up with a simple numbering system maybe Alpha first level Alph
###
#what if I have pairs, simple numbering but 
##===========================================	
## number_nested_switches_in_sequence()
##===========================================
#put the input I just created into ibm[0]
#this would be the main string after the nested switches are taken out  leaving switch word
forcedinputstring='''
	switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 5')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){     #  this would be 10  for line number      
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== autumn nest===')
			switch(exp){   #this is new 18 but it said previously 28      
			fallthru
		
		default:
			print('the end')
}
'''
#this is input for add counter to switches
trouble=[]
trouble.append(forcedinputstring)


#this is using preset nested switch starting locations 11 and 29 for this test
# this is for making the nested switch numbered method 



#this swaps switch with nested_switch_" n
##########################################
## number_nested_switches_in_sequence():  #this is using hardcoded input for testing
##########################################
def number_nested_switches_in_sequence(): # list_of_nested_switches[11,29]
	print("=R2D2= NUMBER_nested_switches_in_sequence()  ====== ajax =====")
	newcount=1  #number of nested switches starts from 1
	## wait do I loopthru it get the position of the inner switches now why not
	## modification on july 24th 
	print("to see what it sees first")
	#this is string above called forcedinputstring
	print(trouble[0])  #it was ibm[0] which I will change it back to later
	mystring=''
	mystring = trouble[0] #putting the string into trouble[0]
	newcounter=0
	foundone=[]
	# this gets the inner switch locations after the inner switch bodies have been stripped out (deleted)
	##===============================
	for line in mystring.splitlines():  #this fills list foundone with switch line numbers
		if "switch(exp)" in line:
			print("true we found switch")
			foundone.append(newcounter) #this fills the foundone list of line numbers with switch in it
			newcounter += 1
			continue
		else:
			newcounter += 1
			continue
	#=== end loop ========================
	print("we are done looking for the inner switch locations")
	print("====================")
	print("thefoundone llist has",foundone)
	print("the length is", len(foundone))
	print("========........======")
	print(" ") #below we delete the first switch which is on line 1
	del foundone[0] #this should delete the first switch we don't need 
	print("now we have for foundone list",foundone)
	## end getting inner switch lcoations
	##======================================
	
	#shiney= ibm[0] #so it will skip the first few lines skipping the first switch 
	thecounter = 0 #tracking lines in the string   oh it's using preset numbers
	print('the list of nested switches starting line',foundone)
	switchcount=0
	magic_string=''
	seagull='' #WAS shiney.splitlines()
	for line in trouble[0].splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20 #IT HAS TO BE AFTER THE FIRST 2 LINES TO SKIP THE FIRST SWITCH
		#if  switchcount > 0  and thecounter in foundone:
		# if thecounter in founderone
		if  thecounter in foundone:  #this must be line numbers of inner switches
		#this line of code is absolutely beautiful and elegant 
			print("thecounter=",thecounter)
			print("switchcount=",switchcount)
			########We know the line numbers do it on one pass perhaps
			# it should only go to the lines in the list of nested switches
			gettabcount=line.count("\t")
			line = line.replace("switch(exp){","nested_switch_"  + str(newcount) +  "  " +str(gettabcount) + " tabs " +"(n)")
			magic_string += line + "\n"
			#NEW line above
			newcount += 1  #break #because we are only doing it once to replace only ONE switch #start  = thecounter #this resets the range n to skip what it just did.
			thecounter += 1 #this adds to the neste switch counter
			continue    
		else:
			magic_string += line + "\n"
			# new ling e
			thecounter += 1
			continue
	print("=====-----======-----======------=====----====----====---")
	print("magic_string=")
	print(magic_string)
	print("========")
	for line in magic_string.splitlines():
		print(line)
		
	print("were the changes made - this is kind of important at this stage RED ALERT")
	trouble[0] = magic_string #here it's fed into trouble[0] so it's in a list now
	print("did I rip out the nested switches or are they still intact???")
	print("trouble[0]=",trouble[0])	
	#ibm[0] = shiney
			
####================================			
print('about to call number-nested_switches_in_sequence() to test it extendo bus just passed')
number_nested_switches_in_sequence()
print("it should have ran already testing bugs bunny here ")
print("the nested switch words should be nested numbered methods now")
print("just ran this function number_nested_switches_in_sequence()")
print("original mac computer")
			
#exit()

print("we are at line 4434 now and after finishing doing number_nested_switches_in_sequence() ==>>")
print("this is where the exit() was.......1..2...3..4....5..555..666...777..8.8..9999.10 10==")













#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========





			
###============== Sunday July 25th, 2021  10:19 am Cafe Borrone ===============
# the idea is to put the information for each nested switch case
# into the dictionary in terms of it's exact information
# so to fill the data into the nested switch dictionary I will need
# to loop thru the switch string and gather the data for each switch location
# and it's particulars and add it to the dictionary (this should be done first')
# the idea occurred to me since each nested switch has a specific location
# and juggling them can get quite confusing so this way I know which is which
# and where it is.
#=======================================================================
####################
## DICTIONARY HERE 
####################
#putting a named list inside of known dictionary
nest_data=[]
# I probably won't need this.
nested_switch_data =	{  #for pear tree in backyard (2 of them)
#key [level tab depth,number case,  line number, series number
"1": [3,2,23,1], # I can make these now 
"2": [3,3,43,2],
}

print(nested_switch_data)

result=[]
result.append(0)

###############################################################
## RAM LIST TO HOLD TEMPORARY DATA FROM LIST WITHIN DICTIONARY
###############################################################
ram_list=[]
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)
ram_list.append(0)

########################
## get_nest_data(key)
########################
def get_nest_data(x): #puts it temporarily into result[0]
	print("get nest data called",x)
	#this grabs the value from the key and puts it into result[0]
	#these are teh parameters for tehe signature for this nested switch
	result[0]=nested_switch_data.get(x)
	#s- there would be a list within result[0]
	#why not instead populate a list
	print("this is what is in result[0]")
	print(result[0])
	for item in result[0]:
	    ram_list.append(item) #see if this fills it or not
	print('ram_list=',ram_list)
#############################		

  #test data input
############################
##  add_to_nest_data(x,y)
############################
cool_list=[]

# what is missing is the meaning of the code and the beahvior that it creates
# when it's running and knowledge
# how it works and what it does at levels

x = cool_list
def add_to_nest_data(x,y):
	print("====add to nest data() called with ", x  ,"and",y)
	nested_switch_data["my_list_" + str(x) ] = y

#print("my_list_1[0]",my_list_1[0])
#print("gosh")
######====================================
########
print("working on access a dictionary in a precise positiion in a list")
print("that is in the dictionary")
my_dict={}
#add a dictionary #this might be just what I need actually 
my_dict["my_list"] =[3,1,4,1]
print('terrible')
print('trying mydict[0] see if it works')
print(my_dict["my_list"][0]) #the key
print(my_dict["my_list"][1]) #the key
print(my_dict["my_list"][2]) #the key
print(my_dict["my_list"][3]) #the key
alpha = my_dict["my_list"][0]
print("alpha sees =",alpha)
#check in the list


# 

my_list_1=[]
my_list_2=[]
my_list_3=[]
#####======================================
y = [1,2,3,4,5]
add_to_nest_data(1,y)

y = [23,26,34,42,52]
add_to_nest_data(2,y)

y = [63,66,64,72,72]
add_to_nest_data(3,y)
print("=================")
print(my_list_1)
print(my_list_2)
print(my_list_3)

#print(my_list_2)
#alpha = mylist_1[0] #should be 1
print("is this even working....",alpha)

print(" == looping through nested_switch_data to see the contents == ")
print("TESTING ship wreck the contents of the dictionary now,,,")
for key,value  in nested_switch_data.items():
	print(key,value)
	













################################
##  NESTED_SWITCH_INFO
###############################	
def nested_switch_info(x):
	get_nest_data(x)
	#this will get the info from the dictionary		
			
			
			
switch_location=[]
endswitch_location=[]
#  WE ARE HERE THIS IS WHERE THE BIG TEST BEGINS TO REPLACE INNER SWITCHES WITH METHODS ON THE FLY
##=================
#if we already have the numbers it should work, later I will have it find the locations first
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG==")
print("=====GODZILLA and KING KONG ===BIG TEST here in the switch with 2 nested switches")
print("========")
print("this does the bottom half the bottom nested switch first ")
print("this is becuase it's governed by the corect line numbers")
print("and if I take out the top switch code then the numbers for the lower switch will be wrong")
print("I just realized that") #this is the purpose of experimentation
ibm[0] = tuna  #I am force feeding it into ibm[0]

# I have to tell it what number to use to number the nested method using
# use_number[0]= 2 example








################
# the skipping is done by the main switch when I cam copying it and taking out the 
# nested switches below but keeping the switch word that I then convert to a method nested numbered
#################
### TESTING 
#NUMBERING OF NESTED SWITCH HAS TO BE DONE BOTTOM UP SINCE WE ARE RIPPING OUT THE NESTED SWITCH AFTER THE SWITCH WORD
#oh I will have to do this bottom up so the line numbers are correct.
#first show what is in ibm[0]
print("====== testing main switch template ======tue sep 14, 2021 ================")
print("WE MADE IT HERE line 4691 it's tuesday today")
print("TUESDAY TERRIBLE TEST of main nested switch and adding methods for switches swapped out") 
print(ibm[0])
print("I am taking out the lower switch first (later I will copy it first)")
print("it does it upside down going bottom up to do this.")
'''
skipping_some_lines(ibm[0],28,38) #changes 2nd nested switch
use_number[0]=2
swap_switch_for_nest_method_new(21) #second number has the switch in it 
#the first number is the number for the nested_switch
print("this now does the top nested switch")
print("here I am taking out the first nested switch later I will copy it first")
skipping_some_lines(ibm[0],10,20) #changes first nested switch in the sequence
use_number[0]=1
swap_switch_for_nest_method_new(11) #second number has the line number with switch   #needs to be 1 not 2
print("this is the end of Godzill and King Kong testing")
'''






#this should be called only once and 
print("====++++now testing running number_nested_switches_in_sequence()")
#number_nested_switches_in_sequence()
print("we have just completed the first nesteed switch skipping and putting a nested method 1 in ")
print("ibm[0] should show the main switch with 2 methods where the inner switches were previously")
print("this is the output of the string ibm[0]")
print(ibm[0])
print("I am going to loop thru the switch and change the lines with nested_switch")
print("============= Godzilla =============")
print("END OF GODZILLA AND RODAN AND MOTHRA")


#go thru a number the switches numerically top down

























hawaii ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown 6')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#######
			switch(exp){          
				case 'blable':
					print("do something")
					print("yep")
					######
					switch(exp){          
						case 'blable':
							print("do something")
							print("yep")
							fallthru
						case 'more':
							print("nice")
							break
						default:
							print("we are done here")
						endswitch 
						######
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			######
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			#######
			switch(exp){          
				case 'fish':
					print("do something")
					print("yep")
					fallthru
				case 'trout':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch 
			#######
			fallthru
		
		default:
			print('the end')
}
'''	
get_switch_and_endswitch_locations(hawaii)
print("this would have just gotton the switch and endswitch line number locations above...")
print("I found it, I was looking for this code")
#empty_switch_and_endswitch_list_locations()

get_switch_and_endswitch_locations(tuna)
###======================================================
#july 19th 2021 testing this feature now morgan hill starbucks
########################################################
#empty_switch_and_endswitch_list_locations()
#print("the one below this line should produce 2 switches and one with 10,20")
#print("why is this wrong")
#get_switch_and_endswitch_locations(samplestring) #samplestring 
#get switch and endswitch lcoations for one nest
#it's off by one says 11,21
#input is 10 and 20 and yet this says the line number is 11 and 21 for nested switch

empty_switch_and_endswitch_list_locations()
print("the one below this line should produce 2 switches and one with 10,20")
print("why is this wrong")
print("get result of get switch and endswitch locations from samplestring")
print("earth is over level ======")
print("earth is over level ======")
print("=== tea time =============")
get_switch_and_endswitch_locations(samplestring) # sammplestring


###  july 14th wednesday 2021 working on this
#real number is count endswitches and add 1 for total switches

#endswitches number is how many nested switches

# this empties the lists storing the switch and end switch locations

#del switch_location[:]
#del endswitch_location[:]

#get_switch_and_endswitch_locations(hawaii)

print("this is the string with two nested switches")
print("here we go wednesday coding - the bicycle gloves are great")
print("first clearing out the lists that hold the locations of the switch and endswitches")
print("this clears out the swith and endswitch locations in the list so it starts empty")

#I was deleting the crucial lists so the code down below couldn't behave correctly

#del switch_location[:]
#del endswitch_location[:]
#feed the string into the method to get the switch and endswitch locations
# but delete the first switch details which isn't important at this point.

#get_switch_and_endswitch_locations(tuna)
#this creates a list that can be of any size and then I can subtract the first switch
#and then divide the number by 2 to get teh number of switches or just count teh switches
'''
nest1=[]
nest1.append(switch_location[0])
nest1.append(endswitch_location[0])
nest2=[]
nest2.append(switch_location[1])
nest2.append(endswitch_location[1])
#wait a  second with each pass the output will be teh same unless I have 
#a list of say ten spaces tol hold locations to be proactive.
#####################################################
print("nest1=",nest1)
print("the two values in nest1 are",nest1[0],nest1[1])
print("nest2=",nest2)
print("the two values in nest2 are",nest2[0],nest2[1])
'''


#++++++++++=========================================================
### july 7th 2021 experimenting 
### testing cutting out two nested switches one at a time
### and replacing the switch location with the nested method with a number
# I need to do these separately first to make that they work
##===========================================
##===========================================
#skipping_some_lines(tuna,nest1[0],nest1[1])
#swap_switch_for_nest_method_new(1)

#and I need to make sure that the resulting string to modify the second phase is correct
#skipping_some_lines(tuna,nest2[0],nest2[1])
#swap_switch_for_nest_method_new(2)
##============================================
##============================================
# what I will attempt it going thru the double nested switch with two nests
# and delete the two nests and put nest methods in the location of the inner switches.
# and then after that is figured out I will first copy each inner switch
# Based on the nested switch locations I find I can determine how many nested switches
# espcially with teh endswitch count 



#######================================================================#########==========

#######================================================================#########==========

#######================================================================#########==========


















def end_program():
    print("ending program")
    return

## method chaining nov 13th, 2021 &:45 am
print("======= chaining methods =======")

'''
I was going to do method call
Loop thru all slots in list
====================
Then do next method call to all items in list
Chaining input to output is input fir next method
Then realized if i chained
Sequence of methods only go thru loop once (genius)
'''


## chain methods code  chain methods chain methods CHAIN METHODS 



#A method that calls a series of methods really utilizing output from previous method

#these might have been created above but I am doing them again here just in case.
input=[]
input.append(0)

output=[]
output.append(0)


##=====================
##   get_final_finished_string()
##=====================
def get_final_finished_string():
    print("===get_final_finished_string():===")
    print("output[0]=",output[0])
    print("=== result is in output[0] ===")
    
# passing the baton in the relay race 
##=====================
##   so_pipe()   #this feeds output[0] into input[0] to be used with next method
##=====================
def do_pipe():
    print("==== do_pipe() ====")
    #put output[0] into input[0]
    input[0] = output[0] 


##=====================
##   initialize_lists()
##=====================
def initialize_lists():
    print("====initialize_lists(): ====")
    input[0] =''
    output[0]=''
   


old_string_test='''
switch(exp) {  
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 7')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   #here        representings stripped out inner nest
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			switch(exp){     #here     
			fallthru
			
		
		case 11 to 12:
			print('this is so frustrating')
			print('== window won't go back up===')
			break
			
		
		case 13 to 15:
			print('at starbucks')
			print('== where is my mocah?===')
			switch(exp){     #here    # represents already stripped out inner nest 
			fallthru
		default:
			print('the end')
endswitch
'''

  
holdthis=[]
holdthis.append(0)

#this swaps endswitch with }
######################################
## take_out_endswitch(stringname)  #from bottom of nested switch 
######################################
def take_out_myendswitch(stringname):
	print("take_out_endswitch called=============")
	galaxy = stringname
	#print(galaxy)
	holdthis[0] = galaxy.replace("endswitch","}")
	##================================
	#what this does is take off the comment after }
	#and then it shifts } to the far left against the margin with no spaces
	
	buildnewstring=''
	for line in holdthis[0].splitlines():
		if "}" in line:
			print("detected } in line")
			#location = line.index("#")    #gets location from left where position of #
			#line = line[:location] 
			print("resulting line looks like this",line)
			line = line.lstrip() #this should move it to the far left to align with margin
			print("after left shift it is ",line)
			#line[0] = first #this is new to slice off right of brace
			line = line[0]#first char
			buildnewstring += line + "\n";
		else:
			buildnewstring += line + "\n";
	#end loop
	holdthis[0] = buildnewstring
	print("this is the final outpout of take out endswitch")
	#for line in holdthis[0].splitlines():
	#    print(line)
	    
	##===========today sunday coding
	
	#then look for this } and reposition it
	'''
	testingthis=''
	for line in holdthis[0].splitlines():
	    
	    if "}" in line:
	        line= line.lstrip()
	        testingthis += line
	    else:
	        testingthis += line
	holdthis[0] =testingthis
	print("now testing if this change worked shifting } to far left")
	for line in holdthis[0].splitlines():
	    print(line)
	'''       
	#this is what I need to modify.
	#so the whole modified string after ripping out endswitch is now in holdthis[0]
	
	print(holdthis[0])
	galaxy = holdthis[0] #now galaxy gets what is in holdthis[0]
	return galaxy #and this is returned
	
print("testing taking out endswitch and putting in brace")
#take_out_endswitch(old_string_test)
print(holdthis[0])


    
##======================================================================================
#the result of each of these methods will put their result in output[0]
#swap_feed_data then puts what is currently in output[0] into input[0] so it's a handoff of the baton
#each of these methods takes in input[0] as input with the result going into output[0]
#after each method we call do_pipe() which puts output[0] into input[0]
# string --> m1(input) => m2(input) => m3(input) => m4(input) => m5(input) 

##====================================================
##  first_method : manipulate_string  (left indent)
##====================================================
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    print("manipulate_string left margin indent ===first message called..")
    #shifts string left to indent it properly
    astring=manipulate_string(astring) #I think that this does left shift indentation
    return astring

##==========================================
##  second method : take_out_switch_body  from inner switches
##=========================================    
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    print("take_out_switch_body ...seconed method called...")
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #<== key this is new to see if it works=========
    #astring += " water"
    return astring


##=================================================
##  third method : change_switch_to_method_solved
##=================================================
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("change_switch_to_method_solved  swapto neested_switch method third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    return finalresult

##======================================
##  fourth method  : take_out_endswitch
##======================================
#take_out_endswitch(stringname)
def fourth_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("take_out_endswitch  put in brace instead third method called...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring)
    #astring += " bright"
    return finalresult
    
    
##=======================================================================================
#using descriptive names not true method names yet
# what this is doing is modifying a string in stages in a sequence 
# code name waterfall
output=[]
output.append(0) #so we can use output[0] below
##========================================
##  chain_methods()   this just does a sequence of methods piped  
##                    together so each method passes its output as input for next method
##=====================================
def chain_methods(item):
    print("==NOT ANY MORE OFFICIAL== chain_methods called ====")
    firstresult  = first_method(item)         # manipulate_string(string)
    secondresult = second_method(firstresult) # take_out_switch_body(string)
    thirdresult  = third_method(secondresult) # change_switch_to_method_solved(string)
    fourthresult = fourth_method(thirdresult) # take_out_endswitch(string)
    output[0]    = fourthresult #this puts the result into output[0]
    print("now we are looking in the frac output of fourth method")
    for line in output[0].splitlines():
        print(line)
    #the resulting string is put into output[0]
    
    
    # I still need to rename the actual methods and put them above this section 
    #add comment number to all switches at the very beginning of initial switch string(not here)
    #add_comment_with_number_to_top_switch(input[0]);do_pipe();  #switch # 22 <-- line number added
    #shift_string_to_left_by_reducing_tabs(input[0]);do_pipe();  #subtract tabs # works nov 19th
    #cut_out_switch_bodies_at_3_tabs_depth(input[0]);do_pipe();  #reduce switch body to just switch word
    #swap_switch_with_nested_switch_number(input[0]);do_pipe();  #change switch to nested_switch_22(exp)
    #replace_the_last_endswitch_with_brace(input[0])             # endswitch becomes  }
    #get_final_finished_string() #in output[0] prints it out nest_list to see it




##=================================
## change_slot_string(counter)    this changes content of each slot in nest_list
##=================================
def change_this_slot_string(counter): #requires output[0] finished string
    print("==== change_this_slot_string(counter) ====")
    counter = int( counter)
    nest_list[counter] = output[0] #I really need to test this one and see if it works 
    #this means that needs to have finished chained_methods put into output[0]
    
##============================
## transform_string()    uses nest_list with strings in it of switch case bodies
##============================
def transform_string():  #this calls chain_method(item) # separate switch string input
    print("==== transform_string() ====")
    counter =0  #loop
    for item in nest_list:  #loop thru nest_list and each loop does the chain_methods
        chain_methods(item) # takes in string and does sequence methods puts into output[0]
        change_this_slot_string(counter) #changes slot string from output[0]
        counter +=1


##==================================================
## loop_thru_finished_list_of_prepped_strings():
##==================================================
def loop_thru_finished_list_of_prepped_strings():
    print("==== loop_thru_finished_list_of_prepped_strings() ====")
    counter =0  #loop
    for item in nest_list:
        print(item)
        print("counter=",counter)
        print("===========")
        


# loop_thru_finished_list_of_prepped_strings() took this out
# this hasn't been tested yet. Today is Sunday, November 14th, 2021 10:58 am Pacific Standard Time
# this goes thru nest_list and modifies all of the switch strings
# and fixed the indentation, and adds nested methods and a comment after each switch 
# with the number after it and cuts out the switch bodies at three tabs depth
# and it uses chain methods in a sequence on each string so the loop only goes ONCE !!!!!
##====================================================
##  prep_nest_list_of_switch_strings_for_bypass205()   STAINED GLASS WINDOW SECTION
##====================================================
## ATTENTION: I have the code for this working but the names are new and I need to 
# put the first two methods lists below in these names. This is SOOO COOL NOW 
#dec 5th sunday I don't think that this is called yet.not tested yet then.
def prep_nest_list_of_switch_strings_for_bypass205():
    print("====prep_nest_list_of_switch_strings_for_bypass205() ====")
    go_thru_input_major_switch_string_and_make_list_of_pairs_switch_and_endswitches() # made above
    using_pair_list_make_seperate_switch_strings_and_put_into_nest_list()             # made above
   # transform_string() #DOES CHAIN METHODS  loops thru  nest_list modifies each separated string
    #loop_thru_finished_list_of_prepped_strings() #thru FINISHED nest_list
    #the end result will be in nest_list with the strings ready to feed into bypass205
    

print("testing if this prep nest list is even called or not on dec 12th, 2021")
#prep_nest_list_of_switch_strings_for_bypass205()
print('after calling prep nest list of switch strings for bypass205')

#exit()





holdingpattern=[]
holdingpattern.append(0)
##=========================================
## fixes_dots_in_nested_string(inputstring)
##=========================================
def fixes_dots_in_nested_string(inputstring):
    print('testing very_clever')
    #    print(item)
    newline =''   
    for line in inputstring.splitlines():
        if "nested_switch" in line:
            newline += line.replace(":","") + "\n"
        else:
            newline += line + "\n"
    print("this is the result of modifying and taking out : after nested_switch")        
    for line in newline.splitlines():
        print(line)
    holdingpattern[0] =newline
     #I still need to change the slot in the string though 


##========================================================================
##========================================================================
##========================================================================



input=[]
output=[]
output.append(0)

mystring = "smile "

def get_one(astring):
    astring += " a"
    return astring
    
def get_two(astring):
    astring += " water"
    return astring

def get_three(astring):
    astring += " bright"
    return astring

fizz  = get_one(mystring)
fizzy = get_two(fizz)
fuzzy = get_three(fizzy)

print("fuzzy after my simulated piping =",fuzzy)
print("")
print("")
print("final test before sending it to bypass205()")
print("this should take in a string")
print("indent it to the left margine")
print("take out switch bodies")
print("swap switch with nested_switch numbered")
print("============== here we go rudolph ======")
print(" . ")
print('...................,.,.,.,.,.,.,.,.,.,.,.')



#for testing purposes of transforming an input string this one is teststring3
mystring = teststring3  #right here change it 
for line in mystring.splitlines():
    print(line)
   
   
   
##=============================================    
#manipulate_string left shift indentation
def first_method(astring): #this does the left shift 
    print("=====first method started..")
    #shifts string left to indent it properly
    #LEAVE THIS DON"T MEDDLE THIS WORKS
    # MODERN TAB SHIFTER TO LEFT IS PURE GOLD
    modern_tab_shifter_to_left(astring) #I think that this does left shift indentation
    astring= goldtime[0] #output from modern_tab_shifter_to_left
    #removes garbage on right side of switch strings (still testing)
    ########################
    print("check right here frosty")
    #print("newstring[0]=",newstring[0])
    
  
    
    ##################################
    #print("calling: fixes_dots_in_nested_string() method")
    #fixes_dots_in_nested_string(astring) #when it is nested_switch_22:(exp) removes :
    #astring=holdingpattern[0]
    for line in astring.splitlines():
        print(line)
    
    #return astring
 ######################################   
#take_out_switch_body
def second_method(astring): #cuts out switch body leaving switch word in all occurances
    print("=======seconed method started.take_out_switch_body..")
    #astring =newstring[0] #from first method above outoput
    #TAKE OUT SWITCH BODY METHOD
    #print("see what we are passing does it have something in it")
    print(astring)
    take_out_switch_body(astring) #this takes out the switch body 
    #the output goes into lightning[0]
    astring=lightning[0] #this is new to see if it works=========
    
    
    print("==output from second method take out switch body==")
    for line in astring.splitlines():
        print(line)
        
    print("================")
    #astring += " water"
    return astring




 #converts inner switch into a nested_switch method numbered
############################################
#change_switch_to_method_solved
def third_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("=======third method started...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    #converts inner switch into a nested_switch method numbered
    finalresult=change_switch_to_method_solved(astring)
    #astring += " bright"
    print("===third method output==")
    print("outoput from change switch to method solved")
    #for line in finalresult.splitlines():
    #    print(line)
    
    print("what does it say right here")
    for line in finalresult.splitlines():
        print(line)
        
    return finalresult    
    
    
    
############################################

#take_out_endswitch(stringname)  #this would do all of them regardless of number
def fourth_real_method(astring):  #this changes the inner switch to nested_switch numbered 
    print("third method startedc...")
    #change_switch_to_method_solved() takes out switch puts in nested_switch
    finalresult=take_out_endswitch(astring) #replaces it with }
    #astring += " bright"
    return finalresult
    
hollister_list=[]
#take_out_endswitch(stringname)
##=========================================
##  simulated_chain_methods():  this is called for each switch string
#this is doing one string at a time. 
##===================================
def simulated_chain_methods(mystring): #starting point 
    print("SIMULATED CHAIN METHODS () Rudolph the red nosed reindeer")
    first_method(mystring)
    fizz=goldtime[0] #output from first_method()
    print("stage1 fizz =",fizz)
    
    print("FIZZ TESTING CRITICAL 1ST METHOD output of first_method() ")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fizz.splitlines():
        print(line)
    
    ##############################==================
    fizzy = second_real_method(fizz)  #missing 66
    print("stage 2 fizzy=",fizz)
    
    print("FIZZ  TESTING CRITICAL 2ND METHOD to see what's in frac")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fizz.splitlines():
        print(line)
    
    #return   
    ##############################
    fuzzy = third_method(fizzy)
    print("stage 3 fruzzy=",fuzzy)
    
    print("FUZZY  TESTING CRITICAL 3RD METHOD to see what's in ")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in fuzzy.splitlines():
        print(line)
        
        
    ############################
    frac  = fourth_method(fuzzy)
    print("strage 4 frac=",frac)
    #############################
    print("now we are looking in the frac output of fourth method")
    for line in frac.splitlines():
        print(line)
    print('above this line is the Rudolph the red nosed reindeer final first test')    
    print("line number 12502")
    #frac is the result
    #look at frac to see when  switch 31 and 66 are missing
    print("FRAC  TESTING CRITICAL 4TH METHOD n frac")
    print("==looking for missing switch 31 and missing switch 66=======")
    for line in frac.splitlines():
        print(line)
        
    hollister_list.append(frac) #new on november 30th Tuesday 
    
    
    
    
###==============
##   plan B 
##================  testing converting nest string testlist_of_strings
def planB():  #november 30th, tuesday 9:45 am morgan hill starbucks 
    print("never give up")
    print("PLAN B called using simulated_chain_methods on each switch string")
    print('===== welcome to planB ==== november 30th tuesday===')
    print("doing planB testing each nest_list doing chain_methods")
    counter=1
    for item in testlist_of_strings: #test string names numbered
        print("========================")
        simulated_chain_methods(item) #testing chain methods
        print("====== counter= ",counter)
        counter += 1
        
    print("the HOLLISTER LIST of modified switch strings that started out seperated")
    for item in hollister_list:
        print(item)
        print("==== middle ground between methods ===")


#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########
#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###########


#making this sucker work no matter what 

#print("the big test begins")
#planB()
#print("now simply loop thru the finished changes in the list")

#### stage 1 test ###############
#each fruit method will do the list of 7 input strings stop
#these are the REAL CHAIN METHODS AS OF DEC 11 SATURDAY 2021 8:10 AM ====
result_of_first_method=[]
result_of_second_method=[]
result_of_third_method=[]
result_of_fourth_method=[]

print("this is after the input stings have already been seperated")
##======================
##  move_string_to_left_side()        first method modern tab shifter to left 
##======================
#output: result_of_first_method all switch strings modified
def move_string_to_left_side():
    print("=====APPLE== modern_tab_shifter_to_left()=====")
    counter = 1
    for item in testlist_of_strings:
        print("=======")
        modern_tab_shifter_to_left(item)
        fizz=goldtime[0] #output from first_method()
        #print("apple stage1 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_first_method.append(fizz)
        print("===== counter =",counter)
        counter += 1
    ################################################    
    counter =1
    print("result of shifting input strings to left")
    print("=====APPLE==APPLE   APPLE   APPLE   APPLE   APPLE=====")
    for item in result_of_first_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    




##======================================================
## take_out_the_inner_switch_bodies_leaving_switch()
# output result_of_second_method
# method used: take_out_switch_body(string)
##======================================================
def take_out_the_inner_switch_bodies_leaving_switch():
    print("=====PLUM == take_out_switch_body(item)====")
    counter = 1
    for item in result_of_first_method:
        take_out_switch_body(item)
        print("===== counter =",counter)
        counter += 1
        fizz =lightning[0]
        print("plum stage2 fizz =",fizz)
        #append outpoutto result_of_first_method
        result_of_second_method.append(fizz)
    ###################################################
    counter =1
    print("result of taking out inner switch bodies")
    for item in result_of_second_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    

#good_plum()





##===================================================================
## good_peach()  change_switch_to_method_solved : switch to nested_switchX(exp) # 
## output: result_of_third_method
##=================================================================
def change_switch_to_nested_switch_method(): #swaps switch with nested_switch method
    print("=====PEACH===change_switch_to_method_solved===")
    counter = 1
    for item in result_of_second_method:
        fizz=change_switch_to_method_solved(item)
        print("peach fizz=",fizz)
        #append outputto result_of_first_method
        result_of_third_method.append(fizz)
        print("===== counter =",counter)
        counter += 1
    #########################################
    counter =1
    print('result of 3rd method on string')
    for item in result_of_third_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    
    
    
##===================================================================
## replace_endswitch_with_close_brace     take_out_endswitch() 
## output: result_of_fourth_method
##=================================================================
def replace_endswitch_with_close_brace():
    print("=======ORANGE=====take_out_myendswitch===")
    counter = 1
    for item in result_of_third_method:
        take_out_myendswitch(item)  #other one is take_out_endswitch
        print("=======")
        fizz =  holdthis[0]
        print('orange fizz =',fizz)
        result_of_fourth_method.append(fizz) #this fills up result_of_fourth
        print("===== counter =",counter)
        counter += 1
   #########################################
    print('result of 4th method on string')
    counter=1
    for item in result_of_fourth_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1


#######################################################

    
    
    
    
    
    
    
    
#this gets the numbers and fills up the list switch_numbers_to_transfer  
switch_numbers_to_transfer=[]
cell=[]
cell.append(0)
##==================================== created dec 6th monday 2021
##  get_switch_number_now(lestring): from quail list before bypass205 is called
##====================================
def get_switch_number_now(lestring): #fills list switch_numbers_to_transfer
    print("====get_switch_number_now()=====") #gets it from quail list
    counter =0
    for line in lestring.splitlines():
        if  counter == 1 and "switch" in line and "#" in line and "end" not in line:
             x =line.index("#");
             x=x+1;
             answer=line[x:];
             cell[0]=answer;
             switch_numbers_to_transfer.append(answer) #fills up this list
             break;
        else:
             counter +=1
    
    
            
#this fills up the switch_numbers_to_tranfer list used in bypass205 to
#use in the numbering of the switches with a # after each
##====================================================
##  fill_switch_numbers_list_to_transfer():
##  method: get_switch_number_now()
##==================================================  
def fill_switch_numbers_list_to_transfer():
    print("=======fill switch nubmers list to transfer()====")
    #this is where each switch number in the comment #11 example is put
    #into the list switch_numbers_to_transfer the baton to python output string put in number
    for item in result_of_fourth_method:
         get_switch_number_now(item) #fills list switch_numbers_to_transfer
    #there will be no changes to this switch string   
    print('result of 5th method on string is filling the switch_nubmers_to_transfer')
    print('no changes to the result of the fourth method')
    counter=1
    for item in result_of_fourth_method:
        print(item)
        print("=========")
        print("counter=",counter)
        counter += 1
    print("let's see the (switch_numbers_to_transfer) list now")
    print(switch_numbers_to_transfer)
    #exit()
    #this gets the switch number from each first switch in a string
    # and put is tinot switch_numbers_to_transfer 


#print("=========== get switch numbmer in quail list") 
##=============================================
## get the switch_numbers_to_transfer():
#this is trapeze to get the switch number for first switch in each string
#which will be used for make the def nested_switch and main_switch in python mode
##=============================================
def get_the_switch_numbers_to_transfer():
    counter=1
    for item in chain_output_list:
        get_switch_number_now(item) 
        print("number =",counter)
        print(cell[0]) 
        counter += 1          
    print("switch_numbers_to_transfer",switch_numbers_to_transfer)
  
  
  
  
  
chain_output_list=[]
##===================================================
## fill_chain_output_list():
##==-================================================
def fill_chain_output_list():
    del chain_output_list[:] #empty it to be sure
    print("====fill chain output list()====")
    for item in result_of_fourth_method:
        print(item)
        chain_output_list.append(item) #ah this is where that is. 

##======================================================
## loop_thru_chain_output_list_and_fill_quail_list()
##======================================================          
def loop_thru_chain_output_list_and_fill_quail_list():
    print("here we are filling the QUAIL list officially -it's about time")
    del quail[:] #empties quail list
    for item in chain_output_list:
        quail.append(item)
    print("====Quail List Output========== ")
    print("quail output now is this which will be fed into bypass205() parser")
    for item in quail:
        print(item)        
    print(" ")
   # print("==switch_numbers_to_transfer list==")
    #print(switch_numbers_to_transfer)
##=============================================
## show_list_switch_numbers_to_transfer()
##=============================================
def show_list_switch_numbers_to_transfer():
    print("===switch numbers to transfer== stage2 Linus==")
    print(switch_numbers_to_transfer)
    #print("")
    #for item in switch_numbers_to_transfer:
    #    print(item)     

##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##===BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER BLENDER
##====================================
##  do_the_blender_chain_methods()
##====================================
def do_the_blender_chain_methods():
    print("==the blender chain methods()==")
    move_string_to_left_side()                         #indents to left
    take_out_the_inner_switch_bodies_leaving_switch()  #cut out switch bodies leaving switch
    change_switch_to_nested_switch_method()            #switch becomes nested_switchX
    replace_endswitch_with_close_brace()               #endswitch becomes }
    fill_switch_numbers_list_to_transfer()             #list generated used for codegen
    fill_chain_output_list()  
    print("=== end of blender chain methods() ==")    

##  waterfall_chain_methods_gold_master()  formally called do_it()  #this is the one actually being used.
## uses testlist_of_strings for input
##==================================================
#the way this works is each method does all of the switch strings as a set
#each of these methods does all of the switch strings in the list at once 
#and the results are passed downward cascading for the next method to modify.
#========WATERFALL CHAIN METHODS GOLD MASTER THE REAL DEAL=======
##===================================================================================    
## ====  WATERFALL CHAIN METHODS GOLD MASTER OFFICIAL OFFICIAL OFFICAL OFFICIAL  =====       
##=====================================================================================
def waterfall_chain_methods_gold_master():  #THIS WILL TAKE IN THE QUAIL LIST FOR INPUT
    print("===WATERFALL CHAIN METHODS Gold Master 1.3()====THE REAL DEAL  REAL WORLD = ")
    print(" == Sunday, dec 12th, morgan hill starbucks 10:01 am ==")
    #loops thru testlist_of_strings
    for item in testlist_of_strings: #this displays each switch string starting out
        print(item)
        print("========")#formally apple, plum, peach, orange 
    #==chain methods called here=== 
    do_the_blender_chain_methods()
    #loop_thru_chain_output_list_and_fill_quail_list() #ultimately will need to feed quail list
    #    method above turned off for now
    show_list_switch_numbers_to_transfer()
    print("LINUS list switch_numbers_to_transfer at bottom of chain methods")
    print(switch_numbers_to_transfer)
    print(" ==end of line ... Sunday, dec 12th, morgan hill starbucks 10:07 am ==")
   
    #new as of dec 9th  2021 #this fills the switch_numbers_list_to_tranfer 
    #of the switch id numbers which are utilized in the stanford string list
    #and added to each first switch in the stanford list and then accessed
    #to use to make the nested_switch_number or main_switch if it's 1.
    #exit():

print("new starting point just 2 function calls===") 
print("serious fireworks star spangled banner")  
print("end of crucial test copying the strings and putting them into a list")
#this separates the switches built using copy body using pairs x,y  
#this needs to be called before filling the list obviously  

#comemnted these out for testing purposes..
#split_up_big_string_into_nested_switches(red_robin)  
##===================================================================
## prepare_input_switch_strings_with_chain_methods_for_bypass205()
##==================================================================
def prepare_input_switch_strings_with_chain_methods_for_bypass205():
    waterfall_chain_methods_gold_master()  #<<=== this calls the chain_methods to run
    #this would prepare the separated switch string bodies for parsing


#so this will be called on the test strings 
# the current working code isn't using this because it hasn't been used yet
##=================================
prepare_input_switch_strings_with_chain_methods_for_bypass205()

#print("quail list output")
#the strings below are after the waterfall chain methods modified the strings
#to prepare them for the bypass205() parser 
##=========================

#chain_output_list.append(gold1)
#chain_output_list.append(gold2)
#chain_output_list.append(gold3)
#chain_output_list.append(gold4)
#chain_output_list.append(gold5)
#chain_output_list.append(gold6)
#chain_output_list.append(gold7)


#WATERFALL CHAIN METHODS CALLED HERE  




#



#fill_chain_output_list()
        
#print("end result of running chain methods on input switch nested code.")
#for item in chain_output_list:
#    chain_output_list.append(item)
#    print(item)

    
output='''

get switch number now
cell[0]=1  1
get switch number now
cell[0]=2  11
get switch number now
cell[0]=3  15
get switch number now
cell[0]=4  23
get switch number now
cell[0]=5  31
get switch number now
cell[0]=6  62
get switch number now
cell[0]=7  66
'''
#testing_with_new_list=[]
#testing_with_new_list.append(gold1)
#testing_with_new_list.append(gold2) 
#testing_with_new_list.append(gold3) 
#testing_with_new_list.append(gold4) 
#testing_with_new_list.append(gold5) 
#testing_with_new_list.append(gold6) 
#testing_with_new_list.append(gold7) 

print("linus ends here ha ha ====")
  
#exit(); 
 
  
### end of Linus file #######===================


#import method_calls
#from method_calls  import *  
#from Linus import switch_numbers_to_transfer
#from Linus import switch_numbers_to_transfer

#######################################################
# official_switch_case_silver.py  works in conjuction with test file test_inputs_beta.py
# developed solely by Blake Southwood  this is version 1.0
# June 10th, 2021  I live in Silicon Valley south of San Jose in California
# southwood.blake@gmail.com
# I live in Gilroy, CA and will relocate.
# I am currently looking for a full time python developer job.
# I am in the process of refactoring this code base but wanted
# to get it working and stable first.
####################################################### 
# -*- coding: utf-8 -*-
tahoetest=[] #initalized here
tahoetest.append('starter') #position 0 holds just starter

# empty_tahoetest()
switch_count=[]
del switch_count[:] #empties list in case residue from previous runs

#############################
##    empty_tahoetest()
#############################
def empty_tahoetest():
    del tahoetest[:] #this erases the list completely if called 

########################################
## show_the_nested_strings_in_memory()
########################################
def show_the_nested_strings_in_memory():
    for item in tahoetest:
        print("=======")
        print(item)
        print("=======")
           
           
disney_tron_trace_list=['starter']

######## show tron trace path ===========
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number




#### mytrace ===============
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)
	
#import sw_module_extra
digitalcandy=[]
line_numbers_of_first_cases=[]

#########==============================
### added June 3rd, 2021 
## initialization 
show_code=[]
show_code.append(False)
#show_code[0]= False
#print('starting out what the flag for show code shows')
#print("default setting for show_code[0]",show_code[0])
#show_code.append(False) # by default
#############################################
#to show or hide the docstring switch input in C style
### show input switch string
show_input_string=[]
show_input_string.append(False)
#show_input_string[0]= False

def show_input_switch_string():
    del show_input_string[:] #empty it first
    show_input_string.append(True) #then add True to position [0]
################################
### hide input switch string
def hide_input_switch_string():
    del show_input_string[:] #empty it first
    show_input_string.append(False)

### show_generated_code
def show_generated_code():
    show_code[0]= True
    
### hide_generated_code
def hide_generated_code():  #test this if it really works
    show_code[0]= False
    
#the dilimma is resetting it to default of False
#actually they would probably want them all on or all off honestly
#and they -the settings - show stay in that state  (makes sense)    



    
########## woodstock here may 29th ===============


disney_tron_trace_list=['starter']
######## show tron trace path
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number

#### mytrace
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


############################=============
varholder=[]
#def flush_lists():
#	varholder=[]
varholder.append("zilch") #if nothing changes it's default



def is_number(inputString):
	return any(char.isdigit() for char in inputString)
valve=[]
###############################===========


#####################		
newlist =[];count =''  # these are used
######################
####################################################
##      swap_thru_lines_with_expanded_cases()     ##  this is for number cases
####################################################
def swap_thru_lines_with_expanded_cases():
	mytrace('swap_thru_lines_with_expanded_cases()')
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			# this is where it gets number that is now a string
			cat =is_number(smart[1])  #calling method to check if  #the case name is a number
									 
			#print(cat)
			cool = smart[1][:-1]  #chops off : from end last char
			holder = "'" + cool + "'"  #this puts the number in quotes
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	#after the numbers have been converted into strings


############################
list_with_thru_macros=[]
list_with_thru_macros.append(0) #position 0 nothing
backwards_thru_list =[]  #initializing the list




#############################
################ case 1 to 10: becomes case 1 thru 10:######################
################################
#### change to into thru ()       created friday feb 5th, 2021 morning
################################
def change_to_into_thru():  #this is a simple way of doing it
	mytrace('change_to_into_thru()')
	#print("change macro to into thru")
	global switchcasetester
	mycounter = 0; banana=''
	for line in switchcasetester.splitlines():
		simple = mycounter-1
		if "case" and "to" in line:  #this means the macro to
			banana=switchcasetester.replace(" to "," thru ")  #just addded spaces
			switchcasetester=''; switchcasetester = banana
			#print(switchcasetester)
		else:
			pass


###########################################		
## make_list_of_lines_using_thru_macro():		
###########################################
def make_list_of_lines_using_thru_macro():
	mytrace('make_list_of_lines_using_thru_macro()')
	#print("=====WARNING WILL ROBINSON LOST IN SPACE====")
	#print("* * * * WORKING ON FUNCTION make_list_of_lines_using_thru_macro()")
	#print("===----------=== make list of lines using thru macros() ====--------=")
	#go thru list and if thru in line add that line to list
	global switchcasetester #just added this 
	#how comes this works without global switchcasetester?

	#global switchcasetester #it should work now
	thru_counter = 0
	for line in switchcasetester.splitlines():
		#just added the word to that means the same thing as thru
		if  "case" and "thru" in line:  #on
			list_with_thru_macros.append(thru_counter)
			thru_counter += 1
		else:
			thru_counter += 1
			continue
	#print(list_with_thru_macros)		
	#then I need to reverse the list
	backwards_thru_list=list_with_thru_macros
	backwards_thru_list.reverse()
	#print("backwards we have",backwards_thru_list)
	bottom_up_change_of_thru_line_test() #this just shows the result but really does nothing



##### testing january 10th to go to each case thru from bottom up and change line
##### to prove it's working
####################################################################
## what this does is change the thru macro line starting at the bottom
## by accessing the backwards list made above 
##  backwards_thru_list  that took in the line number of each thru line and reversed it
##########
def bottom_up_change_of_thru_line_test():
	mytrace('bottom_up_change_of_thru_line_test()')
	#global mouse
	global opal; opal = ''; mycounter = 0
	#print("value of mycounter should be zero",mycounter)
	#for item in backwards_thru_list: 
	#set mycounter to a number for line in mouse.splitlines() : #this goes thru the mouse string
	#	print(line)
		

###############==============
smart =''
beta =''
opal=''
import re
newline=''
#################==============


##############################################################################
#################### case_numbers_to_strings() ###############################
##############################################################################
######  converts numbers to strings case 1: to case '1': #####################
##############################################################################
def case_numbers_to_strings():
	mytrace('case_numbers_to_strings()')
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#print("========  CASE NUMBERS TO STRINGS  ====")#go thru the entire string
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global switchcasetester ## just addded this may 27th
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			#print(cat)
			cool    = smart[1][:-1]  #chops off : from end
			holder  = "'" + cool + "'" #this puts the ' on both flanks of the number
			cool    = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	#after the numbers have been converted into strings


#############################================


exp =''; case =''
exp = ""

mycounter=0


line =""
varholder=[]
varholder.append('0')
###############################============

#perhaps this is the clever() being called afterall june 9th 2021
#apparently this needs to exist in this file
def clever(i): #so it already exists we are changing its value
	print("clever() on line 276")
	varholder[0]='' #this should reset it to nothing
	mytrace('clever()')
	varholder[0]= i
	#===this works and it fills a list with input from an argument
	#print('varholder[0]=',varholder[0])
	#print(varholder[0]) #to actually see proof
	return varholder[0]
	angel = varholder[0]

###############################================


z =''
import re  #for regular expressions
acounter=0
x = 0;y =0
smart=''
res =[]
newlist=[]
switch_python_gen=''
###########################================




###==============================================================
###================  expand_thru_macro()  =======================
###==============================================================

inputnum = 1
def expand_thru_macro():
	mytrace('expand_thru_macro()')
	global switchcasetester
	change_to_into_thru()   #<======  "to macro" swapped with "thru" in switch case input
	newlist=[] #resets newlist
	global mouse; global ajax; global snowy; snowy=''
	mycounter = 0 ### mouse 
	for line in switchcasetester.splitlines():  #doing mouse not doing switchcasetester yet
		#beta = mycounter-1
										#reinitialize what I'm using with each loop iteration
		smart=[]; ajax=''; newlist  =[]
		#this is the bug fix so I say if "thru" in line but NOT "fallthru" in line.
		if "thru" in line and "case" in line and "fallthru" not in line:  #only used with numbers
			#print(line)
			if ":" in line and line.endswith(":"): #referring to one : in line
				line = chomp(line) #moved taking off colon here  line=line[:-1] 
				print(line)
				## added on new years eve to hopefully fix bug of : in line with number
				#ValueError: invalid literal for int() with base 10: '3:'
				if ":" in line:
					print("true : in line where only numbers allowed")
					line=line.replace(":",'')
					print("now it looks like this on new years eve insane bug ")
					print(line)
			else:  #so now if the line doesn't end with a colon it doesn't chomp it
				pass
			
			smart=line.split() #separates case from casename
			#print("what does smart list have",smart)  #fallthr  missing a u
			#print("smart alleck result for smart[3]",smart[3])
			#print("does thisfix   smart list now!! have",smart)  #fallthr  missing a u
			#print("this should be case", smart[0])
			#print("first number ",int(smart[1]) )     #first number  don't need int
			#print("this should be --thru--",smart[2]) #thru
			#print("last number", smart[3])            #last number 
			#print("will then write perhaps from list yes")
			#print("the input for this macros test")
			#print("=============================")
			#print(smart[0] + " " + smart[1] + " " + smart[2] + " " + smart[3] + ":")
			#print("")
			counter = smart[1]
			#this is filling up the newlist
			
			#### THIS FILLS newlist with the case info
			# ======LOOP  ==================
			print("sniffing for bug here ===")
			if ":" in smart[3]:
				print("smart[3]=",smart[3])
				smart[3]=smart[3].replace(":",'')
				print("now we have",smart[3])
			##============ bug is down her ein smart[3] apparently =============
			for counter in range(int(smart[1]),int(smart[3]) + 1):
				newlist.append(counter)
				counter += 1
			
			ajax =''
			
			##==============================================================
			# LOOP ====================
			 
			for item in newlist:  #this list has the number in it
				ajax += "\t\tcase " +   str(item)   + ":" + "\n"
				#now delete last \n on end 
			#print("==== big test of replacing it ====")
			ajax = ajax.rstrip() #see if this works takes off last "\n" whcih was extra
			ajax = ajax[:-1] #chops off last char on end which is the :
			
			snowy=switchcasetester.replace(line, ajax)
			switchcasetester='';switchcasetester = snowy
			
			



######################################
##  convert_case_numbers_to_strings()
#######################################  #if no macros it just adds strings around numbers


def convert_case_numbers_to_strings():
	#print("we are here in convert case numbers to strings did this reach this far")
	#print("convert_case_numbers_to_strings() called ")
	mytrace('convert_case_numbers_to_strings()')
	global switchcasetester
	make_list_of_lines_using_thru_macro()
	expand_thru_macro()
	case_numbers_to_strings() #stringifies the numbers like this 3 becomes '3'



#this calls convert_case_numbers_to_strings
#this is reading numbers in cases NOT STRINGS and converting them into strings
##############================
cray=[] # this is used to hold the switchcasetester briefly when rewriting it
cray.append('starter')
##############=================

###########################################################
# if a multiple nested switch (at least one nested switch)
#added Mon June 28th, 2021 doing the engineering to make the impossible possible fuzzy logic
multi_switch_with_nested_switches=[]
multi_switch_with_nested_switches.append(0)
multi_switch_with_nested_switches[0] = False #by default
############################################################



##############################
##     macro_expansion()       
############################## # may 26th testing this 

def macro_expansion(y): #expands macros to and thru (if they exist)
	mytrace('macro_expansion()')
	#print("-----==macro_expansion ==-------")
	#print("macro_expansion called")
	if valve[0] == True:    #meaning numbers in cases detected
		#mytrace('starter_sequence_mode_2()')
		global switchcasetester; switchcasetester=y;
		#print("what is in switchcasetester before expanding macros if they exist")
		#print(switchcasetester)
		#################################
		convert_case_numbers_to_strings()  ## <<=== expands macros here 
		#################################
		#print(switchcasetester)
		cray[0] =switchcasetester  #this assigns the output string to cray[0]
	
############==============
# these are used 
coffee=[]  
valve=[]
valve.append("nada")# 0
valve.append("sway")# 1
#############==============


# this gets the line number of the first case in the switch case string
#################################################
##  grab_first_case_of_switch_string(y)
#################################################
def grab_first_case_of_switch_string(y): 
	mytrace("grab_first_case_of_switch_string()") 
	#global switchcasetester
	mycounter = 0
	#this takes in sw to test for finding out if numbers like case 2: or words case "apple"
	for line in y.splitlines():
		if "case" in line:
			#print("the counter for spotting word case is ")
			#print(mycounter)
			#print("coffee has in it at this point ",coffee)
			coffee.append(mycounter)
			#print(coffee[0]) #just added this 
			break  #here after getting the first instance of a case we leave the loop
		else:
			mycounter += 1
			continue




#####################################################
##  remove_tabs_from_string(y)
##################################################### 
def remove_tabs_from_string(y):
	mytrace("remove_tabs_from_string()") 
	y=y.replace("\t","")
	return y





#####################################################
##  grab_first_case_line_in_switch_case_string(y)
##################################################### 


def grab_first_case_line_in_switch_case_string(y):
	#global sw
	mytrace("grab_first_case_line_in_switch_case_string()") 
	#print(coffee[0])  #testing what's in this
	getline= eval("y.splitlines()[" + str(coffee[0]) + "]")
	#print(getline)
	return getline


##################################
##  check_if_number_in_string(x)
################################## 


def check_if_number_in_string(x):
	mytrace("check_if_number_in_string()") 
	theresult = any(char.isdigit() for char in x)  #this line from stackoverflow
	return theresult







################################
########    CHOMP(x)  ##########
################################
## this bites off the last character in a string ##
def chomp(x):
	mytrace('chomp()')
	#print("====== chomp called",x)
	x = x[:-1] 
	#print("x=",x)
	return x




##### end of woodstock code =========================




###=====================
##      adder(x)
##======================

targetlist=[] #just added this 
targetlist.append(0) #initializes it

#math demonstration adding numbers between cases using fallthru
############ adder() ############## added may 27th 2021
def adder(x): #this can be modified to do more
	#print("targetlist[0]=",targetlist[0])
	print("adder called with ",x)
	#first time thru
	if targetlist[0] == 0:    
		x = str(x)
		targetlist[0] = x
		#print(targetlist[0])
	else:   #already something in here
		x = str(x)
		targetlist[0] = int(targetlist[0]) + int(x)
	print(targetlist[0])
	#return(x)

##====================================================================
	
buildstringlist=[]
buildstringlist.append(0)
# this can be used to create a math formula on the fly too
# from my experience 
################################################
##### concatting a string in fallthrus in switch case
############ buildstring() ############## added may 27th

###=========================
##      buildstring(x)
##==========================
def buildstring(x): #this should be 3
	#print("buildstring called with ",x)
	if buildstringlist[0] == 0: #first time thru
		#x =x + 1
		x = str(x)
		buildstringlist[0] = x # example 'Cola'
	else:   #already something in here
		#targetlist[0] = targetlist[0] + x
		#x =x + 1
		x = str(x)
		buildstringlist[0] = str(buildstringlist[0]) + str(x)
	print(buildstringlist[0])
	#return(x)
		




###================================================================	
#bugsbunny.py
#march 18th, 2021
global sw
varholder=[]
baseline=[]
baseline.append('a') #holder for switch code
#def flush_lists():
#	varholder=[]
varholder.append("zilch")

case_main_body_list_with_tail=[]

#experimental

valve=[]
var2=[]
var2.append("zilch")
starbuckslist=[]

# I have cases lists up to 1000
# you can add more but they must be in order and spelled correctly.
# python won't correctly dynamically generate them unfortunately.

def sw_reset():
	return
	#print("sw_reset() was called!!!!!========")
	#importlib.reload(switchmodtrial7)
	
#empty_list method
def empty_list(name): #might need to have it take in with string
	del name[:] #this empties the list
		


############## june 8th attempt ###########========= works==============================
###################################################################
##  TOP OF CASE CONSTANT UPPERCASE AND CONVERSION TO STRINGS
###################################################################
if_strings_found=[]
if_strings_found.append(False) #to initialize it with something

#print(sw)

#endswitch(sw)
def hasNumbers(inputString):
	return any(char.isdigit() for char in inputString)

#june 5th 2021 coding test
uppercase_test=[]
uppercase_test.append(False) # by default
#uppercase_test[0]

found_number_in_case=[]
found_number_in_case.append(False)

#might have to change sw to switchcasetester



#####################################
##  detect_if_number_in_cases()
#####################################
def detect_if_number_in_cases():
	global sw
	#print(sw)
	mycounter = 0
	contains_digit= False
	#global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:  #all it does is test the first case and then bails
			contains_digit = any(map(str.isdigit, line))
			if contains_digit == True:
				#print("number found")
				found_number_in_case[0]= True
				break
			else:
				pass
	#this will be commented out later
	#print("===========================")
	#print("did we find numbers in cases?",found_number_in_case[0])
	#print("===========================")	    
 






###########################################
##     detect_if_no_quotes_around_word()
###########################################
def detect_if_no_quotes_around_word():
	#print("detect if no quotes aorund word called")
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	#global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:  #all it does is test the first case and then bails
			if "'" not in line and '"' not in line:
				#print("no strings in line that we can see")
				#if_strings_found[0] == False:
				continue
					
			else:
				if "'"  in line or '"'  in line:
					if_strings_found[0]= True
					#if_strings_found[0] == True:
					break
					
	#this will be commented out later
	#print("===========================")
	#print("if_strings_found[0] =",if_strings_found[0])
	#print("===========================")
	
	
	
	
	
	
	
	
##########################################   
##    check if case word is uppercase()
##########################################
def check_if_case_word_is_uppercase():  #returns uppercase_test[0]
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			#cat =is_number(smart[1])  #calling method to check if the case name is a number
			##############################
			#print('smart[1]=',smart[1])
			#print("========================")
			#print("verify that it\'s all caps for the word ignoring _")
			cat = smart[1]
			#print("cat=",cat)
			#print(line)
			
			#print("verify that it's all uppercase constant")
			if cat.isupper() ==  True:
				#print("=====yes all UPPERCASE=====")
				uppercase_test[0] = True  #sets flag to True
				#print("===============")
				#print("uppercase_test[0]=",uppercase_test[0])
				#print("==============")
			else:
				pass #print("not all uppercase")
	###########################################				
	
	
	


###############################################
##  case_constant_uppercase_word_to_strings()
###############################################
def case_constant_uppercase_word_to_strings(): # case WORDINCAPS: becomes case 'WORDSHERE':
	#print("case constant uppercase word to strings() called")
	mytrace('case_numbers_to_strings()')
	#print("called case constant uppercase word to strings()")
	#print('starting this function we have this test view of uppercase',uppercase_test[0])
	global sw
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	global sw ## just addded thismay 27th
	for line in sw.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			#cat =is_number(smart[1])  #calling method to check if the case name is a number
			##############################
			#print('smart[1]=',smart[1])
			#print("========================")
			#print("verify that it\'s all caps for the word ignoring _")
			cat = smart[1]
			#print("cat=",cat)
			#print(line)
			
			#print("verify that it's all uppercase constant")
			if cat.isupper()==  True:
				#print("=====yes all UPPERCASE=====")
				uppercase_test[0] = True
				#print("===============")
				#print("uppercase_test[0]=",uppercase_test[0])
				#print("==============")
			else:
				pass #print("not all uppercase")
				
			#print("=================")
			da = cat.isupper()
			#print("if upper",da)
			#print("=================")
			#looks like this test requires word in a string
			
			dog = "'" + cat + "'"
			#s = "abc1"
			#contains_digit = any(map(str.isdigit, s))
			#sclise off head and tail of cat now
			dog = cat[1:] 
			dog = cat[-1:]
			#print(cat) #to see what it sees now
			#print("=================")
			sa = cat.islower()
			#print("if lowercase",sa)
			#print("=================")
			
			################################
			# print("====verify that this is called to look for apostrophe and quotes")
# 			print("checking that case word not in quotes")
# 			print("maybe if it finds one take it out replace with nothing")
# 			print("testing if casename is in strings or not")
			#print("first char = cat[0]",cat[0])
			#print("check if first char is a number")
			#it can't be a number to start with only to end with
			#print("new test here if first char a number")
			#print("=====")
			fuel =cat[0].isdigit()
			#if fuel == True:
			#	print("===='''''=============")
			#	print("first char is a number")
			#else:
			#	print("first char is NOT a number")
				
			#print("last char = cat[-1]",cat[-1])
			#print("====this code removes strings IF THEY EXIST")
			
			if cat[0] == "'": 
				cat.replace("'",'' )
			if cat[-1] == "'":
				cat.replace("'",'' )
			#print(cat)	
			#####========
			if cat[0] == '"':
				cat.replace('"','' )
			if cat[-1] == '"':
				cat.replace('"','' )
			#print(cat)	
			###### new idea on Wednesday June 2nd
			#print("=====verify not single or double quotes in case line")
			if "'" not in line and '"' not in line:
				#print("true no quotes in line")
				#print("so quotes and apostrophe = False")
				#print(line)
				pass
			else:
				pass#print("true no quotes in line")
			######################################		
			#print('====this adds the strings to be sure that they are in the correct format')
			cool    = smart[1][:-1]  #chops off : from end
			holder  = "'" + cool + "'" #this puts the ' on both flanks of the number
			cool    = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			opal=sw.replace(line,"\t\t" +newline)
			sw=''
			sw = opal
			mycounter += 1
		else:
			mycounter += 1
			continue
						
	#print("this should print out the modified sw switch case with quotes for cases now")
	#print(sw)	
	#before this stage by default it will be 'nada' in baseline[0]
	baseline[0] = sw  #this means uppercase constant words
	#to see output after conversion
	#print("baseline[0] now")
	#print(baseline[0])





###############################################
##    check_if_uppercase_constant_cases()
###############################################
def check_if_uppercase_constant_cases(y):
    global sw
    sw = y
    detect_if_number_in_cases()
    detect_if_no_quotes_around_word()
    check_if_case_word_is_uppercase()
    
    if uppercase_test[0] == True:  #this does nothing now 
        pass #print("it is UPPERCASE")
    else:
        pass #print("it is lowercase")
    # this is if numbers in case and if strings found and if uppercase (3 booleans))
    ##===========================================
   # 

   ### BOOLEAN test to determine if case UPPERCASE: no numbers, no strings and uppercase True
    if found_number_in_case[0]  == False \
        and if_strings_found[0] == False \
        and uppercase_test[0]   == True:
    ### BOOLEAN test to determine if meets criteria of uppercase word for a case
    ##============================================
        ## this is where the case words are converted to strings
        ########################################
        case_constant_uppercase_word_to_strings()
        ########################################
        #print("MEETS criteria to convert inputs string uppercase constants to strings")
    else:
        baseline[0] = "nada"  # doesn't meet criteria of case UPPERCASE
        pass                  # do nothing if critiera not met for converting to strings
                              # later will add ability to handle lowercase and numbers 
                              # print("doesn't meet criterial to do uppercase to strings")
                              #	adds strings


#print("BIG TEST HERE ===>>")

############## end of june 8th attempt #########
############## end of june 8th attempt #########
############## end of june 8th attempt #########=========================================



	
caselist1=[]
caselist2=[]
caselist3=[]
caselist4=[]
caselist5=[]
caselist6=[]
caselist7=[]
caselist8=[]
caselist9=[]
caselist10=[]
caselist11=[]
caselist12=[]
caselist13=[]
caselist14=[]
caselist15=[]
caselist16=[]
caselist17=[]
caselist18=[]
caselist19=[]
caselist20=[]
caselist21=[]
caselist22=[]
caselist23=[]
caselist24=[]
caselist25=[]
caselist26=[]
caselist27=[]
caselist28=[]
caselist29=[]
caselist30=[]
caselist31=[]
caselist32=[]
caselist33=[]
caselist34=[]
caselist35=[]
caselist36=[]
caselist37=[]
caselist38=[]
caselist39=[]
caselist40=[]
caselist41=[]
caselist42=[]
caselist43=[]
caselist44=[]
caselist45=[]
caselist46=[]
caselist47=[]
caselist48=[]
caselist49=[]
caselist50=[]
caselist51=[]
caselist52=[]
caselist53=[]
caselist54=[]
caselist55=[]
caselist56=[]
caselist57=[]
caselist58=[]
caselist59=[]
caselist60=[]
caselist61=[]
caselist62=[]
caselist63=[]
caselist64=[]
caselist65=[]
caselist66=[]
caselist67=[]
caselist68=[]
caselist69=[]
caselist70=[]
caselist71=[]
caselist72=[]
caselist73=[]
caselist74=[]
caselist75=[]
caselist76=[]
caselist77=[]
caselist78=[]
caselist79=[]
caselist80=[]
caselist81=[]
caselist82=[]
caselist83=[]
caselist84=[]
caselist85=[]
caselist86=[]
caselist87=[]
caselist88=[]
caselist89=[]
caselist90=[]
caselist91=[]
caselist92=[]
caselist93=[]
caselist94=[]
caselist95=[]
caselist96=[]
caselist97=[]
caselist98=[]
caselist99=[]
caselist100=[]
caselist101=[]
caselist102=[]
caselist103=[]
caselist104=[]
caselist105=[]
caselist106=[]
caselist107=[]
caselist108=[]
caselist109=[]
caselist110=[]
caselist111=[]
caselist112=[]
caselist113=[]
caselist114=[]
caselist115=[]
caselist116=[]
caselist117=[]
caselist118=[]
caselist119=[]
caselist120=[]
caselist121=[]
caselist122=[]
caselist123=[]
caselist124=[]
caselist125=[]
caselist126=[]
caselist127=[]
caselist128=[]
caselist129=[]
caselist130=[]
caselist131=[]
caselist132=[]
caselist133=[]
caselist134=[]
caselist135=[]
caselist136=[]
caselist137=[]
caselist138=[]
caselist139=[]
caselist140=[]
caselist141=[]
caselist142=[]
caselist143=[]
caselist144=[]
caselist145=[]
caselist146=[]
caselist147=[]
caselist148=[]
caselist149=[]
caselist150=[]
caselist151=[]
caselist152=[]
caselist153=[]
caselist154=[]
caselist155=[]
caselist156=[]
caselist157=[]
caselist158=[]
caselist159=[]
caselist160=[]
caselist161=[]
caselist162=[]
caselist163=[]
caselist164=[]
caselist165=[]
caselist166=[]
caselist167=[]
caselist168=[]
caselist169=[]
caselist170=[]
caselist171=[]
caselist172=[]
caselist173=[]
caselist174=[]
caselist175=[]
caselist176=[]
caselist177=[]
caselist178=[]
caselist179=[]
caselist180=[]
caselist181=[]
caselist182=[]
caselist183=[]
caselist184=[]
caselist185=[]
caselist186=[]
caselist187=[]
caselist188=[]
caselist189=[]
caselist190=[]
caselist191=[]
caselist192=[]
caselist193=[]
caselist194=[]
caselist195=[]
caselist196=[]
caselist197=[]
caselist198=[]
caselist199=[]
caselist200=[]
caselist201=[]
caselist202=[]
caselist203=[]
caselist204=[]
caselist205=[]
caselist206=[]
caselist207=[]
caselist208=[]
caselist209=[]
caselist210=[]
caselist211=[]
caselist212=[]
caselist213=[]
caselist214=[]
caselist215=[]
caselist216=[]
caselist217=[]
caselist218=[]
caselist219=[]
caselist220=[]
caselist221=[]
caselist222=[]
caselist223=[]
caselist224=[]
caselist225=[]
caselist226=[]
caselist227=[]
caselist228=[]
caselist229=[]
caselist230=[]
caselist231=[]
caselist232=[]
caselist233=[]
caselist234=[]
caselist235=[]
caselist236=[]
caselist237=[]
caselist238=[]
caselist239=[]
caselist240=[]
caselist241=[]
caselist242=[]
caselist243=[]
caselist244=[]
caselist245=[]
caselist246=[]
caselist247=[]
caselist248=[]
caselist249=[]
caselist250=[]
caselist251=[]
caselist252=[]
caselist253=[]
caselist254=[]
caselist255=[]
caselist256=[]
caselist257=[]
caselist258=[]
caselist259=[]
caselist260=[]
caselist261=[]
caselist262=[]
caselist263=[]
caselist264=[]
caselist265=[]
caselist266=[]
caselist267=[]
caselist268=[]
caselist269=[]
caselist270=[]
caselist271=[]
caselist272=[]
caselist273=[]
caselist274=[]
caselist275=[]
caselist276=[]
caselist277=[]
caselist278=[]
caselist279=[]
caselist280=[]
caselist281=[]
caselist282=[]
caselist283=[]
caselist284=[]
caselist285=[]
caselist286=[]
caselist287=[]
caselist288=[]
caselist289=[]
caselist290=[]
caselist291=[]
caselist292=[]
caselist293=[]
caselist294=[]
caselist295=[]
caselist296=[]
caselist297=[]
caselist298=[]
caselist299=[]
caselist300=[]
caselist301=[]
caselist302=[]
caselist303=[]
caselist304=[]
caselist305=[]
caselist306=[]
caselist307=[]
caselist308=[]
caselist309=[]
caselist310=[]
caselist311=[]
caselist312=[]
caselist313=[]
caselist314=[]
caselist315=[]
caselist316=[]
caselist317=[]
caselist318=[]
caselist319=[]
caselist320=[]
caselist321=[]
caselist322=[]
caselist323=[]
caselist324=[]
caselist325=[]
caselist326=[]
caselist327=[]
caselist328=[]
caselist329=[]
caselist330=[]
caselist331=[]
caselist332=[]
caselist333=[]
caselist334=[]
caselist335=[]
caselist336=[]
caselist337=[]
caselist338=[]
caselist339=[]
caselist340=[]
caselist341=[]
caselist342=[]
caselist343=[]
caselist344=[]
caselist345=[]
caselist346=[]
caselist347=[]
caselist348=[]
caselist349=[]
caselist350=[]
caselist351=[]
caselist352=[]
caselist353=[]
caselist354=[]
caselist355=[]
caselist356=[]
caselist357=[]
caselist358=[]
caselist359=[]
caselist360=[]
caselist361=[]
caselist362=[]
caselist363=[]
caselist364=[]
caselist365=[]
caselist366=[]
caselist367=[]
caselist368=[]
caselist369=[]
caselist370=[]
caselist371=[]
caselist372=[]
caselist373=[]
caselist374=[]
caselist375=[]
caselist376=[]
caselist377=[]
caselist378=[]
caselist379=[]
caselist380=[]
caselist381=[]
caselist382=[]
caselist383=[]
caselist384=[]
caselist385=[]
caselist386=[]
caselist387=[]
caselist388=[]
caselist389=[]
caselist390=[]
caselist391=[]
caselist392=[]
caselist393=[]
caselist394=[]
caselist395=[]
caselist396=[]
caselist397=[]
caselist398=[]
caselist399=[]
caselist400=[]
caselist401=[]
caselist402=[]
caselist403=[]
caselist404=[]
caselist405=[]
caselist406=[]
caselist407=[]
caselist408=[]
caselist409=[]
caselist410=[]
caselist411=[]
caselist412=[]
caselist413=[]
caselist414=[]
caselist415=[]
caselist416=[]
caselist417=[]
caselist418=[]
caselist419=[]
caselist420=[]
caselist421=[]
caselist422=[]
caselist423=[]
caselist424=[]
caselist425=[]
caselist426=[]
caselist427=[]
caselist428=[]
caselist429=[]
caselist430=[]
caselist431=[]
caselist432=[]
caselist433=[]
caselist434=[]
caselist435=[]
caselist436=[]
caselist437=[]
caselist438=[]
caselist439=[]
caselist440=[]
caselist441=[]
caselist442=[]
caselist443=[]
caselist444=[]
caselist445=[]
caselist446=[]
caselist447=[]
caselist448=[]
caselist449=[]
caselist450=[]
caselist451=[]
caselist452=[]
caselist453=[]
caselist454=[]
caselist455=[]
caselist456=[]
caselist457=[]
caselist458=[]
caselist459=[]
caselist460=[]
caselist461=[]
caselist462=[]
caselist463=[]
caselist464=[]
caselist465=[]
caselist466=[]
caselist467=[]
caselist468=[]
caselist469=[]
caselist470=[]
caselist471=[]
caselist472=[]
caselist473=[]
caselist474=[]
caselist475=[]
caselist476=[]
caselist477=[]
caselist478=[]
caselist479=[]
caselist480=[]
caselist481=[]
caselist482=[]
caselist483=[]
caselist484=[]
caselist485=[]
caselist486=[]
caselist487=[]
caselist488=[]
caselist489=[]
caselist490=[]
caselist491=[]
caselist492=[]
caselist493=[]
caselist494=[]
caselist495=[]
caselist496=[]
caselist497=[]
caselist498=[]
caselist499=[]
caselist500=[]
caselist501=[]
caselist502=[]
caselist503=[]
caselist504=[]
caselist505=[]
caselist506=[]
caselist507=[]
caselist508=[]
caselist509=[]
caselist510=[]
caselist511=[]
caselist512=[]
caselist513=[]
caselist514=[]
caselist515=[]
caselist516=[]
caselist517=[]
caselist518=[]
caselist519=[]
caselist520=[]
caselist521=[]
caselist522=[]
caselist523=[]
caselist524=[]
caselist525=[]
caselist526=[]
caselist527=[]
caselist528=[]
caselist529=[]
caselist530=[]
caselist531=[]
caselist532=[]
caselist533=[]
caselist534=[]
caselist535=[]
caselist536=[]
caselist537=[]
caselist538=[]
caselist539=[]
caselist540=[]
caselist541=[]
caselist542=[]
caselist543=[]
caselist544=[]
caselist545=[]
caselist546=[]
caselist547=[]
caselist548=[]
caselist549=[]
caselist550=[]
caselist551=[]
caselist552=[]
caselist553=[]
caselist554=[]
caselist555=[]
caselist556=[]
caselist557=[]
caselist558=[]
caselist559=[]
caselist560=[]
caselist561=[]
caselist562=[]
caselist563=[]
caselist564=[]
caselist565=[]
caselist566=[]
caselist567=[]
caselist568=[]
caselist569=[]
caselist570=[]
caselist571=[]
caselist572=[]
caselist573=[]
caselist574=[]
caselist575=[]
caselist576=[]
caselist577=[]
caselist578=[]
caselist579=[]
caselist580=[]
caselist581=[]
caselist582=[]
caselist583=[]
caselist584=[]
caselist585=[]
caselist586=[]
caselist587=[]
caselist588=[]
caselist589=[]
caselist590=[]
caselist591=[]
caselist592=[]
caselist593=[]
caselist594=[]
caselist595=[]
caselist596=[]
caselist597=[]
caselist598=[]
caselist599=[]
caselist600=[]
caselist601=[]
caselist602=[]
caselist603=[]
caselist604=[]
caselist605=[]
caselist606=[]
caselist607=[]
caselist608=[]
caselist609=[]
caselist610=[]
caselist611=[]
caselist612=[]
caselist613=[]
caselist614=[]
caselist615=[]
caselist616=[]
caselist617=[]
caselist618=[]
caselist619=[]
caselist620=[]
caselist621=[]
caselist622=[]
caselist623=[]
caselist624=[]
caselist625=[]
caselist626=[]
caselist627=[]
caselist628=[]
caselist629=[]
caselist630=[]
caselist631=[]
caselist632=[]
caselist633=[]
caselist634=[]
caselist635=[]
caselist636=[]
caselist637=[]
caselist638=[]
caselist639=[]
caselist640=[]
caselist641=[]
caselist642=[]
caselist643=[]
caselist644=[]
caselist645=[]
caselist646=[]
caselist647=[]
caselist648=[]
caselist649=[]
caselist650=[]
caselist651=[]
caselist652=[]
caselist653=[]
caselist654=[]
caselist655=[]
caselist656=[]
caselist657=[]
caselist658=[]
caselist659=[]
caselist660=[]
caselist661=[]
caselist662=[]
caselist663=[]
caselist664=[]
caselist665=[]
caselist666=[]
caselist667=[]
caselist668=[]
caselist669=[]
caselist670=[]
caselist671=[]
caselist672=[]
caselist673=[]
caselist674=[]
caselist675=[]
caselist676=[]
caselist677=[]
caselist678=[]
caselist679=[]
caselist680=[]
caselist681=[]
caselist682=[]
caselist683=[]
caselist684=[]
caselist685=[]
caselist686=[]
caselist687=[]
caselist688=[]
caselist689=[]
caselist690=[]
caselist691=[]
caselist692=[]
caselist693=[]
caselist694=[]
caselist695=[]
caselist696=[]
caselist697=[]
caselist698=[]
caselist699=[]
caselist700=[]
caselist701=[]
caselist702=[]
caselist703=[]
caselist704=[]
caselist705=[]
caselist706=[]
caselist707=[]
caselist708=[]
caselist709=[]
caselist710=[]
caselist711=[]
caselist712=[]
caselist713=[]
caselist714=[]
caselist715=[]
caselist716=[]
caselist717=[]
caselist718=[]
caselist719=[]
caselist720=[]
caselist721=[]
caselist722=[]
caselist723=[]
caselist724=[]
caselist725=[]
caselist726=[]
caselist727=[]
caselist728=[]
caselist729=[]
caselist730=[]
caselist731=[]
caselist732=[]
caselist733=[]
caselist734=[]
caselist735=[]
caselist736=[]
caselist737=[]
caselist738=[]
caselist739=[]
caselist740=[]
caselist741=[]
caselist742=[]
caselist743=[]
caselist744=[]
caselist745=[]
caselist746=[]
caselist747=[]
caselist748=[]
caselist749=[]
caselist750=[]
caselist751=[]
caselist752=[]
caselist753=[]
caselist754=[]
caselist755=[]
caselist756=[]
caselist757=[]
caselist758=[]
caselist759=[]
caselist760=[]
caselist761=[]
caselist762=[]
caselist763=[]
caselist764=[]
caselist765=[]
caselist766=[]
caselist767=[]
caselist768=[]
caselist769=[]
caselist770=[]
caselist771=[]
caselist772=[]
caselist773=[]
caselist774=[]
caselist775=[]
caselist776=[]
caselist777=[]
caselist778=[]
caselist779=[]
caselist780=[]
caselist781=[]
caselist782=[]
caselist783=[]
caselist784=[]
caselist785=[]
caselist786=[]
caselist787=[]
caselist788=[]
caselist789=[]
caselist790=[]
caselist791=[]
caselist792=[]
caselist793=[]
caselist794=[]
caselist795=[]
caselist796=[]
caselist797=[]
caselist798=[]
caselist799=[]
caselist800=[]
caselist801=[]
caselist802=[]
caselist803=[]
caselist804=[]
caselist805=[]
caselist806=[]
caselist807=[]
caselist808=[]
caselist809=[]
caselist810=[]
caselist811=[]
caselist812=[]
caselist813=[]
caselist814=[]
caselist815=[]
caselist816=[]
caselist817=[]
caselist818=[]
caselist819=[]
caselist820=[]
caselist821=[]
caselist822=[]
caselist823=[]
caselist824=[]
caselist825=[]
caselist826=[]
caselist827=[]
caselist828=[]
caselist829=[]
caselist830=[]
caselist831=[]
caselist832=[]
caselist833=[]
caselist834=[]
caselist835=[]
caselist836=[]
caselist837=[]
caselist838=[]
caselist839=[]
caselist840=[]
caselist841=[]
caselist842=[]
caselist843=[]
caselist844=[]
caselist845=[]
caselist846=[]
caselist847=[]
caselist848=[]
caselist849=[]
caselist850=[]
caselist851=[]
caselist852=[]
caselist853=[]
caselist854=[]
caselist855=[]
caselist856=[]
caselist857=[]
caselist858=[]
caselist859=[]
caselist860=[]
caselist861=[]
caselist862=[]
caselist863=[]
caselist864=[]
caselist865=[]
caselist866=[]
caselist867=[]
caselist868=[]
caselist869=[]
caselist870=[]
caselist871=[]
caselist872=[]
caselist873=[]
caselist874=[]
caselist875=[]
caselist876=[]
caselist877=[]
caselist878=[]
caselist879=[]
caselist880=[]
caselist881=[]
caselist882=[]
caselist883=[]
caselist884=[]
caselist885=[]
caselist886=[]
caselist887=[]
caselist888=[]
caselist889=[]
caselist890=[]
caselist891=[]
caselist892=[]
caselist893=[]
caselist894=[]
caselist895=[]
caselist896=[]
caselist897=[]
caselist898=[]
caselist899=[]
caselist900=[]
caselist901=[]
caselist902=[]
caselist903=[]
caselist904=[]
caselist905=[]
caselist906=[]
caselist907=[]
caselist908=[]
caselist909=[]
caselist910=[]
caselist911=[]
caselist912=[]
caselist913=[]
caselist914=[]
caselist915=[]
caselist916=[]
caselist917=[]
caselist918=[]
caselist919=[]
caselist920=[]
caselist921=[]
caselist922=[]
caselist923=[]
caselist924=[]
caselist925=[]
caselist926=[]
caselist927=[]
caselist928=[]
caselist929=[]
caselist930=[]
caselist931=[]
caselist932=[]
caselist933=[]
caselist934=[]
caselist935=[]
caselist936=[]
caselist937=[]
caselist938=[]
caselist939=[]
caselist940=[]
caselist941=[]
caselist942=[]
caselist943=[]
caselist944=[]
caselist945=[]
caselist946=[]
caselist947=[]
caselist948=[]
caselist949=[]
caselist950=[]
caselist951=[]
caselist952=[]
caselist953=[]
caselist954=[]
caselist955=[]
caselist956=[]
caselist957=[]
caselist958=[]
caselist959=[]
caselist960=[]
caselist961=[]
caselist962=[]
caselist963=[]
caselist964=[]
caselist965=[]
caselist966=[]
caselist967=[]
caselist968=[]
caselist969=[]
caselist970=[]
caselist971=[]
caselist972=[]
caselist973=[]
caselist974=[]
caselist975=[]
caselist976=[]
caselist977=[]
caselist978=[]
caselist979=[]
caselist980=[]
caselist981=[]
caselist982=[]
caselist983=[]
caselist984=[]
caselist985=[]
caselist986=[]
caselist987=[]
caselist988=[]
caselist989=[]
caselist990=[]
caselist991=[]
caselist992=[]
caselist993=[]
caselist994=[]
caselist995=[]
caselist996=[]
caselist997=[]
caselist998=[]
caselist999=[]
caselist1000=[]

'''
def runthisnow():
	print("====caselists generated===")
	i = 128; j = 1000;
	while i  < j:
		print("caselist" + str(i) + "=[]")
		i += 1
		continue;
'''	
		

#runthisnow()


def clear_out_all_case_lists():
	#get last case list number like 14
	caselist1=[]
	caselist2=[]
	caselist3=[]
	caselist4=[]
	caselist5=[]
	caselist6=[]
	caselist7=[]
	caselist8=[]
	caselist9=[]
	caselist10=[]
	caselist11=[]
	caselist12=[]
	caselist13=[]
	caselist14=[]
	caselist15=[]
	caselist16=[]
	


#this resets all of the lists
##### flush_lists() ##############
def flush_lists():
	#print("===== flush lists() called =====")
	mytrace('flush_lists  =====')
	#switchcasetester = ''
	#sw=''
	#newest additions here april 7, 2021
	birdsong=[0]
	music=[0]
	colorful=[0]

	caseset=[]
	wilsonball=[]
	palmtrees=[]
	candy=[]
	digitalcandy=[]
	caselist =[]
	breaklist =[]
	einstein=[]
	smartcasemanager=[]
	british=[]
	cranberries=[]
	defaultlist =[]
	blanklines  =[]
	mixedlist   =[]
	batterondeck =[] #I can have item to comapore with in here
	seriestogether =[]
	res =[]
	getfirstword =[]
	casephrase =[]
	alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
	casesections =[]
	casesectioncounter =[]
	breakposition =[]
	trontime =[]
	tronlinenumbers =[]
	fallthrulist = []
	smartlist =[]
	smartlistlocations=[]
	fallthrulocations=[]
	#theinputlist =[]
	digitalcandy=[]
	line_numbers_of_first_cases=[]
	#deepsea_line_numbers=[] 
	# print("==== showing the lists values now after flushing them clean ===")
# 	print("birdsong",birdsong)
# 	print("music",music)
# 	print("colorful",colorful)
# 	print("caseset",caseset)
# 	print("wilsonball",wilsonball)
# 	print("palmtrees",palmtrees)
# 	print("candy",candy)
# 	print("digitalcandy",digitalcandy)
# 	print("caselist",caselist)
# 	print("breaklist",breaklist)
# 	print("einstein",einstein)
# 	print("smartcasemanager",smartcasemanager)
# 	print("british",british)
# 	print("cranberries",cranberries)
# 	print("defaultlist",defaultlist)
# 	print("blanklines",blanklines)
# 	print("mixedlist",mixedlist)
# 	print("seriestogether",seriestogether)
# 	print("res",res)
# 	print("getfirstword",getfirstword)
	# print("casephrase",casephrase)
# 	print("alphalist",alphalist)
# 	print("casesections",casesections)
# 	print("casesectioncounter",casesectioncounter)
# 	print("breakposition",breakposition)
# 	print("trontime",trontime)
# 	print("tronlinenumbers",tronlinenumbers)
# 	print("fallthrulist",fallthrulist)
# 	print("smartlist",smartlist)
# 	print("smartlistlocations",smartlistlocations)
# 	print("fallthrulocations",fallthrulocations)
# 	#print("theinputlist",theinputlist)
# 	print("digitalcandy",digitalcandy)
# 	print("line_numbers_of_first_cases",line_numbers_of_first_cases)

#################  from woodstock_alpha which is the numbers code 
#################======== beginning of woodstock code added here at top =====
#################
show_py_switch=[]
show_py_switch.append(False)  #this is show_py_switch[0]

#to debug generated code you can see the generatedcode 
def view_code_turn_on():
    show_py_switch[0] = True
    
    
def view_code_turn_off():
    show_py_switch[0] = False

#what this does is show the output python code that is genereated from code gen
#and then executed

view_code_turn_on()  #if it says view_code_turn_off() it won't show the generated python
    
  



'''
reset_list_to_just_starter(listname)
this makes sure that a list is reset if already used recently to
the initial state with starter in the first list element with nothing else
so that it will have a lengthh of 1. It can be 0 or 'starter' in the first slot.
This was devised to clear out lists so that after the first switch is called
all subsequent switch calls have cleared lists so it's as if each call of a 
switch is the first switch call rather than calling reload module. 
'''
#april 27th, 2021  2:46pm
############################################
#   reset_list_to_just_starter(listname)
############################################
def reset_list_to_just_starter(listname):
	print("reset_list_to_just_starter() called")
	if len(listname) > 1:         # checks if list length greater than 1
		for item in listname:     # loop through entire list
			if len(listname) > 1: # if length of list > 1
				listname.pop()	  # delete last item of list
		#end loop
		if len(listname) == 2:    # if length of list equals 2
			listname.pop()		  # delete last item in list

		if len(listname) == 1:    # if list length = 1  all okay
			print('proceed',listname, ' length 1 is correct')
		else:
			print("this list", listname, "is wrong supposed to be length 1", len(listname))
	else:
		# length of list is 0 or 1 do nothing
		pass

#####################################
# reset_list_to_empty
#####################################
def reset_list_to_empty(listname):
	del listname[:]  #just changed this wednesday may 19th 

  
###++++$$$$$$$$$$$$$$$$$$$$$$$$$ working on this sunday january 10th $$$$$$$$$$$$$$$$$
###++++$$$$$$$$$$$$$$$$$$$$$$$$$ working on this sunday january 10th $$$$$$$$$$$$$$$$$
####////////////===========================================
## will use this one to replaceing the macro with the expanded macro
## which is a string I reference in a list by order number like string_1, string_2
## these will be
## I need to have my macroexpand function go thru a list of thru lines
## and dynamicallyh build each case thru expanded and the stringname
## added to a list
##  and change each case number  into a string for preparing for python handling
## this isn't called yet #go thru the entire string
####################################################
##      swap_thru_lines_with_expanded_cases()     ##  this is for number cases
####################################################
#def swap_thru_lines_with_expanded_cases():
#	## https://www.youtube.com/watch?v=_CzJ5bdRDU4
#	#import pudb; pu.db  #added at point you want to start debugger
#	
#	mytrace('swap_thru_lines_with_expanded_cases()')
#	global switchcasetester
#	print("=========testing case_numbers_to_strings===january 5th 2020====")
#	mycounter = 0
#	for line in switchcasetester.splitlines():
#		beta = mycounter-1
#		if "case" in line:
#			print(line)
#			print(" ")
#			smart=line.split() #separates case from casename
#			#checks if case name is a number returns True or False
#			# this is where it gets number that is now a string
#			cat =is_number(smart[1])  #calling method to check if 
#									  #the case name is a number
#			print(cat)
#			cool = smart[1][:-1]  #chops off : from end last char
#			holder = "'" + cool + "'"  #this puts the number in quotes
#			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
#			newline = cool
#			#print("\t\t" + newline)  #adds tabs to front of it
#			#print("next I will use replace to each case line")
#			opal=switchcasetester.replace(line,"\t\t" +newline)
#			switchcasetester=''
#			switchcasetester = opal
#			#HERE is where the changed case numbers as strings are put into switchcasetester
#			#will use a replace here to the switchcasetester string
#			mycounter += 1
#		else:
#			mycounter += 1
#			continue
#	#print(switchcasetester) #this is to see the switch case input string after the modification
#	#after the numbers have been converted into strings



###////////////////////////////////////////////===========
    

#list_with_thru_macros=[]
#list_with_thru_macros.append(0) #position 0 nothing
#backwards_thru_list =[]  #initializing the list

#### ### this needs to happen first 
################ case 1 to 10: becomes case 1 thru 10:######################
######################################################
#### change to into thru ()       created friday feb 5th, 2021 morning
######################################################

#########################################
#def change_to_into_thru():  #this is a simple way of doing it
#	mytrace('change_to_into_thru()')
#	print("change macro to into thru")
#	global switchcasetester
#	mycounter = 0; banana=''
#	for line in switchcasetester.splitlines():
#		simple = mycounter-1
#		if "case" and "to" in line:  #this means the macro to
#			banana=switchcasetester.replace(" to "," thru ")  #just addded spaces
#			switchcasetester=''; switchcasetester = banana
#			#print(switchcasetester)
#		else:
#			pass
		
		










		
	
	

####=========== test here concatting little chunks for the switch case







	


#varholder=[]
#varholder.append("walmart")  #position 0  varholder[0]
#varholder.append("0")      #position 1
# =======   testfunction    ========================
#exp=''








#coyote_list=[]  #initialize it
#trontime= ['empty', 'switch', 'case', 'case', 'code;', 'code;', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'break', 'empty', 'case', 'case', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'default', 'code;', 'code;', 'break', 'code;']


# I can simply fill it manually with a loop and append
#print(trontime)



#what I can do is have a simple true or false switch
#and leave the function calls where they are and if triggered true
#then they will be called otherwise they won't be called.


#start_trigger()


######################################
default_location=''
def get_default_location_2(): #line number location of the word default
	print("=============get default location called =================")
	mytrace('get_default_location_2')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
			break
		else:
			counter += 1
			continue
	return default_location







	
########################################
##      get last break in string
########################################
listofbreaks=[]
def get_last_break_in_string_2():
	print("==============find last break in string============")
	mytrace('get_last_break_in_string_2()')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string
	
	
	
	
#############################


#I need to add a break if there isn't one saturday, December 5th
#it expects a break at bottom of default.
#and I just realized it requires a default but doesn't look for one
newton=''
orange=''
#this scans through input switch and changes default to case default
#switchcasetester=''
last_break=''
#this assumes that there is a default. I will just make it mandatory to have a default
################################################################################
### this does convert_default_case AND add break after default if it needs one
################################################################################
def convert_default_case_2(): #I got this working November 26th, 2020
	print("IS THIS BEING CALLED convert_default_case_2()")
	mytrace('convert_default_case_2')
	#print("===========convert default case called ===========")
	############################################################
	get_default= get_default_location_2()
	last_break =get_last_break_in_string_2()
	
	
	############################################################
	global switchcasetester
	# IF default(LINE NUMBER) < last break(LINE NUMBER)  There is a break
	#########################################################################
	#this says: if default (line number) LESS than last break (line number)
	#in other words this says if "break" after "default" is True 
	if int(get_default) < int(last_break):  #### if default  < last break  
	
	#########################################################################
		
		#print("there is a break after default")
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
		
		# at this ELSE This is triggered if NO BREAK IS AFTER DEFAULT and therefore add a break
		#the else  is triggered if int(a)> int(b) meaning break number LESS THAN default line num
	else:
		#down below here it adds break after default and makes case deafult
		#print(switchcasetester)
		########################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		orange=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = orange
		#print(switchcasetester)
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
	
	






def testing_number_of_lines_in_string_2():
	mytrace('testing_number_of_lines_in_string_2()')
	count =0
	for line in switchcasetester.splitlines():
		count +=1
		#print(count)
	#print("there were ",count, "lines in string")
	return count




    #apple = "one"
###=================== nov 19th new code ============
###================ get_closing_brace (line number) ==============
closing_brace=''
def get_closing_brace_2():
	#print("get_closing_brace called")
	mytrace('get_closing_brace_2')
	counter =0
	closing_brace =testing_number_of_lines_in_string_2()
	return closing_brace

###=============================================
default_location=''
def get_default_location_2():
	mytrace('get_default_location_2')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
		else:
			counter += 1
			continue
	return default_location



list1 =[]
list1.append("four")


#varholder[0] ="four"







print("this is actual generated code I am trying to run now....")
print("this is betterworknow in python generated previously")



list1=[]
exp =''; case =''
exp = ""

#exec(betterworknow)
print("=== executin betterwork now test bit")




####======== starts here ===============
#this is the function triggered to start the parser and codegen
def start_trigger_2():  #this converts the default case immediately
	#global switchcasetester  #just added this to hopefully fix bug
	trigger = True
	print("trigger =", trigger)
	if trigger == True:
		print("trigger =", True)
	else:
		print('trigger=',False)

	mytrace('start_trigger_2')
	convert_default_case_2()





caselist    =[]
breaklist   =[]
defaultlist =[]
blanklines =[]
mixedlist   =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]
getfirstword =[]
casephrase =[]
alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
casesections =[]
casesectioncounter =[]
breakposition =[]
trontime =[]
tronlinenumbers =[]
fallthrulist = []
smartlist =[]
smartlistlocations=[]
fallthrulocations=[]
#theinputlist =[]





###### how do I pass a list
#this might work
def get_first_list():
	mytrace('get_first_list()')





#this finds teh first case in each case section and works
#should be: starter,apple, bananas,chocolate, fish,default
#digitalcandy=[[3,7],[7,19],[19,26],[26,33],[33,43],[43,46]]
















mycounter=0
turtle_tab1=[]
turtle_tab2=[]
turtle_tab1.append('starter')
turtle_tab2.append('starter')
#print('looking for tabs in lines================')
#this is just testing in one case for now
#what I am trying to do is 2 loops one for each case section
#so for the second pass it should start at the next case occurrence
#so first I need to prescan it and get the line number of each case
#apparently the solution is using the digitalcandy list with
#the range of case line numbers which I already have calcualted
#this way I can reuse that and focus on just one case section at a time
#and loop through the digital candy list
#I should fill a two dimensional loop
#I can make each new loop and apppend it to the big loop

biglist=[]
testlist=[1,1,1,1,] #tabs for each line in a case
testlist2=[2,2,2,2,2,2]
biglist.append(testlist)
biglist.append(testlist2)

listofifs =[]

def big_gears_filling_list_with_case_bodies_2():
	mytrace('big_gears_filling_list_with_case_bodies_2')
	#mytrace('snowtime') #it calls snowtime() below
	#print("================  big gears filling list with case bodies called  ==========")
	counter=0
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]
		counter += 1
		snowtime(item[0],item[1])  #snowtime is called here





z =''
#this loopsthru the string of jsswitch between
#case numbers in line
mytablist=[]
sublist=[]
case_main_body_list=[]  #just added this oct 8th
#this copies the case body for each case section and addds it to case_main_body_list

def snowtime_2(x,y):  #this grabs the body from one case section at a time
	mytrace('snowtime()')
	global practicestring1
	practicestring1 = ""
	
	mycounter=0
	dog=''
	mytablist=[]
	for line in switchcasetester.splitlines():


		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line:

			if len(line) == 0: #this means that the line is empty

				mycounter += 1 #see if this is necessary here or not
				continue
			else:


				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				sublist.append(dog)
				#print('the tabs are invisible and embeddd in the code string.')


		mycounter += 1
		#print(sublist)
	mytablist.append(sublist)
	#print("mytablist =",mytablist)

	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 ='' #clears it out

#=========================================================================






#===================================================
#global variable initialization here
#november 10th, 2020
theresult = ''
#testing_this_out function calls function input_string() which returns
#the docstring as a variable and is assigned to the global variable theresult



#=====================================================






















#line_numbers_of_first_cases
#look at this force feeding it input i need to find the generation of the inputlist


	#print("=======")

	#str = "'apple'"
	#print(str)
	#print(str.replace('"', ''))





#sunrise();

#what this does is take the input of teh [concatstring list] with line numbers
#which has the first case line number for each section
#I need the case number list name to feed it













#this_needs_to_work_badly();[2, 7, 17, 24, 34]
#theinputlist =[2,7,17,24,34]  #5 which is case_sections + 1 (default)
case_sections = 0
total = 5
#==========================
#I will have to dynamically initialize these


mainlist=[]
#diamonds=[[2,7],[7,19],[19,26],[26,36]]  what I am aiming to make
#these are lines of the first case line numbers and then the default line number


#theinputlist= [2, 7, 17, 24, 34]  #last one is default which is really a case


length_of_input_list = len(line_numbers_of_first_cases)   #question does this work because it's an even number
#output
mainlist= [] # [[2, 7], [7, 19], [19, 26], [26, 36]]



find_default=''
lastbrace=''

list_trex=[]
listcandy=[]
defaultlist=[]  #here defaultlist is declared as empty



	#digitalcandy.append(defaultlist)
###=============================================




## what this does is delete the existing last sublist from digitalcandy
## and then it replaces it with a new list appended that has the default line number and
## curly brace line number (can alternatively be the last line of string) both equal length





#==============
# this looks like good logic to check between default and closing brace/last line
# determined last line number also eventually
# december 7th, this is dependent on default word existing
# the point of this code section is to VERIFY that there IS a BREAK after default
# and if there isn't a break add one
#=========
#
#===============
#defaultlist=[]
'''

'''
###====================
####======== find_last_break_in_string  ========= in switchcasetester input switch
listofbreaks=[]
def find_last_break_in_string_2():
	mytrace('find_last_break')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string

#=========================
####### special addition to digital_candy 2
#############################################


#working on this December 17th new functions
'''

   
'''

######################
##  stage_four_2
#######################
def stage_four_2():
	mytrace('stage_four_2()')
	#print('stage four')
	#magictimenow_2()
	#convert_to_twin_list_2()
	#special_addition_to_digital_candy_2() #======added nov 25th, 2020
	#rule_the_earth_2()






#================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.
firstline =""
#additions on Sunday August 23rd, 2020
royallist=[]  #mythical list of tail for case section codegen
royallist.append('starter'); #which fills position0


#this is a super important function I think I wrote it at the beach a few days ago
def testing_this_to_get_word_2():
    return
   



#testing_this_to_get_word()  #==================this should call it now
######################
##  stage_five_2
#######################
def stage_five_2():
    return#print('stage five')
    #testing_this_to_get_word_2()




    ###########################################################
    #these are the line number positions of first case for each section [2, 7, 19,26]
    #this looks in one section at a time for a break and fallthru
#diamonds =[]
    #this is all just raw code not even in a function
def does_this_run():
    mytrace("does_this_run")
    c = 1    #current case numbr section
    d = c + 1

    x = clever[0]
    y = clever[1]
             #this loops by default through the entire string
             #for line in splitline().switch:

     #=======================================================
     #this is looking between x and y which are in diamonds
     #========================================================

    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]
    #print("testing getting the dam range to work")
    #print("looking for BREAK in this case section")
    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;


        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=========================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##===========================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:  #what about fallthrough also to test for
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');

    if "true" in case1findfallthru:
        #print('fallthru found')
        royallist.append('fallthru')

    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        royallist.append('fallthru')

    #print("royallist=",royallist)
###########






#//=========== iron curtain============================

 ##===============================================================
  ####=================== American River Methods ==================
  ##===============================================================


  #================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.







######################
##  grab_body_of_code_inside_case_sections_2
#######################
buildlist=[]
def grab_body_of_code_inside_case_sections_2():
    mytrace("grab_body_of_code_inside_case_sections")
    #print("grab body of code called== @@@@")
    smartcounter=0  #reset at zero

    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)

        if smartcounter > x and smartcounter < y:  #so get what's inbeteen
       #this should only print the body of this one case section
            if "case" not in line and "break" not in line and "fallthru" not in line:
                #print(line)
                buildlist.append(line,smartcounter);
                smartcounter += 1;
                #do I need continue?





#august 27 thurday coding test       this will be the sets of cases for each case section
caseset=[]
###############################
## create_case_name_lists_2
###############################

def create_case_name_lists_2(x,y):
    #print("==$$$$$$$$$$$$$$$$$$$$$$$$$$$$$==")
    #print("================this is line 1615===CREATE CASE NAME LISTS=====================")
   # print("def create_case_name_lists:")
    #print("working on fix to solve bug if user uses more than one word for a case")
    #print("such as alpine meadows whereas right now its geared for one word cases")
    
    mytrace('create_case_name_lists')
    #print("=================create case name lists called == @@@@")

    smartcounter=0 #reset at zero
    genius = ''
     #need list of first cases that will work for input
    
    ##===================================================================
    ## LOOP LOOKING  CASE SECTION APPEND LINES FROM BODY AFTER CASES UNTIL NEXT FIRST CASE
    ##=======================================================================
    #print("here we get the words in each case section=====------")
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter < y:  #so get what's inbeteen
        #this should just look
            if "case"  in line:
                #print("did it take off front of line?")
                #print(line.split(' ',1)[1])
                #print(line,smartcounter)
               # print("=================================")
                genius =line.split()
                #print("genius =",genius)
                #print("======= len(genius) ==============")
                #print("WE ARE HERE==>>>>")
                #print('number of words in the line case = len(genius) ',len(genius))
                
                #print("number of words in this line =",len(genius))
                #print("it's current state is only grab the second word which is position [1] by default")
                ap=''
                #testing with more than one word the defualt was the first one
               #================  jan 3, 2021 code fix experimentiong case alpine meadows
                if len(genius) == 2:
                    #print('teh default was 1 word case and one word')
                    caseset.append(genius[1])
                    #print(caseset)
                    
                if len(genius) == 3:
                    #print('teh default was 3 words case and two words')
                    ap =genius[1] + genius[2]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) == 4:
                   # print('teh default was 4 word case and 3 words')
                    ap =genius[1] + genius[2] + genius[3]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) > 4:
                    #print("more than four words in this line detected")
                    #print("just do the default for now will fix later")
                    caseset.append(genius[1])
                    #print(caseset)
                
                #print("it looks like I'm just grabbing the first word of a case which I initially tested it with")
                #print('line 1632')
                #print(caseset)
                #buildlist.append(line);
                smartcounter += 1;

    #print("caseset list for one case section=",caseset);
    wilsonball=[]
    wilsonball.append('starter')
    wilsonball.append(caseset)
    #print("******** === wilsonball=",wilsonball)





#do bypass before even doing switch case

'''
if number quick check if number in list
get highest_number in list of numbers
if entered number > highest_number 
   goto default case
   print("msg your number is not in list")
'''








#this actually looks for breaks, missing beaks, and fallthrus
####=====================
##case_tail_list_maker_2() finds breaks, missing break detection, fallthrus
##========================
def case_tail_list_maker_2(x,y):
    #empty_list(royallist)
    mytrace('case_trail_list_maker_2')
    #print("=######	C A S E    T A I L   M A K E R called  ")
    smartcounter=0
    #this looks for "case" in the switch case string
    print("what the hell is in switchcasetester")
    print("///////////////////////")
    #print(switchcasetester)
    print("//////////////////////")
    for line in switchcasetester.splitlines(): #switch case in JS
        if "case" in line: #see if this puppy works
            firstline = line.split()
          #  print(firstline)
          # print(firstline[0])
            smartcounter += 1;
        else:
            smartcounter +=1;

    #here we get the location of the "default"
    smartcounter=0
    for line in switchcasetester.splitlines(): #switch case in JS
        if "default" in line: #see if this puppy works
            firstline = line.split()
            location_of_default = smartcounter
            break
            #smartcounter += 1;
        else:
            smartcounter +=1;



   #not sure if I am using c and d or not or if I switched to x, y instead
    c = 1    #current case numbr section
    d = c + 1



    #print("x",x,"y",y);
    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]

    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;

     #we ARE STARTING A SECOND LOOP HERE -------------------
        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=====================================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##======================================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #I think that this is the end of the for loop here



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');



    if "true" in case1findfallthru:
        #print('fallthru found')
        smart = len(royallist)  #new code
        smart += 1
        #before I add this one         so I am putting a number here which is used
        fall = "fallthru" + str(smart)  #to call the correct word in starbuckslist
        #print("we have",starbuckslist[smart]," added to fallthru")
        #I will need to do this
        #  fall = "fallthru('" + starbuckslist[smart] + "'")
        royallist.append(fall)
    wolf =''
    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        sosmart = len(royallist)
        sosmart += 1   #number below so it makes fallthru4 in example
        fall = "fallthru" + str(sosmart) #+ ")"  #just added this  thursday night
        #print("we have",starbuckslist[sosmart], "added to fallthru")
        #print("smart is length of royal list before adding fallthru",sosmart)
        wolf = "fallthru(" + "'" +  str(sosmart) + "'" + ")"  #this makes fallthru(4) which I need
        #because I can convert the number to a word in new list
        #print("wolf=",wolf)  #so this works
        royallist.append(fall)
    print("=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=00=0=0=0==")
    print("=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=00=0=0=0==")
    print("=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=00=0=0=0==")
    print("=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=0=00=0=0=0==")
    
    print("royallist=",royallist)
    #this changes the first position which is [0] fallthru1 to starter
    royallist[0] = "starter"
    print("now royallist has this in it")
    print(royallist)











tail_list=[]
cranberries=[]
cranberries.append('starter')
##===========================
##==== def p51_mustang_2() ===  adds the number to  fallthru(3) like that
##===========================
  #this makes the cranberries list which is the tail list used on codegen page
#diamonds=[[2,7],[7,17],[17,24],[24,34]]
#this makes the cranberries list
def p51_mustang_2(): #makes critical cranberries list which is the taillist for switch cases
	return


###############################
## stage_six_2
###############################
def stage_six_2():
    return#print('stage six')
    #p51_mustang_2()







#The purpose of this method == flyingcloud == is to
#fill small lists with
#the respective case names
#get case names in each set and add to list





#=====================================
#========== flyingcloud ==============  Thursday morning coding
#=====================================
#case1list=[]
#case2list=[]
#wilderness=''
#wild=''
#diamonds=[[2,7],[7,17],[17,24],[24,34]]

#this is used for the caselists that are generated for
#the python output for each case section there is a list
#and if the programmers writes more case sections and there
#isn't enough lists then the switch will fail
#so I started with ten case section lists and just expanded
#it to a thousands. You can always add more.


#forcing it to see what happens november 21st
#caselist7=['default']


#we will know before hand how many caselists will be filled 4

#this makes the first case list called starbucks which is used throughout the program
##==========================
##   flying fish 2            this loops through the dimaonds list of first cases
##==========================
def flyingfish_2():
	return




##==========================
##   flying cloud_2            this builds a list of the case names for each section
##==========================
#smartcasemanager=[]
#for x in smartcasemanager[:]:
		#smartcasemanager.remove(x)

#if smartcasemanager has anything in it empty it completely

#if len(smartcasemanager) > 0:
#	print('yep something in smartcasemanager length was',len(smartcasemanager))
#	del smartcasemanager[:]

#smartcasemanager.append("['starter']")

def flyingcloud_2(x,y,z):
	return
	
	


einstein=[] #resets einstein to empty
	#========================================
#this fills up smartcasemanager list
###############################
## nightowl_2
###############################
def nightowl_2():
	return
	


#this prints out the smartcasemanager list to verify that it worked and has the sublists

#=================================
def goodseason():
	mytrace('goodseason')



###############################
## stage_seven_2
###############################
def stage_seven_2():
    return#print('stage seven')
    #flyingfish_2()


#wilson=''
#mystring =''

#============================
#      wildgame
#============================
#or am I using the current case number or next case number for fallthru
#so does it represent the current location and then we add 1 to it or does fallthru(#) have
#the next number position embedded in it already
#this will go through the list and convert the fallthru(#) into names making the gold tail list
#which is used to build the case sections









goldtaillist =[]
#I need to loop through this list and create the new list for final gold tail list
def autumn_2():  #this builds the break fallthru(nextcasename) list
	mytrace('autumn_2')
	#print("autumn leaves falling")
	#print("autumn called to make new list of breaks and fallthrus final")
	#print("please work I need this to work")
	counter =0
	#print('starbucks =',starbuckslist)
	#print("mintlist =", mintlist)
	for item in starbuckslist:
		print(item)
		#goes through list


		if item == "break":
			#print('break found')
			goldtaillist.append("break") #how come it doesn't append this
			counter += 1


		if  "fall" in item:
			#print('fallthru found!')
			#print('counter=',counter)
			result =wildgame(counter)  #it wants a number use the counter
			#print("wildgame() result=",result)
			goldtaillist.append(result)
			counter += 1
		else:
			counter += 1

		if item == "starter":
			goldtaillist.append("starter")
			counter += 1
			continue

		if item == "default":
			goldtaillist.append("default")
			counter += 1
			continue

	#print("goldtaillist =",goldtaillist)




#autumn()



crushit =[]









#thurday, september 10, 2020 truck stop insight
#=============== stars() =============================
#=========== this goes thru dummy list with just starter fallthru and break and default
#==========/=== and adds the numbers of teh fallthru locations into cru0list
#=======================================================

miraclelist=[]
###############################
## stars_2
###############################
def stars_2():
	mytrace('stars')
    #print('STARS test of loking for words in list')
	#print('look for break default starter fallthru')
	#print("listnow =",listnow)
	counter =0
	#print("starting looking in loop")

	for item in listnow:
		if "break" == item:
			#print('break')
			crushit.append("break")
			counter += 1

		if  item.startswith("f") == True:
			#print('fallthru found')
			crushit.append("fallthru('" + str(counter) + "')")
			counter += 1

		if item.startswith('d') == True:
			#print("default found")
			crushit.append("default")
			counter += 1

		if item.startswith('s') == True:
			#print("starter found")
			crushit.append("starter")
			counter += 1



	#====
	#starter is 0 but not a case
	#first case is position 1 (if fallthru(1)) it becomes fallthru(2) for conversion
	#so it is based on current position for the current case and then the NEXT case is +1
	#==========================================
	#input must be 1 or higher but less than the length-1 can't be starter (0) or default(length-1)
	wilson=''
	newnumber=''
	counter =0
	for item in cru0:
		if item.startswith("f") == True:  #fallthru or fallthrough
			#print("fallthru found")
			mystring=item
			#print('mystring=',mystring)
			wilson=int(''.join(filter(str.isdigit, mystring)))   #this extracts the number from a string
			newnumber = wilson + 1
			newnumber = int(newnumber)
			answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
			ohbaby = "fallthru('"  + answer  + "')"
			ohbaby =ohbaby.strip()
			miraclelist.append(ohbaby)
			counter += 1

		if item.startswith('d') == True:  #default is last case needs to have break
				#print("default fuound")
				miraclelist.append("break")
				counter += 1

		if item.startswith('s') == True:
				#print("starter found")
				miraclelist.append("starter")
				counter += 1

		if item.startswith('b') == True:
				#print('break')
				miraclelist.append("break")
				counter += 1








#======== adderrsmill==============================
case_main_body_list=[]
case_main_body_list.append('starter')  #this is to fill up position 0

z =''


# big gears filling list with case bodies of python code


###############################
## big_gears_filling_list_with_case_bodies_2()
###############################

def big_gears_filling_list_with_case_bodies_2():
	return

import re  #for regular expressions
#this one
handy_list_of_tabs=[]
dual_slots=[]
crummy =[]
fiasco =[]
n_count_per_section=''
case_section_lines_of_code=[]

#new idea have line count based on first line of code in THIS section after if case
#and the first line is 1 and not 0 so it's human math thinking

###############################
## smarty_2
###############################
def smarty_2(x,y):  #this grabs the body from one case section at a time
	mytrace('smarty_2')
	#print("=====/////======= smarty called ====2340=====//////=====")
	#print("line 818 snowtime(",x,y,")  S  N  O  W  T  I  M  E  ")
	#print("=====================  snowtime called", x, y," ===================")
	#print("smarty x y testing blank lines existence to delete them")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	for line in switchcasetester.splitlines():
		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line  and "}" not in line \
		and "{" not in line:
		#this takes out the empty line by skipping it

			#added this sept 17 2020 to eliminate empty lines that do and mean nothing
			if len(line) == '\n': #this means that the line is empty
				#print("yes an empty line")
				#print(line.count("\n")) #just added this
				#del line #does this work
				mycounter += 1 #see if this is necessary here or not
				continue
			else:
				#I will already know ahead of time how many lines of code output
				#in each case section
				#print building practicestring1 adding lines of strings
				#if lastline == "true":
				#	practicestring1 += line

					#else:
					#by default each line will require 2 tabs in front of it
				line=line[1:] #takes off first tab off from front of line

				#We know the length so if last line no \n on end

					# ============== Glory =======================
				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
					#=============== Glory =======================
					#line 2386 where the fun is

					#Right here  flag whether to add  + "\n"





			####################
		mycounter += 1

	#this would be the string and nuke last line trailing \n which I know will be there
	practicestring1 = practicestring1.rstrip("\n")
	### and here the practice string is added (appended) to case_main_body_list
	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 =''  #here we nuke practicestring1 so I can reuse for each case section
	#print("=========")
	#print("list of tabs=",handy_list_of_tabs)
	#print("number of lines with code =",len(handy_list_of_tabs))
	#print("pairs tabs and line number ",fiasco)
	#print("number of lines in each section =", n_count_per_section)
	#case_section_lines_of_code.append(n_count_per_section)
	#print("=========")

def loop_thru_case_sections_2():
	#print("======== loop thru case sections =============")
	mytrace('loop_thru_case_sections_2')
	#print("loop thru cases sections which is a list")


#loop_thru_case_sections()  #=================

###############################
## stage_eight_2()
###############################
def stage_eight_2():
	mytrace('stage_eight()')
	#print('stage eight')
	#loop_thru_case_sections_2()


icecream=''
###############################
## herewego_2()
###############################
def herewego_2(): #loops and prints all main bodies
	return 
	
	

print("")

acounter=0
#for item in case_main_body_list:
#	print(len(item))
#	acounter += 1










#print("digitalcandy=",digitalcandy)
#big_gears_filling_list_with_case_bodies()
#herewego()  #==================================
###############################
## stage_nine_2()
###############################
def stage_nine_2():
	mytrace('stage_nine()')
	#print('stage nine')
	#big_gears_filling_list_with_case_bodies_2()
	#herewego_2()


#print("tail_list cranberries =",cranberries)
###=============================================================================
x = 0;y =0
smart=''
#cranberries=[]
list_of_rows_of_case_names=[]


#making case section sublists here
#this is for making the variable lists to fill the case sections of cases
# and to refer to each of these caselists with ifs and elifs




###############################
## make_case_sets_2()
###############################

def make_case_sets_2():
	mytrace('make_case_sets_2')
	#print("===== make_case_sets called ====")
	acounter = 0
	firstcasesectionlist=[]
	firstcasesectionlist.append("starter")
	 #this will be the case name
	#print("we have length of ", len(digitalcandy))
	#print(digitalcandy) #so we can see our input values of digitalcandy list
	for item in digitalcandy:
		x = None  #zap them out perhaps
		y = None
		#what = digitalcandy[acounter]
		x = item[0]; y = item[1]

		z = acounter
		partynation_2(x,y) #partynation called here------ PARTYNATION -----------
		acounter += 1
	#adding default to see if it works
	#firstcasesectionlist.append("default")
	#this happens after the loop has finished
	#print("what 9999 is this =",firstcasesectionlist)
	#print("----------")
	counter=0
	list_of_rows_of_case_names.append(firstcasesectionlist) #since this will be the last one
	castle_time_2()

smartcasemanager=[]  #creating the initializing smartcasemanager







###############################
## castle_time_2()
###############################

#this just prints it out the sets of the cases for each case section
def castle_time_2(): #fills up smartcasemanager
	mytrace('castle_time_2')

	#list_of_rows_of_case_names.append("[['default']") #trying this
	#print("============CASTLE_TIME called ===========")
	count=0
	while count < len(list_of_rows_of_case_names):
		if count == 0:
			count +=1
			continue
		#print(list_of_rows_of_case_names[count][1:])
		count += 1

	#print("more testing to get this right")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	##################################################
	### SMARTCASEMANAGER LIST FILLED HERE ############
	##################################################

	#this fills up list smartcasemanager from list_of_rows_of_case_names
	#this is doing a brute force copy of a list
	for item in list_of_rows_of_case_names:
		smartcasemanager.append(item)


	#print(smartcasemanager)
	smartcasemanager.pop()
	#print('after deleting last item in list')
	#print(smartcasemanager)

	finallist = ['default'] #see if this works
	list_of_rows_of_case_names.append(finallist)
	#print("this should be default below======+++")
	#list_of_rows_of_case_names[-1]
	#smartcasemanager.append("['default']") #using a default case so it can be fallthrud from above
	#print(smartcasemanager) #now we add default to the end or do we need to or not
#==========================================================
#======================== partynation =====================


###############################
## partynation_2()
###############################
list_of_rows_of_case_names=['starter']
firstcasesectionlist=['starter']
def partynation_2(x,y):  #this grabs the body
	mytrace('partynation_2')
	#print("====partynation======")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	firstcasesectionlist=[]
	firstcasesectionlist.append('starter')
	#start loop
	#this specifically is looking for the word case
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if mycounter >= x and mycounter < y \
		and "case" in line:     #just added default
			genius = line.split()
			wild=genius[1].strip()
			wild = wild[:-1]
			wild = wild[1:-1]

			firstcasesectionlist.append(wild)  #adding this case name to firstcasesectionlist

		mycounter += 1
	#end loop
	#This is forcing default into firstcasesectionlist
	#wild = 'default'   #major test here
	#firstcasesectionlist.append(wild)
	for item in firstcasesectionlist:
		item.replace('"',' ' )


	firstcasesectionlist[1:-1]
	for item in firstcasesectionlist:
		item.replace('"',' ' )
	#here the currently newly minted case list is added to the big list
	#which is called list_of_rows_of_case_names
	list_of_rows_of_case_names.append(firstcasesectionlist)



	firstcasesectionlist= []
	#firstcasesectionlist.append('starter')



###############################
## testingthis_2()
###############################
def testingthis_2():
	mytrace('testingthis()')
	#print(" this prints out the contents of the important lists")

	#print("==============================================")
	#print("digitalcandy list ========")
	#for item in digitalcandy:
	#	print(item)

	#print("starbucks list ====of first case names in each section ====")
	#print(starbuckslist)

	#print("smartcasemanager list ========", len(smartcasemanager))
	#for item in smartcasemanager:#
	#	print(item)

	#print("case_main_body_list list ========", len(case_main_body_list))
	#for item in case_main_body_list:
	#	print(item)
	#=== code gen here ====

###############################
## stage_ten_2()
###############################
def stage_ten_2():
	mytrace('stage_ten_2()')
	#print('stage ten')
	#make_case_sets_2()
	#testingthis()



#I just need the lists to build my code generation now to generation
#the logic right

#codegen is using the output lists from the parser

#this is the taillist

#this is bringing it altogether simulating it creating the
#switch case in three parts
#with a counter and a loop

#trace()
#lists for starbuvks_drive_thru_code.py
caselist     =[]
breaklist    =[]
fallthrulist =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]


alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]

#this will be the first
#print("this will run at the top of the page and call the functions in sequence\n")
#cranberries=[]
my_godzilla_list=[]
newlist=[]
smartylist=[]
tryagain=[]
coollist=[]
#test data here it will be one file and just flow down with no imports
#rodan=[2,7,17,24,34]

tabs =['starter',"\t","\t\t","\t\t\t","\t\t\t\t","\t\t\t\t\t","\t\t\t\t\t\t"]






firstcaselist=[]

#digital_candy=[[2, 7], [7, 17], [17, 24], [24, 34]]

switch_python_gen=''










###=================================================================
###  below I get the location of default and closing curly brace for end of switch
###  this is to be used for determining the default case which is utilized for
###  the situation of a fallthru down into default
###  this also adds one more case tothe regular cases and I need these parameters

#print("============ surgery here S=================================")
#print("")
###############################
## make_default_case_2()
###############################
def make_default_case_2():
	mytrace('make_default_case()')
	find_default = get_default_location_2()
	#print("NEW location of default =",find_default)

	lastbrace = get_closing_brace_2()
	#print("NEW location of closing brace =", lastbrace)


	#digitalcandy.append
#november 21st coding
#make_default_case()

## what I still need to put together to have the body of the default case
## and that will be used for the default case and the body of the else:


 ##so if line is > default and line is < lastbrace
 ##and "break" not in line
 ##and fill practice string and append the pracietce sting to case_main_body_list
##use snow(x,y) and a loop to grab the lines of code inside of default
##make sure "


#print(" this prints out the contents of the important lists")

#print("==============================================")
#print("digitalcandy list ========")
#for item in digitalcandy:
#	print(item)



#print("they all need to start with 'starter' in position 0")
#print("the big 3 need to have the same number of elements for the length to be the same")

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus
# digitalcandy

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#what smartcasemanager output looks like in ufos file
#this was tyhe failed attempt at managing the indentation over to the left
#for the switch case output in python and I have a simpler solution I will end up using.




		#counter += 1














###############################
## parktime_2()
###############################

def parktime_2():

	mytrace('parktime')
	import re
	myString = "\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
	#print(myString)
	output   = re.sub(r"[\n\t]*", "", myString)



###############################
## stage_eleven_2()
###############################
def stage_eleven_2():
	mytrace('stage_eleven()')
	#print('stage eleven')
	#parktime_2()


#input for the switch case happens (above) the docstring JavaScript switch case interface




######===================================================================
###======== switch_code_gen here ============
# add error mistake if no input for exp it will do nothing
# this is good for me to think of adding
# also add break if no break in default for input from js switch
# monday dec 14th thinking
# need to add input stuff here that is in the top running betterworks

sw=''
sweet =''
switch_gen=''
#testing input here
  #this has to be above the generated code

testlist=[]
exp =''

############################################################
########  SWITCH CODE GENERATOR INTO PYTHON ################
############################################################

#======================================
#  ====== project mr coffee ========
#this takes in lists calculated above and generates a string of python switch case code
def switch_code_gen_2():
	return
	
	


	#this is called in switch as a method from angel_falls
	#to put string into varholder[1]
def dothis(x):
	varholder.append(x)
	#print(varholder[1]) 
	
	
def lovely_output():
	print(varholder[1])
	#print("lovely_output called")
	#print("")
	







###############################
## stage_twelve_2()
###############################
#this executes the generated python switch code
def stage_twelve_2():
	mytrace('stage_twelve()')
	#pass

		
	for x in caselist1[:]:
		caselist1.remove(x)
	
	for x in caselist2[:]:
		caselist2.remove(x)
		
	for x in caselist3[:]:
		caselist3.remove(x)
		
	for x in caselist4[:]:
		caselist4.remove(x)
		
	for x in caselist5[:]:
		caselist5.remove(x)
		
	for x in einstein[:]:
		einstein.remove(x)
	
	smartcasemanager=[]
	print(smartcasemanager)
		
	for x in testlist[:]:
		testlist.remove(x)
		
	print("after emptying einstein list we have")
	print("einstein=",einstein)	
	#global switchcasetester #new
	#switchcasetester =''  #new
	#print(switchcasetester)
	#case_main_body_list=[] #nukes it
	resetting_up_case_body() #clears out case_main_body_list then appends('starter') to it
	#print("caselist",caselist)
	#print("smartcasemanager",smartcasemanager)
	print('printing out lists contents to see what is actually in them')
	print("this is to determine what is in the lists after a switch case has")
	print("been generated and it no long needs the data from the parser")
	empty_list(smartcasemanager)
	empty_list(einstein)
	empty_list(defaultlist)
	empty_list(candy)
	empty_list(digitalcandy)
	empty_list(palmtrees)
	empty_list(gti)
	empty_list(drive_thru)
	empty_list(mochalist)
	empty_list(case1findbreak)
	empty_list(case1findfallthru)
	empty_list(line_numbers_of_first_cases)  #missed s after number
	empty_list(case_main_body_list)
	#empty_list(case_main_body_list_with_tail)
	empty_list(starbuckslist)
	empty_list(wilecoyote)
	empty_list(birdsong)
	empty_list(cranberries)
	empty_list(royallist)
	empty_list(roadrunner)
	empty_list(penguin)
	empty_list(caselist1)
	empty_list(caselist2)
	empty_list(caselist3)
	empty_list(caselist4)
	empty_list(caselist5)
	empty_list(caselist6)
	empty_list(caselist7)
	empty_list(caselist8)
	empty_list(caselist9)
	empty_list(caselist10)
	empty_list(caselist11)
	empty_list(caselist12)
	empty_list(caselist13)
	empty_list(caselist14)
	empty_list(caselist15)
	empty_list(caselist16)
	empty_list(caselist17)
	empty_list(caselist18)
	empty_list(caselist19)
	empty_list(caselist20)
	

	
	
	print("defaultlist=",defaultlist)
	print("candy=",candy)
	print('digitalcandy=',digitalcandy)
	print("palmtrees=",palmtrees)
	print("how many of these have data in them after the first switch?")
	print("gti",gti)
	print("mochalist",mochalist)
	print("drive_thru",drive_thru)
	print("einstein",einstein)
	print("smartcasemanager",smartcasemanager)
	print("testlist",testlist)
	
	#funny
	print("case1findbreak",case1findbreak)
	print("case1findfallthru",case1findfallthru)
	print("seal",seal)
	print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	print("case_main_body_list=",case_main_body_list)
	#print("case_main_body_list_with_tail",case_main_body_list_with_tail)
	
	
		
	smartcasemanager=[]
	#print("candy=",candy)
	#print("starbucklist=",starbuckslist)
	#print("digitalcandy=",digitalcandy)
	#print("einstein=",einstein)
	#print("wilecoyote=",wilecoyote)
	#print('birdsong=',birdsong)
	#print("cranberries =",cranberries)
	#print("royallist =",royallist)
	#print("roadrunner =",roadrunner)
	#print("penguin =",penguin)
	#print("british =",british)
	#print('stage twelve')

	#print("caselist1=",caselist1)
	#print("caselist2=",caselist2)
	#print("caselist3=",caselist3)
	#print("caselist4=",caselist4)
	#print("caselist5=",caselist5)
	#print("caselist6=",caselist6)
	#print("caselist7=",caselist7)
	#print("caselist8=",caselist8)
	#print("caselist9=",caselist9)
	#print("caselist10=",caselist10)
	#this seems to work whereas nothing above actually worked
	## only guaranteed way to empty lists completely 
	for item in range(0,len(palmtrees)):
		palmtrees.pop()

	for item in range(0,len(digitalcandy)):
		digitalcandy.pop()

	for item in range(0,len(einstein)):
		einstein.pop()

	for item in range(0,len(wilecoyote)):
		wilecoyote.pop()
		
	for item in range(0,len(candy)):
		candy.pop()
		
		
	for item in range(0,len(case_main_body_list)):
		case_main_body_list.pop()
		
	

	for item in range(0,len(birdsong)):
		birdsong.pop()
##3====================
	for item in range(0,len(caselist1)):
		caselist1.pop()

	for item in range(0,len(caselist2)):
		caselist2.pop()

	for item in range(0,len(caselist3)):
		caselist3.pop()

	for item in range(0,len(caselist4)):
		caselist4.pop()

	for item in range(0,len(caselist5)):
		caselist5.pop()

	for item in range(0,len(caselist6)):
		caselist6.pop()

	for item in range(0,len(caselist7)):
		caselist7.pop()

	for item in range(0,len(caselist8)):
		caselist8.pop()

	for item in range(0,len(caselist9)):
		caselist9.pop()

	for item in range(0,len(caselist10)):
		caselist10.pop()
##3==========
	for item in range(0,len(royallist)):
		royallist.pop()

	for item in range(0,len(cranberries)):
		cranberries.pop()
		
	for item in range(0,len(roadrunner)):
		roadrunner.pop()
		
	for item in range(0,len(penguin)):
		penguin.pop()
		
	for item in range(0,len(british)):
		british.pop()
		
		
	###############
	#print("gti",gti)
	for item in range(0,len(gti)):
		gti.pop()
		
	#print("mochalist",mochalist)
	for item in range(0,len(mochalist)):
		mochalist.pop()
		
	#print("drive_thru",drive_thru)
	for item in range(0,len(drive_thru)):
		drive_thru.pop()
	#funny
	#print("case1findbreak",case1findbreak)
	for item in range(0,len(case1findbreak)):
		case1findbreak.pop()
		
	#print("case1findfallthru",case1findfallthru)
	for item in range(0,len(case1findfallthru)):
		case1findfallthru.pop()
		
	#print("defaultlist",defaultlist)
	for item in range(0,len(defaultlist)):
		defaultlist.pop()
			
	#print("seal",seal)
	for item in range(0,len(seal)):
		seal.pop()
	#print("this one is the HOLY GRAIL one")
	#print("line_number_of_first_cases",line_numbers_of_first_cases)
	for item in range(0,len(line_numbers_of_first_cases)):
		line_numbers_of_first_cases.pop()	

	#print('==== after clearing them we have ======')
	
	if len(palmtrees) > 0:
		palmtrees.pop()
	#print('after checking the length of the list this deletes more if greater than 0')
	#print("palmtrees=",palmtrees)
	#print("starbucklist=",starbuckslist)
	for item in digitalcandy:
		digitalcandy.pop()

	#print("digitalcandy=",digitalcandy)
	
	if len(einstein) > 0:
		einstein.pop()
		
	
	#print("=========")
	for x in smartcasemanager[:]:
		smartcasemanager.remove(x)
	#print("contents of smartcasemanager=",smartcasemanager)
	
	#print("see if this helps empty it smartcasemanager")
	for item in smartcasemanager:
		smartcasemanager.pop()
		
		
	#print("candy=",candy)
	#print("defaultlist=",defaultlist)	
	#print("einstein=",einstein)
	#print("wilecoyote=",wilecoyote)
	#print('birdsong=',birdsong)

	#print('british=',british)
	#print('penguin=',penguin)
	#print('royallist=',royallist)
	#print('cranberries=',cranberries)
	#print('roadrunner=',roadrunner)
	#print('case_main_body_list=',case_main_body_list)
	#print('case_main_body_list_with_tail=',case_main_body_list_with_tail)

	#if len(caselist1) > 0:
	#	caselist1.pop()

	#print("caselist1=",caselist1)
	#print("caselist2=",caselist2)
	#print("caselist3=",caselist3)
	#print("caselist4=",caselist4)
	#print("caselist5=",caselist5)
	#print("caselist6=",caselist6)
	#print("caselist7=",caselist7)
	#print("caselist8=",caselist8)
	#print("caselist9=",caselist9)
	#print("caselist10=",caselist10)
	
	#print("are these empty now for a clean slate after first switch?")
	#print("gti",gti)
	#print("mochalist",mochalist)
	#print("drive_thru",drive_thru)
	#funny
	#print("case1findbreak",case1findbreak)
	#print("case1findfallthru",case1findfallthru)
	#print("seal",seal)
	#print("this one is the Big Deal line_numbers_of_first_cases needs to be empty")
	#print("It was previously not being emptied obviously ... now it is")
	#print("apparently this one REALLY needs to be empty or I am screwed")
	#print("line_number_of_first_cases",line_numbers_of_first_cases)
	#print("===== bottom of stage twelve reloading module if possible")
	#print("might have to call function from another function")
	#importlib.reload(switchmodtrial7)
	#print('stage twelve')
    
































#######################################
##  convert_case_numbers_to_strings()
#######################################
#def convert_case_numbers_to_strings():
#	print(y)
#	print("Palomar Drive windy road up")
#	#print("convert_case_numbers_to_strings() called ")
#	mytrace('convert_case_numbers_to_strings()')
#	global switchcasetester
#	make_list_of_lines_using_thru_macro()
#	expand_thru_macro()
#	case_numbers_to_strings() 

#this is reading numbers in cases NOT STRINGS and converting them into strings

#this is new but I haven't tried it yet december 5th
def starter_sequence_mode_2():
	return
	#mytrace('starter_sequence_mode_2()')
	#this ensures that these are ONLY called if valve[0] is True
	#if valve[0
		








	
daisy=''
def parser_mode_2(a):  #in snoopy1.py
	mytrace('parser_mode_2 in snoopy1()') #was greatpumpkin
	print('=======INSIDE OF PARSER in snoopy1  =========')
	return
	


##############  added April 2nd, 2021  ###############################################
# this is a pre scan of the switch case input string to determine if


# this gets the line number of the first case in the switch case string








	
#this will need to be called for each specific thru line
###==============================================================
###================  expand_thru_macro()  ===================
###==============================================================

#inputnum = 1
#def expand_thru_macro1():
#nt(switchcasetester) #was mouse here 
#return ajax
			
			








#this should only go through the first case and then leave the loop
#this grabs the first case line from the switch case looking for a number
#this looks in the string switchcasetester string using a loop
#and in first line with case to see if there is a number or are numbers

#######################  this is used by faucet_valve to detect numbers
##       finbar()    ##  tests first case in switch for numbers
#######################  and returns True if numbers are used else False
def finbar():
	mytrace('finbar()')
	toowild='';global switchcasetester;counter =0;
	numberflag = False # by default until otherwise determined 
	for line in switchcasetester.splitlines():
		if "case" in line and "'" not in line and '"' not in line:  
			#print("so I can see what it sees I am printing the line")
			#print(line)
			toowild = line
			break #get out of the dam loop 
		else:
			counter += 1
			continue
	#end loop
	money= hasNumbers(toowild)  #returns True or False
	if money == True: #means has number(s) in it
		print("yes number in the line")
	else:
		print("no number in line")
	return money 



icetea=''
valve=[]
##########################################
#             faucet_valve()  this fills valve[0] with True or False for numbers
##########################################
def faucet_valve():
	mytrace('faucet_valve()')
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#here it calls finbar() which looks for number in the first case line
	icetea =finbar()  #method finbar() determines if case has a number like case 4:
	print("icetea =",icetea) #True if numbers
	#decided to just return True or False for now
	valve.append(icetea) #valve[0] = icetea
	firstcase = valve[0]  #True if number otherwise a string so False
	#print("contents of valve[0]",valve[0])
	



############################################
##             is_number()
############################################
def is_number(inputString):
	mytrace('is_number')
	return any(char.isdigit() for char in inputString)







#what if I go thru switchcasetester
#and each line with case is just converted to lowercase
#it should work because it's still a string
#make the whole thing lower case



newlist =[];count =''




####################################################
##      swap_thru_lines_with_expanded_cases()     ##
####################################################
def swap_thru_lines_with_expanded_cases():
	mytrace('swap_thru_lines_with_expanded_cases()')
	print("swap thru lines with exanded cases() called...")
	global switchcasetester
	#print("=========testing case_numbers_to_strings===january 5th 2020====")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			#print(" ")
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			# this is where it gets number that is now a string
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			print(cat)
			cool = smart[1][:-1]  #chops off : from end last char
			holder = "'" + cool + "'"  #this puts the number in quotes
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#print(switchcasetester) #this is to see the switch case input string after the modification
	##=====
	#after the numbers have been converted into strings



### LISTS ####
list_with_thru_macros=[]
list_with_thru_macros.append(0) #position 0 nothing
backwards_thru_list =[]  #initializing the list






############################################
##        change_to_into_thru():
############################################
def change_to_into_thru():
	mytrace('change_to_into_thru()')
	#print("change to into thru() called...")
	global switchcasetester
	#print("=========looping thru looking for to===feb 5th 2020====")
	#print(switchcasetester)
	mycounter = 0
	for line in switchcasetester.splitlines():
		simple = mycounter-1
		
		if "case" and "to" in line:  #this means the macro to
			#print(line)
		
			banana=''
			banana=switchcasetester.replace(" to "," thru ")  #just addded spaces
			switchcasetester='' #this nukes it resets it
			switchcasetester = banana
			#print("the result of changing macro to to thru is this:")
			#print(switchcasetester)
		else:
			pass






############################################
##	bottom_up_change_of_thru_line_test():	
############################################
def bottom_up_change_of_thru_line_test1():
	#print("bottom up change of thru line test() called")
	mytrace('bottom_up_change_of_thru_line_test()')
	global mouse
	global opal
	opal = ''

	#go thru the entire string")
	#and change each case number  into a string for preparing for python handling
	## this uses backwards_thru_list
	mycounter = 0
	
	
	#for item in backwards_thru_list: 
	#set mycouter to a number for line in mouse.splitlines() : #this goes thru the mouse string
		#print(line)






###############################################
##   make_list_of_lines_using_thru_macro()
###############################################
def make_list_of_lines_using_thru_macro1():
	#print("we are in make_list_of_lines_using_thru_macro1")
	#print("make lis tof lines using thru macro() called")
	mytrace('make_list_of_lines_using_thru_macro()')
	# make list of lines using thru macros()
	#go thru list and if thru in line add that line to list
	global switchcasetester
	thru_counter = 0
	for line in switchcasetester.splitlines():
		#just added the word to that means the same thing as thru
		if  "case" and "thru" in line:  #on
			list_with_thru_macros.append(thru_counter)
			thru_counter += 1
		else:
			thru_counter += 1
			continue
	#THIS IS the list with thru macros line numbers====")
		
	#then I need to reverse the list
	backwards_thru_list = list_with_thru_macros
	backwards_thru_list = backwards_thru_list.reverse()  #list reversed right here
	bottom_up_change_of_thru_line_test1()






smart =''
beta =''
opal=''
import re
foolish =''
newline=''
#case_numbers_to_strings changes number cases to strings with the number inside
# I still need to sniff and detect if the cases are numbers before calling this 
##############################################################################
#this converts the numbers to strings such as case 1:  to case '1': ####






#######################################
##    case_numbers_to_strings()    ##
#######################################
def case_numbers_to_strings_1(str):
	#print("THIS one was called line 4194....")
	#print("case numbers to strings () called")
	mytrace('case_numbers_to_strings1()')
	global switchcasetester

	#and change each case number  into a string for preparing for python handling
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			#print(line)
			#print(" ")
			smart=line.split() #separates case from casename
			#checks if case name is a number returns True or False
			cat =is_number(smart[1])  #calling method to check if the case name is a number
			#print(cat)
			#print("HOW DOES IT LOOK HERE???-----====")
			cool = smart[1][:-1]  #chops off : from end
			holder = "'" + cool + "'"
			cool = "case " + holder + ":"  #this is essentially rewriting the line with number in quotes
			newline = cool
			#print("\t\t" + newline)  #adds tabs to front of it
			#print("next I will use replace to each case line")
			opal=switchcasetester.replace(line,"\t\t" +newline)
			switchcasetester=''
			switchcasetester = opal
			
			#HERE is where the changed case numbers as strings are put into switchcasetester
			#will use a replace here to the switchcasetester string
			mycounter += 1
		else:
			mycounter += 1
			continue
	#this is to see the switch case input string after the modification
	#after the numbers have been converted into strings



#above and before stage_one()

#===================================



			
			
	




###########################################################
# I can't assume that there is a to or thru macro in use
# this checks if at least one to or one thru in the entire switch case since it will
# be scanned entirely.
############################################################





## march 15th, 2021 Monday
##################################
valve=[]

##################################
## checks if first case is number
##################################
def check_if_first_case_is_number():
	# I think I can test if there is a number in the line that determines it
	#print("check_if_first_case_is_number called")
	mytrace('check_if_first_case_is_number()')
	# loop through switchcasetester
	# this only looks for the first case that it encounters
	counter =0
	numberflag = False # by default until otherwise determined 
	for line in switchcasetester.splitlines():
		if "case" in line:  #error this doesn't account for using thru or to
			grabchunk = line
		# I will need it to specifically look for if "case" in line and not "thru" or not "to"
		# another situation is if case and line and 'thru' in line or 'to' in line
		# however, no matter what I can just look if number in line meaning it's a number
		# and then just grab what is after the word case before : or thru or to
		# I think I can check if two numbers are in line
		#this apparently tests if 2 numbers in the line
			#print("== TESTING HOW MANY NUMBERS IN CASE LINE == if 1 or 2 numbers")
			if sum(map(str.isdigit, line)) == 2 and "thru" or "to" in line:
				#this checks if thru in line 
				####### RIGHT HERE THE FLAG NUMBERS IS FLIPPED TO TRUE AFTER THIS TEST
				#######  NUMBERS
				numbers = True  #this is used for knowing there is likley to and thru in use in case
				numberflag = True  #2 numbers in line 
				if  "thru" in line:
					print("'thru' detected and there are 2 numbers in the line")
				else:
					pass
				#this checks if to in line
				if  "to" in line:
					print("'to' detected and there are 2 numbers in the line")
				else:
					pass

			else:
				print("there are not 2 numbers in the line")
				#this checks if only one number in line and no thru or to in line
				if sum(map(str.isdigit, line)) == 1 and "thru" not in line and "to" not in line:
					#print("there is only one number in the case line")
					#print("here we have discovered there is indeed a NUMBER in case line")
					numbers = False  #meaning ONLY one number in case not two numbers 
					numberflag = True
				else:
					numberflag = False
					pass

			#this scenario is for just  case 2:
			#if  " thru " and " to " not in line:
			
			#print('== TESTING GRABCHUNK == to have it grab a number in case')
			#print("grabchunk",grabchunk)
			if grabchunk.startswith('\t\tcase'):
				grabchunk = grabchunk[7:-1]
				print("now grabchunk=",grabchunk)

			#test here if empty space at end of string
			if grabchunk.endswith(':'):
				grabchunk.replace(":","") #so rediculously stupid
				#grabchunk = grabchunk[:-1]
				print("now grabchunk=",grabchunk)
				grabchunk = grabchunk.rstrip() #to remove leading and trailer spaces
			#print("we now have (will it work) for grabchunk",grabchunk[:-1])
			#print("what happens after this is strange")


			#grabchunk = line[5:] #this cuts off 'case ' and ':' at end
			#print("first test of grabchunk=",grabchunk)
			
			#print("numberflag either True number or False not number",numberflag) #was super
			if numberflag == True:  #it was super == True
				#print("the first case True is a number",numberflag) #was super
				valve.append(numberflag) #was super
			else:
				#print("the first case False is NOT a number",numberflag) #was super
				valve.append(numberflag) #was super
			break
		else:
			#print("no case in line", counter)
			counter += 1
			continue
		# end if
	# end loop
	
###############====





disney_tron_trace_list=['starter']


##################################
##  show tron trace path        ##
##################################
def show_tron_trace_path():
	print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number





#######################
##     mytrace     ##
#######################
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


###====================================
# march 18th, 2021 testing 9:45 am

###############################
##  hasNumbers(string)
###############################
#def hasNumbers(inputString):
# 	return any(char.isdigit() for char in inputString)


disney_tron_trace_list=['starter']
######## show tron trace path
def show_tron_trace_path():
	#print("#######==== showing TRON TRACE path list =====#####")
	counter=0
	last =''
	disney_tron_trace_list.pop(0) #delete's starter position 0
	#reading thru looking for pairs
	for item in disney_tron_trace_list: #loops thru it
		print(item) #gives us the line number

#### mytrace
def mytrace(x): #just checks if first item is the same if slo don't load it
	disney_tron_trace_list.append(x)


#also do this for reset below

#this alters a string so the case doesn't matter, (think it's all lowercase)
#for laster # make it suitable for caseless comparison 
#str = str.casefold() 
numbers = False #by default and is flipped to True in 
digitalcandy=[]
######################### reset()  the module ##########
####### this makes it possible to call multiple switch cases that start out empty
######################################

# march 15th, 2021 at the beach =============================
# this has the names of vars I need to empty when flush
# the names of the vars are constant and I should hard code them in
list_of_vars=[]

# this holds the names of the lists I used in parser and codegen
# that will be flushed after generating a switch case
# the names of the lists will be hardcoded since they are unchanging
# and this listoflists is now actually emptied - it's a guide rail
list_of_lists=[]



# this resets the sw and switchcasetester variables
def reset():  #this now does nothing.
	#print("reset() called but does nothing now ....")
	global sw
	global switchcasetester
	sw='' #this empties it
	switchcasetester='' #this empties it
	return sw;

#zap var method
def zap_var(y):
	eval("y=''")  #this empties the var
	return y    




def change_list(zoo):
    #print("change_list() calleed")
    switch_config.init()
    switch_subfile.stuff(zoo)
    print(switch_config.mylist[0])
    


###############===================================




###////////////////////////////////////////////===========
###   American Standard  Flush all vars and lists clean
##///////////////////////////////////////////////////////////

#print("========= together =========")
#print(" did I just quote our principal? ")

#print("purely testing this now ")

#list_of_lists=["applepie","peachpie","lemonpie"]

applepie =["one","two","three"]
peachpie =["fun","silly","iceplant"]
lemonpie =["lemon tree","plum tree", "pear tree"]

##===========================
#this was for testing   
list_of_lists=[['applepie'],['peachpie'],['lemonpie']]



###==============
#new "thursday march 18th, 2021 today "
#this is the format that works for names of lists stored in a list
#this means that the vars also use a list of lists  of length 1 with string inside
list_of_vars = [['chilis'],['mystarbucks'],['jungle']]

#solution put the string in a list
chilis = ["one flew over the cuckoos nest"]
mystarbucks = ["is the drive thru open or not"]
jungle = ["better get walking"]

#target = list_of_lists[0]  this represents a list in a list position 0
#print_out_a_list(target) 

def print_out_a_list(target):
	nicejob= " ".join(str(x) for x in target)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	for item in eval(nicejob):
		print(item)
	
#target = list_of_lists[0] #get name of list in list by position
#empty_a_list(target)
#target = list_of_lists[1] #get name of list in list by position
#empty_a_list(target)
def empty_a_list(target):
	nicejob= " ".join(str(x) for x in target)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	sweet = eval(nicejob) #applepie
	del sweet[:] # will this work
	print(sweet) #should be []


def clear_out_list(i): # clear_out_list('fox')
	#print("clear_out_list() called")
	#print('startingit has apps jacks popcorn mtv')
	print(i)
	nicejob = i
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	sweet = eval(i) #fox
	print(sweet) #['apps','balls','craps']
	del sweet[:] # will this work
	print(sweet) #should be []

fox = ['apps','jacks','popcorn','mtv'] #so an outside free floating list not in a list




###### empty_this_list_now(x) list name
def empty_this_list_now(x): #param is listname
	print("x=",x)
	x=[]
	print("x=",x)

# this means view_all_list_contents()
################################
##  see_each_list_contents()
###############################
def see_each_list_contents():
	mytrace('see_each_list_contents()')
	#print("see_each_list_of_contents() testing this now")
	counter=0
	#print("====== list_of_lists ====")
	#print("=== testing so I have utter and complete control ====")
	#print(list_of_lists[0])
	cards = list_of_lists[0]
	#print("this is what we are starting with ")
	#print(cards)
	#print("what I am testing here is getting the name of a list")
	#print("so that I can manipulate it")
	L = list_of_lists[0]       
	nicejob= " ".join(str(x) for x in L)
	nicejob = nicejob.lstrip()
	nicejob = nicejob.rstrip()
	print(nicejob) #should be the name of the list applepie
	#print("testing looping thru the list of applepie useing eval")
	for item in eval(nicejob):
		print(item)
	#print("====end of looping ===")





#empty_lists_in_list_of_lists()




 # flush all vars and all lists which will be done after codegen completed
 # this flushes the lists to empty and vars set to ''
 #################################
 ##      american_standard()  couldn't not working
 #################################
def american_standard():
	#flush lists
	mytrace('american_standard()')
	print("american_standard() called")
	#empty lists used in parser and codegen
	#note the list_of_lists does not get emptied, these are necessary for the data structure
	for item in list_of_lists:
		weasel=item[counter]
		print("list name=",weasel)
		#this loops through the list item from list above
		for item in eval(weasel):
			print(item)
			empty_list(item) #calls method empty_list()
			print(item)
		print("------------")
		#empty_list(item) #this empties this list to []
	#flush vars 
    #empty vars used  in parser and codegen
    #the list_of_vars[] does not itself get cleared it is for the loops reference
	for item in list_of_vars:   #which have their names in a list for convenience
		vartime=item[counter]
		print("list name=",vartime)
		for item in eval(vartime):
			print(item)
			zap_var(item) #calls zap_var() erases contents of var
			print(item)
		 #this empties this var to ''




#print("testing view contents of lists")
see_each_list_contents()
#print("flush lists clean")
#american_standard()










###################################################################
## this determines if numbers are used in switch case
## such as case 3 thru 30:  and case 1: etc and case 35 to 50:
## however odd case if a person uses case "4": that is a string though a number
## oh just thought what if someone enters numbers as strings!!!?? 
## dam another filter to add.
## THIS DETERMINES IF CASES USE NUMBERS NOT WORDS
## IT LOOKS IN FIRST CASE LINE IF NUMBER(S) ARE USED LIKE case 5:
#######################  this is used by faucet_valve to detect numbers
##       finbar()    ##  tests first case in switch for numbers
#######################  and returns True if numbers are used else False
def finbar():
	mytrace('finbar()')
	toowild=''
	#print("FINBAR ====$$$$ ===== called to test if detecting a number in string")

	#print("FINBAR ====$$$$ ===== called ")
	#print("FINBAR ====$$$$ ===== called ")
	global switchcasetester
	counter =0
	#this should only go through the first case and then leave the loop
	#this grabs the first case line from the switch case looking for a number
	#this looks in the string switchcasetester string using a loop
	#and in first line with case to see if there is a number or are numbers
	numberflag = False # by default until otherwise determined 
	print("ABOUT TO LOOK IN SWITCH STRING FIRST CASE FOR WORD")
	for line in switchcasetester.splitlines():
		#this will be the first case it test
		#just added "'" not in line and '"' not in line:
		################################################################
		if "case" in line and "'" not in line and '"' not in line:  
			#print("so I can see what it sees I am printing the line")
			print(line)
			toowild = line
			#print("this has to be the first case line the FIRST LINE")
			#print(line)
			#print("###################################")
			break #get out of the dam loop 
		else:
			counter += 1
			continue
	#end loop
	#uses method hasNumbers to determine if a string has number in it.
	money= hasNumbers(toowild)  #returns True or False
	print("is there a number in the string",money)
	if money == True:
		print("yes number in the line")
	else:
		print("no number in line")
	return money 
	#######
	









#this will need to be called for each specific thru line
###==============================================================
###================  expand_thru_macro()  ===================
###==============================================================















	


valve=[]
#def is_number(inputString):
#	return any(char.isdigit() for char in inputString)

# this has mode 1 to do words by default but if numbers calls methods to
# convert the numbers into strings and expand the macros to and thru and 
# create lists of cases if macros used
# # ex case 1:    #if firstcase is a number its True


##########################################
#             faucet_valve()
##########################################
def faucet_valve():
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	#print("=====faucet VALVE=======")
	mytrace('faucet_valve()')
	icetea =finbar()  #method finbar() determines if case has a number like case 4:
	print("icetea =",icetea) #True if numbers
	#decided to just return True or False for now
	valve.append(icetea) #valve[0] = icetea
	firstcase = valve[0]  #True if number otherwise a string so False
	
	if firstcase == True: 
		#print("here means firstcase == True meaning a NUMBER:")
		convert_case_numbers_to_strings()
	else:
		pass
		#print('firstcase == False  meaning strings words')
		#meaning to the strings words as normal

	
	


#################################


#change_list("The Simpson's cartoon")
#print(switch_config.mylist)


#change_list("funny times")
#print(switch_config.mylist)

    ############################
    ### get_case_name()
    ############################
def get_case_name(y):  #y will be the line
    #print("get_case_name called")
    #y = y.split()
    y = y.replace(":","")
    y = y.replace("case","") #remove case
    y = y.replace("\t","")    # remove :
    #print(y)
    return y
    
    
    
    ############################
    ### get_location_of_case()
    ############################
    #debugging june 16th, 2021
def get_location_of_case(listname,word):
    print("called get_location_of_case(listname,word) line 5220")
    print("listname,word=",listname,word)
    #print("get location of case () called ")
    print("this is searching for ",word)  #below took out  + "'" + both sides of word
    ## june16th2021
    
    ##### the bug is here ValueError: None is not in list
    answer =eval("" + listname + ".index("  + word + ")")
    #print('====after running get_location_of_case we get this== should be a number==')
    print("location of case",word," in listname=",answer)
    return answer




def replace_in_list(x,y,z):  
	z[x]= y   #listname[5] = 'word'
	#this doesn't do print of the list afterwards




sneaky = ['british'] # I  can change the list it uses on-the-fly
#z = 'british' as global variable
###############################
##  do_replace(x,y)
###############################
def do_replace(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=british  #list name for breaks and fallthrus final
	replace_in_list(x,y,z) 
		
		
def smart_replace(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=penguin  #list name for breaks and fallthrus final
	replace_in_list(x,y,z) 
			
		
		
		
		
###################################
## do_replace_item_in_list
###################################

	# LISTNAME z   [x  NUMBER]=  y  WITH WORD using 3 inputs 
	###########################################
def do_replace_item_in_list(z,x,y): #listname[5] = 'word'
	replace_in_the_list(x,y,z)






#dec 31st
### for combo words like "alpine meadow" allow them in javascript interface
#of switch case and then concat them together with _ underscore
#for processing and then in output remove _ underscore


#from goldfish import ball #the string will that work
#dec 24, 2020 4pm pacific standard time progress putting code in module
#talking to goldfish right now which will be input file

#from triple_lindy import *
#imports the switch case

#defining varholder

strawberry_log=[]
#tbhis will be based on tron trace idea 

  ## WRITE STRING TO FILE
def write_string_to_file(xx):
	print("=====write string to file called ====")
	print("===PUT STRING INTO FILE =====")
	import os
	os.remove("sw_test.txt")  #this deletes the file
	f = open("sw_test.txt", "a")
	print("===about to add string switchcasetester to file===")
	f.write(xx)  #make sure it reads from goldfish
	f.close()

###############
##  check if default and check if beak in switch case#####
def add_break_to_default():  #and check if default too
    print("add break to default() current does nothing ")
    # look in stirng for break
    #if "break" in switchcasetester:
        #do nothing
    #actually also test here if default in switchcasetester stirng
      #and if not default then add default
    #else:
        #then add the break to default
        #brilliant;
        #first test if default case
        #if no default add default and break







   #READ STRING FROM FILE
def read_string_from_file():
	#print("====== read string from file called ======")
	#print("=== READ_FILE_PUT_INTO_STRING====")
	f = open("sw_test.txt", "r")
	boomerang = f.read()
	#print("=====output of string here=======")
	#print(boomerang)
	return boomerang


case_main_body_list=[]
def resetting_up_case_body():
	case_main_body_list=[]
	case_main_body_list.append('starter') 
	z =''
	
	
####################################################################
##  get_length_of_string()  the length of the switch case string
## this 
####################################################################
## get length of string()
mrdefault = 0
#this gets the line number of default (there must be a default)
#this also gets the length of the switchasetester string
def get_length_of_string():  #this only works if there is a default
	mytrace('get_length_of_string()')
	#print("######## get_length_of_string() called")
	#print("get length of string() called ====== ")
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
		#this is where the default is located on this line number
			mrdefault = counter;  #right here it assigns the counter number to mrdfault var
			#print("mrdefault=",counter) #this won't work without default word
		else:
			pass
		counter += 1
		
	#count backwards thru loop to get first break
		
	#print("length of the string =",counter)
	the_counter=mrdefault
	#print("we are starting to count from ",the_counter)
	solution ="false"
	for line in switchcasetester.splitlines():
		if "break" in line:
			#print('yes break after default')
			solution="true"
			break
	
		else:
			the_counter += 1
	
	
	#if solution == "true":
	#	print("break after default")
	#else:
	#	print("add the break at end")
	

	#the_last_line = counter
	#the length of the string of switchcasetester is returned here 
	return counter;  #it returns the length of the string in counter.


thebreak = False  #by default setting


############################################
##  wise_owl()  adds break to default case
############################################
def wise_owl(t):
	#mytrace('wise_owl()')
	#print("##### wise_owl() called with",t)
	#print("WISE OWL CALLED with ",t)
	#print("wise owl() called to add break to default case if it is missing ====== door number 3")
	#print("wise_owl input t =",t)
	if t == True:
		pass #print('already a break in default case')
	else:
		#print("it's obviously FALSE so add break to switchcasetesterstring")
		#print('no break detected so adding break at bottom of default')
		global switchcasetester
		#print("switchcasetester=",switchcasetester)
		################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		strawberry=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = strawberry
		#print("=====after adding break to bottom of default we have====== ")
		#print(switchcasetester)
	#print("t=",t,"already break beneath default") #this outputs the input paramter to see what wise_owl saw
		
#######


#we know from above the range of lines that the default is 
#we also know the last line number
#we start counting from the position of the default word
#################################################
##  testing_if_break_in_default_tail()
#################################################
### if there is default fine, but it requires a break (to be parsed)
## the reason is that at Yale is says that in C a break in default is optional
## but they also say at Yale that a default is REQUIRED
## so this tests that in default(is there a break and if not simply add a break

def testing_if_break_in_default_tail(): #assumes that there is a default!!!!!
	mytrace('testing_if_break_in_default_tail()')
	#print("######## testing_if_break_in_default_tail() called############")
	#print("testing if break in default tail() called=====DOOR NUMBER 2 ===")
	global mrdefault #I was missing this
	#print("mrdefault =",mrdefault)
	#get_last_break_in_string()
	#look at this carefully it starts the smartcounter with the line of default 
	smartcounter = int(mrdefault) #the starting point   #the default line number retrieved before this
	#print("for smartcounter starting we have ",smartcounter)
	thebreak = False #default setting boolean
	global switchcasetester
	for line in switchcasetester.splitlines():
		if "break" in line:
			thebreak = True
			break  #out of loop
		else:
			pass
			smartcounter += 1
	#print("thebreak=",thebreak) #this returns True in thebreak if there is a break in default
	#print("new roller coaster testing if break missing after default and ")
	#print("now add the break at bottom of default ")
	if thebreak == False:
		#print("add break to bottom of default case now right here")
		#global switchcasetester
		#print("switchcasetester=",switchcasetester)
		################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		#######################################################################
		staypuff=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = staypuff
		#print("=====after adding break to bottom of default we have====== ")
		#print(switchcasetester)
	
	#wise_owl(thebreak) #would be wise_owl(True) #adds break to default case if it is missing break
	#return thebreak  #would return True  or   False
    

#switchcasetester=''

#saw this on the web, doubt it works
def doesitwork():
    print(getattr(goldfish, seagull))



def felix(): #felix the cat for testing
	print("====felix called testing writing string to file =======")
	newyears=read_string_from_file()
	print('     ')

	print(newyears)
	print('     ')







'''
The difference is one is just in a wordname
and the other format is typed out
maybe I need to make it the triple string
previou idea was
'''









#def victory():
#	print("read the dam file")
#	#open and read the file after the appending:
#	f = open("sw_test.txt", "r")
#	print(f.read())

# I should have case names in a list
# merely check if word "not in" list then default
# I can go through the switch case input and build a list of each case name
# dec 27th thinking to detect if no matches using not in list so that
# I can return the entered value confidently
# I found them they are in the caselist taht is generated, where I can grab them
# and merely dump them into one big list using append
switch_return_value=['starter']

varholder=[]
varholder.append("zilch") #if nothing changes it's default

var2=[]
var2.append("zilch")


def is_number(inputString):
	return any(char.isdigit() for char in inputString)

valve=[]
valve.append("nada")
angel =''
input = ''

#it would already be tested if a number in the first case already 

#this is the clever() that is actually being called line 4847
# this calls faucet_valve to determine if cases are numbers or words
#apparently this needs to exist in this file
# I need to number them because I have several functions called clever()
def clever(i): #so it already exists we are changing its value
	print("clever() line 4851")
	#sw_reset()
	print("this is the clever() that is being called line 4850")

	 #this reloads the module
	varholder[0]='' #this should reset it to nothing
	reset()  #reset() is hidden inside of clever for input to the switch
	mytrace('clever()')
	print("clever() called in switch_mgrcat")
	#faucet_valve()
	#print("valve[0]",valve[0])
	print("if true then number in first case in switch so using numbers")
	print("if false then string word in first case in switch using words or char")
	print("clever called for input to switch case exp")
	varholder[0]= i
	#===this works and it fills a list with input from an argument
	#print('varholder[0]=',varholder[0])
	#print(varholder[0]) #to actually see proof
	return varholder[0]
	angel = varholder[0]
	## ===check if input is a number or a word with letters
	#====x = angel.isdigit() commented out march 17, 2021
	#print('about to call FINBAR() to look in first case line')





#apparently this needs to exist in this file
def moreclever(i): #so it already exists we are changing its value
	print("moreclever input called")
	varholder[0] ='' #clears it out
	print("clever called for input to switch case exp")
	varholder[0]= i
	#this works and it fills a list with input from an argument
	#print('varholder[0]=',varholder[0])
	#print(varholder[0]) #to actually see proof









#testing accessing switchcase from file goldfish
def mountain2(c):
	mytrace('mountain2()')
	print("===mountain 2called===playing with switch case ")
	var2[0]= c
	global weasel
	weasel = var2[0]
	print(weasel) #so by default it prints the input string
	
	################## print input switch case string ##########################
	################## if show_input_string[0] = True for show_input_switch_string ############
	#if show_input_string[0] == None: #this is new
	#    show_input_string[0]= False
	#end if
	#so bug is this is set to True when I set it to False june 4th, 2021  
	
	##### just commented this out for the time being #########################
	#if show_input_string[0] == True:
	#   #pass
	#   print(weasel) #it was printing the switchcasetester right here
	#else:
	#   pass #otherwise it wont print the input string
	    
	global switchcasetester
	switchcasetester =''
	switchcasetester = weasel







jazz=''
#thinking of putting the switch case in here
def galaxy(moon):
	print(moon)
	jazz = moon
	c = len(jazz)
	print(c)
	#I need to generate a long string

	#switchcasetester=moon
	#return switchcasetester



##########################
##  romanwall()(
##########################
def romanwall(j):
	mytrace('romanwall')
	#print("=======romanwall called=====")
	#I might have to concat it and make it into
	#virgin reutrn switchcasetester = '''
	#it might have to be generated and then eval(string) or exec(string)
	supertramp= j
	switchcasetester= j  #seeing what happens
	print(supertramp)
	#see if it can read what is in the string
	#just testing what I can do here with the string
	answer =supertramp.count("case")
	#print("the number of cases in this string =",answer)
	#print(switchcasetester)




def adjust_input(x):
	print("adjust input called with", x, "inside of yosemite")
	newstring =varholder.append(' + x + ')

	
	
	
	 #should print 4

# Remember that the output code gen is invisible and won't be seen by
# he programmer
case = ''
valve_setting=''
# =======  switch  =================================
def switch(x):
#####################  filter to determine if input is number or word/letter/alpha
	print("we are inside of switch now",x)
	global input
	
	global case
	#strings
	#print("switch method called",x)
	#if string
	if type(x) == str:
		x = str(x)
		case = x.lower()
		print("case =",case)
	
	



# =======   fallthru       =========================
# the magic is here fallthru actually calls switch
def fallthru(y):
    eval("switch('" + y + "')")


#varholder=[]
#varholder.append("walmart")  #position 0  varholder[0]
#varholder.append("0")      #position 1
# =======   testfunction    ========================
exp=''



def first_test():
	print(" ==  testing def first_test with switch case translate test====")
	#varholder=[]
	varholder[0] ="candy" #input value test

#### this is used to do a trace log of functions called #################
### this is called at the bottom show_tron_trace_path()
### and at the beginning of each function/method  mytrace(x) name inserted of the function




print("======")
print("practicing with list funnybusiness here for practice and fun")
print("======")
funnybusiness=['starter','wildone','wildtwo']
reset_list_to_just_starter(funnybusiness)
print(funnybusiness)

coyote_list=[]  #initialize it
#trontime= ['empty', 'switch', 'case', 'case', 'code;', 'code;', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'break', 'empty', 'case', 'case', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'case', 'case', 'code;', 'code;', 'code;', 'code;', 'code;', 'empty', 'fallthru', 'empty', 'default', 'code;', 'code;', 'break', 'code;']


# I can simply fill it manually with a loop and append
#print(trontime)

birdsong=['starter'] #assigned
music=[0]
colorful=[0]
#down here it was unassigned
#empty_this_list_now(birdsong) #clearing it before entering the function this time
#######################################
def make_list_of_first_cases():
#######################################
	#print("initially list length of birdsong is",len(birdsong))
	if len(birdsong) > 1:
		for item in birdsong:
			if len(birdsong) > 1: 
				birdsong.pop()
		#end loop
		if len(birdsong) == 2:
			birdsong.pop()

		if len(birdsong) == 1:
			print('length of this list is 1 is correct')
		else:
			print("this list is wrong should be length 1", len(birdsong))
	else:
		if len(birdsong) == 1:
			print('the length of',birdsong, 'is 1')
		else:
			print("this one slipped though and has a length greater than 1 ",birdsong)


####################
	mytrace('make_list_of_first_cases')
	#print("========== called make list of first cases() ===========")
	mycounter = 0
	for line in switchcasetester.splitlines():
		beta = mycounter-1
		if "case" in line:
			smart=line.split()        # separates case from casename
			birdsong.append(smart[1]) # this adds casenameto list birdson
			music.append(mycounter)   # list of number for case line
			mycounter += 1
		else:
			mycounter +=1
		#print("after the if this is the content of birdsong",birdsong)
	#print("I think that the list of line numbers of cases is called music",music)
	#print("list of first case names",birdsong)


	if len(music) % 2 !=0:
		music.append("0")  #this is a balancer if it's an odd number adds one more to it


#what I can do is have a simple true or false switch
#and leave the function calls where they are and if triggered true
#then they will be called otherwise they won't be called.


#start_trigger()

######################################
default_location=''
def get_default_location(): #line number location of the word default
	#print("=============get default location called =================")
	mytrace('get_default_location')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
			break
		else:
			counter += 1
			continue
	#print("the default location line number =",default_location)
	return default_location
	
	
##############################################
##	add_break_to_bottom_of_default():
##################################################
lovely=''
def add_break_to_bottom_of_default():
	mytrace('add_break_to_bottom_of_default()')
	global switchcasetester
	#print("=========just called ADD_BREAK_TO_BOTTOM_OF_DEFAULT()=========")
	lovely = switchcasetester #the whole switch case string
	x = lovely.count('break')
	#print("there are ",x ,"breaks in the switch case")
	#test if break after default line
	#print('start phase 1 ....')
	
	counter =get_default_location() #the line number
	#print("counter starting value of default is",counter)
	findbreak = False #by default unknown at this point if a break after default
	#print("findbreak=",findbreak)
	#print('start phase 2 ....')
	
	for line in switchcasetester.splitlines():
		#print('counter=',counter)
		if "break" in line:
			break_location = counter
			findbreak = True
			#print('findbreak =',findbreak)
			break
		else:
			counter += 1
			continue
	#print('start phase 3 ....')		
	#print("the value of findbreak =",findbreak)
	#print("this is after the loop has gone through looking for break after default line")		
	if findbreak == True:
		pass
		#print("findbreak = True so do nothing break exists after default")
		#print("do nothing break exists after default")
		#print("it will be interesting if this is true, but I can test it")
		#print("the number of breaks found in the switchcasetester was",x)
		#print("let's look in switchasetester and see for ourselves.")
		#print(switchcasetester)
	else:
		#print("if at this point then break after default is False")
		#print("break is false and need to add it")
		#print("switchcasetester starting =")
		#print(switchcasetester)#have to add break with tabs before it
		peach=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = peach
		#print("after adding beak beneath default we have ")
		#print(switchcasetester)
		#print("end of BIG TEST for break in default addition")	
	#return break_location   (maybe we don't need this)
	
    
		








#########=============== get last break in string ==================
listofbreaks=[]
genius=''
nobreaks = "false"
def get_last_break_in_string(): #but what if no break??? march 1st bad assumption here
	#print("======BLINK182========get last break in string in the whole switch case string ============")
	mytrace('get_last_break_in_string()')
	counter=0
	global switchcasetester
	#test this right here and now
	#print("### @@@@@ simple test looking for any break in switch case string switchcasetester")
	#if "break" in switchcasetester:
	#	print("yes there is a break")
	#	
	#lse: #this means there are no breaks in the switchcase string
	#	listofbreaks.append("0")  ## this is new 
	#	print("no break in switch case")
	
	#print("starting loop looking for breaks in switch case")
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			nobreaks = "false"	
			counter +=1
		else:
			counter += 1
			continue
		###=============
	#print(switchcasetester)
	#print("testing length of listofbreaks list")
	#print("if no breaks in switch case then add a break after default now")
	if len(listofbreaks) == 0:
		#print("list of breaks is empty")
		#print("therefore there is no break in entire string ")
		#print("this means no break in default")
		#print("adding break at bottom of default case now")
		#global switchcasetester
		#this immediatley adds break after default
		courage=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = courage
		#print("we now have ((look for the new break in default")
		#print(switchcasetester)
		#################### looks for location of break in default
		newcounter =0
		#print("starting loop looking for breaks in switch case")
		for line in switchcasetester.splitlines():
			if "break" in line:
				listofbreaks.append(counter)
				nobreaks = "false"	
				newcounter +=1
			else:
				newcounter += 1
				continue
			
	else:
		#print("the list of breaks has",len(listofbreaks), " elements")
	#idea if no breaks add one
		genius = listofbreaks[-1]  #last break number
	#print("genius is the last break line number =",genius)
	
	if counter == 0: #means no breaks in string of switchcasetester
		#print("there aren't any breaks in the switch case")
		nobreaks = "true"
		#print("nobreaks = true")
	else: #counter greater than 0
		nobreaks = "false"
		#print("nobreaks = false")
		pass

	#print("lets see the list of breaks full list",listofbreaks)
	#print("the length of hits of lines with break so the length is ",len(listofbreaks))
	#print("the number of breaks = ",counter," if none then nobreaks = ",nobreaks)
	if len(listofbreaks) >= 1:
		baby = listofbreaks[-1] #the last one
		print("the last break line number is ", baby)
	else:
		print("the number of breaks in the string is None",0)
		
	return baby #which is a string
	
	
	
	
#############################


#I need to add a break if there isn't one saturday, December 5th
#it expects a break at bottom of default.
#and I just realized it requires a default but doesn't look for one
newton=''
orange=''
#this scans through input switch and changes default to case default
#switchcasetester=''
last_break=''
#this assumes that there is a default. I will just make it mandatory to have a default
################################################################################
### this does convert_default_case AND add break after default if it needs one
################################################################################
last_line_of_string=0 #initializes it 
#####################################
## this assumes that there is a default which should exist.
## I will deal with a missing default and insert one later


# so before convertind default to case default I need to count breaks from default down
# and if there isn't one in default add a break

#idea first pass makes switch with place holder innerswitch functionname with input
#but on second pass I make the second internal switch BRILLIANt

##################################
###  convert  default  case '':
mrlastbreak=''
lastbreak=''
###################################
def convert_default_case(): #I got this working November 26th, 2020
######################################
	#print("convert_default_case()  ===&&&&&-- CALLED Motel 6 test night")
	#add_break_to_bottom_of_default()  ##march 3rd, 2021
	mytrace('convert_default_case')
	#print("===========convert default case called ===========")
	############################################################
	get_default= get_default_location()
	
	#print("the last break would be ",listofbreaks[-1])
	if len(listofbreaks) == 0:  #maybe it will be None
		pass  #print("no breaks in the whole switch case string")
	else:
		pass
	
	last_break=get_last_break_in_string() #what if it returns None???
	#this is new march 1st 2021 starbucks coding in earlying
	last_line_of_string = get_length_of_string()
	#print("the last line of string =",last_line_of_string)
	
	if int(last_break) < int(get_default):
		#print("there is definitely no break in default case")
		#print("and a break needs to be added immediately")
		######################################################
		#print("adding break at bottom of default case now")
		global switchcasetester
		tang=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester=''
		switchcasetester = tang
		#print("we now have ((look for the new break in default")
		#print(switchcasetester)
	else:
		pass #print("there is a break inside of default")
	
	#print("====================")
	#last_line =get_closing_curly_brace() #its just the length of the string switchcasetester
	################# just commented out line above march 1st, 2021
	
	############################################################
	
	# IF default(LINE NUMBER) < last break(LINE NUMBER)  There is a break
	#########################################################################
	#oh my god this assumes that there is a break
	#so no matter what I should put a break after default
	# this says if default is after break meaning no break after it
	#this is dependent on the last break existing or any break for that matter; it assumes a break
	#however, if there is no break in the string I am hosed and need to realize that.
	#I can't assume that there will be a break above the default or after the default either.
	#print("this if test for get_default < last_break fails if no break in string")
	#print("it's based on the bad assumption that there is a break in the switch case")
	#print("so I need to modify it to check if there is a break in the whole string")
	#print("and if count('break') == 0 then the answer is None")
	#if line number of default is LOWER then last break line number
	
	#then there is a break AFTER the default
	
	if int(get_default) < int(last_break):  #### if default  < last break  
	#this means that last break in string is above the default. b
	#########################################################################
		
		#print("there is a break after default")
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		
		###==== tuesday coding project =====##
		## test right here if a break or not
		#need to test if break is after default or not
		# and add a break here if no break so the switch case gets read.
		
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		##I need to add the break to default here if it doesn't exist. 
		# I need to look if a break is between default and last line of switchcase
		# march 1st, 2021 I need to add a break to default if no dfeault
		#look between default word and {
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
		
		#the else  is triggered if int(a)> int(b) meaning break number LESS THAN default line num
	else:
		#down below here it adds break after default and makes case deafult
		#print(switchcasetester)
		
		########################################################################
		#### THIS IS WHERE WE ADD A  BREAK AFTER DEFAULT IF ITS MISSING  ####### 
		## I can do a count for break  starting from the default line number
		## and discover if there is a break in default the only safe place I can put it .
		#this is now unecessary since it's alrady done.
		#######################################################################
		
		
		#orange=switchcasetester.replace("}","			break \
		#	\n}")
		#switchcasetester=''
		#switchcasetester = orange
		
		
		#print(switchcasetester)
		#################################################################
		####  DEFAULT IS CHANGED TO CASE 'DEFAULT':            ########### 
		#################################################################
		#change default to case 'default':
		newton=switchcasetester.replace("default:","case 'default':")
		switchcasetester=''
		switchcasetester = newton
		#print("")
		#print(switchcasetester)
		
		make_list_of_first_cases()
		#print(switchcasetester)
		return switchcasetester
	
	






def say(x):
    print(x)

def testing_number_of_lines_in_string():
	mytrace('testing_number_of_lines_in_string')
	count =0
	for line in switchcasetester.splitlines():
		count +=1
		#print(count)
	#print("there were ",count, "lines in string")
	return count



def testingatheory():
    mytrace('testingtheory()')

    #apple = "one"
    
    
    
    
###=================== nov 19th new code ============
###================ get_closing_brace (line number) ==============
closing_brace=''
def get_closing_brace():
	#print("get_closing_brace called")
	mytrace('get_closing_brace')
	counter =0
	closing_brace =testing_number_of_lines_in_string()
	return closing_brace




###=============================================
default_location=''
def get_default_location():
	mytrace('get_default_location')
	counter =0
	for line in switchcasetester.splitlines():
		if "default" in line:
			default_location = counter
		else:
			counter += 1
			continue
	return default_location



list1 =[]
list1.append("four")


#varholder[0] ="four"







#print("this is actual generated code I am trying to run now....")
#print("this is betterworknow in python generated previously")



list1=[]
exp =''; case =''
exp = ""

#exec(betterworknow)
#print("=== executin betterwork now test bit")




####======== starts here ===============
##################################
##          start_trigger()
##################################
#this is the function triggered to start the parser and codegen


# this is to circumvent a bug if no break in switchasetester it crashes
# this is to circumbent a bug if the user doesn't include a default case
# which is necessary since it has a break mandatory even if all above
# cases have no break which they can
# this way I'm not adding a break to a case that wasn't intended to ahve one

    #global switchcasetester
    #if "default" not in switchcasetester
    ## add dfeeault case with break
  
    #if "break" not in switchcaseter
        #add break to default which is the only one required to have break
        #since it's the last case 
    
      
###  right here I need to add
###  verifiy default and a break in switchcase strubg  to begin with
######################################
##    starter_trigger()  
######################################
	#global switchcasetester  #just added this to hopefully fix bug
def start_trigger():
	trigger = True  #default setting
	#print("trigger =", trigger)
	#if trigger == True:
	#	print("trigger =", True)
	#else:
	#	print('trigger=',False)
	mytrace('start_trigger')
	convert_default_case() #this changes default: to case 'default': but default needs to exist!
	output = testing_if_break_in_default_tail()
	wise_owl(output) #this should feed in the parameter of if break between default and last line of string
	#print("this will go first")
	### convert default case and then test if break in default and add break if necessary
	#this is done because in C and javascript it's just:   default: so it needs to be converted to a case
	#I will have it add break inside of convert_default_case()
	#convert default case called here 







## from web stackoverflow
def islist(obj):
    if ("list" in str(type(obj)) ): 
        return True
    else : 
        return False
################################
        
#line numbers with line_numbers_of_first_cases
#################################
foo =[]
def bar():  #call this when clever(input) called
    print("bar() called") # to clear out list to make sure it's empty 
    global foo
    #print('in here now')
    foo =[1]
    print(foo)

#bar()

def goldmedal():
    global foo
    #print(foo)
    foo.append("xmas time")
    #print(foo)
    
#goldmedal()

def silvermedal():
    global foo
    foo.pop(0)
    #print(foo)
    foo.append("nighttime")
    #print(foo)
    
    
#silvermedal()

def coolness():
    global foo
    foo=[]
    #print(len(foo))
    
#coolness()

def solid():
    global foo
    foo.append("water")
    foo.append("tennis")
    foo.append("gold")
    print(foo)
    print(len(foo))
    
#solid()    

def badass():
    return  #don't need this now
    print("badass callsed")
    global foo
    foo=[]
    print(foo)
    foo.append("starter")
    foo.append("charlie brown")
    foo.append("wilson")
    foo.append("frisbee")
    foo.append("target")
    foo.append("snoopy")
    foo.append("red barron")
    foo.append("coffee")
    foo.append("starbucks")
    #print(foo)
    print("==============")
    


def clearit():
    print("clearit()")
    global foo
    foo =["starter"]
    if type(foo) is list:
        print('a list')
    else:
        print("not a list")
    #print(foo)

#badass()

def showit():
    global foo
    print(foo)
####################
##    STAGE ONE
####################
def stage_one():  #this calls start_trigger()
    mytrace('stage_one')
    #print('stage one')
    #emptying the lists in question here that might be the problem
    #print("in stage_one() resetting lists palmtrees, carnberries, royalllist, british")
    #print("penguin, roadrunner, starbuckslist")
    palmtrees=[]
    cranberries=[]
    royallist=[]
    british=[]
    penguin=[]
    roadrunner=[]
    starbuckslist=[]
    digitalcandy=[]
    start_trigger()



# thursday january 21st testing early in morning
# .bug I see is line number of first case lists is wrong
#rule_the_earth()
# File "/Users/blakesouthwood/Desktop/python code /gold Switch case code/backups GOOD working gold master switch case/
#firefall_yosemite_falls.py", line 1322, in rule_the_earth
#   second_word = line.split()[1]
# also digitalcandy has the duplciate first 2,10 issue bug

#=====line numbers of first cases list====
#[2, 10, 16, 23, 29, 35, 41, 47, 52, 52, 2, 10, 16, 25, 26, 32, 38, 42]    

'''
##  so per MIT I need to use assertion checks
#  if (condition == true) 
    do this
    else
    assertion error put messsage and then
    call return
''' 

   





caselist     =[]
breaklist    =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]
getfirstword =[]
casephrase =[]
alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]
casesections =[]
casesectioncounter =[]
breakposition =[]
trontime =[]
tronlinenumbers =[]
fallthrulist = []
smartlist =[]
smartlistlocations=[]
fallthrulocations=[]
#theinputlist =[]
digitalcandy=[]
line_numbers_of_first_cases=[]

global woodstock #is this what it wanted to solve the bug
#global candy
#####this is where i'm testing now
line_numbers_first_cases =[]        

woodstock =[]  #testing this out   
candy =[]  #for digital candy    ###3 oh my god I had candy a global and candy a list  [] jeeze. 
#==================================     
def simple_test():  #call this when clever(input) called
    # print("================")
    # print("simple test of filling global list") # to clear out list to make sure it's empty 
    global line_numbers_first_cases
    # print('in here now')
    #print(line_numbers_first_cases)
    line_numbers_first_cases =['snoopy','linus','lucy','woodstock']
   # print(line_numbers_first_cases)
    #print("=============")

simple_test()   


def add_to_test_list():
    #print("==================")
    #print("add to test list attempt")
    global line_numbers_first_cases
   # print("in here now")
   # print(line_numbers_first_cases)
   # print("now adding three more words to it")
    line_numbers_first_cases.append("rediculous")
    line_numbers_first_cases.append("silly")
    line_numbers_first_cases.append("tired")
    #print(line_numbers_first_cases)
    #print("====================")
            
def empty_test():  #call this when clever(input) called
   # print("===============")
   # print("empty list") # to clear out list to make sure it's empty 
    global line_numbers_first_cases
   # print('in here now')
    line_numbers_first_cases =['starter']
    #print(line_numbers_first_cases)        
    #print("==================")
        
        
        
linenumber=[]        
dunkindonuts=['starter']
list_with_code=[]
jazz=['starter']
##################################################
def magictimenow():   ### this builds the list for line_numbers_of_first_cases using strings
##################################################
	mytrace('magictimenow')
	#breakpoint()
	#print("THIS IS MAGICTIMENOW TESTING WHERE THE BUG IS APPARENTLY")
	#print("down to 11% charge better hurry")
	#this should make it real
	global woodstock
	#print("========== what is in trontime? =======")
	#print("what the fuck is in trontime",trontime)
	#print("length of trontime=", len(trontime))
	
	if len(trontime) > 0:
		del trontime[:] #this empties the list trontime
	
	#print("trontime length is now",len(trontime))
	#print("now trontime should be empty by default - to cover all of the bases")
	#print("trontime=",trontime)
	
	
	#print("woodstock contains=",woodstock)
	#global candy
	#print("candy contains=",candy)
	#print("switchcasetester=",switchcasetester)
	mytrace('magictimenow()')
	#This makes a list of true if case in line and false if no case in this line
	#print("first fillup a list with true and false")
	#print("true if case in this line and false if not")
	#print("=== simple test if case in a line if so then True")
	#print("let us see what is in switchcasetester")
	#print(switchcasetester)
	#print("=== and if no case in this line then put False")
	#print("these true and false go into list called ifcaseinline")
	ifcaseinline=['starter']   #theresult
	#this loop puts true into ifcaseinline if case in this line otherwise it puts false
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if "case" in line:
			#print(line)
			ifcaseinline.append("true") #adds "true" to list ifcaseinline
			continue
		else: #no case in this line
			ifcaseinline.append("false") #adds 'false' to list ifcaseinline
			continue

	#print("this should show list of each line and if case in this line")
	#print("ifcaseinline",ifcaseinline)

	#now just find pattern this line true and line above it false
	firsttestforfirstcase=['starter']
	coolcounter=0
	#print("about to test loop looking for first case")
	for item in ifcaseinline:
		if item == "true" and ifcaseinline[coolcounter-1] == "false":

			#print("the line number of teh first case is",coolcounter)
			firsttestforfirstcase.append(coolcounter)
			coolcounter +=1
			continue
		else:
			coolcounter +=1
			continue
	#print("finished",firsttestforfirstcase)#this is list of trues and falses
	#pertaining to if the word 'case' is in this line number of code

	counternew=0
	for item in ifcaseinline:
		#print(item,counternew)
		counternew += 1
	#print("=============================")
	#return #this kills the function and it stops


	counter = 1  #starting counting with 1
	a_string = switchcasetester
	first_word = a_string.split()[0]
	#print('big assed test here to get a first word in a string')
	#print(first_word)
	#get line numbers and see if sequential cases on neighboring lines
	word = 0
	mycounter=0  #switchcasetester
 	#this is where trontime list is filled with 'true' if line number has 'case' in it
 	#and 'false' is put if this line doesn't have the word 'case' in it

	#print("this is the beginning of the regular for loop through the string")
	num = 1  #for organizing case numbers in order of appearance
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		genius = line.split() #new  [0] was at end of it  ((this does the line split for each line))
		mycounter += 1
		#these are two different conditions see if it finds them
		######### these are new to filter it more strictly July 23, 2020
		

		if "case" in line:
			#getfirstword.append("case")
			trontime.append("case")
			#print('case found')
			continue

		if "switch" in line:  #force feed it
			getfirstword.append("switch")
			trontime.append("switch")
			#print("switch found")
			continue

		if "fallthru" in line or "fallthrough" in line:  #force feed it
			getfirstword.append("fallthru")
			trontime.append("fallthru")
			#print("linenumber of fallthru =",mycounter)
			smartlistlocations.append(mycounter)
			fallthrulocations.append(mycounter)
			continue

		if "break" in line:  #force feed it
			#getfirstword.append("break")
			trontime.append("break")
			breakposition.append(mycounter)
			continue
			##################


		if "default" in line:  #force feed it
			getfirstword.append("default")
			trontime.append("default")
			continue

		if len(line.strip()) == 0: 
			getfirstword.append("empty")
			trontime.append("empty")
			continue
        #I remember this line clearly I wrote it at cafe borrone in Menlo park
        #and I finally was able to get the detection of cases in the correct lines in the list
		if "case" and "break" and "default" and "switch" not in line and len(line.strip()) > 0 :

			getfirstword.append("code;")
			trontime.append("code;")
			continue

	#print("==========  CAFE BORRONE  ============")


	#print('this is looking in trontime')
	thecounter=0
	for item in trontime:
		#print(item,thecounter)  #commented out long list
		thecounter += 1

	#print("now this is new virgin code to detect a case that is the first case")
	#print("and this is done by also checking if the line above tested False for having a case")
	firstcaselist=[]
	#print("========here we do some more HALLOWEEN testing============")
	#print("-----this is getting the first case in each section to use in fallthrus-----")
	#this is designed to detect the first case in a case section by detecting a case
	#that does not have a case above it making it by definition the first case
	#now this means no blank spaces between lists of cases for this detection to work.


############## this is where line_numbers_of_first_cases is constructed ##################
##############  I should make this a separate function ###################################
	
	################### may 13th, 2021 coding #########################
	#this is where the line_numbers_of_first_cases list is filled with the line number of first cases
	 #nuked 'starter' from it
	
	#breakpoint()
	#print('what it sees in the input switch case line 6675')
	#print(switchcasetester) 
	#print("this is a simple pretest of cases")
	jumbocounter=0
	for line in switchcasetester.splitlines():
		#how we designate it being the first if no case above it on previous line.
		if "case" in line:
			#print("case found in this line")
			#print(line)
			
			jumbocounter += 1
			dunkindonuts.append(jumbocounter)
			#print("line number =",jumbocounter)
			continue
		else:
			jumbocounter += 1
			continue
	#end loop
	#print("dunkindonuts=",dunkindonuts)
	
#####################################################################

	#end loop
	#print("after finding default it should be below this line ..")
	#print("after sensing if default in switch case are",dunkindonuts)
	#print("so I can see what the computer sees and analyzes where the cases are and if default there")
	
	################### may 13th, 2021 coding #########################
	
		

	#print("now in JAZZ LIST list we have hopefully just the first cases")
	#print("and here is the list",jazz)
	#don't recall if I need to add default as a case think so
	
	#what this does is look in the current line for the word "case"
	#and looks in the trontime list for the line above the current line to make
	#sure that "case" is not in the previous line determined by the word 'false'
	#print("the counter in trontime might be wrong or missing or something")
	#print("trontime=",trontime)
	#print("WAIT WHERE'S MY PHONE??? What is in trontime",trontime)
	###### this printed trontime #########
	#for item in trontime:
	#	print(item)
		
	acounter=0
	#THE BUG IS EITHER HERE SOMEHOW OR IN TRONTIME
	#the trontime list only has trues and falses so true if case in line otherwise false
	for line in switchcasetester.splitlines():
		#this checks if case in this line but no case in line before it
		#the tricky part of this solution is that it is looking above the current line
		#trontime list holds true and false depending on if 'case' in that line number
		if "case" in line and "case" not in trontime[acounter-1]:  #tests if no case above this line with case
			#print('the line number is',acounter)
			line_numbers_of_first_cases.append(acounter)
			#global woodstock
			woodstock.append(acounter)
			#global tintoy
			#tintoy = genius
			genius = line.split()
			#print(genius[1])
			strng= genius[1]
			angel= strng[:-1]
			#print(angel)
			angel = angel.strip()
			firstcaselist.append(angel) #this should grab the case name
			#print('case found')
			acounter +=1
			continue
		else:
			acounter +=1
			continue

	acounter=0
	for line in switchcasetester.splitlines():
		#this checks if case in this line but no case in line before it
		if "default" in line:  #tests if no case above this line with case
			#print('the line number is',acounter)
			line_numbers_of_first_cases.append(acounter) #adds the default line number to list
			
			woodstock.append(acounter)
			genius = line.split()

			firstcaselist.append('default') #this should grab the case name
			#print('default found')
			acounter +=1
			continue
		else:
			acounter +=1
			continue
	######################################################
	#print("there I empty dunkindonuts, list_with_code, jazz")
	#empty these lists
	del dunkindonuts[:]
	del list_with_code[:]
	del jazz[:]

	#print("after empting the new lists we have ")
	#print("dunkindonuts=",dunkindonuts)
	#print("list_with_code",list_with_code)
	#print("jazz",jazz)
	######################################################
	smartnewlist=[]

	for item in firstcaselist:
		if item != "default" :
			item = item[1:-1]
			smartnewlist.append(item)

		if item == "default":
			smartnewlist.append(item)




###################################################################################


###### how do I pass a list
#this might work
def get_first_list():
	mytrace('get_first_list()')





#this finds teh first case in each case section and works
#should be: starter,apple, bananas,chocolate, fish,default
#digitalcandy=[[3,7],[7,19],[19,26],[26,33],[33,43],[43,46]]








#2, 3, 7, 8, 9, 10, 19, 20, 26, 27, 36
def go_thru_casenumbers():
	mytrace('go_thru_casenumbers')

	dacounter=0
	for item in music:

		dacounter += 1












mycounter=0
turtle_tab1=[]
turtle_tab2=[]
turtle_tab1.append('starter')
turtle_tab2.append('starter')
#print('looking for tabs in lines================')
#this is just testing in one case for now
#what I am trying to do is 2 loops one for each case section
#so for the second pass it should start at the next case occurrence
#so first I need to prescan it and get the line number of each case
#apparently the solution is using the digitalcandy list with
#the range of case line numbers which I already have calcualted
#this way I can reuse that and focus on just one case section at a time
#and loop through the digital candy list
#I should fill a two dimensional loop
#I can make each new loop and apppend it to the big loop

biglist=[]
testlist=[1,1,1,1,] #tabs for each line in a case
testlist2=[2,2,2,2,2,2]
biglist.append(testlist)
biglist.append(testlist2)

listofifs =[]

##### this calls snowtime inside of big_gears_filling_list_with_case_bodies()
def big_gears_filling_list_with_case_bodies():
	mytrace('big_gears_filling_list_with_case_bodies')
	#mytrace('snowtime') #it calls snowtime() below
	#print("================  big gears filling list with case bodies called  ==========")
	counter=0
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]

		counter += 1

		snowtime(item[0],item[1])  #snowtime is called here with parameters two index numbers
		#from digitalcandy for the first case and next case line number
		





z =''
#this loopsthru the string of jsswitch between
#case numbers in line
mytablist=[]
sublist=[]
case_main_body_list=[]  #just added this oct 8th
#############################################################################
#this copies the case body for each case section and addds it to case_main_body_list
#### def snowtime fills up case_main_body_list with the body of code in each case section
#############################################################################
def snowtime(x,y):  #this grabs the body from one case section at a time
	mytrace('snowtime')
	global practicestring1
	practicestring1 = ""
	
	mycounter=0
	dog=''
	mytablist=[]
	for line in switchcasetester.splitlines():


		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line:

			if len(line) == 0: #this means that the line is empty

				mycounter += 1 #see if this is necessary here or not
				continue
			else: #if here then the line length must be greater than 0 so something is in it


				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				sublist.append(dog)
				#print('the tabs are invisible and embeddd in the code string.')


		mycounter += 1
		#print(sublist)
	mytablist.append(sublist)
	#print("mytablist =",mytablist)

	case_main_body_list.append(practicestring1)  #the body case code is added here

	del practicestring1  #this nukes it
	practicestring1 ='' #clears it out

#=========================================================================




def cotton_candy():
	mytrace('cotton_candy')
	#print("===========cotton candy debugging jan 15th 2021==========")
	
	answer=''
	for item in range(1,len(case_main_body_list)):
		#print("item in cotton candy is",item)
		if isinstance(item,int): #if int is True
			pass
		else:  #if it's not int strip it
			item = item.strip() #not int  THIS STRIPS OFF SPACES
		
		if isinstance(item,int): #if int is True
			pass
		else: #if not int do this
			answer =item.count('\\t')  #COUNTS TABS BUT I DON'T THINK I DO ANYTHING WITH THEM
			answer = ''
#I think I was using this previously to calculate tabs to add 


def stage_two():
	mytrace("stage_two")
	#print('stage two')
	#cotton_candy()

#cotton_candy()


'''
	print("about to copy practicestring1 into sweetlist")
	#this goes through the practicestring1 string using a loop and appends 
	each line into sweetlist
	for line in practicestring1.splitlines():
		sweetlist.append(line)
	case_main_body_list.append(practicestring1) #add the string not a list
	del practicestring1  #this nukes it
	practicestring1 =''
	sweetlist[:] = []  #this empties the list
	print("===just cleared practicestring1 and sweetlist set to nothing====")
'''



#===================================================
#global variable initialization here
#november 10th, 2020
theresult = ''
#testing_this_out function calls function input_string() which returns
#the docstring as a variable and is assigned to the global variable theresult



#=====================================================






#counts tabs

#### =================== truckeeriver() ==================
def truckeeriver():
	mytrace('truckeeriver')
	casecounter=0
	mycounter = 1
	#print('truckee river called')
	for line in switchcasetester.splitlines():   #this was just going thru my prototype string of switch cases
		if "case" in line:				#and oh, I need to make sure I have tabs in my real js switch
			casecounter += 1
			if "case" not in line:
				if "\t" in line and not "break" in line and not "switch" in line and not "fallthru" in line and not 'case' in line:
					#print(line)
					dog=line.count('\t') #this counts the tabs in front of a line
					turtle_tab1.append(mycounter)
					turtle_tab1.append(dog) #dog this counts total number of tabs in this line


					mycounter += 1


		else:
			pass

	#print("turtle_tab1 list=",turtle_tab1) #should be just one slot


#truckeeriver()

def stage_three():
    #print('=====stage three====')
    mytrace("stage three")
    truckeeriver()







my_list=[1, 3, 4, 5, 6]
global coyote_length
new_c_list = []
####################################
def shrink_coyote_list():
	#print("======== shrink_coyote_list called ===========")
	mytrace("shrink_coyote_list")

    #get length of coyote_list
	global coyote_length;
	coyote_length = len(coyote_list)
    #print("the list length =", coyote_length)


	default_loc = coyote_list.index('default')


	for item in coyote_list:
		if item != "default":
			new_c_list.append(item)
			continue;
		else:
			break;



    #print("the length of the new shortened list =", len(new_c_list))
    #this is my solution for list out of range bull bug

	if (len(new_c_list))% 2 == 0:  #this would only be done once and modify the list
    #to manipulate.
		pass
	else:

		new_c_list.append('nada')






#============== get starting position in coyote




x = 0
destination =0
playwith =0
def get_starting_position_in_coyote(x):
    mytrace('get_starting_position_in_coyote')
    #print("getting starting position")
    answer =new_c_list[x]  #this is what I'm looking inside of the list
   






def get_current_position_in_coyote(x):
    mytrace("get_current_position_in_coyote")
    #print("getting starting position")
    answer =new_c_list[x]  #this is what I'm looking inside of the list







hopper_list =[]
def add_one_to_position_in_coyote(x):
    mytraace("add_one_to_position_in_coyote")
    #print("fall to position called")
    x= x + 1
    answer =new_c_list[x]

    destination = answer;




#print("okay the fun starts here =======>>>>>>>>")

# this figure out the number of case sections (number of case ifs really)
#it goes through the coyote list and checks if a line contains case and the next doesn't
#this works  july 30 2020
counter =0
casecounter = 0
list_of_cases =[]
while counter < len(new_c_list):
    #print(get_starting_position_in_coyote(counter)) #position 0

    if new_c_list[counter] == "case" and new_c_list[counter +1] != "case": #this represents the bottom of case set group
        counter += 1
        casecounter += 1;
        continue;
    else:
        counter += 1
        continue;


########################################
##  new_add_to_front() actually appending it to end of list
########################################
## it's adding it to the tail NOT THE FRONT

def new_add_to_front(x,listname):
	mytrace('new_add_to_front')
	#print(" ============ function new_add_to_front() called =======")
	#listname.insert(0, x) #cool it worked  this would add it to the front
	listname.append(x)

    #go through copy of that list and del items
    #I see this represents building the list











#what I already solved was how many sections of case groups there are
#now I need to get the remaining case locations
#if case not in line meaning after first case section so this would start after the last case in the first section
#July 30th, 2020 fun
# i should know how many cases in each section
####THIS GETS THE FIRST CASE IN EACH CASE SECTION THE LINE NUMBER
#starbuckslist=[]
#starbuckslist.append('starter')
genius =''
#diamonds=[[2,7],[7,19],[19,26],[26,36]] #this is input
#I have that list 2,7,19,26,36


#so quite simply I just need to cascade it down like a waterfall from above
#which shouldn't be too hard



#line_numbers_of_first_cases
#look at this force feeding it input i need to find the generation of the inputlist
#theinputlist =[2,7,17,24,34]  # case case case case default   I took off 36 default
total = len(line_numbers_of_first_cases)
palmtrees=[]  #defined here so it's global 
mochalist=[]
greenmilelist=[]
###################################
def rule_the_earth():
###################################
	#print("========rule the earth called========")
	#print("== DEBUGGING ==")
	mytrace("rule_the_earth")
	#print("line_numbers_of_first_cases")
	#print(line_numbers_of_first_cases)
	global woodstock
	#print("woodstock list=",woodstock)
	#this is to get the first case of each section
	#print('======= ***** ====rule the earth ==== creates starbucks list === *******  =====')
	#print("==here we can see what the machine sees=====---***")
	#print(switchcasetester)
	mycounter =0
	second_word=''
	theline=''
	#print("the input to figure out the first case in each list inputlist list =",line_numbers_of_first_cases)
	## go thru digital list of the case locations
	## it will be the x position that's easy enough
	bestbuy1 =''
	bestbuy2 = ''
	
	
	test1 =''
	test2 =''
	plumtree=''
	total_word_count=''
	#print("inside of function rule_the_earth()")
	#print("palmtrees at this point has in it line 6693 ",palmtrees)
	#palmtrees.append('starter')
	#####################################
	## new addition to reset palmtrees list april 27th 2021 6:30 pm
	reset_list_to_just_starter(palmtrees) #clears out list if previously used resets it
	#print("palmtrees should only have starter in it at this location")
	palmtrees.append('starter') #which would be in slot 0
	#print("palmtrees=",palmtrees)
	#breakpoint()
	##for case sets I just go thru till case not in line and fill a new list
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		#go thru case list here as the feeder
		if mycounter in line_numbers_of_first_cases:
			#breakpoint()#print(line)
			#felix is the line split into a string
			felix= line.split()
			#print("NUMBER OF WORDS IN THIS CASE LINE")
			#print("number of words in this line is ",len(felix))
			
			#print("inside rule_the_earth line with case")
			#print("felix=",felix)

			if "default" in line:
				#print(line)
				second_word = line.split()[0]
				#########experimentaionl april 29th 
				#print("this is new on april 29th, 2021")
				#whatcount = len(second_word)
				#if 'case' in second_word:
				#	print("true case in this line")
				#	print("the number of words -1` for case",whatcount -1)
				#	whatcount = whatcount -1
				#else:
				#	print("false no case in this line")

				#print("the number of words -1` for case",whatcount)
				#this line will be no default
			else:
				#this ELSE MEANS DEFAULT NOT IN THIS LINE !!!!!!!
			################# code to get the 
				#print("I think that case must be in this line")
				#print("look at this next line carefully")
				#print('line =',line)
				second_word = line.split()[1] #right here it grabs just one word
				#that is the flaw
				##### addition here 
				#### first check if only one word
				#print("felix=",felix)
				#print("DEBUGGING ==6730==")
				#print("the line with default=",line)
				#print("felix[0]=",felix[0])
				del felix[0] #should delete first word case
				total_word_count = len(felix) #already deleted first word
				if total_word_count > 0:
					#print("assertion :: there is at least one word in the case")
					pass
					
				#secenario if only one word case like Tahoe
				#############################################
				## SCENARIO 1  IF ONLY ONE WORD FOR THE CASE
				# THIS DETERMINES IF THE CASE IS JUST ONE WORD
				#############################################
				if total_word_count == 1:
					#print("there is only one word in this case",felix)
					the_words = felix
					plumtree=' '.join(felix)
					#plumtree = felix  #it might be in a list actually 
					#print(plumtree)
					plumtree=plumtree[:-1] #this takes off the : on the end of the string
					#print("plumtree=", plumtree)
					#print("yeah plumtree is a stirng at this stage")
					#print("===== experimenntal plum tree to add to palmtrees === ")
					coolness = plumtree.replace("'","")
					plumtree = coolness
					#print(plumtree)
					
					#palmtrees=palmtrees[1:-1]
					palmtrees.append(plumtree)
					#print('AT THIS JUNCTURE LINE 6745 palmtrees=',palmtrees)
					#starbuckslist.append(plumtree)
				else:
					pass
				##############################
				#this senario if 2 or more words for the case like "alpine meadows
				## SCENARIO 2 IF 2 OR MORE WORDS IN THE CASE
				#THIS DETERMINES IF THE CASE IS AT LEAST 2 OR MORE WORDS
				###############################
				if total_word_count > 1:
					#print(total_word_count, " words in this  case")
					#print("felix =",felix)
				#========here is the JOIN to convert the line as a list with case into a string ======
					plumtree=' '.join(felix)
					#print("== output of plum tree ==")
					#print(plumtree)
					if plumtree.endswith(":"):
						plumtree=plumtree[:-1]  #this should delete the colon of end
						alltheway = plumtree.replace("'","") #this elminates double quotes
						plumtree = alltheway
						#starbuckslist.append(plumtree)
						palmtrees.append(plumtree)
						#print("here at line 6767 palmtrees=",palmtrees)
					else:
						pass
					
				#print("plumtree=", plumtree)
				
				#print("the words for this case are",the_words)
				#print("the number of words for this case in the line are ",total_word_count)
				##===========
				#print(" ====== entering new section of coding here at Volvo ==== ")
				
				#print("=====")
				#print("=== coding at walmart saturday night ===")
				
				
				

#january 26yh, 2021 my initial design was
#this is where we will have the case words 
#my flaw was having it designed to only handle the second word, the word after case
#and that was limiting it but it will be modified correctly soon.

# case word:  but this breaks if more than one word like "alpine meadows"
# I need to add my code adjustment here 
			#======================  thursday surgery cleaning up the words 'words'
			#wild= second_word[1:-1]
			
			#wild = "'" + wild       #adding a ' to left side of word
			#darn = wild[1:-1]
			#wild = darn
			#second_word = wild
			#=======================
			#if second_word != "default": #this is new
			#	starbuckslist.append(second_word)

			if mycounter == total:
				break
			else:
				mycounter += 1
		else:
			mycounter += 1
	#starbuckslist.pop()
	#starbuckslist.append('default')
	#print("starbuckslist=",starbuckslist)
	palmtrees.append('default')
	#print("palmtrees=",palmtrees)
	starbuckslist=[] #resets it
	reset_list_to_just_starter(starbuckslist)
	#print("what's in starbuckslist here",starbuckslist)
	#filling starbuckslist
	#####################################
	
	#print("===========================")
	for item in palmtrees:
		starbuckslist.append(item)
	#print("at line 6820 strarbuckslist =",starbuckslist)	
	#print("we now have... starbuckslist")
	#print(starbuckslist)
	#print("===========================")
	
	
	




	#print("testing this::::")
	#RIGHT here is where I need to remove " and : from each item in list
	counter = 0
	#print("new test here")
	mochalist.insert(0, "'starter'")
	for item in starbuckslist:
		#print(item)
		#if item != "starter":
		if item != "starter":
			item = item[:-1] #take out the :
			#===================================== experimental surgery here to have list

			#=====================================['apple','fish',etc]
			#print(item)
			mochalist.append(item)
		else:
			mochalist.append(item)
	mochalist.append("'default'")

	#print("the mochalist after adding starter and default to it ")
	#for item in mochalist:
	#	print(item)


	acounter=0
	#greenmilelist.append('starter')
	for item in mochalist:
		if item != "starter" and item != "default":
			item[1:-1]
			greenmilelist.append(item)



	#print("=======")

	str = "'apple'"
	#print(str)
	#print(str.replace('"', ''))





#sunrise();

#what this does is take the input of teh [concatstring list] with line numbers
#which has the first case line number for each section
#I need the case number list name to feed it
















#starbuckslist=[]
#starbuckslist.append("starter");
################################################################
def this_needs_to_work_badly():   
#this fills the starbuckslist which is used in p51 for fallthru(casenmae)

#################################################################
	#print("=========this_needs_to_work_badly() =============")
	#print("=========this_needs_to_work_badly() =============")
	#print("=========this_needs_to_work_badly() =============")
	mytrace('this_needs_to_work_badly')
	#print('===============this needs to work badly called =======to get first case name ==')
	#print("============= THIS NEEDS TO WORK BADLY() called =============== ")
	#print('this gets the first case name (designed as one word initially')
	#print("but I need to modify it to take more than one word so I will need to count")
	#print("how many words are in the *first case* so it's flexible and smart")
	#new_add_to_front(x,listname)
	mycounter = 0
	#print("starting out we have in starbuckslist",starbuckslist)
	#print('case section line number list =',concatstring)
	#print("what is in concatstring?") #I think it's the first case line number in each section
	#print(concatstring)
	
	
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		#batterondeck represents previous loop count
		#go thru case list here as the feeder
		#print(line)
		if mycounter in concatstring: #so it's looping thru switchase and line number in concatstring list
			#print("!!!!!!!======!!!!!!!!!!line=")
			#print("dam line?",line)
			#print("underneath line=====================")
			firstline = line.split() #we refer to the line as firstline a variable
			#print(firstline)
			### this is where it was grabbing the one word after case
			### which wasn't able to grab more than one word by design
			
			#genius = line.split() #new  [0] was at end of it  ((this does the line split for each line))
			#print("genius[1]=",genius[1])    #gets word of that case name
			#print("the design is only getting one word")
			#print("genius=",genius)
			#print("genius this is in the first case line above")
			################# this is the problem it's only grabbing the first word
			#################
			#################
			#baby = genius[1] # it's only grabbing one word after case (by design here)
			#print("baby= genius[1]",baby)
			# if "case" in line: #see if this puppy works
			#remove the colon from the end
			#use a replace
			#firstline = line.split()
			#this makes a list called firstline
			#this gets the number of words in the line
			length_list = len(firstline)
			#now subtract first word 'case' 
			del firstline[0] #deletes the first word which is case
			length_list = len(firstline) #we thn print the number of words in this case
			#print("the number of words in this case is",length_list)
			#['case', "'alpine", "meadows':"]
			#print("line 1538")
			#print(firstline)
			#print("the length of this case name in words =",length_list)
			#while True:
			#remember that we have wiped away(erased) the case word it's gone
			if length_list == 1:
				answer = firstline[0]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                 
			if length_list == 2:
				answer= firstline[0] + " " + firstline[1]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 3:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 4:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3]
				answer = answer[:-1]
				print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 5:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 6:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4] + " " + firstline[5]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 7:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 8:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 9:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]  + " " + firstline[8]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			if length_list == 10:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7] + " " + firstline[8] + " " + firstline[9]
				answer = answer[:-1]
				#print(answer)
				baby = answer
				drive_thru.append(baby)
                
			
			
			
			####==============
			new_add_to_front(baby,starbuckslist)  ## actually adds to tail of starbuckslist
			#test
			#print("new add to front (baby,stabuckslist)")
			#print("baby=",baby)
			#print("starbuckslist=",starbuckslist)
			mycounter += 1 #n
		else:
			mycounter += 1
			
	#print("resulting starbuckslist=",starbuckslist)


######=============================================================















#this_needs_to_work_badly();[2, 7, 17, 24, 34]
#theinputlist =[2,7,17,24,34]  #5 which is case_sections + 1 (default)
case_sections = 0
total = 5
#==========================
#I will have to dynamically initialize these


mainlist=[]
#diamonds=[[2,7],[7,19],[19,26],[26,36]]  what I am aiming to make
#these are lines of the first case line numbers and then the default line number


#theinputlist= [2, 7, 17, 24, 34]  #last one is default which is really a case


length_of_input_list = len(line_numbers_of_first_cases)   #question does this work because it's an even number
#output
mainlist= [] # [[2, 7], [7, 19], [19, 26], [26, 36]]



find_default=''
lastbrace=''

list_trex=[]
listcandy=[]
defaultlist=[]  #here defaultlist is declared as empty

#uses input_list[2,7,19,26,36]
# THIS IS NEW FOR SUNDAY AUGUST 23, 2020 modified november 16th
# CONVERT TO TWIN LIST
number_of_case_sections=0
###################################
def convert_to_twin_list():  #uses list called line_numbers_of_first_cases
###################################
    mytrace("convert_to_twin_list")
    #print("=====line numbers of first cases list====")
    #print(line_numbers_of_first_cases)
    #so the length of line_numbers_of_first_cases tells us how many case sections
    #print("=9009=0=09=0=0=00=000099999=9=9=9=9=99=9=9=9=")
    #print("the number of case sections =", len(line_numbers_of_first_cases))

    #####
    ## create case lists
    #print("called create case lists")
    #create_case_lists()
    #print("them out to see them now")
    #show_case_lists()
    ##3===================
    global woodstock
    #print("woodstock in twin list=",woodstock)
    # added april 27th,2021 at 6:35 pm ===================
    
    #sniffer to see what is in digitalcandy here 
    #print("digitalcandy=",digitalcandy)
    #print('testing what is in digitalcandy line 7128')
    if len(digitalcandy) == 0:
    	print('')#'digitalcandy is empty')
    else:
    	print('')#"digitalcandy length =",len(digitalcandy))


    #this clears out digitalcandy (hopefully)
    # if digitalcandy has something in it then clear it
    if len(digitalcandy) > 0:
    	reset_list_to_just_starter(digitalcandy) #this makes it read ['starter']
    else:
    	pass
    #================
    #breakpoint()
    #print("starting out this is what is inside of list digitalcandy")
    #print("this is a moment before converting it into a twin list")
    #print("before appending to digitalcandy I wasnt verifying if it was empty")
   # print('the length of digitalcandy =',len(digitalcandy))
    #print(digitalcandy)
    ###############
    #digitalcandy.pop() #takes off first item of starterj this makes it empty
    #========================
    #global candy
    #candy=''
    #candy=[]
    #breakpoint()
    #input_list -= 1 #true cases last number is default
    ##################
    #print("inside of convert_to_twin_list")
    #print("line_numbers_of_first_cases",line_numbers_of_first_cases)
    list_trex=[] #this should reset it
    #print("list_trex=",list_trex)
    alpha = 0; beta = 1; counter = 0  #down below it was: length_of_input_list
    while counter < len(line_numbers_of_first_cases) -1:
        eval("list_trex.append(line_numbers_of_first_cases[alpha])")
        eval("list_trex.append(line_numbers_of_first_cases[beta])")
        eval("digitalcandy.append(list_trex)")
        eval("candy.append(list_trex)")
        alpha += 1; beta += 1; counter += 1
        list_trex=[] #resets list to reuse next loop
    #print('digitalcandy =',digitalcandy)
	#digitalcandy.append(defaultlist)
###=============================================




## what this does is delete the existing last sublist from digitalcandy
## and then it replaces it with a new list appended that has the default line number and
## curly brace line number (can alternatively be the last line of string) both equal length





#==============
# this looks like good logic to check between default and closing brace/last line
# determined last line number also eventually
# december 7th, this is dependent on default word existing
# the point of this code section is to VERIFY that there IS a BREAK after default
# and if there isn't a break add one
#=========
#
#===============
#defaultlist=[]
'''
mycounter = 0
check_for_default_break = "false"
x = defaultlist[0] #dfault word
y = defaultlist[1] #closing brace
for line in switchcasetester.splitlines():
	if mycounter > x and mycounter < y \
		and "break"  in line :
		check_for_default_break="true"
		break
		#mycounter += 1 #see if this is necessary here or not
	else:
		mycounter += 1
		continue
'''
###====================
####======== find_last_break_in_string  ========= 
##in switchcasetester input switch
listofbreaks=[]
def find_last_break_in_string():
	mytrace('find_last_break')
	counter=0
	for line in switchcasetester.splitlines():
		if "break" in line:
			listofbreaks.append(counter)
			counter +=1
		else:
			counter += 1
			continue
	baby = listofbreaks[-1] #the last one
	return baby #which is a string

##############################
##  change_to_string()   -- fancy replace to switchcasetester
##############################
def change_to_string(x,y):
	mytrace('change_to_string()')
	#print('change_to_string()',x,y)
	global switchcasetester
	peach='';peach=switchcasetester.replace(x, y)
	switchcasetester=''; switchcasetester = peach



##### friday, march 26th, 2021
##### convert case line to lowercase that's what matters for matching
def convert_case_line_to_lowercase():
	mytrace('convert_case_line_to_lowercase()')
	#print('convert case line to lowercase')
	counter=0
	global switchcasetester
	for line in switchcasetester.splitlines():
		if 'case' in line:
			#this should make whole line lowercase
			change_to_string(line,line.lower())
			counter +=1
		else:
			counter += 1
			continue
	#print("after lowering words in case line we have")
	#print(switchcasetester)




#=========================
##########################################
def special_addition_to_digital_candy():
##########################################
	mytrace("special_addition_to_digital_candy")
	#global candy
	candy.pop() #treated as a list
	digitalcandy.pop() #delete last item sublist
	#print("digital candy after pop =",digitalcandy)

	#this gets the line number of the word default
	find_default = get_default_location()  #gets line number of default

	#this gets the line number of the closing brace (identical to last line of docstring)
	last_brace   = get_closing_brace()  #gets the line number of closing curly brace
	thelastbreak = find_last_break_in_string()# put it here
	mystring = str(get_closing_brace()) #puts closing brace line number in mystring
	defaultlist.append(find_default)  #defaultlist[0] #default line number
	defaultlist.append(int(mystring)) #defaultlist[2]
	
	#print("defaultlist=",defaultlist)
	#print("digitalcandy at this point",digitalcandy)
	#so this means that digital candy should already exist and be populated
	#don't want to corruptthis it is only expecting two values not three
	digitalcandy.append(defaultlist) #these two are the parameters to look between
	#print("defaultlist=",defaultlist)
	#print("line 7317")
	#print("candy",candy)
	candy.append(defaultlist)
	#print("now candy shows",candy)
	#print("at this point digital candy shows",digitalcandy)
	
	#look_for_break_after_default(defaultlist)
	#this is new code to determine if missing break in default input section
	three_in_row=[]
	three_in_row.append(find_default)  #defaultlist[0] #default line number
	three_in_row.append(thelastbreak)  #defaultlist[1] #break line number (if here)
	three_in_row.append(int(mystring))
	a = find_default
	b = thelastbreak
	c = int(mystring)
	#print("testing here before doing comparison")
	#print("a,b,c",a,b,c)
	#I might need to call this first since it's a strange bug if a missing break
	#remember if there is no break then add it with replace
	####################
	if b > a:
		#print("==== testing if break AFTER default")
		#print("there is a break in default") #in the default case
	#else:
		#print("there is a MISSING break in default case") #beneath default
		#print('there is NOT a break in default need to add one')
		#again this is adding a break in default to javascript switch case
		#because of an obscure bug caused by missing break in default
		#print("this is before adding break to default")
		#print(switchcasetester)
		#global switchcasetester
		orange=''
		global switchcasetester  #just added this may 31st, 2021 
		orange=switchcasetester.replace("}","			break \
			\n}")
		switchcasetester='' #this nukes it resets it
		switchcasetester = orange
		#print("after adding break to default")
		#print(switchcasetester)
		return switchcasetester

#working on this December 17th new functions
'''
found_break_in_default=[]
	#called after special addition to digital candy
def look_for_break_after_default(input):
	smartcounter=0
	x = input[0]
	y = input[1]
	print("testing if it received the input values from js switch ")
	print("x=",x," ","y =",y) #between default and last line of string
	acounter =0
    for line in switchcasetester.splitlines():
        if acounter > x and acounter < y:
       		if "break" in line:
               # print("we found a break",smartcounter)
                found_break_in_default.append("true")
                break #if it's in there bail out no further action needed
            else:
                found_break_in_default.append("false")
            if "true" not in found_break_in_default: #this is a growing list it's making
            	print("need to add a break")
            else:
            	print("true is in it so don't need to add break already there")
		#   print(firstline[0])
        acounter += 1;
#==============================================================
def add_break_to_bottom_of_default(): #I got this working November 26th, 2020
	#print("=====convert_default_case called===") #this needs to be called first definitely
	mytrace('convert_default_case')
	#input
	global switchcasetester
	#print("this is the original input on switchcastester")
	#print(switchcasetester)
	newton=switchcasetester.replace("default:","case 'default':")
	switchcasetester=''
	switchcasetester = newton
	make_list_of_first_cases()
	print(switchcasetester)
	return switchcasetester
'''
##### stage_four has faucet_value() in it which checks if switch is case numbers
##### and if so then converts the numbers to strings





#############################################################################
def stage_four():
	#print(switchcasetester) 
	#print("===== testingwhat it sees in stage four() ======")
	mytrace('stage_four()')
	#print('stage four')
	####<<====== added March 15th,2021 converts numbers to strings if numbers
	magictimenow()
	convert_to_twin_list()
	special_addition_to_digital_candy() #=======added nov 25th, 2020
	rule_the_earth()


'''
starbuckslist is just the first case name of each case section
in drive_thru list I put EACH case which is wrong.
'''




#================ this gets the case names from all cases
#talk about militant bull0 indentation -wasting my precious time unreal.
firstline =""
#additions on Sunday August 23rd, 2020
royallist=[]  #mythical list of tail for case section codegen
royallist.append('starter'); #which fills position0

drive_thru=[]
drive_thru.append("starter")
#this is a super important function I think I wrote it at the beach a few days ago

### modfiied tuesday january 26th, 2021 to put a multi word like "alpine meadows" into fallthru('alpine meadows') currently only takes in one word
###
def testing_this_to_get_word():
	mytrace('testing_this_to_get_word')
	#print("======def ======testing this to get word() ==================")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")
	#print("*** MASSIVE TESTING AT STARBUCKS ON TUESDAY MORNING ***")

	smartcounter=0
	#this looks for "case" in the switch case string
	for line in switchcasetester.splitlines(): #switch case in JS
		if "case" in line: #see if this puppy works
			#remove the colon from the end
			#use a replace
			firstline = line.split()
			#this makes a list called firstline
			length_list = len(firstline)
			#now subtract first word 'case' 
			del firstline[0]
			length_list = len(firstline)
			#print("the number of words in this case is",length_list)
			#['case', "'alpine", "meadows':"]
			#print("line 1441")
			#print(firstline)
			#print("the length of this case name in words =",length_list)
			#while True:
			
			if length_list == 1:
				answer = firstline[0]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
			 
			if length_list == 2:
				answer= firstline[0] + " " + firstline[1]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 3:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 4:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 5:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 6:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2] + " " + firstline[3] + " " + firstline[4] + " " + firstline[5]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 7:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 8:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 9:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7]  + " " + firstline[8]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			if length_list == 10:
				answer= firstline[0] + " " + firstline[1] + " " + firstline[2]+ " " + firstline[3] + " " + firstline[4] + " " + firstline[5] + " " + firstline[6] + " " + firstline[7] + " " + firstline[8] + " " + firstline[9]
				answer = answer[:-1]
				#print(answer)
				drive_thru.append(answer)
                
			#print(firstline[0])
			#print("now try this",firstline[length_list])
			smartcounter += 1;
		else:
			smartcounter +=1;
    
	#print("================== drive thru list of case names ")
	#print("the list of case names no matter how many words is here in list drive_thru")
	#print("drive_thru list contents now are ",drive_thru)
	#print("")
	#print("now we will loop thru the drive_thru list")
	#LIST OF CASE NAMES
	#print("==========================")
	#print("drive_thru=",drive_thru)
	#print("===========================")
	count=0
	for item in drive_thru:
		#print(item,count)
		count += 1
        
	#here we get the location of the "default"
	smartcounter=0
	for line in switchcasetester.splitlines(): #switch case in JS
		if "default" in line:
			firstline = line.split()
			location_of_default = smartcounter
			break
			#smartcounter += 1;
		else:
			smartcounter +=1;

########   end of this never ending function ##########

#testing_this_to_get_word()  #==================this should call it now

def stage_five():
    #print('stage five')
    testing_this_to_get_word()




    ###########################################################
    #these are the line number positions of first case for each section [2, 7, 19,26]
    #this looks in one section at a time for a break and fallthru
#diamonds =[]
    #this is all just raw code not even in a function
case1findbreak=[]
case1findfallthru=[]



def does_this_run():
    mytrace("does_this_run")
    c = 1    #current case numbr section
    d = c + 1

    x = clever[0]
    y = clever[1]
             #this loops by default through the entire string
             #for line in splitline().switch:

     #=======================================================
     #this is looking between x and y which are in diamonds
     #========================================================

    counter =0
    case1 =[] #case number list to add fallthru
   
    #print("testing getting the dam range to work")
    #print("looking for BREAK in this case section")
    smartcounter=0
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to 
            #firstline = line.split()
            #print(line)

            if "break" in line:
               # print("we found a break",smartcounter)
                case1findbreak.append("true")
            else:
                case1findbreak.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;


        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
    smartcounter=0 #reset at zero
    ##=========================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##===========================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" in line:  #what about fallthrough also to test for
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;



   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found')
        royallist.append('break');

    if "true" in case1findfallthru:
        #print('fallthru found')
        royallist.append('fallthru')

    if "true" not in case1findbreak and "true" not in case1findfallthru:
        #print("need to add a fallthru")
        royallist.append('fallthru')

    #print("royallist=",royallist)







#//=========== iron curtain============================

 ##===============================================================
  ####=================== American River Methods ==================
  ##===============================================================









buildlist=[]
def grab_body_of_code_inside_case_sections():
    mytrace("grab_body_of_code_inside_case_sections")
    #print("grab body of code called== @@@@")
    smartcounter=0  #reset at zero

    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)

        if smartcounter > x and smartcounter < y:  #so get what's inbeteen
       #this should only print the body of this one case section
            if "case" not in line and "break" not in line and "fallthru" not in line:
                #print(line)
                buildlist.append(line,smartcounter);
                smartcounter += 1;
                #do I need continue?








#august 27 thurday coding test       this will be the sets of cases for each case section
caseset=[]
def create_case_name_lists(x,y):
    #print("==$$$$$$$$$$$$$$$$$$$$$$$$$$$$$==")
    #print("================this is line 1615===CREATE CASE NAME LISTS=====================")
    #print("def create_case_name_lists:")
    #print("working on fix to solve bug if user uses more than one word for a case")
    #print("such as alpine meadows whereas right now its geared for one word cases")
    
    mytrace('create_case_name_lists')
    #print("=================create case name lists called == @@@@")

    smartcounter=0 #reset at zero
    genius = ''
     #need list of first cases that will work for input
    #Thursday coding to save this day from a disaster of nothing working
    ##===================================================================
    ## LOOP LOOKING  CASE SECTION APPEND LINES FROM BODY AFTER CASES UNTIL NEXT FIRST CASE
    ##=======================================================================
    #print("here we get the words in each case section=====------")
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter < y:  #so get what's inbeteen
        #this should just look
            if "case"  in line:
                #print("did it take off front of line?")
                #print(line.split(' ',1)[1])
                #print(line,smartcounter)
                #print("=================================")
                genius =line.split()
                #print("genius =",genius)
                #print("======= len(genius) ==============")
               # print("WE ARE HERE==>>>>")
               # print('number of words in the line case = len(genius) ',len(genius))
                
                #print("number of words in this line =",len(genius))
                #print("it's current state is only grab the second word which is position [1] by default")
                ap=''
                #testing with more than one word the defualt was the first one
               #================  jan 3, 2021 code fix experimentiong case alpine meadows
                if len(genius) == 2:
                    #print('teh default was 1 word case and one word')
                    caseset.append(genius[1])
                    #print(caseset)
                    
                if len(genius) == 3:
                    #print('teh default was 3 words case and two words')
                    ap =genius[1] + genius[2]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) == 4:
                    #print('teh default was 4 word case and 3 words')
                    ap =genius[1] + genius[2] + genius[3]
                    caseset.append(ap)
                    #print(caseset)
                    
                if len(genius) > 4:
                    #print("more than four words in this line detected")
                    #print("just do the default for now will fix later")
                    caseset.append(genius[1])
                    #print(caseset)
                
                #print("it looks like I'm just grabbing the first word of a case which I initially tested it with")
                #print('line 1632')
                #print(caseset)
                #buildlist.append(line);
                smartcounter += 1;

    #print("caseset list for one case section=",caseset);
    wilsonball=[]
    wilsonball.append('starter')
    wilsonball.append(caseset)
    #print("******** === wilsonball=",wilsonball)










#this actually looks for breaks, missing beaks, and fallthrus
####=====================
##case_tail_list_maker() finds breaks, missing break detection, fallthrus
##========================
snowman=[]
homer=[]
gti=[]
gti.append("starter")
funny=''
seal=[]
homer.append('starter')
solution=''
snowman.append('starter')
wilecoyote=[]  #I was clearing it out here good thing I noticed it
casecaptured=''

reset_list_to_just_starter(wilecoyote)
#print("wilecoyote list",wilecoyote)
#wilecoyote.pop()

mrcase=''
def case_tail_list_maker(x,y):  #two vars x and y are case locations from digitalcandy
    mytrace('case_trail_list_maker')
    #print("=######	C A S E    T A I L   M A K E R  searches for breaks and fallthrus  ")
    #print("digitalcandy=",digitalcandy)
    #print("length of digitcandy=",len(digitalcandy))
   
    smartcounter=0
    #this looks for "case" in the switch case string
    for line in switchcasetester.splitlines(): #switch case in JS
        if "case" in line: #see if this puppy works
            firstline = line.split()
           
            smartcounter += 1;
        else:
            smartcounter +=1;

    #here we get the location of the "default"
    smartcounter=0
    for line in switchcasetester.splitlines(): #switch case in JS
        if "default" in line: #see if this puppy works
            firstline = line.split()
            location_of_default = smartcounter
            break
            #smartcounter += 1;
        else:
            smartcounter +=1;



   #not sure if I am using c and d or not or if I switched to x, y instead
    c = 1    #current case numbr section
    d = c + 1
    #print("x",x,"y",y);
    counter =0
    case1 =[] #case number list to add fallthru
    case1findbreak=[]
    case1findfallthru=[]

    smartcounter=0
    ram=''
    #look for BREAK in range of lines
    ##================================================
    ## LOOP LOOKING FOR BREAK IN CASE SECTION CODE
    ##================================================
    #homer=[] #this is to keep track of whether break or fallthru as backup checker
   ##############################################
   
    ##############################################
    ##############################################
   # print("HUGE TEST to make it work Tuesday feb 22nd")
    #this goes through the whole switch case 
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        #print("======= TESTING THIS  ========")
        #print("x =",x,"and y=",y)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            ####################################
            if smartcounter == x: #case line
                #print("GET CASE NAME")
                mrcase =get_case_name(line);  #calling method here 
               # print("just here got the_section",mrcase)
               # print(mrcase)
                
                mrcase =mrcase.lstrip() 
                mrcase =mrcase.rstrip()
                #print(mrcase)
            #end if
            
            
            #firstline = line.split()
            #print("I need to make sure it searches through the lines")
            #print(line)
            global funny
            funny += line
            #### I have simpified it to if break then break, otherwise fallthru
            if "break" in line:
                #print("===== gold ======")
                #print("we found a break line number =",x,y,smartcounter)
                
                wilecoyote.append(mrcase) # first case number in digitalcandy
                #I will put the case name instead of x
                
                homer.append(smartcounter)
                seal.append(smartcounter)
                #if i detect a break on a line in a case section that's true
                
                #smartass.append("break")
                #homer.append('break')
                case1findbreak.append("true")
            else:  # I just modified this one and using homer
                case1findbreak.append("false")  #meaning add invisible fallthru
                #print("no break found in this section") #and no fallthru
                #print("no break found =",x,y,0) #using 0 for no break found
                #homer.append('fallthru')
                #break not in line it's fallthru
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #########################
  
        
        
     #we ARE STARTING A SECOND LOOP HERE -------------------
        #look for FALLTHRU in range of lines
    #print("starting 2nd loop now looking for FALLTHRU")
        #=========================
        #print("this was the old design the newone will be different")
        if "break" in funny:
            gti.append("break")
        else:
            gti.append("fallthru")
        
        
    smartcounter=0 #reset at zero
    ##=====================================================================
    ## LOOP LOOKING FOR FALLTHRU IN CHUNK OF CODE INSIDE OF A CASE SECTION
    ##======================================================================
    for line in switchcasetester.splitlines(): #switch case in JS
        #print("smartcounter =",smartcounter)
        if smartcounter >= x and smartcounter <= y:
       #this is the range I want to print
            #firstline = line.split()
            #print(line)

            if "fallthru" or "fallthrough" in line: #just added fallthrough here
                #print("we found a fallthru",smartcounter)
                case1findfallthru.append("true")
              
            else:
                case1findfallthru.append("false")
         #   print(firstline[0])
        smartcounter += 1;

        #are you serious is this it? this fixed the bug
        if smartcounter > y:
            break;
    #I think that this is the end of the for loop here
    #print("=================================")
    #print("gti  list has",gti)
    #print("=================================")
    #print("========WILECOYOTE LIST=========")
    #print(wilecoyote)

   #this is all so clever
   # looks inside of lists for breaks, fallthrus
    if "true" in case1findbreak:
        #print('break found in this case section ')
        royallist.append('break'); #this adds break to royallist
       # homer.append("break")


# here it's appending the fallthru('casename')
    if "true" in case1findfallthru:
        #print('** = fallthru found in case section')
        smart = len(royallist)  #new code  a number
        smart += 1
        #before I add this one         so I am putting a number here which is used
        fall = "fallthru" + str(smart)  #to call the correct word in starbuckslist
        #print("we have",starbuckslist[smart]," added to fallthru")
        #I will need to do this
        #  fall = "fallthru('" + starbuckslist[smart] + "'")
        royallist.append(fall)
        #homer.append(fall)
        
  # here it test if "break" not in case section and "fallthru" not in case section
    wolf =''
    if "true" not in case1findbreak and "true" not in case1findfallthru:
       # print("** = need to add a fallthru in this section with no break and no fallthru")
        sosmart = len(royallist)
        sosmart += 1   #number below so it makes fallthru4 in example
        fall = "fallthru" + str(sosmart) #+ ")"  #just added this  thursday night
        #print("we have",starbuckslist[sosmart], "added to fallthru")
        #print("smart is length of royal list before adding fallthru",sosmart)
        #print just eliminted "'" +  and  "'"
        wolf = "fallthru(" +   str(sosmart)  + ")"  #this makes fallthru(4) which I need
        #because I can convert the number to a word in new list
        #print("wolf=",wolf)  #so this works
        royallist.append(fall)
       # homer.append(fall)
   
    #print("let us see what the size and end of royallist is",royallist)
    #print("royallist lenght=",len(royallist))
    royallist.append('break'); #this is for the default case which must be a break
    #print("royallist final =",royallist)
    #print("lenght of royallist final =",len(royallist))
    snowman.append("break")
    #print("gti coming thru",gti)
    #print("this is our winner=================")
    #print("seal=",seal)
    #print("the list of first case number in digitalcandy with a break in it")
    #print("wilecoyote=",wilecoyote)



##########################################################################
##           dividide and conquor    thrusday, feb 25th, 2021 nearly 1pm
##########################################################################






#####################################
### crashing waves at beach ()   ####
#####################################
penguin=[]  #defining a new list here 
def crashing_waves_at_beach():
	mytrace('crashing_waves_at_beach()')
	#print("Crashing Waves At Beach function called")
	######## there is a lot going on here
	'''
	loop thru wilecoyote of cases with breaks and
	   get index location of those cases in palmtrees list
	   put the index number into roadrunner list
	   
	 
	loop thru digitalcandy to make list of same size and fill british list with all 'fallthru'
	
	loop thru roadrunner list with index number
	and replace index number in british with "break"
	
	'''
	#print("this is what is in wilecoyote",wilecoyote)
	#print("I got this working the other day at motel 6 on Tuesday night")
	################################################
	#print('in crashing waves at beach we have wilecoyote line 7975',wilecoyote)
	#print("palmtrees at line 7977 we have ",palmtrees)
	###=================#######@@@@@@@@@@@@@@@@@@@@@@@
	print("debugging on june 16th, 2021")
	print("palmtrees to see whats in this list")
	##########################
	print("palmtrees==============")
	print(palmtrees)
	print("wilecoyote==============")
	print(wilecoyote)
	## this gets the location of the case in wilecoyote inside of palmtrees list
	for item in wilecoyote: #goes through list of case sections with breaks
		print("debugging in wilecoyote")
		print(item)
		####@@@++++++++++__+++========================
		toad = get_location_of_case("palmtrees",str(item))
		
		#print("we have this in toad=",toad)

		roadrunner.append(toad) #this returns a number the index position
	#print("ROADRUNNER list contains numbers of index locations of cases in palmtrees",roadrunner)
#################################################
	# make a new list based on digitalcandy
	#print("in digitalcandy at line 7988 we have",digitalcandy)
	thecounter=0
	for item in range(0,len(digitalcandy)): #using this for length of case sections sequence
		#filling list with fallthrus
		#print("what I am doing here is adding the Next case number so it's correct")
		  #I had to move the counter before it to get it working correctly
		british.append("fallthru" + str(thecounter + 1)) # current case number + 1 for next case
		thecounter += 1
	#this adds break after the loop finishes	
	british.append("break") #adds one more to list since default is extra case
	
	#print("========== british list ======")
	#print("british filler list =",british)
	#british[0] = "starter" #this is position 0 filler
	#british[-1] = "break" #last one must be break for default case
	#print("========== british list ======")
	#print("so here the british list should have breaks and fallthrus(with number to next case")
	
	#print("british list =",british)
	##################################################
	#this is walking thru the british list and replacing fallthru with break where there was a break in a case
	#the bug is here 
	#It's initially filled with all faltlhrus, so replace with break
	#Next I need to replace with fallthru with number 

	#print("==BIG LOOP TEST TO INSERT BREAK INTO FALLTHRU LIST CALLED BRITISH==")
	#print("what this does is replace fallthru with a break based on location of a break")
	#print("and this is in the british list")
	#print("this is using digitalcandy for the proper length of the new list roadrunner")
	############ this is where BREAK  is inserted into the list with replace method 
	mycounter=0
	#print("in crashing_waves_at_beach() around line 7942")
	#print("digitalcandy",digitalcandy)
	#print("roadrunner",roadrunner)
	
	#to debug
	#print("digitalcandy at line 8024",digitalcandy)
	#print("roadrunner at line 8025,roadrunner")
	for item in range(0,len(digitalcandy)):  #adding a case to it default
		if mycounter in roadrunner: #if it finds first case line number in roadrunner
			#print("this is where it is inserting break into the list british")
			do_replace(int(item),"break")## do_replace(1, 'break')  list[index number]
			mycounter += 1
		else:
			mycounter += 1
			
	#print("============================")
	#print("british is ",british) #break and fallthru list
	#this changes the first position slot to starter

	#this assigns values to specific elements in the british list
	#british[0] = "starter"
	#this ensures that the last one is a break no matter what it's force fed in. 
	#british[-1] = "break" #makes sure last one is break which is absolutely must be. 
	#print("here is the finished british list before adding teh fallthru with case")
	#print("british now =",british)
	##############
	#print("british list at line 8024=",british)
	#############
	#do this first  assuming of course default (worry about adding defaeult laster
	#check if "break" in switchcasetester
	#if False then add it to bottom of default
	#if no break in switch case it won't parse - sooo funny 
	
	####==================================================
	#print("=== OFFICIAL BRITISH LIST ==== USING SMART BREAKS AND FALLTHRUS NUMBERED == ")
	#print(british)
	########################################################
	british[0]  = "starter"
	british[-1] = "break" #just to be sure 
	#print("####################E#######################")
	#print("February 25th, 2021 Beach Coding with seagulls flying just above the waves ")
	#print('totally NEW OCEAN BEACH CODE TO MAKE NEW FALLTHRU INTO LIST OCEANWAVES')
	#print("which will be put into cranberries replacing what's in cranberries ")
	#print("=================-------- waves at abeach -------+++++++++=================")
	#print("======================= waves at beach and seagulls flying over ice plants =====")
	print("british list line 8593=",british)
	#print("palmtrees list =",palmtrees)
	#penguin.append('starter')
	for item in british:
		penguin.append(item)
	
	#print('penguin at line 8066',penguin)

	#penguin.append('break')
	#print("penguin= ", penguin)
	#print("starting length of penguin=",len(penguin))
	
	
	### new coding here 
	#print('british list=',british)
	newcounter=0
	#print("in crashing_waves_at_beach()")
	#print("length of palmtrees at line 8081 =", len(palmtrees))
	#print("palmtrees =",palmtrees)
	#print("around line 8004")
	#exit() #see if this works

	#print("british at line 8085=",british)
	#print("line 8086 palmtrees=",palmtrees)

	for item in range(0,len(british)):  #should only look inside of items starting with f
		if british[item].startswith("fallthru"):
			#print('item =',item)
			#print("newcounter =",newcounter)
			getnumber= british[newcounter] #gets the fallthruX
			
			getnumber = getnumber[8:] #gets the number from cutting off front fallthru
			getnumber = getnumber.rstrip()
			getnumber = getnumber.lstrip()
			#print("getnumber=",getnumber)
			newnumber = int(getnumber)
			
			casename =palmtrees[newnumber] #has cases in sequence
			#print("casename=",casename)
			mrfallthru = "fallthru("  + "'" + casename + "'" +  ")"#
			#print("mrfallthru =",mrfallthru)
			#do_replace(int(getnumber),mrfallthru)
			smart_replace(newnumber-1,mrfallthru)## just added minus 1
			#print("########### building the penguin list ")
			#print(penguin)
			newcounter += 1
		else:
			newcounter += 1
	newcounter = 0		
			
	#print("00000000000000000000000000000000")
	#print("british=",british)
	penguin[-1] = "break"
	
	#### I can change the contents of british or makea  new list so as to not mess it up.
	oceanwaves =[]

###########################################################################









tail_list=[]
cranberries=[]
cranberries.append('starter')
british =[]  # list for faltlhru and breaks for each section to be managed
roadrunner=[]
######################################
##  f22_fighter_jet()
######################################
#this is called if numbers is true:
#this is not called because I found a way
# to send the numbers thru the string parser
# I don't think that this is called 

def f22_fighter_jet(): #makes critical cranberries list which is the taillist for switch cases
	return #this kills it
	

###################################################
 
  #this makes the cranberries list which is the tail list used on codegen page
#diamonds=[[2,7],[7,17],[17,24],[24,34]]
#this makes the cranberries list

##===========================
##      def p51_mustange()  ==  adds the number to  fallthru(3) like that
##===========================
def p51_mustang(): 
	mytrace('p51_mustang')
	counter = 0
	c = 1		#current case number section
	d = c + 1
	#print("** inside of p51 mustange [[ digitalcandy ]] =",digitalcandy)
	royallist =[] #resetting this Friday april 9th
	#maybe in digitalcandy
	#print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	#print("digitalcandy in p51mustange=",digitalcandy)
	for item in digitalcandy:	#this is going through the diamonds list
		holder = digitalcandy[counter]
		x = holder[0]
		y = holder[1]
		##print("x",x,"y",y);
		case_tail_list_maker(x,y)   #here it is calling case_tail_list_maker
		counter += 1

	royallist.append('break');  #in default
	counter = 0
	#print("royallist at line 8223 =",royallist)


	#this goes thru the royallist with breaks and fallthrus(numbers)
	# starter 0  fallthru2 fallthru3 fallthru4  fallthru5 default
	#loops thru to royalist[item] then accesses the starbucklist[item to append
	# I can make fallthru('fish') and fallthru('default')  and have the formula working
	#I use numbering in royalist starter1(0) (position1 fallthru2)   (position2 fallthru3) etc
	#if they use big numbers I will put them inside of (number) and grab teh number startswith("(")
	#and endswith(")")
	#print("royallist =")
	#print(royallist)
	#for item in range(1,len(royallist)):
	for item in royallist:  #so royallist has starter break fallthru3 default in it 
		if "break" in item:
			cranberries.append("break")
		
		#print("this is where fallthru gears work line 2182")
		if "fallthru" in item:
			#### this grabs the number on the end of fallthru that is already there. 
			item=item.strip()
			#print("item=",item)
			item =item[-1]
			#print("after item[-1] we have item=",item)
			item = int(item)   #is this returning a number?
			## yea this is retrieving the number from the end of the word fallthru
			
			
			doggy =palmtrees[item] #just added -1   this is like fallthru('cherry')  #was starbucks
			#print("doggy",doggy)
			doggy[1:]  #deletes first item
			doggy[:-1] #deletes last item
			
			#this builds the fallthru(nextcase)

			#print("ohbaby which has fallthru from doggy starbuckslist[item]")
			ohbaby = "fallthru("  + "'" + doggy + "'" +  ")"#this is the number
			
			cranberries.append(ohbaby) # just added this Thrusday, sept 10th Target
			
		
	
		
	#print(wilecoyote[0])
	#print(wilecoyote)
	#print("firstcaselist now in palmtrees")
	#print(palmtrees)
	
	oceanwaves=[] #this sets it at empty
	#print(" ====== JUMANJI ====")
	#print(" ..................J U M A N J I ......inside of P51 Mustang() function..........")
	#add method here
	crashing_waves_at_beach()
	print("tyring to fill  list oceanwaves with british list")
	#print("here I am filing the list oceanwaves with the british list")
	print("british list which goes into oceanwaves list")
	print(british)
	
	for item in british:
		oceanwaves.append(item)
	
	#print("OCEANWAVES LIST now ",oceanwaves)
	#print(oceanwaves)
#I will needto add this to royallist
	
			
			
	
	#print("THIS IS THE TAIL LIST CALLED CRANBERRIES")
	#print("cranberries=",cranberries)
	#print("penguin=",penguin)
	
	#tail_list = copy.deepcopy(cranberries)
	#print("see if this works == making the tail_list")
	#for item in cranberries:
	#	tail_list.append(item)


# I will need to change this here and just have p51mustang
def stage_six():
    p51_mustang() #so it only calls p51_mustang now
    #firstcase = valve[0]
    #if firstcase == True:  #which means numbers like case 4:
    #    f22_fighter_jet()
    #else:
    #    p51_mustang()




#The purpose of this method == flyingcloud == is to
#fill small lists with
#the respective case names
#get case names in each set and add to list





#=====================================
#========== flyingcloud ==============  Thursday morning coding
#=====================================
case1list=[]
case2list=[]
wilderness=''
wild=''
#diamonds=[[2,7],[7,17],[17,24],[24,34]]



#forcing it to see what happens november 21st
#caselist7=['default']


#we will know before hand how many caselists will be filled 4

#this makes the first case list called starbucks which is used throughout the program
##==========================
##   flying fish             this loops through the digitial candy list of first cases
##========================== which are the line numbers of each case
def flyingfish():
	#print('digitalcandy=',digitalcandy)
	ax = len(digitalcandy)
	#print("length of digitalcandy =",ax)
	mytrace('flyingfish')
	mytrace('flyingcloud')
	x =''
	y =''
	z ='' #just reset z to nothing
	thecounter=0
	thecounter=0
	# loops through diamonds list of case position to build the first case list
	# which is called starbucks
	z = thecounter #which is 0 by default above
	z += 1  #then it starts at 1
	#print('digitalcandy=',digitalcandy)
	global candy
	#print('candy=',candy)
	#print("digitalcandy at line 8418=",digitalcandy)
	for item in digitalcandy:
		x = item[0]
		y = item[1]
		#print("** look at x,y,z here **")
		#print("x",x,"y",y,"z",z)
		flyingcloud(x,y,z) #z starts at 1 and adds 1 to z with each loop
		z += 1
		thecounter += 1
	z = 0
	thecounter=0
	nightowl()   #fills smartcasemanager





##==========================
##      flying cloud            
##==========================
#  this builds a list of the case names for each section
smartcasemanager=[]
smartcasemanager.append("['starter']")
def flyingcloud(x,y,z):
	#print("smartcasemanager=",smartcasemanager)
	words=''
	
	#print("flyingcloud called; this builds a list of the case names for each section")
	mytrace('flyingcloud')

	smartcounter=0
	#print("x,y",x,y)
	for line in switchcasetester.splitlines(): #switch case in JS
		#print("inside of loop values of x,y at top of for loop ",x,y)

		if smartcounter < x:
			smartcounter += 1
			continue

		#to stop going through string of code
		if smartcounter == y:
			break

		if "case" not in line:
				break

		if (smartcounter >= x and smartcounter < y) and ("case" in line):
			firstline = line.split()
			#print("length of firstline words =",len(firstline))
			words = len(firstline)  #this is the length of the first line
			
			#print("=========== line 2000 ===firstline====")
			#print("firstline=",firstline)
			if words == 2:
				wilderness = firstline[1] #this grabs the case name
				
			if words == 3:  #if 2 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]   
				
			if words == 4:  #if 3 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3] 
			
			if words == 5:  #if 4 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] 
				
			if words == 6:  #if 5 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5]
				
			if words == 7:  #if 6 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6]
				
			if words == 8:  #if 7 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7]
				
			if words == 9:  #if 8 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8]
				
			if words == 10:  #if 9 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8] + ' ' + firstline[9]
				
			if words == 11:  #if 10 words for case 
				wilderness = firstline[1] + ' ' + firstline[2]  + ' ' + firstline[3]  + ' ' + firstline[4] + ' ' + firstline[5] + ' ' + firstline[6] + ' ' + firstline[7] + ' ' + firstline[8] + ' ' + firstline[9] + ' ' + firstline[10]
			
			wild= wilderness[1:-1]
			#print("wild=",wild)
			wild = "'" + wild  #adding a ' to left side of word
			darn = wild[1:-1]
			wild = darn
			
			############# feb 6, 2021
			
			# will need to use the case or counter number and
			# use eval to just do this with one if
			eval("caselist" + str(z) + ".append(wild)")

		else:
			if "case" not in line:
				break

#############################################
einstein=[] #resets einstein to empty
	#========================================
#this fills up smartcasemanager list




#============================
#      nightowl()
#============================
def nightowl():
	#print("===== nightowl() called ======")
	mytrace('nightowl()')


	i = 1
	#this filles the list smartcasmanager skipping 0 position
	#while i <= len(digitalcandy):  #use range here
	for item in range(1,len(digitalcandy)):
		eval("smartcasemanager.append(" + "caselist" + str(i)+ ")")
		i += 1

	i+=1
	eval("smartcasemanager.append(" + "caselist" + str(i)+ ")")

	#this copies smartcasemanager and puts it into list einstein
	for item in smartcasemanager:
		einstein.append(item)



#this prints out the smartcasemanager list to verify that it worked and has the sublists

#=================================
def goodseason():
	mytrace('goodseason')




def stage_seven():
    #print('stage seven')
    flyingfish()


wilson=''
mystring =''


#or am I using the current case number or next case number for fallthru
#so does it represent the current location and then we add 1 to it or does fallthru(#) have
#the next number position embedded in it already
#this will go through the list and convert the fallthru(#) into names making the gold tail list
#which is used to build the case sections
bronzelist =[]
#I think it will already have it in it calculated currecent case section number + 1

#============================
#      wildgame
#============================
def wildgame(y):   #this gets the number out of fallthru(5) and converts it to the casename
	mytrace("wildgame")

	mystring='fallthru(' + str(y) + ')'  #this gets the number from fallthru to use in starbuckslist to get case name
	#print('mystring=',mystring)

	wilson=int(''.join(filter(str.isdigit, mystring)))  

	#this extracts the number from fallthru(5) and gets the 5

	#print("the input number it sees in fallthru as input",wilson)
	newnumber = wilson + 1
	#print("newnumber=",newnumber)
	newnumber = int(newnumber)
	#print("the output fallthru number for next case name after adding 1 = ",newnumber)
	answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
	#answer should be a string which is the case name
	ohbaby = "fallthru('"  + answer  + "')"  #this is the number
	#print("we now have ",ohbaby)   #this should be "fallthru('casename') which is put at bottom of a case section
	ohbaby =ohbaby.strip() #this is beautiful
	#it looks like this:   fallthru('fish')
	return ohbaby   #first time I recall using return in python for anything










goldtaillist =[]
#I need to loop through this list and create the new list for final gold tail list
def autumn():  #this builds the break fallthru(nextcasename) list
	mytrace('autumn')
	counter =0

	for item in starbuckslist:
		print(item)
		#goes through list


		if item == "break":
			#print('break found')
			goldtaillist.append("break") #how come it doesn't append this
			counter += 1


		if  "fall" in item:
			result =wildgame(counter)  #it wants a number use the counter
			#print("wildgame() result=",result)
			goldtaillist.append(result)
			counter += 1
		else:
			counter += 1

		if item == "starter":
			goldtaillist.append("starter")
			counter += 1
			continue

		if item == "default":
			goldtaillist.append("default")
			counter += 1
			continue

	#print("goldtaillist =",goldtaillist)




#autumn()



crushit =[]


#thurday, september 10, 2020 truck stop insight
#=============== stars() =============================
#=========== this goes thru dummy list with just starter fallthru and break and default
#==========/=== and adds the numbers of teh fallthru locations into cru0list
#=======================================================

miraclelist=[]

####################
##    stars()
####################
def stars():
	mytrace('stars')
    #print('STARS test of loking for words in list')
	#print('look for break default starter fallthru')
	#print("listnow =",listnow)
	counter =0
	#print("starting looking in loop")

	for item in listnow:
		if "break" == item:
			#print('break')
			crushit.append("break")
			counter += 1

		if  item.startswith("f") == True:
			#print('fallthru found')
			crushit.append("fallthru('" + str(counter) + "')")
			counter += 1

		if item.startswith('d') == True:
			#print("default found")
			crushit.append("default")
			counter += 1

		if item.startswith('s') == True:
			#print("starter found")
			crushit.append("starter")
			counter += 1



	#====
	#starter is 0 but not a case
	#first case is position 1 (if fallthru(1)) it becomes fallthru(2) for conversion
	#so it is based on current position for the current case and then the NEXT case is +1
	#==========================================
	#input must be 1 or higher but less than the length-1 can't be starter (0) or default(length-1)
	wilson=''
	newnumber=''
	counter =0
	for item in cru0:
		if item.startswith("f") == True:  #fallthru or fallthrough
			#print("fallthru found")
			mystring=item
			#print('mystring=',mystring)
			wilson=int(''.join(filter(str.isdigit, mystring)))   #this extracts the number from a string
			newnumber = wilson + 1
			newnumber = int(newnumber)
			answer =starbuckslist[newnumber] #this gets teh string word out of the starbucks list of case names
			ohbaby = "fallthru('"  + answer  + "')"
			ohbaby =ohbaby.strip()
			miraclelist.append(ohbaby)
			counter += 1

		if item.startswith('d') == True:  #default is last case needs to have break
				#print("default fuound")
				miraclelist.append("break")
				counter += 1

		if item.startswith('s') == True:
				#print("starter found")
				miraclelist.append("starter")
				counter += 1

		if item.startswith('b') == True:
				#print('break')
				miraclelist.append("break")
				counter += 1








#======== adderrsmill==============================
case_main_body_list=[]
 #this is to fill up position 0

z =''


# big gears filling list with case bodies of python code



#################### this is where the case section bodies are added to a list
#################### case_main_body_list



################################################
##  big_gears_filling_list_with_case_bodies()
################################################
def big_gears_filling_list_with_case_bodies():
	case_main_body_list.append('starter')  #moved this here 
	mytrace('big_gears_filling_list_with_case_bodies')
	#print("================big gears filling list with case bodies called==========")
	#breakpoint()

	counter=0
	#print("=====DIGITAL CANDY ======")
	#print("digitalcandy=",digitalcandy)
	for item in digitalcandy:  #=[[2,14],[14,26],[26,33],[33,3],[38,43],[43,47]]
		#print(item[0],item[1])
		
		counter += 1
		#print("counter=",counter)
		smarty(item[0],item[1])  #snowtime is called here
	#case_main_body_list.append('default')

import re  #for regular expressions
#this one
handy_list_of_tabs=[]
dual_slots=[]
crummy =[]
fiasco =[]
n_count_per_section=''
case_section_lines_of_code=[]

#new idea have line count based on first line of code in THIS section after if case
#and the first line is 1 and not 0 so it's human math thinking

def smarty(x,y):  #this grabs the body from one case section at a time
	mytrace('smarty')
	#print("in smarty what is in case_main_body_list",case_main_body_list)
	
	#print("smarty x y testing blank lines existence to delete them")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	for line in switchcasetester.splitlines():
		if mycounter > x and mycounter < y \
		and "case" not in line and "break" not in line and "fallthrough" \
		not in line and "fallthru" not in line  and "}" not in line \
		and "{" not in line:
		#this takes out the empty line by skipping it
			#print("line=",line)
			#added this sept 17 2020 to eliminate empty lines that do and mean nothing
			if len(line) == '\n': #this means that the line is empty
				
				mycounter += 1 #see if this is necessary here or not
				continue
			else:
				

					#by default each line will require 2 tabs in front of it
				line=line[1:] #takes off first tab off from front of line

				# ============== Glory =======================
				practicestring1 += line + "\n"  #this puts the lines of the string into practicestring1
				#=============== Glory =======================

		mycounter += 1

	#this would be the string and nuke last line trailing \n which I know will be there
	practicestring1 = practicestring1.rstrip("\n")
	### and here the practice string is added (appended) to case_main_body_list
	#print("this is WHERE a line inside of a case section is added to case_main_body_list")
	case_main_body_list.append(practicestring1)  #the body case code is added here
	#print("case_main_body_list=",case_main_body_list)
	del practicestring1  #this nukes it
	practicestring1 =''  #here we nuke practicestring1 so I can reuse for each case section
	#print("=========")
	#print("list of tabs=",handy_list_of_tabs)
	#print("number of lines with code =",len(handy_list_of_tabs))
	#print("pairs tabs and line number ",fiasco)
	#print("number of lines in each section =", n_count_per_section)
	#case_section_lines_of_code.append(n_count_per_section)
	#print("=========")
	#print("==== attempting to print out cases section code from case_main_body_list")
	acounter=0
	for item in case_main_body_list:
		#print("==========")
		#print(item)
		acounter += 1
		#print("case=",acounter)
		#print(item)
	

def loop_thru_case_sections():
	#print("======== loop thru case sections =============")
	mytrace('loop_thru_case_sections')
	#print("loop thru cases sections which is a list")

###############################################################################
###############################################################################
#TUESDAY CODING February 7th outside Panara Bread

##  THIS IS TO REPLACE A WORD IN A LIST
#################################
##  replace_in_list(number,word)    replace_in_list(2, 'fallthru')
##################################
# replace word in list by index position
def replace_in_list(x,y,z):  
	z[x]= y   #listname[5] = 'word'
	#print(z)  #print(listname)

#  new_replace_index(x,y)  uses two variables and 
#  hard code list name and call replace_in_list(x,y,z)
def new_replace_index(x,y):  ###<<=========== I hardcode the list name NOT a string
	z=fruits  #list name
	replace_in_list(x,y,z)   ##<<==== it calls the method above brilliant
	#print(fruits)
	


fruits = ['apple', 'banana', 'fallthru']

fruits.insert(1, "orange")

#print(fruits)

fruits[0] = 'starbucks'
#print("")
#print(" changing replacing value")
#print(fruits)
end = len(fruits)-1 # last index position

#this should put tophat into front of list
new_replace_index(0,"tophat")   #<<==== look here oinly using 2 vars
replace_in_list(1, 'break',fruits)
replace_in_list(2, 'fallthru',fruits)
replace_in_list(end, 'break',fruits)
#replace_in_list(0, "starter",fruits)
fruits=[]
fruits.append("starter")
ii = 0
while ii < 10:
	fruits.append("fallthru")
	ii += 1  #always add the dam counter
	
	
#need to have a list with the NUMBER in sequence of case sections with break
# like this  listofbreaks=[1,2,5,6,7,9]

#print(fruits)
replace_in_list(end, 'break',fruits)
#print(fruits)
replace_in_list(2, 'break',fruits)
replace_in_list(3, 'break',fruits)
replace_in_list(4, 'break',fruits)
replace_in_list(8, 'break',fruits)
replace_in_list(9, 'break',fruits)
end = len(fruits)-1 # last index position
replace_in_list(end, 'break',fruits)
#print(fruits)
#print("=====")
new_replace_index(end,"panera bread") 
new_replace_index(6,"break") 

#print("=== the end here of replace for now ===")


#==================
#Output

#['apple', 'orange', 'banana', 'fallthru']

#changing replacing value
#['starbucks', 'orange', 'banana', 'fallthru']
#['starbucks', 'break', 'banana', 'fallthru']
#['starbucks', 'break', 'fallthru', 'fallthru']
#['starbucks', 'break', 'fallthru', 'break']


######################################








#loop_thru_case_sections()  #=================


#######################
##  stage_eight()
#######################
def stage_eight():
	mytrace('stage_eight()')
	#print('stage eight')
	loop_thru_case_sections()


icecream=''
def herewego(): #loops and prints all main bodies
	mytrace('herewego')
	

	counter=0
	#this loops thru the case_main_body_list
	for item in case_main_body_list:
		if counter == 0: #skips the first slot "starter"
			counter += 1 #I forgot the bloody counter
			continue

		#print("=========================================")
		#print(case_main_body_list[counter])

		icecream= case_main_body_list[counter].count("\n")

			#myString = practicestring1
			#	print(myString)  #below zapping out pesky tabs at front
			#	# uses regular expression to nuke tabs
			#	output   = re.sub(r"[\t]*", "", myString)

		#print("==== ICE CREAM number of lines of code in section =====")
		#print("the number of lines of code in this  section=",icecream, "section",counter)

		#print("================================",counter)
		counter += 1




	#print("experimenting here in here we go")
	#get length (number of lines) of each
	#body_size = len(case_main_body_list[3])
	#print("the number of lines =",body_size)

#print("")

acounter=0
#for item in case_main_body_list:
#	print(len(item))
#	acounter += 1



#print("digitalcandy=",digitalcandy)
#big_gears_filling_list_with_case_bodies()
#herewego()  #==================================




##########################
##  stage_nine()
##########################
def stage_nine():
	mytrace('stage_nine()')
	#print('stage nine')
	big_gears_filling_list_with_case_bodies()
	herewego()


#print("tail_list cranberries =",cranberries)
###=============================================================================
x = 0;y =0
smart=''
#cranberries=[]
#print("at this juncture line 9166 what exactly is in list of rows of case names list")
#print(list_of_rows_of_case_names)

list_of_rows_of_case_names=[]
for item in list_of_rows_of_case_names:
	del item
#print("length of list_of_rows_of_case_names=", len(list_of_rows_of_case_names))


#making case section sublists here
#this is for making the variable lists to fill the case sections of cases
# and to refer to each of these caselists with ifs and elifs


#########################
##   make_case_sets()
#########################
def make_case_sets():
	mytrace('make_case_sets')
	#print("===== make_case_sets called ====")
	acounter = 0
	firstcasesectionlist=[]
	firstcasesectionlist.append("starter")
	 #this will be the case name
	#print("we have length of ", len(digitalcandy))
	#print(digitalcandy) #so we can see our input values of digitalcandy list
	for item in digitalcandy:
		x = None  #zap them out perhaps
		y = None
		#what = digitalcandy[acounter]
		x = item[0]; y = item[1]

		z = acounter
		partynation(x,y) #partynation called here------ PARTYNATION -----------
		acounter += 1
	#adding default to see if it works
	#firstcasesectionlist.append("default")
	#this happens after the loop has finished
	#print("what 9999 is this =",firstcasesectionlist)
	#print("----------")
	counter=0
	list_of_rows_of_case_names.append(firstcasesectionlist) #since this will be the last one
	castle_time()

smartcasemanager=[]  #creating the initializing smartcasemanager



#this just prints it out the sets of the cases for each case section
def castle_time(): #fills up smartcasemanager
	mytrace('castle_time')

	#list_of_rows_of_case_names.append("[['default']") #trying this
	#print("============CASTLE_TIME called ===========")
	count=0
	while count < len(list_of_rows_of_case_names):
		if count == 0:
			count +=1
			continue
		#print(list_of_rows_of_case_names[count][1:])
		count += 1

	#print("more testing to get this right")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	##################################################
	### SMARTCASEMANAGER LIST FILLED HERE ############
	##################################################

	#this fills up list smartcasemanager from list_of_rows_of_case_names
	#this is doing a brute force copy of a list

	#print("list_of_rows_of_case_names",list_of_rows_of_case_names)
	#print("this is what is in list_of_rows_of_case_names")
	#for item in list_of_rows_of_case_names:
	#	print(item)

	del smartcasemanager[:] #this doesn't seem to work 
	while len(smartcasemanager) > 0:
		for item in smartcasemanager:
			del item
	#print("what is in smartcasemanager now???",smartcasemanager)

	#print("smartcasemanager should be empty now",smartcasemanager)

	#print(smartcasemanager)

	#print('after deleting last item in list')
	#print("this is what is in smartcasemanager",smartcasemanager)
	#print("the length of smartcasemanager is", len(smartcasemanager))

	finallist = ['default'] #see if this works
	list_of_rows_of_case_names.append(finallist)
	#print("this should be default below======+++")
	#list_of_rows_of_case_names[-1]
	#smartcasemanager.append("['default']") #using a default case so it can be fallthrud from above
	#print(smartcasemanager) #now we add default to the end or do we need to or not


############################
#        partynation 
############################
list_of_rows_of_case_names=['starter']
firstcasesectionlist=['starter']
def partynation(x,y):  #this grabs the body
	mytrace('partynation')
	#print("====partynation======")
	global practicestring1
	practicestring1 = ""
	mycounter=0
	firstcasesectionlist=[]
	firstcasesectionlist.append('starter')
	#start loop
	#this specifically is looking for the word case
	for line in switchcasetester.splitlines():   #so if they are together  stacked
		if mycounter >= x and mycounter < y \
		and "case" in line:     #just added default
			genius = line.split()
			wild=genius[1].strip()
			wild = wild[:-1]
			wild = wild[1:-1]

			firstcasesectionlist.append(wild)  #adding this case name to firstcasesectionlist

		mycounter += 1
	#end loop
	#This is forcing default into firstcasesectionlist
	#wild = 'default'   #major test here
	#firstcasesectionlist.append(wild)
	for item in firstcasesectionlist:
		item.replace('"',' ' )


	firstcasesectionlist[1:-1]
	for item in firstcasesectionlist:
		item.replace('"',' ' )
	#here the currently newly minted case list is added to the big list
	#which is called list_of_rows_of_case_names
	list_of_rows_of_case_names.append(firstcasesectionlist)



	firstcasesectionlist= []
	#firstcasesectionlist.append('starter')




def testingthis():
	mytrace('testingthis()')
	#print(" this prints out the contents of the important lists")

	#print("==============================================")
	#print("digitalcandy list ========")
	for item in digitalcandy:
		pass #print(item)
		
	global candy
	for item in candy:
		pass #print(item)
		
	#print("starbucks list ====of first case names in each section ====")
	#print(starbuckslist)

	#print("smartcasemanager list ========", len(smartcasemanager))
	
	#for item in smartcasemanager:#
	#	print(item)
	
	#print("============")
	#print("case_main_body_list list ========", len(case_main_body_list))
	
	#for item in case_main_body_list:
	#	print(item)
		#print(item)
	#=== code gen here ====



####################
##    stage_ten()
####################
def stage_ten():
	mytrace('stage_ten()')
	#print('stage ten')
	make_case_sets()
	#testingthis()



#I just need the lists to build my code generation now to generation
#the logic right

#codegen is using the output lists from the parser

#this is the taillist

#this is bringing it altogether simulating it creating the
#switch case in three parts
#with a counter and a loop

#trace()
#lists for starbuvks_drive_thru_code.py
caselist     =[]
breaklist    =[]
fallthrulist =[]
defaultlist  =[]
blanklines   =[]
mixedlist    =[]
batterondeck =[] #I can have item to comapore with in here
seriestogether =[]
res =[]


alphalist =  ["a", "b", "c","d", "e","f","g", "h", "i","j","k","l","m","n", "o","p","q","r", "s", "t", "u","v", "w","x","y",":",";","(",")","{","}"]

#this will be the first
#print("this will run at the top of the page and call the functions in sequence\n")
#cranberries=[]
my_godzilla_list=[]
newlist=[]
smartylist=[]
tryagain=[]
coollist=[]
#test data here it will be one file and just flow down with no imports
#rodan=[2,7,17,24,34]

tabs =['starter',"\t","\t\t","\t\t\t","\t\t\t\t","\t\t\t\t\t","\t\t\t\t\t\t"]



#I just turned these off at the bottom

'''
sunrise=[]
fishfood()
fortunate()
test1()
testhere()
'''
###################
#       get() 
###################
#this is a return value in varholder[1]
def get(x):
	switch_return_value.append(x)
	#print("inside of switch_return_value[1]")
	#print(switch_return_value[1])


firstcaselist=[]

#digital_candy=[[2, 7], [7, 17], [17, 24], [24, 34]]

switch_python_gen=''










###=================================================================
###  below I get the location of default and closing curly brace for end of switch
###  this is to be used for determining the default case which is utilized for
###  the situation of a fallthru down into default
###  this also adds one more case tothe regular cases and I need these parameters

#print("============ surgery here S=================================")
#print("")



##########################
##  make_default_case()
###########################
def make_default_case():
	mytrace('make_default_case()')
	find_default = get_default_location()
	#print("NEW location of default =",find_default)

	lastbrace = get_closing_brace()
	#print("NEW location of closing brace =", lastbrace)


	#digitalcandy.append
#november 21st coding
#make_default_case()

## what I still need to put together to have the body of the default case
## and that will be used for the default case and the body of the else:


 ##so if line is > default and line is < lastbrace
 ##and "break" not in line
 ##and fill practice string and append the pracietce sting to case_main_body_list
##use snow(x,y) and a loop to grab the lines of code inside of default
##make sure "


#print(" this prints out the contents of the important lists")

#print("==============================================")
#print("digitalcandy list ========")
#for item in digitalcandy:
#	print(item)



#print("they all need to start with 'starter' in position 0")
#print("the big 3 need to have the same number of elements for the length to be the same")

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus
# digitalcandy

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#=============================================================
# smartcasemanager list   #list of lists of case names
# case_main_body_list     #body python code for each case section
# tail_list               #breaks and fallthrus

#===== inputs ========
#firstcasesectionlist
#list_of_rows_of_case_names
#case_main_body_list
#cranberries #taillist

#what smartcasemanager output looks like in ufos file
#this was tyhe failed attempt at managing the indentation over to the left
#for the switch case output in python and I have a simpler solution I will end up using.




		#counter += 1














##########################
##  parktime()
###########################
def parktime():
	mytrace('parktime')
	import re
	myString = "\t\t\tI want to Remove all white \t spaces, new lines \n and tabs \t"
	#print(myString)
	output   = re.sub(r"[\n\t]*", "", myString)

 #seeing teh contents of stanford
def what_is_in_stanford():
   # print("what is in stanford")
    print("len of stanford =",len(stanford))
    for item in stanford:
        print(item)
        print("---------------")
        
##########################
##      stage_eleven()
###########################
def stage_eleven():
	mytrace('stage_eleven()')
	#print('stage eleven')
	parktime()


#input for the switch case happens (above) the docstring JavaScript switch case interface

#made June 29th, 2021 
#this changes switch to inswitch and fallthru into infallthru
#this is required for doing nested switches 
#nested_switch[0] must be = True
#paloalto[0]




######===================================================================
###======== switch_code_gen here ============
# add error mistake if no input for exp it will do nothing
# this is good for me to think of adding
# also add break if no break in default for input from js switch
# monday dec 14th thinking
# need to add input stuff here that is in the top running betterworks

sw=''
sweet =''
switch_gen=''
#testing input here
  #this has to be above the generated code

testlist=[]
exp =''
##############################
tahoetest=[]
tahoetest.append(0)
nested_switch=[]
nested_switch.append(False) #default testing 

main_switch=[]
main_switch.append(0)
main_switch[0]=0

#added this on June 28th, 2021 7:08 pm
gti=[] #this saves the output for the main switch by default no matter what (CATCHES IT)
execute_main_switch=[]
execute_main_switch.append(0) #this just creates position 0
###############################	
funny=[]
funny.append(0)  #used for testing nested switch
	
	
	###================= june 29th editing ===================
'''
	print("this is the test_flag") 
	if execute_main_switch[0] == True:  #flag  execute_main_switch
		exec(sweet)
	else:  #if False then store teh string for later use 
		#print(sweet)
		paloalto.append(sweet)
		print("this should be the main switch printed out, and not executed")
		print("paloalto=",paloalto[0])
	####============= june 29th 2021  testing ==================	
	print("try the magic add infallthru and inswitch june 29th,2021")
	if nested_switch[0]== True: 
		print("yes nested_switch[0] == True")
		seal1 = paloalto[0]
		x1 = seal1.replace("switch(exp)", "inswitch(exp)")
		paloalto[0] = x1
	
		seal2 = paloalto[0]
		x2 = seal2.replace('fallthru(', 'infallthru(')
		paloalto[0] = x2
		#print(paloalto[0])
	else:
		pass
		
'''

# this replaces switch to inswitch and fallthru to infallthru
# after the python has been generated

#def modify_for_nested_switch_method(x):


#paloalto=[]
#def change_switch_and_fallthru_for_nested_mode(inputlist):
#	return
#	if nested_switch[0]== True: 
#		print("yes nested_switch[0] == True")
#		seal1 = paloalto[0]
#		x1 = seal1.replace("switch(exp)", "inswitch(exp)")
#		paloalto[0] = x1
#	
#		seal2 = paloalto[0]
#		x2 = seal2.replace('fallthru(', 'infallthru(')
#		paloalto[0] = x2
#		#print(paloalto[0])
#	else:
#		pass

###########################
# june 30th 2021  wednesday testing gathering the output of the code gen into stanford list
stanford=[]  #I am not emptying this so it should just fill up
################################
##      switch_code_gen()                                                                 ###
################################
#this takes in lists calculated above and generates a string of python switch case code
def switch_code_gen():
	mytrace('switch_code_gen()')
	#####
	
	
	#Here I am putting the contents of penguin into cranberries
	#print("this is where I empty cranberries list and fill it with penguin")
	del cranberries[:]  #emptying cranberries here 

	for item in penguin:  #this works - how wonderful
		#print(item)
		cranberries.append(item)
		
	
	
	###########  march 7, 2021  #######################################
	# I think that I just need to loop through casemainbodylist
	# and append cranberries based on teh counter and then eliminate the third tier below
	# what I am doing is adding teh cranberris(one liner break or fallthru to the case_main_body_list
	####################################################################

	
	
	case_main_body_list_with_tail=['starter']
	
	######## acounter is HERE on next line
	acounter=1
	
	for item in range(1,len(case_main_body_list)):
		felix = case_main_body_list[item]
		#print("inside of the parser ========")
		#print("====I am looking inside the case_main_body_list here===")
		#print(felix) # I would get what case I am in here 
		#print("====acounter=", acounter ,"============")
		
		# removes newlines after lines of code
		victory = felix.rstrip()
		
		victory +="\n\t\t"+ cranberries[acounter] #tacks on break/fallthru
		
		case_main_body_list_with_tail.append(victory)  #appends the melding together to 
		
		victory=None
		victory=''
		                                 #case_main_body_list_with_tail
		#print("--------------")
		
	
		acounter += 1
	
	
	#==== end loop ======
	
	anewcounter=0
	
	
	


	##############
	topvars2 = "\n\n" #"\nexp = varholder[0]\n\n"


	#this builds the case lists for each case section
	#which are used when it says: if case in caselist2:

	numb = 1
	counter = 1
	#thedefault = "['default']"
	# for i in range(len(list_fruits)):
	numberofcaselists = len(einstein)-1 #was using smartcasemanager but polluted
	###################################################
	#   this is printing out the caselists at the top
	###################################################
	
	#print("einstein=",einstein)
	
	#--- testing dec 24th for varholder[0] input word ----
	#------------------------------------
	top_input_of_exp = "exp = varholder[0]" 
	
	# "varholder.append(exp)\n" +
	#print("varholder[0] =",varholder[0])  
	#new line to see the input expression exp from clever

	
	print(varholder) #added this to see what the input in clever is
		#-------------------------
	# this prints the case lists of the words in each case section
	


	einstein.append("default")  #adding default to the end of einstein copy list
	
	#print("einstein list",einstein)
	
	
	
	 
	for item in range(1,len(einstein)):     #first loop was smartcasemanager
		trains =  str(counter)
		merge = "caselist" + trains    #caselist1
		toosmart = eval(merge)
		caselist = merge + " = " + str(toosmart)    #this is the caselist name we eval to display it
		#print(caselist)
		testlist.append(caselist) #trying a hunch here
		######################
		#inside1 = caselist  #this is only apparently capturing the last one
		#####################

		counter += 1
		numb += 1
		
	#after loop finished we have the caselists generated captured inside of testlist
	
	##############################################
	switchy= "switch(exp)\n" +"while True:\n\n" #=====
	##############################################

	print("")

	mycounter =1 #it was 0
	#size=  #notice -1

	front="case in caselist"

	#this makes each case section
	#=======   LOOP  =================
	# I will need to use the first part, second part, third part
	# I will use three seperate lists that work in tandem to hold the variable strings
	# which will then be accessed to concat the strings in the proper order
	#=================================
	firstpart =[]
	secondpart=[]
	thirdpart =[]
	extremelysmart=[]
	
	

	#just changed this to range(0,len(case  it was range(1,len(case 
	for item in range(1,len(case_main_body_list_with_tail)):       #second loop
		if mycounter == 1:
		#============  first section case=============

			first_if= tabs[1] + "if " + front+str(mycounter)   + ": #"
			toosmart = eval("caselist" + str(mycounter))

			newlist = [first_if, toosmart]
			##############################################################
			sofrustrated =str(newlist[0]) + " " + str(newlist[1]) #=== only catching last one==
			extremelysmart.append(sofrustrated)
			###### firstpart adding if line ###########
			firstpart.append(sofrustrated) #this feeds the if line into first part list
			### these are the case sections AFTER the FIRST CASE SECTION  	
			# this is different because it starts with an elif instead of the first if
		else:    #rest of cases after first case ======
			restofifs= tabs[1] + "elif " + front+str(mycounter)+ ": #"
			toosmart = eval("caselist" + str(mycounter))
			newlist = [restofifs, toosmart] #comments put case names to right of caselistnumber
			caselistline = str(newlist[0]) + " " + str(newlist[1]) #=====
			extremelysmart.append(caselistline)
			firstpart.append(caselistline) #this feeds elif line into first part list
		
		######################
		#=== second part of each case section
		weasel= case_main_body_list_with_tail[mycounter]   ### RIGHT HERE 
		secondpart.append(weasel) #this feeds the string body into secondpart

		######################
		#=== third part of each case section
		#this is the tail either break or fallthru(name)
		
		
		mycounter += 1     #loop counter
	
	#=== END LOOP  =============================================

	################
	theelse = tabs[1] + "else:"  #this is just once
	firstpart.append(theelse) #this feeds the else clause into first part
	#this is the last real case after the regular cases

	##################3
	 #last case body for default

	lastishcase =case_main_body_list_with_tail[-1]

	secondpart.append(lastishcase)  #this feeds the body into secondpar

	##########################
	
	#this works this creates the strings of the caselist at the top above switch correctly
###============================================
# caselists concatted to string cool
	cool=''

	#== LOOP === these are stored in list called testlist
	for item in testlist: #to see if the caselist names are in here  in this list
		cool += item + "\n"
		#print(item)
	#== end loop 
	
	cool += "\n\n"

	#== END LOOP

################################################################################################
##### march 7th, 2021  I think I just add thirdpart to end of second part (it's just one line)
################################################################################################
#===case sections three parts at once ==")
	rocks=''
 #=====================
 #== LOOP
	counter=0  #each section will have the same number of items
	for item in firstpart:
		rocks += str(firstpart[counter]) + "\n" + str(secondpart[counter]) + "\n\n"
		counter += 1
		#printing out the three part case sections")
 #=== END LOOP

	#adding strings together here
	#=========================================
	sweet = topvars2 + cool + switchy + rocks
	#=========================================
	###============== stanford. append(sweet) =============
	# putting sweet into list stanford june 30th, 2021
	# PUT GENERATED PYTHON SWITCH STRING INTO STANFORD LIST
	#=======================
	stanford.append(sweet) #Right here the output string is appended to stanford
	#=======================
	#here I am filling the list stanford with the sweet string before it's executed
	###=====================================================
	
	#here I will put exec(sweet) but testing multiple right onw
	
	print("=======sweet in code gen ==has this in it====june 21st==")
	print("=======sweet in code gen ==has this in it====june 21st==")
	print("=======sweet in code gen ==has this in it====june 21st==")
	print("=======sweet in code gen ==has this in it====june 21st==")
	funny[0]='' #clears it out first
	funny[0] = sweet
	print("june 29th progress Santa Cruz Avenue coding ")
	#del tahoetest[:]
	#print("just emptied tahoetest")
	#print(tahoetest)
	############ this takes out endswitch from python generated code
	##=-============june 29th, 2021 coding starbucks ===============
	# print(sweet) #this is the generated code 
# 	if "endswitch" in sweet:
# 		print("yes endswitch found in output")
# 		for line in sweet.splitlines(): 
# 			if "endswitch" in line:
# 				line = line.replace("endswitch","}")
# 				break
# 			else:
# 				continue
# 	print("new version of sweet")
# 	print(sweet)
	#so whenever I need to grab the main 
	#list gti will hold the main switch in position 0 always and is current
	gti.append(sweet)  #default this is saved 
	#when multiple switch is carried out I need to grab the main switch string
	#to add to the multi layer cake
	
	
	#what if we just capture this string so we can use it and save it if we need
	# it and so that solves the problem actually.
	
	
	#june 28th 2021=================
	#########----------------------------------------------
	#if doing_main_switch_with_nested_switches == True:
	#   #add main switch string which will have nested_switch_methods
	#   if len(multiple_switches) == 0: #not filled yet
	#       #add main switch to list 
	#        multiple_switches.append(sweet)
	#        
	#    if len(multiple_switches >= 1 and nested_switch[0] == True:
	#     
	    
	print("to execute it or not, yes if only one switch stanford len == 1 =")
	print("I will need to know based on before it is even run so I need to")
	print("count how many switches are in the switch string")
	print("based on that number we will KNOW before start inside of endswitch() ")
	print("if it is a solitary switch or a switch with nested switches inside of it")
	#listname switchcount
	
	## the list name will be called switch_count
	################# june 30th, 2021  10:02 am Santa Cruz Avenue Starbucks #############
	#this determines if we execute a switch string based on if there is ONLY one switch() in it)
	# because if there are more than 1 switches in it then it MUST HAVE nested switches
	print("this is INSIDE THE CODE GENERATOR in teh Silver Module")
	print("number of switches in this switch string is ",len(switch_count))
	print("we have a switch_count = ",len(switch_count))
	#switch_count is a list
	print("this is where the fuzzy logic determines if")
	print("the switch code in python is executed or NOT executed immediately")
	print("but is added to the stanford list which is automatic and then")
	print("it is put into a triple string to work in tandem with the nested switches")
	print("methods")
	print("LEN(SWITCH_COUNT=",len(switch_count)) #this will be for each switch string
	print("we have for len(switch_count",len(switch_count))
	'''
	if len(switch_count) == 1:
		exec(sweet)
	else:
		pass  #it is automatically already indenpendently added as a string to stanford list
	'''	
		
	#############################################
	if show_code[0] == True:
		print(sweet)
	else:
		#print(sweet)  #otherewise don't print it
		pass     
	    
	    
	    
	# here I will have the flag to show or hide the output 
	# to see what the generated code is.
	#############===================
	#################################
	#################################
	print("show_code =",show_code[0])
	if show_code[0] == True:
		print(sweet)
	else:
		#print(sweet)  #otherewise don't print it
		pass # do nothing
	#############===================
	#################################
	#################################

	#print('===== executing generated  code=====')
	# right now the nested output switch is a nested single switch
	# for doing what I want to do I need to create the main switch also
	# as a string and not execute it immediately.
	# today is June 28th, 2021
	
	########################################
	print("the input exp in clever was:: ",varholder[0]) #varholder[0]
	#print("")
	#this is where the generated python code (shown above) is executed
	
	#print("$$$ ===>> nested_switch[0]=",nested_switch[0])
	#print("what is in tahoe test at this point",tahoetest)
	#print("what is in tahoetest[0]",tahoetest[0])
	######################################
	
	
	
	
	
	##### this is to check to make sure that it puts sweet string into
	##### tahoetest[0] which is the first slot for now
	##### eventaully it will be several.
	#It is set before the switch string input in file test_inputs_beta
	#by default nested_switch[0] will be set at False
	## June 17th, 2021 testing Starbucks Santa Cruz Avenue
	#if nestedswitch True add sweet string to tahoetest[0]
	
	'''
	if nested_switch[0] == True:
		print("====nested_switch[0] = True ===",nested_switch[0])
		print("====don't execute generated python===")
		print("==== put it into tahoetest[0]===")
		## this says: put sweet into tahoetest[0]
		#############################################
		tahoetest.append(sweet) #this adds it in sequence
		# this captures the generated string and puts it into tahoetest list
		
	
		#this will needto append it rather then targeting tahoetest[0]
		#print insdeof this if let's see what it's lengthis
		print("length of tahoetest[0] =",len(tahoetest))
		print("let's immediatley see it's contents")
		print("===...===...===...==this prints out the generated python")
		print("tahoetest[0]=",tahoetest)
		#halloween=''
	'''
		#halloween = ''.join(tahoetest) #string from list to loop thru it
		######################################
		#decided I concat and build a string just use it - sweet
		#for line in sweet.splitlines():
			#if "break" or "fallthru" in line:
				#how_many_tabs=line.count("\t")
				#print("number of tabs =",how_many_tabs)
	'''
		#################################################
		print("==== /// \\\\ =====bottom of the output python hopefully")
	else:  # if nested_switch[0]= False
		#this means exec(sweet) which means it's not a nested switch 
		print("$$$ ==should be False=>> nested_switch[0]=",nested_switch[0])
		print("we are executing the generated code")
		
		main_switch[0]=gti[0] #this is a flow thru transfer by default
		
		#this will need to be set in bypass205
		
		if multi_switch_with_nested_switches[0] == True:
			print("don't execute it - don't run the output python")
			print("this is the main switch which we will add to the rest of the nested switches")
			print(gti[0])
			print(main_switch[0])
			#we can access gti[0] with the main switch python where we need it
		else: #means  multi_switch_with_nested_switches[0] == False
		
			#regular single switch with no nested switches within it
			exec(sweet)  #this is the building of the string of python code strings
	'''
	#####################################
	## testing ##### experimenting June 29th, 2021 Starbucks testing =======
	# remember that I wanted it to save each main switch by default
	# and only execute it if it is only switch in list so list length of 1  is True
	
	#paloalto=[]
	
	
	## what this does is use a flag to govern whether the main switch is executed
	## right off the bat. if execute_main_switch(first switch) is set to True execute
	## it means that there are no nested switches in it (except a method)
	## this is based on how many switches there are inside of the string
	
	#### this is a flag to determine if it is generated ######

	#change_switch_and_fallthru_for_nested_mode(paloalto[0])
	#print(paloalto[0])
	print("I jsut flipped it to False to see if it now doesn't ")
	print("put the sweet string of the python output into tahoetest[0]")
	print("what is in slot 1 of the list -the entire output string")
	#print(tahoetest[0])
	#print("what we have in tahoetest",tahoetest)
	#lets's look at tabs in line with fallthru
	
	
	# this runs the python switch code as ifs with the input
	# hard coded into it
	sweet=None
	sweet=''
	
	topvars2=None
	topvars2=''
	
	cool=None
	cool=''
	
	switchy=None
	switchy=''
	
	rocks=None
	rocks=''
	
	#print("")
	#print(" =====done executing output from switch ======")
	#print("")
	#print("testing this deletion of list with tail")
	case_main_body_list_with_tail=['']
	#print("we have",case_main_body_list_with_tail)	
		
	#print("now deleting this list case_main_body_list_with_tail")
	#case_main_body_list_with_tail=[] #hardcoded it to ensure it works
	firstpart=[]
	secondpart=[]
	thirdpart=[]
	extremelysmart=[]

#loop thru stanford list  dedc 15th wednesday morning 7"23 am
#print("==loop thru stanford list in snoopy_doghouse==")
#for item in stanford:
#    print(item)	
#this is called after switch_code_gen
#####managing_nested_switch_scenario():

## MANAGING NESTED SWITCH SCENARIO

def managing_nested_switch_scenario():
	print("=====managing_nested_switch_scenario() called=====")
	print("=====managing_nested_switch_scenario() called=====")
	if len(stanford) > 0: #meaning something is in Stanford
		#print('nested_switch[0] = True')
		print("stanford list length=",len(stanford))
		print("so do the building cake methods")
		print("lengstanfordth of stnaford is ",len(stanford))

	else:
		print('nested_switch[0] = False')
		print("nested switch is False do nothing more")

##3===================================================        













#this executes the generated python switch code
def stage_twelve():
	gti=[] #clears out gti list 
	mytrace('stage_twelve()')
	#changing to run second switch case january 15, 2021
	switchcasetester =''
	sw =''
	
	#print("hopefully this will empty smartcasemanager")
	#print("it current has this in it ", smartcasemanager)
	#print("it's current length =",len(smartcasemanager))
	
	
	#print("list_of_rows_of_case_names ", list_of_rows_of_case_names )
	del list_of_rows_of_case_names[:] #empties this list
	#print("list_of_rows_of_case_names ", list_of_rows_of_case_names )
		
	for x in caselist1[:]:
		caselist1.remove(x)
	
	for x in caselist2[:]:
		caselist2.remove(x)
		
	for x in caselist3[:]:
		caselist3.remove(x)
		
	for x in caselist4[:]:
		caselist4.remove(x)
		
	for x in caselist5[:]:
		caselist5.remove(x)
		
	for x in einstein[:]:
		einstein.remove(x)
	
	smartcasemanager=[]
	#print(smartcasemanager)
		
	for x in testlist[:]:
		testlist.remove(x)
		
	
	resetting_up_case_body() #clears out case_main_body_list then appends('starter') to it
	 
	
	smartcasemanager=[]
	

# right now the limit is 10 case sections I need to add to that


	
	#this seems to work whereas nothing above actually worked
	## only guaranteed way to empty lists completely 
	for item in range(0,len(palmtrees)):
		palmtrees.pop()

	for item in range(0,len(digitalcandy)):
		digitalcandy.pop()

	for item in range(0,len(einstein)):
		einstein.pop()

	for item in range(0,len(wilecoyote)):
		wilecoyote.pop()
		
	for item in range(0,len(candy)):
		candy.pop()
		
		
	for item in range(0,len(case_main_body_list)):
		case_main_body_list.pop()
		
	

	for item in range(0,len(birdsong)):
		birdsong.pop()
##3====================
	for item in range(0,len(caselist1)):
		caselist1.pop()

	for item in range(0,len(caselist2)):
		caselist2.pop()

	for item in range(0,len(caselist3)):
		caselist3.pop()

	for item in range(0,len(caselist4)):
		caselist4.pop()

	for item in range(0,len(caselist5)):
		caselist5.pop()

	for item in range(0,len(caselist6)):
		caselist6.pop()

	for item in range(0,len(caselist7)):
		caselist7.pop()

	for item in range(0,len(caselist8)):
		caselist8.pop()

	for item in range(0,len(caselist9)):
		caselist9.pop()

	for item in range(0,len(caselist10)):
		caselist10.pop()
##3==========
	for item in range(0,len(royallist)):
		royallist.pop()

	for item in range(0,len(cranberries)):
		cranberries.pop()
		
	for item in range(0,len(roadrunner)):
		roadrunner.pop()
		
	for item in range(0,len(penguin)):
		penguin.pop()
		
	for item in range(0,len(british)):
		british.pop()
		
		
	###############
	#print("gti",gti)
	for item in range(0,len(gti)):
		british.gti()
		
	#print("mochalist",mochalist)
	for item in range(0,len(mochalist)):
		mochalist.pop()
		
	#print("drive_thru",drive_thru)
	for item in range(0,len(drive_thru)):
		drive_thru.pop()
	#funny
	#print("case1findbreak",case1findbreak)
	for item in range(0,len(case1findbreak)):
		case1findbreak.pop()
		
	#print("case1findfallthru",case1findfallthru)
	for item in range(0,len(case1findfallthru)):
		case1findfallthru.pop()
		
	#print("defaultlist",defaultlist)
	for item in range(0,len(defaultlist)):
		defaultlist.pop()
			
	#print("seal",seal)
	for item in range(0,len(seal)):
		seal.pop()
	#print("this one is the HOLY GRAIL one")
	#print("line_numbers_of_first_cases",line_numbers_of_first_cases)
	for item in range(0,len(line_numbers_of_first_cases)):
		line_numbers_of_first_cases.pop()	

	#print('==== after clearing them we have ======')
	
	if len(palmtrees) > 0:
		palmtrees.pop()
	#print('after checking the length of the list this deletes more if greater than 0')
	#print("palmtrees=",palmtrees)
	#print("starbucklist=",starbuckslist)
	for item in digitalcandy:
		digitalcandy.pop()

	#print("digitalcandy=",digitalcandy)
	
	if len(einstein) > 0:
		einstein.pop()
		
	
	#print("=========")
	for x in smartcasemanager[:]:
		smartcasemanager.remove(x)
	#print("contents of smartcasemanager=",smartcasemanager)
	
	#print("see if this helps empty it smartcasemanager")
	for item in smartcasemanager:
		smartcasemanager.pop()
		
		
	
	del trontime[:]  #empties trontime list
	#print("now trontime =",trontime)
	



#==========================================================================================
#===== this is test what will be generated below after the python switch is generated above



####======= this is the input to the python switch
#input_list = ["fortune"]  #global var that will be fed into switch(x)








list1=[]
list1.append("five")












#========================
#bigtestofcodegen() #massive test here getting the output
#remember that the generated python switch will be invisible except for debugging purposes


#I turned this off to work on the generation of the python that this represents

#bigtestofcodegen()

#I will need the switch and fallthru functions now
#this counts the number of lines with \n in each case section

#############################################
#count number of n's in tail
#append 2 tabs to the front of each line to
# Slice string to remove 3 last characters
#mod_string = org_string[:-3]
#print(mod_string)
















def marine_one():
	mytrace('marineone()')
    #print("====== marine one called =====")
	#print(switchcasetester)
    #print("the number of tabs in this baby")
	tabnumbers =switchcasetester.count("\t")






# put this into a function
#switch_code_gen() ##=== this calls and generates the python switch case
				  ##=== this has the code generation of the python code
				  # and adds the generated python switch string to stanford list
#print(switch_python_gen)
#exec(switch_python_gen)




def pilgrim(): #testing import in another file
		print('pilgrim')


##############################
###      flush lists()
##############################
def flush_lists_previous():
	mytrace('flush_lists()')
	#print("flush_lists() called hallijua")
	gti=[]
	royallist=[]
	palmtrees =[]
	woodstock=[]
	oceanwaves=[]
	candy=[]
	digitalcandy=[]
	einstein=[]
	smartcasemanager=[]
	varholder=[]
	british=[]
	cranberries=[]
	

#case_main_body_list=[]
#this is new but I haven't tried 
# this has a sequence that must be followed for it to work 
##################################
## starter sequence mode 1
##################################
#this is for parsing and codegen of cases with words only
def starter_sequence_mode_1():
	print("it SEES in valve[0]",valve[0])
	#print("the if vavle[0] = False is the setting in here ")
	# valve[0] is False if words, it is True if numbers
	#this if means this can only run if valve[0] is False not numbers
	# I just made this change since both are now strings
	#########################################
	if valve[0] == True or valve[0] == False: #case numbers if True WAS False #means cases are words like "apple pie"
		mytrace('starter_sequence_mode_1()')
		
		convert_case_line_to_lowercase()  #right here for conformity all words lowercase
		badass()
		stage_one() 				## and if numbergs
		add_to_test_list()  #testing here
		#case_main_body_list.append("starter")
		stage_two()
		stage_three()
		stage_four()
		stage_five()
		stage_six()
		stage_seven()
		stage_eight()
		stage_nine()
		stage_ten()
		stage_eleven()
		#print('stopping just before switch_code_gen()')
		#quit() #see if this works
		switch_code_gen() #  <<<==============it's called right here the code generator
		#this creates the generated python string and puts it into (adds it to) the stanford list
		
		######### testing this to do next stages 
		######### if nested switch with several strings
		######### so that I don't just tack it onto switch code gen
		######### and this way it's done after stanford is filled with output 
		######### python stings
		managing_nested_switch_scenario()
		
		stage_twelve()  # <== this resets the lists for next use of switch
		########=== added june 16th, 2021 #####
		#uppercase reset to default 
		#set these after exec
		#this resets defaults to turn off uppercase yes 
		
		#uppercase_test[0] = False:
		#baseline[0]="nada"
		#############################
		clearit()
		global woodstock
		#print("what we have in woodstock=",woodstock)
		#print("now we clear out woodstock list")
		woodstock=[]
		#print("woodstock=",woodstock)
		global candy
		#print('what we have in candy=',candy)
		#print("now we delete its contents")
		candy=[]
		#print("candy=",candy)
		#flush_lists()
		global sw 
		sw = ''
		global switchcasetester
		switchcasetester =''
		smartcasemanager=[]
		print("smartcasemanager=",smartcasemanager)
		british=[]
		#print("british=",british)
		penguin=[]
		#print("penguin=",penguin)
		clear_out_all_case_lists() #doing 16 for now
		#show_tron_trace_path()
	else:
		pass
		
	
	showit()
	empty_test() #test of global list
	
	#flush_lists() #this is new january 16th, saturday debugging trying second switch case
	
daisy=''
m1=[]
m1.append(0)

sample_fish='''
 switch(x)    
    while True:                 
        if   case  == "one":
            print("this is the first case in the main ")
          
            ######################
            print("out of from  below")
            print("tahoe[0]=",tahoe[0]) #result of  running
          
            fallthru('word')   
                     
        elif case == "two":
            print("this is the first case in the main ")
            prelow")
            print("tahoe[0]=",tahoe[0]) #result of  running
            fallthru('word') 
            
        elif case == "three":
            print("this is the first case in the ")
            print("out of from  below")
'''
### just had idea if a nested method switch has yet another nested switch
#in it it needs to be changed to a method so it wouldn't happen.

listforfun=[]
listforfun.append(0)
inputstringswitches=[]
inputstringswitches.append(0)
inputstringswitches.append(0)

#after doing the silver module call this
#modify nested switch 
def modify_nested_switch():
    print("called modify switch for nested method switch")
    galaxy=''
    galaxy = sample_fish  #this is modifying string above for being a nested switch
    #listforfun[0]= galaxy
    inputstringswitches[1] = galaxy.replace("switch","inswitch")
    galaxy = galaxy.replace("fallthru","infallthru")
    inputstringswitches[1] = galaxy
    print("how does this look.... june 29th.")
    print(inputstringswitches[1])
    
    #inputstringswitches[1] = galaxy.replace("endswitch","}")
print("just checked it's not changing switch to inswitch for some bizarre reason")
print("that is a bug in the method and programming language python")
print("good thing I tested this thoroughly to find the bugs")
print("so this code above that should work DOES NOT work")
print("testing output string converted sample to nested type inswitch, infallthru")
print("=====[[[[[[[[[=quick testing I did a while ago juen 29th =====]]]]]]]]]]===[[[[]]''';;;;;;;;;")
modify_nested_switch()

#this works in fourth_of_july through dulegence 
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")
print(" TrYING TO DO SOMETHING SIMPLE super simple")

#x =dumbstringcode.replace("switch","inswitch")
#dumbstringcode=x

#y = dumbstringcode.replace("fallthru","infallthru")
#supergood = y

#print(supergood)
#print("did it finally work or not===========>>>>>")
#z = supergood  #this fixes a bug where the nested switch method is wrong
#y = supergood.replace("inner_inswitch","inner_switch")
#exam = y
#print(exam)
#print("===== end of good working code ==============")




####### TESTING 
print("testing doing a simple test of switch and fallthru changing it")
#modify_nested_switch(sample1)
#print(m1[0])


import re
def hasNumbers(inputString):
		return bool(re.search(r'\d',inputString))



	############################
	
			

##############  added April 2nd, 2021  ###############################################
# this is a pre scan of the switch case input string to determine if
# the cases are numbers like case 1 thru 5: or case 10 OR words like case "apple":
coffee=[]  #holds line number of first case in switch case
valve=[]
valve.append("nada")# 0
valve.append("sway")# 1 #so we have valve['nada','sway']
#these are just fillers they mean absolutely nothing

# this gets the line number of the first case in the switch case string
#####################################################
##  grab_first_case_of_switch_string(y)
##################################################### 
def grab_first_case_of_switch_string(y): 
	mytrace("grab_first_case_of_switch_string()") 
	#global switchcasetester
	mycounter = 0
	#this takes in sw to test for finding out if numbers like case 2: or words case "apple"
	for line in y.splitlines():
		if "case" in line:
			coffee.append(mycounter) 
			break  #here after getting the first instance of a case we leave the loop
		else:
			mycounter += 1
			continue

#####################################################
##  remove_tabs_from_string(y)
##################################################### 
def remove_tabs_from_string(y):
	mytrace("remove_tabs_from_string()") 
	y=y.replace("\t","")
	return y

#####################################################
##  grab_first_case_line_in_switch_case_string(y)
##################################################### 
def grab_first_case_line_in_switch_case_string(y):
	#global sw
	mytrace("grab_first_case_line_in_switch_case_string()") 
	#print(coffee[0])  #testing what's in this
	getline= eval("y.splitlines()[" + str(coffee[0]) + "]")
	#print(getline)
	return getline


##################################
##  check_if_number_in_string(x)
################################## 
def check_if_number_in_string(x):
	mytrace("check_if_number_in_string()") 
	theresult = any(char.isdigit() for char in x)  #this line from stackoverflow
	return theresult

###########################
##     parser_mode_1()
###########################
## testing April 3rd 2021 seeing if this works or not. 
def parser_mode_1(a):
	#print("a= ",a)
	mytrace('parser_mode_1 in switch_cat()') #was greatpumpkin
	#print('=======INSIDE OF PARSER in switch_cat for strings  =========')
	mountain2(a)    # this changes sw to switchcasetester #I can't beleive that this reverse number was being called 
	starter_sequence_mode_1()
# flow_fork_input()  #this fills valve[0] with True or False
# if valve[0] is True  it means numbers = True  (thus numbers      )
# if valve[0] is False it means numbers = False (thus words strings)
## the new code will go in here Friday morning.. April 2, 2021
#this fills valve[0] with True or False for numbers in cases
#################################
##     flow_valve_input(y)
##################################
def flow_valve_input1(y):  #this determines if switch case string is numbers or words
    #print("Flow Valve input")
    mytrace("flow_valve_input()")                            #get first case in switch case string
    ######## this gets the necessary data to test if case is a number
    getline  = grab_first_case_of_switch_string(y)           #get first case line
    toocool  = grab_first_case_line_in_switch_case_string(y) #remove tabs from the case line
    toocool  = remove_tabs_from_string(toocool)              #test if number in first case line yes = True no = False
    ######## here the data is now analyzed to see if a number  and returns True if number False if not number
    valve[0] = check_if_number_in_string(toocool)            #looks in case line
    valve[1] = toocool                                       #put case name/number into valve[1]
    #print("output from FLOW VALVE=",valve[0],"and",valve[1])
    
    #print("valve[0]=",valve[0]," and valve[1]=",valve[1])
   # print("========")
################################################



def blue2():
    mytrace("blue2()")
    #print("blue2()")
    #print("do NUMBERs parser")
    
def pink1():
    mytrace("pink1()")
    #print("pink1()")
    #print("do words parser")
    
#this fills valve[0] with True or False
#based on analyzing the switch case string first case if number or not
############################
#this controls calling numbers parser if True
#this controls calling words   parser if False
#this is in great_pumpkincat2.py


#this part hasn't been tested yet.
# I have to make sure that the normal endswitch() continues to work 
switch_count=[]
switch_count.append(0) #to create position 0
number_of_switches_in_string='' #initializing it July 1st 2021

########################
##     endswitch(y)      this calls flow_valve_input which checks if cases are numbers or words
########################  and if numbers = True then call parser_mode_2(y); If numbers = False parser_mode_1(y)
def endswitch(y): #pulls in sw 
	#print("====TESTing in beginning of endswitch() =====>>>")
	#print("====TESTing in beginning of endswitch() =====>>>")
	print("====TESTing in beginning of endswitch() =====>>>")
	switchcasetester='';switchcasetester=None;
	del switchcasetester;switchcasetester='';
	mytrace("endswitch() in switch_cat called")
	show_input_switch_string() #flag for testing this shows the input string
	#hide_input_switch_string()# flag for showing input string
	###################################
	###################################
	#june 30, 2021 10:10am santa cruz avenue Menlo Park
	#count switch inside of input string for switchcase
	print("====This is inside of silver switch module ")
	print("====This is inside of endswitch function before doing anything to the string")
	print("====meaning BEFORE the switch string is parsed")
	# I might hav eto redo this one as line.startswith("switch")
	########### I might have to do it different hen count and loop thru it
	########### and get teh accurate count that way 
	# so I wouuld loop thru string
	#and check if line.startswith('switch') to know for sure.
	#I can verify by also counting line.startswith("endswitch")
	'''
	###################################################
	#print("what is in switch_count list starting", switch_count) #should be nothing
	#number_of_switches_in_string =y.count("switch")
	#print("extra counts this many switch(s) in the string",number_of_switches_in_string)
	#
	#print("try counting endswitch for nested and then add 1 for first switch")
	#this idea occurred to me if the switch search isn't accurate
	'''
	############
	############ testing experimental (right now it doesn't matter
	############ july 1st, 2021  commented this out today don't want to think about this part 
	'''
	realnumber = y.count("endswitch") #it's possible there are no nested switches
	realnumber = realnumber + 1 #this account for the first switch which isn't counted
	if realnumber == None or realnumber == 0:
		realnumber = 1 #this is in case there are no endswitches meaning no nested switches
	#end if
	print("see if this number is different")
	print("counting the endswitch + 1 we get ",realnumber)
	'''
	
	
	#this just counts the number of "switch" in the string but not their locations
	#with my loop concept idea I would get the line number of each switch
	#but the moret that I thought about it the more it occurred to me that
	#the only way to know for sure is to count "endswitch"
	##===================================
	#right now for now this doesn't matter nor concern me one bit
	######### what this section does is determine how many switches are in a string
	#########################
	#print("extra count of switches in this input switch is",number_of_switches_in_string)
	#switch_count[0]=number_of_switches_in_string
	#print("the number of switch_count in THIS input switch string =",switch_count)
	#if switch_count[0] == 1:
	#	print("it is ONE")
	#else:
	#	print("it is ",switch_count)
	#print("===========#####################=====================")
	###################################
	
	###===================
	check_if_uppercase_constant_cases(y)  #if UPPCASE this senses it and converts to string
	
	if baseline[0] != "nada": #means it converted to uppercase
		y = baseline[0]
	#else:   #added this else  and pass on June 16th
	#	 pass #this puts the input string from baseline[0] into y
	#####################
	#this checks if first case is a number like case 2: returning True if numbers 
	flow_valve_input1(y)   #puts True or False into valve[0] added April 2nd, 2021
	#####################
	print("if number in first case",valve[0])
	# the key is macro expansion is only called if numbers are True
	if valve[0] == True:    #meaning numbers like case 12:
		macro_expansion(y); #checks if macros and expands them and converts numbs to strings
		y=None; del y; y = cray[0];
	#end if
	#####################################
	flush_lists() 
	parser_mode_1(y) 
	################## normal endswitch ends here  don't mess it up.
	
	
	
	
	####################################################################
#parser guts is the same sequence of code in the endswitch above
# I am just trying to reduce code  that's all.
####============================
####      parser_guts()           #dreamed up on July 10th, 2021 to see if it would work
####============================
def parser_guts(y):# this is used for the nested switches
	print("parser_guts called =======")
	check_if_uppercase_constant_cases(y)  #if UPPCASE this senses it and converts to string
	
	if baseline[0] != "nada": #means it converted to uppercase
		y = baseline[0]
			#else:   #added this else  and pass on June 16th
			#	 pass #this puts the input string from baseline[0] into y
		#####################
		#this checks if first case is a number like case 2: returning True if numbers 
	flow_valve_input1(y)   #puts True or False into valve[0] added April 2nd, 2021
	#####################
	print("if number in first case",valve[0])
		# the key is macro expansion is only called if numbers are True
	if valve[0] == True:    #meaning numbers like case 12:
		macro_expansion(y); #checks if macros and expands them and converts numbs to strings
		y=None; del y; y = cray[0];
		#end if
		#####################################
	flush_lists() 
	parser_mode_1(y) 	
		
		
#end of parser_guts()	
	
	######## this is the bottom of the normal scenario of a switch string with only one switch case in it
	
	####### this is where I will be testing using 2 and 3 switches in one string
	#######  july 1st, 2021  testing
	#####===============================================================================
	#####      BYPASS205  HANDLES AND MANAGES DOING NESTED SWITCHES , SO SWITCHES WITH 1 OR MORE NESTED SWITCHES
	####==================================================================================================
	##### this is bypass205 and it will manage and handle doing a multiline string
	##### which does multiple calls of the parser and code gen and fills a list called stanford
	####  with the generated python string 
	####  and then adds methods to the nested switches and then 
	#### builds a multi layer cake by concattting (in file fourth of july ) and executes it).

### this is testing and not in the real code ######

#=========================
#actual generated ouput code from chain methods on december 6th around 6 pm gilroy.
# notice that these input strings are how I have designed what goes into the parser
# reviewing this on dec fourtheenth 2021.
print("====testing WHAT IS IN QUAIL DAM IT here=====")
for item in quail:
    print("jeeze here we go again....")
    print(item)
    print("..........")
    
#outpout code from code above  testing at the stage of sending it into
# bypasss205 inside of the quail list
#this is after it has gone through the chain methods apple peach pear orange
#yes these are the gold strings which represnt having already gone thru the chain methods
#so this is after they would have been prepped by the chain methods gold master

#icecream1 thru 6 try it
star1='''
	switch(exp) #1
		case 1 thru 3: #in rudolph dec 30th test
			print("where's the best ever dog house!")
			print('first prize')
			print('you brilliant coder Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			exp = 'blable'
			nested_switch_11(exp) #11
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')
}'''

star2='''
	switch(exp) #11
		case 'blable':
			print("do inside of sw itch 11")
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''

###==============================================
##=  testing dec 30th =========================================================
#put my cold here to see what it does with it for testing 
#this is what it is using for the input for the parser

#I need to have the quail output strings here december 30 and not these canned strings 

gold1='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dazzling dog house!")
			print('first prize')
			print('you block head Charlie dam Brown 9')
			print("this really needs to work tonight to move forwards")
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			exp = 'blable'
			nested_switch_11(exp) #11
			exp = 'burger'
			nested_switch_62(exp) #62
			##############
			print('taught me how to write code file called gold1')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}'''

#=========
#counter= 1
gold2='''
	switch(exp) #11
		case 'blable':
			print("this is nested swith 11")
			####################
			exp = 'tahoe'
			nested_switch_15(exp) #15
			#############
			print("Blake testing again Southwood")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''

#=========
#counter= 2
gold3='''
	switch(exp) #15
		case 'tahoe':
			print("I want to go kayaking again")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("Blake testing is nested switch 15")
			####################
			exp = 'tahoe'
			nested_switch_23(exp) #23
			#############
			break
		default:
			print("we are done here")
}'''

#=========
#counter= 3
gold4='''
	switch(exp) #23
		case 'tahoe':
			print("nested switch 23 tahoe")
			print("yep")
		case 'fallen leaf lake':
			print("blake testing here")
		####################
			nested_switch_31(exp) #31
			#############
			break
		default:
			print("we are done here")
}'''

#=========
#counter= 4
gold5='''
	switch(exp) #31
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'BLAKE TESTING now':
			print("nice")
			break
		default:
			print("we very done")
}'''


gold6='''
	switch(exp) #62
		case 'burger':
			print("nested sw62")
			########testing ############
			exp = 'Monday'
			nested_switch_66(exp) #66
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''

#input switch strings after cleaned up
gold7='''
	switch(exp) #66
		case 'fishy':
			print("do this is sw 66")
			print("yep")
			fallthru
		case 'snow fire':
			print("this is nested switch 66 cool")
			#############
			break
		default:
			print("we are done here no matches")
}'''

#==================================================================
#==================================================================
bronze1='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the best ever dog house!")
			print('first prize')
			print('you brilliant coder Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			nested_switch_11(exp) #11
			exp = 3
			nested_switch_49(exp) #49
			##############
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')
}'''

#- - - - - - - - - - - - - -
	#############
bronze2='''
	switch(exp) #11
		case 'blable':
			print("do inside of sw itch 11")
			####################
			nested_switch_15(exp) #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''


#- - - - - - - - - - - - - -
bronze3='''
	switch(exp) #49
		case 'burger':
			print("do something")
			####################
			nested_switch_53(exp) #53
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''

#- - - - - - - - - - - - - -
	####################
bronze4='''
	switch(exp) #15
		case 'tahoe':
			print("do inside of sw 15")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			nested_switch_23(exp) #23
			#############
			break
		default:
			print("we are done here")
}'''

#- - - - - - - - - - - - - -
	####################
bronze5='''
	switch(exp) #53
		case 'fishy':
			print("do something")
			print("yep")
			fallthru
		case 'snow fire':
			print("nice")
			#############
			break
		default:
			print("we are done here")
}'''

#- - - - - - - - - - - - - -
	####################
bronze6='''
	switch(exp) #23
		case 'tahoe':
			print("do chinquapin")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			break
		default:
			print("we are done here")
}'''

#- - - - - - - - - - - - - -
#198332319 confirmation number new years eve

#these work and were chopped off the working string
cranberries1='''
	switch(exp) #1
		case 1 thru 3:
			print("Colin did not have waffles!")
			print('first prize')
			print('it is new years eve')
			print("Blake is coding at starbucks figuring out a nasty bug")
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			exp = 'blable'
			nested_switch_11(exp) #11
			##############
			print('taught me how to write code file inside of cranberries')
			fallthru
			
		 
		case 8 to 10:
			print('morning brew')
			print('=it is new years eve imagine that==')
			fallthru
		
		default:
			print('the end')
}'''

#=========
#counter= 1
cranberries2='''
	switch(exp) #11
		case 'blable':
			print("this is nested swith 11")
			
			print("Blake testing again Southwood")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''


print('this is generated code that used starship to calculate')
holly1='''
	switch(exp) #1
		case 1 thru 3:
			print("where's off to mars!")
			print('first prize')
			print('you bad ass coder Charlie Brown christmas')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			exp = 'blable'
			nested_switch_11(exp) #11
			print('taught me how to write code')
			fallthru
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		default:
			print('the end')	
}'''

holly2='''
	switch(exp) #11
		case 'blable':
			print("do inside of sw itch 11")
			
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}'''



#but I can empty th elist and fill it here
#del switch_numbers_to_transfer[:]
#del real_switch_numbers_to_transfer[:]
#switch_numbers_to_transfer.append(1)
#switch_numbers_to_transfer.append(11)
print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
#print I am filling the real switch nubmers to transfer here for this experiment
# pretending that it ran thru starship which of course it did not. 
#for item in switch_numbers_to_transfer:
#    real_switch_numbers_to_transfer.append(item)

###==== dec 21st testing =========
#this is prefilling quail list for bypass205() 
#with test input javascript switch strings in chain_output_list
#THIS IS WHERE I WOULD HAVE THE CHAIN METHODS THAT PRODUCES THE SWITCH STRINGS
# PREPPED FOR BYPASS205 FINALLY .
#HERE THEY ARE HARD CODED AND NOT GENERATED (YET) STILL TESTING IT.

#here the gold strings are put into chain_output_list
chain_output_list=[]  #was gold1 thru 7
chain_output_list.append(bronze1)
chain_output_list.append(bronze2)
chain_output_list.append(bronze3)
chain_output_list.append(bronze4)
chain_output_list.append(bronze5)
chain_output_list.append(bronze6)
#chain_output_list.append(gold7)
#chain_output_list which goes into quail list

# this is important. I am bypassing the normal flow of control
# and I am using test data in the chain_output_list in gold1 thru gold7
# so I am force feeding it the input strings in mode after every chain method
# would have been fired off and triggered.
#=============================================
# dec 30th testing this dam thing 
#what it is doing here is taking chain_output_list and feeding it into quail list



##===========================================
## testing_using_chain_finished_output():
##===========================================
# this is filling the quail list with test data switch strings 
def testing_using_chain_finished_output():
    print('for testing putting chain_output_list into quail')
    del quail[:]
    #right here this is filling the quail list from the chain_output_list
    for item in chain_output_list:
        quail.append(item)
    ##====================================
    print("output of quail which should have been generated using starship module")
    print("new years eve test ")
    for item in quail:
        print(item)
           
#this fills the quail list from chain_output_list
testing_using_chain_finished_output()
# I am filling the quail list here with the chain_output_list of teh gold1 thru gold7 strings
##$$$$$$$$$$$$$$$ testing mode #$$$$$$$$
##$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


##================= DARK SIDE OF THE MOON ================ 
##================ this code has methods to create the switch pairs and fill quail list ====
## unreal_2.py
## it will have the switch strings copied and pasted into the quail list raw form
## before chain methods cleans up the switch body strings
##  tuesday, december 21st 8 pm Gilroy, California
#import official_switch_case_silver
#from official_switch_case_silver  import *  

zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'


#print("from the web trying this out")

#quail=[]
# I am adding the quail list to practice filling it

#endswitch_location=[]
#switch_location=[]

def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations 
##########################################
def get_switch_and_endswitch_locations(z): #from string z input parameter
	#print("### must work now ###get switch and endswitch locations########")
	#print("####3##get switch and endswitch locations########")
	#this empties switch and endswitch lists
	empty_switch_and_endswitch_list_locations()
	#print("=====get_switch_and_endswitch_locations(z) called ....")
	#print("====== THIS IS THE ONE THAT I NEED ======")	#this catalogues the switch and endswitch locations for an entire input string
	#print(" GET SWITCH AND ENDSWITCH LOCATIONS ADDED TO LIST")
	#print(" ========  MICKEY MOUSE HOUSE  =========")
	counter=0 #it was 0 starting counting from 1
	for line in z.splitlines(): #determine if "endswitch" is in line
		#this should skip lines between 10 thru 20
		#we know that the lines that the inner switch resides in is between 10 and 20 
		#skip over 10 thru 20
		#print(line) #this should be revealing
		#if line.isspace():
		#right here going thru input string look for switch and endswitch
		#and append the line number to either switch_location or endswitch_location
		if "switch" in line and "end" not in line:
			#print("switch found",counter)
			switch_location.append(counter)
			counter += 1			
		elif "endswitch" in line:
			#print("endswitch found",counter)
			endswitch_location.append(counter)
			counter += 1
		else:
			counter += 1
			
			
			#THIS DELETES THE FIRST SWITCH WHICH WE DON'T USE
	del switch_location[0]	#empties it what am I doing here??? july 7th deleting first switch
	#print(z)                #now I remember that is the first switch which doesn't matter
	#print("I deleted the first switch since I'm not bothering with it")
	#print("switchlocations=",switch_location)
	#print("the length of switch list =",len(switch_location))
	answer = len(switch_location)
	answer = answer -1
	#print("this is how many nested switches are here")
	#print("now we should have this many nested switches to contend with",answer)
	#print("and the answer is above this line .....")
	#this prevents a bug if I don't have endswitch in the string
	if len(endswitch_location) > 0: #this only proceeds if there is at least one endswitch
		pass #print("endswitch locations =",endswitch_location)
		#print("out of curiosity print the number of endswitches", len(endswitch_location))
	else:
		pass
		
	#print("this might be simpler to test and use actually======/////???????//////===")
	#print("======================================")
	#print(" ===  THESE ARE THE SWITCH AND ENDSWITCH LOCATIONS === ")
	#print("I need to delete teh first swithc location")
	
	#del switch_location[0] #ALREADY DELETING FIRST SWITCH ABOVE BECAUSE IT'S NOT NEEDED NOT NESTED
	#print('switch_location=',switch_location)
	#print('endswitch_location=',endswitch_location)
	
#print("testing getting switch and endswitch locations")
#get_switch_and_endswitch_locations(red_robin)	
#exit()
	
	# I need to feed these into the pear dictionary now down below
	#I will feed the pears list with a loop thru the switch_location list
	########## WORKING ON THIS TODAY MONDAY TO MAKE SOME SERIOUS PROGRESS 
	##########  MONDAY JULY 19TH APPROACHING 12 NOON 
	
	#make pairs here
	#might have to delete teh first switch which throws everything off
	
	
	
 ####<<========
#switch 1, 10,29
#endswitch  20, 38

#switch_location
smart_rat=[]
string = """
line1
line2
line3
line4
line5"""
str_list = string.split('\n')
#print('changing line 3')
str_list[3] = "my new line value"
string = "\n".join(str_list)
#print(string)

#print("end of test from the web")
#print("=========")
#this simulates after cutting out the inner switches but leaves the first line
#which is used for replacement of the nested method()
############################################################
########## august 5th testing what to use now #################=========$$$$$$$$$$$
############################################################
# this represents and input string with inner switches cut out
#what remains is just the switch word which will be replaced

#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 


#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
wwwred_robin ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############
			switch(exp){  
				case 'blable':
					print("do something")
					####################
					switch(exp){ # 15  #second level deep          Level 2    
						case 'tahoe':
							print("do something")
							print("yep")
							fallthru
						case 'fallen leaf lake':
							print("nice")
							####################
							switch(exp){ #23  #third level deep   Level 3    
								case 'tahoe':
									print("do something")
									print("yep")
									fallthru
								case 'fallen leaf lake':
									print("nice")
									break
								default:
									print("we are done here")
							endswitch #33
							#############
							break
						default:
							print("we are done here")
					endswitch #38
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #47
			#exp = 3
			switch(exp){ #49 #first level deep                   Level 1
				case 'burger':
					print("do something")
					####################
					switch(exp){  #53  second level deep          Level 2    
						case 'fishy':
							print("do something")
							print("yep")
							fallthru
						case 'snow fire':
							print("nice")
							#############
							break
						default:
							print("we are done here")
					endswitch 
					#############
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #73

			##############
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	





sweetlist=[]
holdinglist=[]; holdinglist.append(0) #to create slot 0
boomerang=[];   boomerang.append(0)
#def get_switch_parents()

# I need to do a second pass and modify this just modified 
# texas string to show it's inner switch line numbers

##============================================
##  modify_string_before_splitting_it_up():
##============================================
def modify_string_before_splitting_it_up(inputstring):
    print("texas string first")
    for line in inputstring.splitlines():
        print(line)
    print("=========================") 
    counter =0    
    #print("modify_string_before_splitting_it_up():")
    craftline =''
    for line in inputstring.splitlines():
        if holdinglist[0] == 0: #this compendates for the first one
            holdinglist[0] = '1' #ASSIGN JUST ONE EQUAL
        else:
            boomerang[0]= holdinglist[0]
    
        if "switch" in line and "end" not in line: #this eliminates endswitch confusion
            tabcount=line.count("\t")#                                   line number          tab count 
            if tabcount == 3: #this compensates for 2nd nested switch at 3 tabs
                boomerang[0]='1' #representing parent switch 
            else:
                pass
            if tabcount == 3:
                boomerang[0]= '1'; #assignment only use one = 
            craftline += line.replace("switch(exp){","switch(exp){ # "+str(counter)+":" + str(tabcount) + " "+"parent switch=" + str(boomerang[0]) + "\n")
            holdinglist[0]=  str(counter)
            #I need to add this to the special dictionary now
            #put it into a list first
            sweetlist.append([counter,tabcount,boomerang[0]])
            counter += 1
        else:
            craftline += line + "\n"
            counter += 1
    #print("this is the output test revisiting this on November 2nd, Tuesday")
    #print(craftline)    
    #print('end of test......... monday morning blues ')  

#modify_string_before_splitting_it_up()

listinput=[]
#exit()

## think if I have a switch at 3 tabs 
'''
[1][1,1]
[3][1,11]
[5][11,15]
[7][15,23]
[23]
[3][1,49]
[5][49,53]
[53]

'''


#
# we have 1,11 and 1,49  so two inner switches
#
# so it would be in main switch 1 and then 11,49
#

#print("I'm making this so only one tab difference")     
#print("sweetlist=",sweetlist)    




#print("and then the switches with no nests") 
#print("if number in second slot and not ever in first slot it's a single")

#need to figure out how to add these automatically
  

switchnumbers=[]
tabslist=[]
switchlinenumbers=[]
peach_data=[]



#at this point peach_data should already be filled
#testing determine what switches are parent-child by tab and sequence
# so 
#print("testing access of data after filling peach_data")
#peach_data[1]= ['1', '1', '1']
#peach_data[2]= ['2', '11', '3']
#peach_data[3]= ['3', '15', '5']
#peach_data[4]= ['4', '23', '7']

isnt_this_pretty='nada'
pattern_input=[]
pattern_input.append('0')
pattern_input.append('0') #[1] patterninput[1]
pattern_input.append('0') #[2] patterninput[2]

##============================
##  input_tab_combo(x,y):
##=============================
def input_tab_combo(x,y):
    #print("====== input_tab_combo(===", x, y)
    pattern_input[1]=x #5
    pattern_input[2]=y #7

porsche_carerra=[]
capture_switch_lines_nested=[]


plums=[]
plums_data=[]
endswitchlinenumbers=[]
endtabslist=[]


             



#this builds the pairs of switch endswitches by tabs since they ahve to be lined up
#from the switch down to the endswitch in the same tab depth 


 ##=====================this might be teh top of the methods ==========================================================
 ##===============================================================================
 
 
        
## loops thru tabsubs and appends item to tabcount
#=========================
#  little_method(tabcount)            
#=========================
def little_method(tabcount): #threetabs example is the param here in tabcount
    for item in tabsubs:
        tabcount.append(item)
    del tabsubs[:]
        
        
        
tabsubs=[]
threetabs=[]
fivetabs=[]
seventabs=[]
ninetabs=[]
eleventabs=[]
thirteentabs=[]
fifteentabs=[]

#used by the super duper function with 6 methods in it
#===============================

first=[]
add_tab_depth=[]
holding_themax=[]
holding_themax.append(0) #to create slot
christmastree=[]
second=[]   #this takes an inputstring which is the combined switchcase big string
slydog=[]
snowtime=[]
mylistinput=[]
#===========================
super_listinput=[]

def put(x):
    listinput.append(x)

#==============================
#  build_listinput_list  for threetabs,fivetabs, seventabs,ninetabs, eleventtabs,thirteentabs
#==============================
def build_list_input_list():  #line 976
    #print('====================METHOD 3 ==== line 976===>>>')
    mx = holding_themax[0] #it's using this number 
    input= holding_themax[0]
    #cascading down is how it works
    if holding_themax[0] >= 3: put(3);
    if holding_themax[0] >= 5: put(5);
    if holding_themax[0] >= 7: put(7); 
    if holding_themax[0] >= 9: put(9); 
    if holding_themax[0] >= 11:put(11);
    if holding_themax[0] >= 13:put(13);
    if holding_themax[0] >= 15:put(15);
       
    for item in listinput:
        super_listinput.append(item)
    
  
  
##=================================
##  list_tabs_lists_by_depth():
##================================== 
def list_tabs_lists_by_depth():
    pass
    #print("==list tabs lists by depth=====METHOD 5======>>")
    #print("threetabs=" ,threetabs); print("fivetabs="  ,fivetabs);
    #print("seventabs=" ,seventabs); print("ninetabs="  ,ninetabs);
    #print("eleventabs=",eleventabs);print("thirteentabs=",thirteentabs) 
    


#this takes in the tab depth with x and goes thru the string
#and fills the appropiate tab list if 3 then threetabs, if 5 then fivetabs
##====================================================
## internal_machinery()   designed wed sep 29th, 2021
##====================================================
## key engine inside of function this_makes_switch_and_endswitch_pairs_by_tab_levels()
def internal_machinery(x,inputstring): #this doesn't change anything in the string whatsoever
    #print("===internal_machinery() called=== METHOD 4.5  inside of METHOD 4  ===")
    counter=0
    for line in inputstring.splitlines():
        tab_length = line.count("\t")
        if tab_length != x or "switch" not in line:
            counter += 1; continue
        if tab_length == x: 
            if "switch" in line and "end" not in line:
                tabsubs.append(counter);counter += 1;continue
            if "endswitch" in line:
                tabsubs.append(counter);counter += 1;continue 
    #print("tabsubs = ",tabsubs) #this can be increased to manage n number of tabs depth
    if   x == 3: little_method(threetabs)
    elif x == 5: little_method(fivetabs)
    elif x == 7: little_method(seventabs)
    elif x == 9: little_method(ninetabs)
    elif x == 11:little_method(eleventabs)
    elif x == 13:little_method(thirteentabs)
    else:
        pass
          







##==================================================
## make_switch_and_endswitch_pairs_by_tab_levels() 
##=================================================== 
def make_switch_and_endswitch_pairs_by_tab_levels(): 
    #print(":=============== METHOD 4 ======") 
    for item in super_listinput: # listinput is dynamically made above
        x = item;
        internal_machinery(x,inputstring)
     

###=============================== 
 
        #del tabsubs[:] #should clear it
###=================
rattabs=[]



##==============================
##  experimental_machinery
##===============================
def experimental_machinery(x,inputstring): 
    counter =0
    #newstring='data on analyzing a multinested string to number the endswitches and tabs' + "\n"
    collosal='';tab_length=''
    internal_machinery(x,inputstring)
 
    ###============

combined_tabs=[]
christmastree=[]




##============================================
## combine the lists together  #waterfall ifs
##=============================================
def combine_the_lists_together(x): 
    get_length_of_threetabs    = len(threetabs)
    get_length_of_fivetabs     = len(fivetabs)
    get_length_of_seventabs    = len(seventabs)
    get_length_of_ninetabs     = len(ninetabs)
    get_length_of_eleventabs   = len(eleventabs)
    get_length_of_thirteentabs = len(thirteentabs)
    #test if threetabs list is empty
    if get_length_of_threetabs > 0: #then proceed there is at least one
        #this is a waterfall extending numbers to add to christmastree list
        if x >=  3:christmastree.extend(threetabs);
        if x >=  5:christmastree.extend(fivetabs);  
        if x >=  7:christmastree.extend(seventabs);
        if x >=  9:christmastree.extend(ninetabs); 
        if x >= 11:christmastree.extend(eleventabs);
        if x >= 13:christmastree.extend(thirteentabs);
    
    else:
        pass
        #print('all of the tab lists are empty')
        #print("don't bother trying to extend empty tab lists")
       

##========================================================
##  build_tab_list_added_together(largest_tab_number):   Thursday, Nov 4th, 2021 
#   this does this combined_tabs = threetabs + fivetabs + seventabs etc
##========================================================
def build_tab_list_added_together(largest_tab_number):
    del christmastree[:] #clears out the combined_tabs list to erase it
    combine_the_lists_together(largest_tab_number) #<<==input is the largest tab number
    
    
 
#==========================================================
# combine_tabs_by_length_into_christmastree_list(input)
#==========================================================
def combine_tabs_by_length_into_christmastree_list():
    #print("======METHOD 6 ===  combine tabs by length into christmastree_list====>>>>")
    themax = holding_themax[0] #this gets the highest tab level (deeply nested)
    build_tab_list_added_together(holding_themax[0])   #METHOD  7
    
   
#================================= 
#  build_pairs_with_jazz()
#=================================  
#this goes thru christmas list of pairs and and makes snowtime list of pairs jazz added to snowtime 
def build_pairs_with_jazz(): 
    #print("=== METHOD 7== build pairs with jazz =======>>>>")
    counter =0
    for x in christmastree: #loops thru at 2 at a time
        jazz = [christmastree[counter],christmastree[counter+1]]
        snowtime.append(jazz) #using startime as practice main pairs list for now nov 3
        counter += 2 
        #prevents overflow error for out of range error
        if counter >= len(christmastree):
            break
            
            
         
#=======================================
#  build_tab_depth(inputstring)
#========================================            
def build_tab_depth(inputstring):
    #print("build tab depth ==== METHOD 1 ==  build_tab_depth(=======>>")
    for line in inputstring.splitlines():
        if "switch" in line and "end" not in line: #this is looking for a switch in a line
            get_tab_depth=line.count("\t")         #this is a var that gets the count of tabs
            add_tab_depth.append(get_tab_depth)    #this is for filling the list of each tab depth
        else:
            continue
    #print("add_tab_depth=",add_tab_depth)
    #print("max tab depth=",add_tab_depth[0])
            
      
      
            
            
def loop_thru_pairs_in_snowtime():
    #print(" ==== #method 8 ===  loop_thru_pairs_in_snowtime()=============")
    for item in snowtime:  
        #print(item);
        rad1=item[0];rad2=item[1];
        #print(rad1,"and ",rad2)
    #print("snowtime list=",snowtime)




##=======================================
## get_max_tab_number_in_list()
##=======================================       
def get_max_tab_number_in_list():  #this fills the max holding_themax[0]
     #print("======  #METHOD 2 ========")
     themax = max(add_tab_depth);  #a list of the tabs before switches
     holding_themax[0]=themax;
     #print("themax=",themax)


##===========================================================================================
##===========================================================================================
##===============================================================
##   ==this_makes_switch_and_endswitch_pairs_by_tab_levels() ====
##===============================================================  
def this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring):
    print("===THIS MAKES SWITCH AND ENDSWITCH PAIRS BY TAB LEVELS========")
    build_tab_depth(inputstring)                           #METHOD 1
    get_max_tab_number_in_list() #fills holding_themax[0]  #METHOD 2
    build_list_input_list()                                #METHOD 3
    make_switch_and_endswitch_pairs_by_tab_levels()        #METHOD 4
    list_tabs_lists_by_depth()                             #METHOD 5
    combine_tabs_by_length_into_christmastree_list()       #METHOD 6 
    build_pairs_with_jazz()  #combines into sublist        #METHOD 7 
    loop_thru_pairs_in_snowtime()                          #METHOD 8
    print("==bottom of this makes switch and endswitch pairs by tab levels()")
    print("snowtime=",snowtime)
    print("============================")#this will go into gold_list
        
   
 
     #this gets one pair in showtime designated by x 
def get_pair_in_snowtime(x):
     #print(" get pair in snowtime testing",x)
     #what if I add 0,0 to first position brilliant
     if len(snowtime) == 0:
        pass #print("length of snowtime is zero")
     #print(snowtime) #would be second position
     cool = snowtime[x]
     print("list at position ",x," is",cool)
 

 


######=================================
#maybe switch line numberYES will be used to access the pairs
#breakthru and use a dictioanry with switch id line number
# like 11 which is going to be the first number in the pair brilliant
############==================================================


param1=[]
param2=[]
param1.append(0)
param2.append(0)


##==============================================================    
#we know that there will be sets of 2 numbers closest to each other
#go thru list and grab two at a time seems simple enough
#based on highest tab number which we would know like 7
#threetabs= [11, 47, 49, 73]
#fivetabs= [15, 38, 53, 64]
#seventabs= [23, 33]

peartree=[]
startime=[]

##======================================
## fill_main_pear_list(listname):  #this build the combined list correctly 
#the lists threetabs,fivetabs,seventabs,ninetabs need to already be filled
#this is just combining them together adding them together
##=====================================

threetabs=[]
endtabslist=[]
endswitchlinenumbers=[]


##======================
##  sound_of_music
##======================
fivetabs=[]



#=============bottom half which is seperates_input_strings============
#import official_switch_case_silver
#from official_switch_case_silver  import *  

def stop():
    print('stop called which calls exit')
    exit()
    
endswitch_location=[]
switch_location=[]
zoo=[]
zoo.append(0)# zoo[0]
zoo.append(1)# zoo[1]
#zoo[1] = 'test3'
cat_scales=[]
cat_scales.append(0)
#so after striping out nested switches at all levels or is it just one deep 
#actually no the first time I need all of them 
#make sure no space and it's switch(exp){


# output is to inputstring[0]
#############################################################
passinputstring=[]
smart_switch_numbers=[]
loopstring=[]
loopstring.append(0)
#twinlist=[]
passinputstring.append(0)  #get line number of switch and add number with comment to after all switches
snowman=[]
snowman.append(0)

##===================================================
##  add comment and lin number to all switches ()   ## put switch line number in
##===================================================
def add_comment_and_line_number_to_all_switches(inputstring): #this modifies the original string
	awesome='';counter =0;newstring='';
	for line in inputstring.splitlines():
		if "switch" in line and "end" not in line:
			# NEED TO HANDLE BOTH SCENARIOS switch with brace and switch without a brace 
			#############################################
			#switch is in this line definitely
			if "{" in line and "switch" in line and "end" not in line:
			### new surgery ===dec 20th monday bug fix out of the blue =======
				#if counter == 1: #modified for bu on dec 20th monday each number was off by 1 except first
				newstring += line.replace("switch(exp){","switch(exp){ #" + str(counter) + "\n")
				
			#this is necessary since the replace is quite specific and so no brace here
			# NOTE: I am adding gthe brace if it's missing to switch 
			if "{" not in line and "switch" in line and "end" not in line:
				newstring += line.replace("switch(exp)","switch(exp){ #" + str(counter) + "\n")  
			#end if  
			smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		####################################################
		elif "endswitch" in line: #just added comment number after endswitch 
			newstring += line.replace("endswitch","endswitch #" + str(counter) + "\n")
			#smart_switch_numbers.append(counter) #this is new september 30th, 2021
			counter += 1
		###################
		else:
			newstring += line + "\n"
			counter += 1
	awesome = newstring #it was concatted to newstring which we now reassign to awesome then red_robin
	return newstring #this way I can capture the changed string
##===================================================================================







import re
def first_letter(s):
    m = re.search(r'[a-z]', s, re.I)
    if m is not None:
        return m.start()
    return -1

s = "##catgiraffeapluscompscI"
i = first_letter(s)
print(i)


testthis='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			print('first prize')
	  		print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
'''

coolinthegang='''
	switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
			    print('first prize')
	  		   print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	    		    print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''


    
        
#print('after ======= attempting lstrip() which I have no confidence in')



newlist=[]
newtime=''
thelist=[]
finaloutput=[]
finaloutput.append(0) #creates slot
'''
this cleans up input javascript code that is supposed to be 
governed by tabs in front ala Python and if a space is discovered
it is neutralized and deleted. 
This first counts the tabs in each line in the string.
second it cuts out all spaces and tabs from left of each line
then it concats a new string with the correct tab count in
front of each line so it's CLEANED UP essentially. 

'''
#bad input
examplestring='''
	      switch(exp){
	    	case 1 thru 3:
		  	print("where\'s the dog house!")
	  		    print('first prize')
	  		    print('you block head Charlie Brown')
			fallthru
	  	case 4 to 7:
	     		      print('first prize')
	     		print('you block head Charlie Brown')
		         case 9 thru 11:
'''
#cleaned up output becomes
'''
	switch(exp){
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
		case 4 to 7:
			print('first prize')
			print('you block head Charlie Brown')
		case 9 thru 11:
'''


finalstage=[]
finalstage.append(0)
##========================================
##  cut_out_left_side(inputstring):
##========================================
def cut_out_left_side(inputstring):
    print("cut out left side")
    fancy=''
    for line in inputstring.splitlines():
        #print(line)
        newline = line.lstrip() #I am using lstrip() look at that!!
        fancy += newline + "\n"
    finalstage[0] = fancy
    ## concatting tabs in front + line to redone


##========================================
##  concat_tabs_in_front(fancy):
##========================================
def concat_tabs_in_front(fancy):
    #print("conctat_tabs_in_front()")
    redone='';counter=0
    for line in fancy.splitlines():
        redone += newlist[counter] + line + "\n"
        counter += 1
        if counter >= len(newlist):#prevents out of range error
           break
    finaloutput[0]= redone
    #print("right here the OUTPUT =",finaloutput[0])


#==================================
#   append_result()  pure genius
#   #appends tabs to newlist
#=================================  
def append_result(x):
    tab = "\t"
    result = tab * x;
    newlist.append(result)  
    #this replaces: #if item == 1:result = tab * 1;newlist.append(result)


#puts tab count in each line into thelist
##===============================================================
## count_tabs_in_each_line_and_put_into_thelist(inputstring):
##===============================================================
def count_tabs_in_each_line_and_put_into_thelist(inputstring): 
    del thelist[:];
    del finaloutput[:];
    finaloutput.append(0) #creats one slot space
    for line in inputstring.splitlines():
        answer =line.count("\t") 
        thelist.append(answer)
 
             
#made into a function on saturday, dec 4th morgan hill starbucks 
# refactored on dec 19th for efficiency and management
##=======================================================
##  take_out_junk_spaces_from_left_side(inputstring):
##=======================================================
def take_out_junk_spaces_from_left_side(inputstring):
    #print("take out junk spaces from left side")
    #print(inputstring)
    count_tabs_in_each_line_and_put_into_thelist(inputstring) # METHOD
    for item in thelist:  #fill a list with tabs corresponding to numberof tabs numbers
        x = item;
        append_result(x)                                      # METHOD
        
    cut_out_left_side(inputstring)#puts fancy in finalstage[0]# METHOD
    fancy =finalstage[0]
    concat_tabs_in_front(fancy)                               # METHOD 
    #result in finaloutput[0] for one converted string cleaned up
#####################################################################
#print("here we go big time test..........fireworks...")

    
#### takes out bad data messing up tabs    
#take_out_junk_spaces_from_left_side(examplestring)
#for line in finaloutput[0].splitlines():
#    print(line)
###========================================================================   

    
#check for position of first character or number in line 
    #check in this line for location of first letter  
    #letter =line.index('s')# or myString.index('c') or myString.index('p') or myString.index('f')
    #print("letter is",letter)
    #no spacesin switch at top so it skips it!!!~!
    #I need the word before
    
    #what if I go thru the line and 
    #first detect a space and proceed till I hit a character
    #so I am only dealing with spaces before the characters
    #and I create a new line modified 





##===================================== border line ======================================








def empty_switch_and_endswitch_list_locations():
    #print("=== empty_switch_and_endswitch_list_locations()")
    del endswitch_location[:]
    del switch_location[:]
    
#get linenumbers of switches and endswitches ignore the first switch though actually doesn't matter
##########################################
#### get switch and endswitch locations    #this fills the together_pair list
##########################################
switch_location=[]
endswitch_location=[]
together_pair=[]






#print("done with test to get the nested switch locations within the big switch")

### this started working on july 9th, 2021 Friday. I forgot that it was friday.
genius=[]
genius.append(0)
# the number series will always start from 1 and then increase in number
number_series=[]
number_series.append(0)
switch_list=[]

#print(genius[0])    	


 ####### august 10th 2021 testing commences.
 
find_nested_switch_game ='''
	switch(exp) {  
		case 1 thru 3:
			print("where\'s the dog house!")
			print('first prize')
			print('you block head Charlie Brown')
			fallthru
			
		case 4 to 7:
			print('kangaroo hop hop!')
			switch(exp){   # === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
			print('taught me how to write code')
			fallthru
			
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
}
'''	

gameday ='''
			switch(exp){   #1 === line 10 beginning of single nested switch ======      
				case 'blable':
					print("do something")
					print("yep")
					fallthru
				case 'more':
					switch() #7
						case 'funny':
							print('fun')
						case "da":
							print('yeah')
						default:
							print('bye')
					endswitch #14
					print("nice")
					break
				default:
					print("we are done here")
			endswitch #this is key here =============line 20 end of nested switch ====
'''	

#print("what we are starting with the switch with a nested switch")
#print(find_nested_switch_game)
#print("=====================")
#oh wait this needs to be the input C style switch that I search in
#maybe I need to go through the case list palmtrees
# so get line number of switches
#get linenumber of each case to determine which case section the inner switch is in
pacman=[]
pacman.append(0)


coollist=[]
#print("this gets the line number of the line that the case starts")
#print("that has the nested switch inside THIS Case")

endnestedswitchline=[]
endnestedswitchline.append(0)
#########################################
##  get_case_line_numbers(string_name):
#########################################
def get_case_line_numbers(string_name):
    linecounter =0
    casecounter = 0
   # print('get line number of each case section')
    #just get first case line numbers print it
    for line in find_nested_switch_game.splitlines(): #be sure to put stringname.splitliens()
        #this looks for cases
        if "case" in line:  #grabs first line
            #print(line)
            pacman.append(linecounter)
            casecounter += 1
            linecounter += 1
            #print(casecounter)
        else: #this looks for the  switch word
            
            linecounter += 1   
            continue
        #if "switch" in line:
   # print("case line numbers",pacman)    
    #print(pacman[2])  
    #print("number less than 10 that ")
    #I reverse the list order to find the first case less than 10 the line with switch in it
    pacman.reverse()

#calls method above
#####==========
#get_case_line_numbers(find_nested_switch_game)
#####========




#####################################
## get_larger_number_less_than_case()
#####################################
def get_larger_number_less_than_case():
    #this gets teh larger number less tahn the case
    for item in pacman:
        if item < 10: #I will need to put  (this cuts the possibilities to those less than 10)
            coollist.append(item)
            #print(item)
            #print("this must be the answer of the case that is on line 8")
            break #so after just the first one
    #get largest number in list
    #print("this is new trying to get largest number only from list")
    superman = max(coollist) #worked June 28th MOnday 2021
    #print("largest number =",superman)

#calls method above
#######========
#get_larger_number_less_than_case()
#######========




###$############===================-----0-0--=-=-=-=-=-=0-0-0-9=0--
### GET END OF SWITCH LINE  number
#######################################
## now looking for end of nested switch case
#june 28th, 2021
#####################################
## get_end_of_switch_line_number():  #  this gets endswitch line number
#####################################
def get_end_of_switch_line_number():
    linecounter=0 #this looks for the line number of endswitch for the nested switch
    for line in find_nested_switch_game.splitlines():
        #this looks for cases
        if "endswitch" in line:  #grabs first line
           #print("we have a match")
            #print(line)
            #linecounter += 1 if it's endswitch don't add one
            #print(linecounter)
            endnestedswitchline[0]=str(linecounter)
            break
        else: #this looks for the  switch word
            linecounter += 1   
            continue
    #print("the end of this nested switchis",endnestedswitchline[0])
    #print("====should be 18 ====")

#calling method above this 
#####=========
#get_end_of_switch_line_number() #puts it into endnestedswitchline[0]
#####=========

#and we know that the case number is 8
#and we know that the nested switch starts on line 10
#therefore we subtract 10-8 = 2
#so within the case the nestedswitchmethod will be on line 10 or the 2nd line within the case
###############=======================########################
#print("copy inner switch")
#first trying to copy the inner switch and put it into a list

linecounter=0 #this looks for the line number of endswitch for the nested switch
#print("testing getting a copy of nested switch")
### what I need to do is grab the numbers that I generated that I am using below
### I determine the line number that the first and only nested switch is on
### I then look for the first "endswitch" after the nested switch starts
### and it must be within the bounds of the case that it is residing within.
#here I am feeding it but I need to make it a method
#x = 11;
#y = 60;
#start  = 11  #hard coded beginning of nested switch
#finish = 60 
start_and_finish=[]


##============================================
##  inputs_pair_to_copy_a_string()
##============================================
def inputs_pair_to_copy_a_string(start,finish):
    #print("inputs pair to copy a string")
    del start_and_finish[:] #this clears it out initializing it
    start_and_finish.append(0) 
    start_and_finish.append(start) #position [1]
    start_and_finish.append(finish) #position [2]
    #start_and_finish[1] = x
    #start_and_finish[2] = y
    #print("x=",start_and_finish[1])
    #print("y=",start_and_finish[2])
    
########################################################################
 #hard coded end of single nested switch 
## COPY A NESTED SWITCH
############################

#so we have

#############################
r=find_nested_switch_game #thats the name of a string fin_nested_switch_came
#linecounter=0
makeitwork=[]
makeitwork.append(0)
## function copy a nested switch()   ==== I just put this into a function



columbia_river=[]
gold_list=[]
###############################
## copy_a_nested_switch(r):   # what this does is copy one nested switch 
###############################
def copy_a_nested_switch(r):  #copy just one nested string 
    innerswitch=''
    #need to skip the first switch though so take out the first number from list
    #global linecounter #this is new july 15th, 2021
    linecounter=0 #where do start and finish come from ...oh  above, put into a list
    answer=start_and_finish[1]
    start_and_finish[1] = start_and_finish[1] - 1 #added this on dec 20th to show switch word
    #print("it sees for start",start_and_finish[1],"and finish",start_and_finish[2])
    for line in r.splitlines(): #if linecounter is between start and finish
    #this should copy a full (every line) of a nested switch from switch to and including endswitch
        # if lincounter >= 10 and linecounter <= 20; #this is what it means
        if linecounter >= int(start_and_finish[1]) and linecounter <= int(start_and_finish[2]):
            innerswitch += line + "\n"  #it's concatted to innerswitch string right here
            linecounter += 1
            continue
        else:
            linecounter += 1
            continue
    #print(":the result COPY OF NESTED SWITCH  ")        
    #print(innerswitch)  #this is the copied string between lines 10 and 20 
    roadrunner = innerswitch
    makeitwork[0] = roadrunner #result of copied string goes in makeitwork[0]

################################################################################

#I need to fill this list (populate it from get switch engineswitch pairs
#print("testing looping thru gold_list")
#gold_list=[[1,100],[11,60],[15,51],[23,46],[31,41],[62,86],[66,77]]
################################################################################
#print("=======begin Sunday Morning Brew Testing==========================")

def show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water):
    pass  #not printing it out at this time on purpose
    #for line in water.splitlines():
    #    print(line)

def show_the_snowtime_list_of_pairs():
    print("snowtime=",snowtime)   
    
def empty_columbia_river_list():
    del columbia_river[:] 
    
def add_main_switch_to_columbia_river(water):
    columbia_river.append(water)  

    
holding_string=[]
holding_string.append(0) 

##============================================================================
##  loop_thru_snowtime_list_copy_switch_bodies_and_add_to_columbia_river():
##============================================================================   
def loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river():
    for item in snowtime:#was gold_list #loop that gets switch,endswitch pair from goldlist
        num1 = item[0];
        num2 = item[1];
        inputs_pair_to_copy_a_string(num1,num2) # get input string from goldlist
        copy_a_nested_switch(holding_string[0]) # copy string based on switch,endswitch pair 
                                                # puts resulting string into makeitwork[0] and output
        output = makeitwork[0]                  # put nested string into columbia_river list
        columbia_river.append(output)
    #print("length of columbia river =",len(columbia_river))
    #counter =1  #adding here the initial string which will be used to make the main switch


    
##=================================  
## loop_thru_columbia_river() 
##================================= 
def loop_thru_columbia_river():
    #print("now loop thru ====== COLUMBIA RIVER === to see the switch bodies seperated")
    counter =1
    for item in columbia_river:   #it is added just before looping thru i
        print("counter=",counter)
        print(item);
        print("===========");
        counter += 1    
    
          

#gold_list= [[11, 47], [49, 73], [15, 38], [53, 64], [23, 33]]    

##==============================================

   #This takes in what has already split the mega nested switch into 
   #switch bodies
gemini=[]
taurus=[]
##======================================================##=========================================
##  ==split_up_big_string_into_nested_switches(myinputstring)==
##  this requires to have the pairs list which is utilizes to create the strings paramaters
##======================================================##=========================================
def split_up_big_string_into_nested_switches(myinputstring):#this would only be called once
    print(" ==  split_up_big_string_into_nested_switches(inputstring)  ==")
    water =add_comment_and_line_number_to_all_switches(myinputstring)             #METHOD 1
    show_switch_string_with_numbers_added_after_each_switch_with_a_comment(water) #METHOD 2
    empty_columbia_river_list()                                                   #METHOD 3
    show_the_snowtime_list_of_pairs()                                             #METHOD 4
    add_main_switch_to_columbia_river(water)                                      #METHOD 5
    holding_string[0] = water
    loop_thru_snowtime_list_and_copy_switch_bodies_and_add_to_columbia_river()    #METHOD 6
    loop_thru_columbia_river() #prints out seperated switch bodies top down       #METHOD 7               
    ##==============
    print("this is the actual result of creating the strings but not thru blender chain methods yet")
    print("running real data here to create switch strings to bypass205() next")
    print("fill gemini list from snowtime list for testing")
    for item in snowtime:
        gemini.append(item)
    print("fill taurus list from columbia_river list for testing")
    for item in columbia_river:
        taurus.append(item)
    print("the switch strings cut up are now printed out top down")
    print("these are the switch pairs in gemini here")
    for item in gemini:
        print(item)
        print("========")
    print("these are the switch strings after going thru the chain methods blender")
    for item in taurus:
        print(item)
        print("========")
##================================================================        
##================================================================




##=================================================================
## manage_creating_pairs_and_separating_input_switch_strings()
## this calls 2 methods  ---------------
## * this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
## * split_up_big_string_into_nested_switches(inputstring)
##=================================================================
###======= create switch pairs and separate switch strings ===========####

## december 22nd, 2021  wednesday 7:51 am ===
def manage_creating_pairs_and_separating_input_switch_strings(inputstring):
    print("this is an independent operation testing that is proving the methods work")
    print("this is on line 41817")
    print("this is..manage_creating_pairs_and_separating_input_switch_strings(inputstring)")
    print(" .............")
    print("this is calling:")
    print("this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)")
    print(" split_up_big_string_into_nested_switches(inputstring)")
    
    #empty both critical lists here 
    del columbia_river[:]
    del snowtime[:]
    #print("called manage_creating_pairs_and_separating_input_switch_strings()")
    this_makes_switch_and_endswitch_pairs_by_tab_levels(inputstring)
    split_up_big_string_into_nested_switches(inputstring)
    #I can use this output in a different list so as to not interfere with running code
    # I will create a list gemini for switch pairs
    # I will create a list taurus for seperated swith strings
    
        



##===============================
#inputstring = red_robin
#manage_creating_pairs_and_separating_input_switch_strings(inputstring)
# just commented this out dec 31st 2021 new years eve don't need it 


print(" testing creating input strings for quail list stopping temporarily here ")
print("this is creating output but it's not at this point doing anythig with it")
##===============================


#at this point I need to call chain methods gold


#currently turned off  this is the beginning of dark side of the moon 
###===================== DARK SIDE OF THE MOON =============================================== 
###===================== DARK SIDE OF THE MOON =============================================== 
###===================== DARK SIDE OF THE MOON =============================================== 
###===================== DARK SIDE OF THE MOON =============================================== 
 #this represents the output of teh chain methods to feed into bypass205()
 # to generate the python switch format
 
 
string_test1 = '''
	switch(exp) {  
		case 1:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 10')
			fallthru
			
		case 4: 
			print('kangaroo hop hop!')
			n = 'more' #testing
			#nested_switch_2(n)         
			print('taught me how to write code')
			fallthru
			
		 
		case 8:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru
		
		default:
			print('the end')
			break
}
'''

string_test2 = ''' 
	switch(exp){          
		case 'blable':
			print("do something")
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
			break
} 
'''


string_test3 = ''' 
	switch(exp){          
		case 'zoo time':
			print("san francisco zoo")
			print("feed the flamingos")
			fallthru
		case 'the beach in santa cruz':
			print("volleyball and boardwalk")
			break
		default:
			print("we are done here")
			break
} 
'''



### this is a force feed test
#this is red_robin after going thru chain methods
string1 ='''
	switch(exp) #1
		case 1 thru 3:
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 11')
			fallthru	
			
		case 4 to 7:
			print('kangaroo hop hop!')
			#############1
			nested_switch_11:(exp) #11
			exp = 32
			nested_switch_62:(exp) #62
			##############)
			print('taught me how to write code')
			fallthru	
			 
		 
		case 8 to 10:
			print('mocha blast')
			print('== 31 flavors===')
			fallthru	
		
		default:
			print('the end') 
}
'''
#this is different I see based on test model above

string2='''
	switch(exp) #11
		case 'blable':
			print("do something")
			####################
			nested_switch_15(exp) #15
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}
'''


string3='''
	switch(exp) #15
		case 'tahoe':
			print("do something")
			print("yep")
			fallthru
		case 'fallen leaf lake':
			print("nice")
			####################
			nested_switch_23(exp) #23
			#############
			break
		default:
			print("we are done here")
}
'''

string4='''
	switch(exp) #23
		case 'tahoe':
			print("do something")
			print("yep")
		case 'fallen leaf lake':
			print("nice")#
		####################1
			nested_switch_31:(exp) #31
			#############
			break
		default:
			print("we are done here")
}
'''

#the missing strings here don't have nested switches I think 




string7='''
	switch(exp) #62
		case 'burger':
			print("do something")
			####################
			nested_switch_66(exp) #66
			#############
			print("yep")
			fallthru
		case 'more':
			print("nice")
			break
		default:
			print("we are done here")
}
'''


#was string1 thru 7
### TESTING THIS Still TOTALLY EXPERIMENTIONAL		
#quail=[] #this will simulate a switch stirng nested that  is split already into 3 switches
#this fills the three inputs trings into the quial list
# so these are still in javascript form for the switches
#quail.append(string_test1) #actual switch case with one switch for simplicity
#quail.append(string_test2) #actual switch with one switch

#the strings are only added to the quail lift AFTER going thru the chain methods
# so I need to add that right now.
#========= just commented these out below since we are filling quail list at end of chain methods
#============================================================================

# I think that chain methods should go here but need to double check
print("this is where the inputs strings already prepped are poured into quail list as gold1 thru gold7")
#these were gold1 - 7

###==================
#quail.append(holly1) #actual switch with one switch 
#quail.append(holly2) #cranberries

#quail.append(gold3)
#quail.append(gold4)
#quail.append(gold5)
#quail.append(gold6)
#quail.append(gold7)

#need this to work 
#right here put the new switch numbers for bronze numbered ones

'''
quail.append(star1) #actual switch with one switch 
quail.append(star2)
quail.append(star3)
quail.append(star4)
quail.append(star5)
quail.append(star6)
'''
##====================================
#  right here 
#=====================================
print("testing calling starship and taking input string and running chain methods on it")


'''
quail=[]
quail.append(string1)
quail.append(string2)
quail.append(string3)
quail.append(string4)
quail.append(string5)
quail.append(string6)
quail.append(string7)
'''
print("====this shows what's in quail at line 40,578===")
#get quial length should be 0, 1, 2 so 3 length
future = len(quail)
print('THE length of quail list =',future)
print('quail[0]')
print(quail[0])
print("===========")
print('quail[1]')
print(quail[1])
'''
print("===========")
print('quail[2]')
print(quail[2])
print("===========")
print('quail[3]')
print(quail[3])
print("===========")
print('quail[4]')
print(quail[4])
print("===========")
print('quail[5]')
print(quail[5])
print("===========")
#print('quail[6]')
#print(quail[6])
'''
print("===========")
## July 1st, 2021 testing bypass205 to see if it does three strings in a series
## thru the parser and codegenerator and puts it into stanford
	#THIS CALLS TEH CODE IN endswitch(y)
	#I need to empty stanford list right off the bat 
	#this will do thing fake switch nested just to get the mechanics understood July 1st 2021
	## right here we do 3 strings in succession
	#at the top here will be the quail list with three strings
	#empty stanford here to start from nothing
	###### empty stanford list here 
	
#this is ONLY called when there are more than ONE switch
#so an input switch string with nested switches(at least one) inside of it.
#and then the SNIFFER determines if regular switch or multi-combo switch with nesting

##=============================================
### REVERSE STANFORD LIST
##
##=============================================
def reverse_stanford_list(): #this just says what it does simply
	print("reverse_the_stanford_list ===")   
	stanford.reverse()#print stanford would have to have a length of 2 actually for a nested switch in a switch
	print("now reversed stanford list")
	print("now printing out the list showing the reversed order")
	# I don't need to print this out once it works
	# so I will commentout the three lines below soon
	#this is just so I can see what's actually in the stanford list to make sure it's correct
	print("== LOOPING THRU STANFORD LIST NOW ==")
	for item in stanford:
		print(item)
		print("==========")

# print("PRETENDING THAT THE LISTS HAVE BEEN MODIFIED THOUGH NOT REALLY YET")
#   print("==================")
#  print('lets pretend that the strings are finished and I will concat them together')
# print("but not run them")
#print("remember after the stanford list has been reversed the LAST list will be the main")
   
   
# JULY 10TH, 2021

### important - need to add methods inswitch and infallthu at top
toocool=[]
toocool.append(0)

output=[]
output.append(0)
#this loop sthru stanford list and concats each switch string together bottom up
##====================================================
##   BUILD STACKED CAKE STRING COMBINING STANFORD LIST
##====================================================
def build_stacked_cake_string_combining_stanford_list(): 
    print("========build stacked cake string by concatting  stanford list=========")
    count =0
    print("length of stanford insid eof build_stacked_cake =",len(stanford))
    ##  THIS LOOPS THRU STANFORD LIST 
    #concat_triple_string_before_and_after_switches_in_stanford_list
    genius="'''" + "\n"#\n"
    for item in stanford:
        genius += item
    genius += "'''"
    toocool[0] = genius
    for line in toocool[0].splitlines():
        print(line)
    #final_output[0]
    output[0]=toocool[0]    
    del stanford[:] #empty stanford here  just in case
    print("now  after build stacked cake string combinging stanford")
    print("stanford list should be empty",len(stanford))
    
    
###================================================================



    
def second_attempt():
    print("is this thing ON")
    volleyball =''
    print("===calling second attempt() ===")
    volleyball += "'''" #starter
    for item in stanford:
         #just added this dec 7 to see if needed 
        volleyball += "\n"
        volleyball += "#count="
        volleyball += str(count) + "\n"
        volleyball += item
        volleyball += "\n\n" #spacer 2 lines
        volleyball += "#============ divider =========== \n"
        count += 1
        print(count)
        #after loop is over
    volleyball += "'''" #after  just added this to see if it is right
    print('now doing the loop after finishing volleyball')
    for line in volleyball.splitlines():
        print(line)

#second_attempt()

tahoedream='''
global x
x = "one" #it was "one"     #<<=== x must be a string just as matching case == "string", 
                            #<<=== if using a number it will be converted to a string
                            #<<=== so x = 22   will work and be converted to "22"
tahoe=[]
tahoe.append(0)
'''


methods ='''
# ====  switch  
def switch(x):
    if type(x) != str:  
        x = str(x)
    global case
    case = x 
    
# ============  
def fallthru(y):
    eval("switch('" + y + "')")
#==================
def inswitch(n):
    if type(x) != str: 
        n = str(n)
    global case
    case = n
#=====================
# for infallthru    
def infallthru(n):
    eval("inswitch('" + n + "')")
'''





main_function_switch='''

def main_switch(exp):	
	exp = varholder[0]
	
	caselist1 = ['1', '2', '3']
	caselist2 = ['4', '5', '6', '7']
	caselist3 = ['8', '9', '10']
	caselist4 = ['default']
	
	
	switch(exp)#1
	while True:
	
		if case in caselist1: # ['1', '2', '3']
			print("where's the dog house!")
			print('first prize')
			print('you block head Charlie Brown 12')
			infallthru('4')
	
		elif case in caselist2: # ['4', '5', '6', '7']
			print('kangaroo hop hop!')
			#############
			nested_switch_11(exp) #11
			exp = 3
			nested_switch_62(exp) #62
			##############
			print('taught me how thru write code')
			infallthru('8')
	
		elif case in caselist3: # ['8', '9', '10']
			print('mocha blast')
			print('== 31 flavors===')
			infallthru('default')
	
		elif case in caselist4: # ['default']
			print('the end')
			break
	
		else:
			print('the end')
			break
	

'''



bottom='''main_switch('1')''' #this calls it this triggers the generated code to run 

#exec(tahoedream)










# in a switch string.
#it doesn't count endswitches as switches 
#but I might count endswitches as a backup insurance parachute.

# this calls endswitch() on each item in quail list 
# these are the input strings that were separated from a switch with nested switches within
# that have been split up above and put into the quial list in the order of appearance
# with main first and the nested afterwards in order
# modified on July 10th, 2021
#=================================================
####======   BYPASS205() ========   ##############
##=================================================
# BYPASS205() takes in the quail list
# and outputs the stanford list of python switch cases code 
########### bypass 205 ########### july 1st 2021 testing starbucks in gilroy
# in bypass205 and it LOOPS THRU QUAIL LIST AND CALLS Y
#  WHICH IS LOADED INTO PARSER_GUTS(Y) WHICH THEN LOADS IT TO STANFORD LIST
#this bypass205 is different then elsewhere in other files apparently - plus this one works
def bypass205(y): #this runs the input strings thru parser and code gen 
	print("THIS IS BYPASS205() officially called translating javascrip to python")
	print("==== bypass205 test === it calls parser guts====") #and puts them into stanford list
	print("this one loops thru the quail list already filled up with strings of switches prepped")#dec 14th notes
	del stanford[:] #this empties the stanford list
	#=======================================================================
	#this loops thru quail and call everything that I normally do for an end switch
	print('in radical_list from starship ===')
	for item in radical_list: #the quail list from starship
		print(item)
	print("============")
	print("====right here this is in churchill sending in instead of quail===========")
	print("this is quail canned input's contents in gold 1 thru 7")
	##===============
	del quail[:]
	for item in radical_list: #from starship running chain methods
		quail.append(item)
	#========== new years eve surgery to fix bug by putting radical_list into quail
	for item in quail:
		print(item)
	print("inside of bypass205 looking at what is in rdical_list and quail list")
	#exit()	
	print("commensing sending churchill from starship thru to parser")
	#for item in churchill:
	#del switch_numbers_to_transfer[:]
	#del real_switch_numbers_to_transfer[:]
	for item in quail: # 0, 1, 2 #so it should call the parser and code gen three times
		y = item #this puts the contents of each string in quail into y 
		print('============')
		print(item)
		print("============")
		#everything below here is the same in parser code
		switchcasetester='';switchcasetester=None;
		del switchcasetester;switchcasetester='';
		mytrace("endswitch() bypass205  in switch_cat called")
		show_input_switch_string() #flag for testing this shows the input string
		###############
		parser_guts(y) #y is put in as a param to paser_guts(y) while looping thru quail list grabbing item(string)
		###############
		#check_if_uppercase_constant_cases(y)  #if UPPCASE this senses it and converts to string
##################################################==========================	
		#if baseline[0] != "nada": #means it converted to uppercase
		#	y = baseline[0]
		#	#else:   #added this else  and pass on June 16th
		#	#	 pass #this puts the input string from baseline[0] into y
		#####################
		#this checks if first case is a number like case 2: returning True if numbers 
		#flow_valve_input1(y)   #puts True or False into valve[0] added April 2nd, 2021
		#####################
		#print("if number in first case",valve[0])
		# the key is macro expansion is only called if numbers are True
		#if valve[0] == True:    #meaning numbers like case 12:
		#	macro_expansion(y); #checks if macros and expands them and converts numbs to strings
		#	y=None; del y; y = cray[0];
		#end if
		#####################################
		#flush_lists() 
		#parser_mode_1(y) 
###  end bypass205()  ##################  		

		
	## end of endswitch()
#testing proof of concept of bypas205 to do three generating strings and save them
#don't run them. Just add them to stanford list
def next_steps():
    print("next_steps().......... today is")
    print("this is next_steps() called")
    print("just do something else")
    print("this is where the next stage of conversion will happen")
######3===================================
#####=====================================
### so this is testing taking in strings and then translating into python with the module
### but I need to add an if else into endswitch governed by the switch count and endswitch count
# THIS IS TESTING AND ISN'T CALLED IN THE endswitch() ABOVE AS YET July 3rd.
#this is what calls it. 
#   made this function on sunday, dec 12th, 2021
##==========================================
##  def testing_input_to_run_thru_bypass205():  
##==========================================
def testing_input_to_run_thru_bypass205():
    print("==== testing_input_to_run_thru_bypass205(): ===== ")
    y=''
    del stanford[:] #just to be sure empty stanford first
    print("the length of stanford=",len(stanford))
    print('about to call bypass205() ======')
    print("first let's loop thru the quail list to see the beginning")
    print("LOOP THRU QUAIL LIST")
    #I am filling up the quail list of input switch strings(prepped to go thru parser)
    print("what is in the quail it sees??")
    for item in quail:
        print(item)
        
    for item in radical_list:
        print
    print("so this is the input for the bypass205 that it will read")    
    #requires the strings in the quail list remember this is key
    #within bypass205() it will loop thru the quail list and get each switch string and
    #then call the parser(quail switch string)
    bypass205(y) #run the test data to see what it does and calls the parser and codegen 3 times
    print("the length of stanford=",len(stanford))
    print("=-- looping thru quail ==")
    for item in quail: #this is the original input
        print(item)
        print("----------")
        #exit()
    #go thru each switch string and get switch comment number
    print("====looping thru Stanford =============")
   
    #bypass205 would generate the python code that is put into the stanford list 
    print("STANFORD OUTPUT LIST PHASE 1 ")
    for item in stanford:
        print("..................")
        print(item)
    print("----------")


##==============================================================    
#this triggers the test running of bypass205()
testing_input_to_run_thru_bypass205()


###==================================================================
#what_is_in_stanford() #what is in the stanford list...to see the output python #this is the real test
# I just want to see the strings and proof that it worked 
#set these after exec
#after the stanford list is generated I can run a method over it
#and modify it to add the comment after each switch which I need
#to create the def nested switch number on top
#december 6th 8:41 opm



#loop thru test item to see that it works
#testing adding the switch number to the first one
testoutputstring='''
exp = varholder[0]

caselist1 = ['1', '2', '3']
caselist2 = ['4', '5', '6', '7']
caselist3 = ['8', '9', '10']
caselist4 = ['default']


switch(exp)
while True:

	if case in caselist1: # ['1', '2', '3']
		print("where's the dog house!")
		print('first prize')
		print('you block head Charlie Brown 13')
		fallthru('4')

	elif case in caselist2: # ['4', '5', '6', '7']
		print('kangaroo hop hop!')
		#############
		exp="blable' #####
		nested_switch_11(exp) #11
		exp = 3
		nested_switch_62(exp) #62
		##############
		print('taught me how thru write code')
		fallthru('8')

	elif case in caselist3: # ['8', '9', '10']
		print('mocha blast')
		print('== 31 flavors===')
		fallthru('default')

	elif case in caselist4: # ['default']
		print('the end')
		break

	else:
		print('the end')
		break

'''

########################################################################
########################################################################
#use this list in order top down starting from 1 to add number after switch
#switch_numbers_to_transfer  list
#this will be filled elsewhere
#I would take these two lines out when I combine the files christmas tree and this one.
print("testing inside of snoopy doghouse switch numbers to transfer")
print("that I imported from Linus file switch_numbers_to_transfer.")
print("switch_numbers_to_transfer=",switch_numbers_to_transfer)
#switch_numbers_to_transfer=[]
#switch_numbers_to_transfer=['1', '11', '15', '23', '31', '62', '66']

#switch_numbers_to_transfer=['1', '11', '15', '23', '31', '62', '66']   

#remember after these numbers are added I need to add teh def nested)switch
#and then the main)switch for the one with switch 1 (this one)
#and then I need to reverse teh switch to prepare it for bake cake method













#before
#for line in testoutputstring.splitlines():
#    print(line)
#created monday december 6th, 2021 gilroy  
#after
#switch_numbers_to_transfer[0] ##=['1'], for testing
silvermine=[]
silvermine.append(0)
number_counter=0
##===========================================================
##  add_switch_number_to_python_output_from_quail_input():  #adds switch number to each python output string
##  this uses list switch_numbers_to_transfer
##===========================================================
def add_switch_number_to_python_output_from_quail_input(testoutputstring,number_counter):
    print(" ===add_switch_number_to_python_output_from_quail_input(testoutputstring): === ")
    createstring=''; # this test is ONLY doing one call of this function 
    counter=0        # so it should work as switch_numbers_to_transfer[0]
    ###====dec 30 th change ==============================
    #del switch_numbers_to_transfer[:]
    print("===========.......")
    print("LOOK RIGHT DAM HERE for a difference!!!")
    print("it sees in    switch_numbers_to_transfer",switch_numbers_to_transfer)
    print("maybe the switch numbers to transfer need to be sorted in numeric order")
    print("I just sorted them to put them in a sequence to see what happens")
    #don't sort them they are in the order that they appear
    print("FROM STARSHIP LOOK  >>>> in thenumbers",thenumbers)
    print("===========.......")
    #for item in thenumbers:
    #    switch_numbers_to_transfer.append(item)
    #print("this should fill it up")
    ##-====================================
    for line in testoutputstring.splitlines():
        if "switch(exp)" in line and "nested" not in line:
            print(line)  #next line accesses switch_numbers_to_transfer[counter]
            print("counter",counter)
            
            ########################################################################
            print("this is what it sees",str(switch_numbers_to_transfer[number_counter]))
            ########################################################################
            #this is using list switch_numbers_to_transfer to add number in comment after switch in python
            #WAS USING SWITCH NUMBERS TO TRANSFER switch_numbers_to_transfer
            createstring += line + "#" + str(switch_numbers_to_transfer[number_counter]) + "\n"
            counter += 1
        else:
            createstring += line + "\n"
            counter += 1
            continue
    print("the output after adding the switch line number after switch")
    for line in createstring.splitlines():
         print(line)
    #this puts the output of the method above into silvermine[0]    
    silvermine[0]=createstring #for output to replace it into the same slot
 ####====== end of fucntion         
 
#number_counter=0
#add_switch_number_to_python_output_from_quail_input(testoutputstring,number_counter)
#this is after
#for line in silvermine[0].splitlines():
#    print(line)
#



# get first line with switch get the number after comment
# append that number to a list
#first_switch_list.append(number)
got_the_number=[]
##====================================================
##  get_switch_number_at_top_of_string(stringname):
##====================================================
def get_switch_number_at_top_of_string(stringname):
	print("=========get switch number at top of string().========. called")
	awesome=''
	counter =0  #say it's 3
	#this will only get the number from the FIRST SWITCH it encounters
	for line in stringname.splitlines(): #this requires the lines numbers already added 
		print(line)
		print("the counter here is",counter)
		if "switch" in line and "end" not in line and "#" in line: #just need to grab the first switch 
			#switchcounter += 1        #O just added" "#" in line and counter > 1
			x = line.split("#")  
			y = x[1];
			#str(y) #turns it into a string
			print("switch number is",y)
			y=y.strip() 
			got_the_number.append(y)
			#how do i get what is after # split th eline I think
			counter += 1
			print(stringname)
			break
		else:
			counter += 1
	return y;




##==========================================================================
xmastime=[]
xmastime.append(0)
#testing december 2, 2021 4:38pm snowman coding project
#this will be called just before bake_cake combinging the switches together happens
#this would be called on each string in stanford list ##<< important note

# this creates the "def main_switch(exp):" and 
# def inner_switch_x(exp): and converts the inner switches to inswitch and fallthru to infallthru 
# verified working dec 3rd Friday 2021 Starbucks Gilroy.


####=======================================================================
##   prepare_python_switch_string_for_baking(stringname):
##   #method used: result= get_switch_number_at_top_of_string(stringname)
##========================================================================= 
def prepare_python_switch_string_for_baking(stringname):
    print('===== prepare_python_switch_string_for_baking() =====')
    buildstring='';
    the_answer_is= get_switch_number_at_top_of_string(stringname)
    mynumb = the_answer_is;
    #========================== added on Fri Dec 3rd ====================
    ## this  ADDS the function name to the top  of a switch string; not tabs in front here
    if mynumb == '1': 
        buildstring += "\n\nexp = varholder[0]\n";
        buildstring += "def main_switch(exp):"; # only triggered for main switch scenario
    else:             
        buildstring += "def nested_switch_" + str(mynumb) +"(exp):" # meaning not  1 
    #====================================================================
    ## changes switch to inswitch and fallthru to infallthru
    for line in stringname.splitlines(): #if mynumber = 1 don't change switch in main scenario
        if "switch" in line and "nested" not in line and mynumb != '1': #if switch 1 skip this
            line = line.replace("switch","inswitch")
        if "fallthru" in line:
            line = line.replace("fallthru","infallthru")
        buildstring += '\t' + line +'\n' #this adds 1 tab  to front of each line after def definition
    xmastime[0] = buildstring; 
    print(" ")
    print(xmastime[0]); 
    print(" ")
    
 #I just generated this with the code    


##==============================================================
##  loop_thru_stanford_list_and_add_number_to_each_switch():
##==============================================================
def loop_thru_stanford_list_and_add_number_to_each_switch():
    counter = 0;number_counter=0;
    for item in stanford: #this loops thru the whole stanford list and adds a number to each switch
        print('number_counter=',number_counter)
        add_switch_number_to_python_output_from_quail_input(item,number_counter) #gets teh number from switch_numbers_to_transfer
        result = silvermine[0];
        fancy_new_car.append(result)
        number_counter += 1


fancy_new_car=[]


##==================================================
##  loop_thru_fancy_new_car()    
##==================================================
def loop_thru_fancy_new_car():
    print("STANFORD LIST WITH switch numbers just added ")
    for item in fancy_new_car:
        print(item)
        print("============")


##==================================================
## fill_stanford_list_from_fancy_new_car()    
##==================================================        
def fill_stanford_list_from_fancy_new_car():
    del stanford[:]
    for item in fancy_new_car:
        stanford.append(item)

##==================================================
## loop_thru_stanford_list()   
##==================================================        
def loop_thru_stanford_list():
    print("===LOOP THRU STANFORD LIST==in snoopy_doghouse.py ==dec 15th =")
    counter=1
    for item in stanford:
        print("==========")
        print(item)
        print("-------------------")
        print("counter=",counter)
        counter += 1
    print("end of looooooping thru Stanford Lake Laguninta --")







##==================================================
##  show_output_after_switch_number_added_to_python_output_strings()    
##==================================================        
def show_output_after_switch_number_added_to_python_output_strings():
    loop_thru_fancy_new_car()  #output of switch number added to a python switch string 
    fill_stanford_list_from_fancy_new_car()
    loop_thru_stanford_list()
    print("stopping here to see what is in stanford list at this point line 42293")
    #exit()
####============== new test down here now ========================================
#### fresh morning coding     tuesday dec 7th, 2021 morgan hill
####################################################################################




#uses method add_switch_number_to_python_output_from_quail_input()
##===========================================================
## add_number_after_top_switch_in_stanford_list():  #modified and streamlined with methods on Dec 12th, 2021
##  MAJOR METHOD 
##===========================================================
def add_number_after_top_switch_into_stanford_list(): #python output strings
    print("=====add_number_after_top_switch_in_stanford_list():=====")
    loop_thru_stanford_list_and_add_number_to_each_switch()#after switches with numbers
    show_output_after_switch_number_added_to_python_output_strings() #in stanford list
    
        
#just commented this out
#add_number_after_top_switch_into_stanford_list() #this does the entire stanford list 
#which it loops thru 




##==================================================
## loop_thru_bad_dog()    
##==================================================
def loop_thru_bad_dog():
    print("length of bad_dog line 12344=",len(bad_dog))
    for item in bad_dog:
        print(item)
      
      
        
##==================================================
##  fill_stanford_list_from_bad_dog()   
##==================================================
def fill_stanford_list_from_bad_dog():
    del stanford[:]  #fill stnaford list
    for item in bad_dog:
        stanford.append(item)
    print("stnaford list here is __",len(stanford))


##==================================================
##  reverse_bad_dog_list()   
##==================================================
def reverse_bad_dog_list():
    bad_dog.reverse() 
#new


  
##==-=============================
test_list=[]
test_list.append(0)

#test_list[0] = grammar

##=================================
##==================================================
## say_what_it_is_doing_comment_as_print()    
##==================================================    
def say_what_it_is_doing_comment_as_print():
    print("bad dog list of final output of all nested switches and main switch")
     
     
     
##==================================================
##  take_bad_dog_list_and_fill_stanford_list()    
##==================================================
def take_bad_dog_list_and_fill_stanford_list():
    loop_thru_bad_dog()
    reverse_bad_dog_list()
    fill_stanford_list_from_bad_dog()
    del bad_dog[:] #new today dec 13th
    say_what_it_is_doing_comment_as_print()
    loop_thru_stanford_list()
####################################################################################
bad_dog=[]
#uses method prepare ptyhon switch string for baking 
#appending output to bad dog of adding def method at top of each switch string






##========================================================
## adding_def_methods_to_top_of_each_switch_string():
## ** MAJOR METHOD **
##========================================================
def adding_def_methods_to_top_of_each_switch_string():
    print(" =====adding_def_methods_to_top_of_each_switch_string(): ======")
    for item in stanford: #what does this do 
        prepare_python_switch_string_for_baking(item) #concats each switch string together (sewing together)
        bad_dog.append(xmastime[0]) 
    take_bad_dog_list_and_fill_stanford_list()
    
    
 ###================ end of function ===============
 
 
 
 

fill_nested_switches_list=[]
fill_nested_switches_list.append(0)
#this is going to be used to pass the generated combined switch
# string of nested and main switches bottom up from main
#which is then passed to concat and execute.
 
 
 
####################################################################################
#uses method build_stacked_cake sring combining stanford list()
#output is in toocool[0] list
##=============================================================
## stack_the_cake_combining_python_switch_methods_together()
## ** MAJOR METHOD ** 
##=============================================================
def stack_the_cake_combining_python_switch_methods_together():
    print("=====stack_the_cake_combining_python_switch_methods_together()=======")
    toocool[0]=''; 
    print("length of stanford before stacking the cake",len(stanford))
    #this loops thru stanford list
    build_stacked_cake_string_combining_stanford_list() #this adds ''' above it and ''' below it
    fill_nested_switches_list[0]= toocool[0]
    ##==========================================
    #This is used to concat other parts of strings to exec(superball)
    #in test file playtime_testing.copy
    #################### yes, that's what I will do. 
    print("inside red nosed deer  testing outpout of concatting strings dec 17th ")
    for line in fill_nested_switches_list[0].splitlines():
        print(line)
    print("====end printing oout fill nested switches list=====")

print("done running trhu fill_nested_switches_list[0] wednesday monrning decmeber 8th after dentist")
##=================================================================
## the_big_test() #this goes thru each switch string in stanford list
## and adds switch number from quail strings in transfer_switch_list
## then adds def main method and def nested_switch_X
## reversing order so main is at the bottom 
## then concats the strings together within '''
##=================================/==============================
####################################################################################

## methods used:
## add_number_after_top_switch_into_stanford_list()
## adding_def_methods_to_top_of_each_switch_string() 
## stack_the_cake_combining_python_switch_methods_together()

fill_nested_switches_list=[]  #000000 modificaitons
fill_nested_switches_list.append(0) #-0000000 modifications dec 15th 
result=[]
result.append(0)



##===============================================================
## create_def_switch_methods_concatted_together_in_one_string()
##=============================================================
def create_def_switch_methods_concatted_together_in_one_string():
    print('=create_def_switch_methods_concatted_together_in_one_string()=')
    add_number_after_top_switch_into_stanford_list()#this is used to label out switches
    adding_def_methods_to_top_of_each_switch_string() #framing each python switch generated output
    stack_the_cake_combining_python_switch_methods_together()
    print('output in toocool[0] ===')
    print(toocool[0])
    for line in fill_nested_switches_list[0].splitlines():
        print(line)
   

print('===================before great barrier reef==============')


#print('looping thru nested_switches now .. this is getting a bit weird')
print('testing seeing what is in list now after(was before) putting it into variable')


topvalue=[]
topvalue.append(0)
 #testing putting it here for INPUT to the dynamically generated switch case

#put this string into a list with just the string by itself in position 0
method_defs='''
# =======  switch  =================================
def switch(x):
	#if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
	#	x = str(x)
	global case
	case = x 
# =======  fallthru       =========================
def fallthru(y):
	eval("switch('" + y + "')")
#==================
#for inswitch
def inswitch(n):
	#if type(x) != str:  #checks to make sure it's a string if for example a number is passed as x
	#	n = str(n)
	global case
	case = n 
#=====================
# for infallthru    
def infallthru(n):
	eval("inswitch('" + n + "')")
'''




result=[]
result.append(0)

varholder=[]
varholder.append(0)


trigger='''\n
main_switch(varholder[0]) 
'''



alltheway=[]
# this concats the strings in the list and then executes the string code
fireone=[]
fireone.append(0)
fireone[0] = False
##########################################################################
def enter_value(x):
	varholder[0]=str(x)  #look at this it takes in the input 

x = topvalue[0];

show_code= True    


###==================================
##  concat_items_in_list(x):
##===================================
def concat_items_in_list(x): 
	#print('--------concat items in list(x)---------------------------')
	create_def_switch_methods_concatted_together_in_one_string() 

	for line in fill_nested_switches_list[0].splitlines():
		print(line)
	
	enter_value(x) #this is fed in from above 
	print("=====concat items in list()====")
	fireone[0]= True #when this is True it shows the code generated with print
	global superball
	tail = "\n"
	future_nested_switches=fill_nested_switches_list[0] #makes a list a string
	superball='' #clears it
	#=================================================================================
	superball =  method_defs + future_nested_switches + trigger + tail
	##================================================================================
	superball=superball.replace("'''",'') #this cuts out ''' from the combined string
	#=================================================================================
	print("the OUTPUT before EXECUTION of the code is..")
	print(superball)
	#exit() #so I can see what is in it
	print("========================")
	#this is a flag
	future_nested_switches='' #empties it
	if show_code == True:
		print(superball) #prints the generated switch code methods
	else:
		pass  #otherwise it prints nothing 
	#so at this juncture the global var superball has the combined stacked string




 
###=============================
### clever_cat()  triggers the concatting and executing of the python
### calls method: concat_items_in_list() filling superball and then executes it
###=============================
def clever_cat():
    print("====CLEVER CAT called==chesire cat test=")
    ### ==== executed here
    concat_items_in_list(topvalue[0])#this builds the concatted string superball
    print('input is ',varholder[0])
    #===========================
    exec(superball, globals()) #runs the switchcase
    #===========================
    
##################################

##=====================================
topvalue[0]='1'
clever_cat()
##======================================================================

#print("input varholder[0]=",varholder[0])
#print(red_robin)
print('result[0] =',result[0])
print(" ")
print("let us see what we have here")
print(" real_switch_numbers_to_transfer=",real_switch_numbers_to_transfer)
#==== now clear them out 

print("======stop the presses=dam it======")
exit()
##================

